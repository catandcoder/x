<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清澄秋爽</title>
  
  <subtitle>苹果树下的思索者 书写是对思维的缓存</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dashen.tech/"/>
  <updated>2021-06-10T13:07:41.263Z</updated>
  <id>http://www.dashen.tech/</id>
  
  <author>
    <name>fliter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Plan9汇编入门</title>
    <link href="http://www.dashen.tech/2022/01/10/Plan9%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"/>
    <id>http://www.dashen.tech/2022/01/10/Plan9汇编入门/</id>
    <published>2022-01-10T14:05:16.000Z</published>
    <updated>2021-06-10T13:07:41.263Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xargin.com/plan9-assembly/" target="_blank" rel="noopener">Go 系列文章3 ：plan9 汇编入门</a></p><p><a href="https://zhuanlan.zhihu.com/p/29892487" target="_blank" rel="noopener">Go 语言的实现为何使用Plan 9的汇编器?</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB" target="_blank" rel="noopener">贝尔实验室九号项目</a></p><p><a href="https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md" target="_blank" rel="noopener">Golang中的Plan9汇编器</a></p><p><a href="https://www.zhihu.com/question/19706063/answer/22881507" target="_blank" rel="noopener">为什么 Plan9 在生产环境没有实际的应用，是因为应用程序匮乏的原因么？</a></p><p><a href="https://codereview.appspot.com/133740043/" target="_blank" rel="noopener">https://codereview.appspot.com/133740043/</a></p><p><a href="http://doc.cat-v.org/plan_9/4th_edition/papers/asm" target="_blank" rel="noopener">A Manual for the Plan 9 assembler</a></p><p><a href="https://mioto.me/2021/01/plan9-assembly/" target="_blank" rel="noopener">Plan9 汇编入门讲解</a></p><p><a href="https://blog.csdn.net/qq_42633819/article/details/106467502" target="_blank" rel="noopener">plan9汇编手册</a></p><p><a href="http://blog.studygolang.com/2013/05/asm_and_plan9_asm/" target="_blank" rel="noopener">汇编和PLAN9汇编</a></p><p><br></p><p><a href>src/internal/bytealg/index_amd64.s</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line">#include <span class="string">"go_asm.h"</span></span><br><span class="line">#include <span class="string">"textflag.h"</span></span><br><span class="line"></span><br><span class="line">TEXT ·Index(SB),NOSPLIT,$<span class="number">0</span><span class="number">-56</span></span><br><span class="line">MOVQ a_base+<span class="number">0</span>(FP), DI</span><br><span class="line">MOVQ a_len+<span class="number">8</span>(FP), DX</span><br><span class="line">MOVQ b_base+<span class="number">24</span>(FP), R8</span><br><span class="line">MOVQ b_len+<span class="number">32</span>(FP), AX</span><br><span class="line">MOVQ DI, R10</span><br><span class="line">LEAQ ret+<span class="number">48</span>(FP), R11</span><br><span class="line">JMP  indexbody&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line">TEXT ·IndexString(SB),NOSPLIT,$<span class="number">0</span><span class="number">-40</span></span><br><span class="line">MOVQ a_base+<span class="number">0</span>(FP), DI</span><br><span class="line">MOVQ a_len+<span class="number">8</span>(FP), DX</span><br><span class="line">MOVQ b_base+<span class="number">16</span>(FP), R8</span><br><span class="line">MOVQ b_len+<span class="number">24</span>(FP), AX</span><br><span class="line">MOVQ DI, R10</span><br><span class="line">LEAQ ret+<span class="number">32</span>(FP), R11</span><br><span class="line">JMP  indexbody&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AX: length of string, that we are searching for</span></span><br><span class="line"><span class="comment">// DX: length of string, in which we are searching</span></span><br><span class="line"><span class="comment">// DI: pointer to string, in which we are searching</span></span><br><span class="line"><span class="comment">// R8: pointer to string, that we are searching for</span></span><br><span class="line"><span class="comment">// R11: address, where to put return value</span></span><br><span class="line"><span class="comment">// Note: We want len in DX and AX, because PCMPESTRI implicitly consumes them</span></span><br><span class="line">TEXT indexbody&lt;&gt;(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">CMPQ AX, DX</span><br><span class="line">JA fail</span><br><span class="line">CMPQ DX, $<span class="number">16</span></span><br><span class="line">JAE sse42</span><br><span class="line">no_sse42:</span><br><span class="line">CMPQ AX, $<span class="number">2</span></span><br><span class="line">JA   _3_or_more</span><br><span class="line">MOVW (R8), R8</span><br><span class="line">LEAQ <span class="number">-1</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop2:</span><br><span class="line">MOVW (DI), SI</span><br><span class="line">CMPW SI,R8</span><br><span class="line">JZ success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop2</span><br><span class="line">JMP fail</span><br><span class="line">_3_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">3</span></span><br><span class="line">JA   _4_or_more</span><br><span class="line">MOVW <span class="number">1</span>(R8), BX</span><br><span class="line">MOVW (R8), R8</span><br><span class="line">LEAQ <span class="number">-2</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop3:</span><br><span class="line">MOVW (DI), SI</span><br><span class="line">CMPW SI,R8</span><br><span class="line">JZ   partial_success3</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop3</span><br><span class="line">JMP fail</span><br><span class="line">partial_success3:</span><br><span class="line">MOVW <span class="number">1</span>(DI), SI</span><br><span class="line">CMPW SI,BX</span><br><span class="line">JZ success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop3</span><br><span class="line">JMP fail</span><br><span class="line">_4_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">4</span></span><br><span class="line">JA   _5_or_more</span><br><span class="line">MOVL (R8), R8</span><br><span class="line">LEAQ <span class="number">-3</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop4:</span><br><span class="line">MOVL (DI), SI</span><br><span class="line">CMPL SI,R8</span><br><span class="line">JZ   success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop4</span><br><span class="line">JMP fail</span><br><span class="line">_5_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">7</span></span><br><span class="line">JA   _8_or_more</span><br><span class="line">LEAQ <span class="number">1</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">SUBQ AX, DX</span><br><span class="line">MOVL <span class="number">-4</span>(R8)(AX*<span class="number">1</span>), BX</span><br><span class="line">MOVL (R8), R8</span><br><span class="line">loop5to7:</span><br><span class="line">MOVL (DI), SI</span><br><span class="line">CMPL SI,R8</span><br><span class="line">JZ   partial_success5to7</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop5to7</span><br><span class="line">JMP fail</span><br><span class="line">partial_success5to7:</span><br><span class="line">MOVL <span class="number">-4</span>(AX)(DI*<span class="number">1</span>), SI</span><br><span class="line">CMPL SI,BX</span><br><span class="line">JZ success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop5to7</span><br><span class="line">JMP fail</span><br><span class="line">_8_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">8</span></span><br><span class="line">JA   _9_or_more</span><br><span class="line">MOVQ (R8), R8</span><br><span class="line">LEAQ <span class="number">-7</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop8:</span><br><span class="line">MOVQ (DI), SI</span><br><span class="line">CMPQ SI,R8</span><br><span class="line">JZ   success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop8</span><br><span class="line">JMP fail</span><br><span class="line">_9_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">15</span></span><br><span class="line">JA   _16_or_more</span><br><span class="line">LEAQ <span class="number">1</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">SUBQ AX, DX</span><br><span class="line">MOVQ <span class="number">-8</span>(R8)(AX*<span class="number">1</span>), BX</span><br><span class="line">MOVQ (R8), R8</span><br><span class="line">loop9to15:</span><br><span class="line">MOVQ (DI), SI</span><br><span class="line">CMPQ SI,R8</span><br><span class="line">JZ   partial_success9to15</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop9to15</span><br><span class="line">JMP fail</span><br><span class="line">partial_success9to15:</span><br><span class="line">MOVQ <span class="number">-8</span>(AX)(DI*<span class="number">1</span>), SI</span><br><span class="line">CMPQ SI,BX</span><br><span class="line">JZ success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop9to15</span><br><span class="line">JMP fail</span><br><span class="line">_16_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">16</span></span><br><span class="line">JA   _17_or_more</span><br><span class="line">MOVOU (R8), X1</span><br><span class="line">LEAQ <span class="number">-15</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop16:</span><br><span class="line">MOVOU (DI), X2</span><br><span class="line">PCMPEQB X1, X2</span><br><span class="line">PMOVMSKB X2, SI</span><br><span class="line">CMPQ  SI, $<span class="number">0xffff</span></span><br><span class="line">JE   success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop16</span><br><span class="line">JMP fail</span><br><span class="line">_17_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">31</span></span><br><span class="line">JA   _32_or_more</span><br><span class="line">LEAQ <span class="number">1</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">SUBQ AX, DX</span><br><span class="line">MOVOU <span class="number">-16</span>(R8)(AX*<span class="number">1</span>), X0</span><br><span class="line">MOVOU (R8), X1</span><br><span class="line">loop17to31:</span><br><span class="line">MOVOU (DI), X2</span><br><span class="line">PCMPEQB X1,X2</span><br><span class="line">PMOVMSKB X2, SI</span><br><span class="line">CMPQ  SI, $<span class="number">0xffff</span></span><br><span class="line">JE   partial_success17to31</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop17to31</span><br><span class="line">JMP fail</span><br><span class="line">partial_success17to31:</span><br><span class="line">MOVOU <span class="number">-16</span>(AX)(DI*<span class="number">1</span>), X3</span><br><span class="line">PCMPEQB X0, X3</span><br><span class="line">PMOVMSKB X3, SI</span><br><span class="line">CMPQ  SI, $<span class="number">0xffff</span></span><br><span class="line">JE success</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop17to31</span><br><span class="line">JMP fail</span><br><span class="line"><span class="comment">// We can get here only when AVX2 is enabled and cutoff for indexShortStr is set to 63</span></span><br><span class="line"><span class="comment">// So no need to check cpuid</span></span><br><span class="line">_32_or_more:</span><br><span class="line">CMPQ AX, $<span class="number">32</span></span><br><span class="line">JA   _33_to_63</span><br><span class="line">VMOVDQU (R8), Y1</span><br><span class="line">LEAQ <span class="number">-31</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">loop32:</span><br><span class="line">VMOVDQU (DI), Y2</span><br><span class="line">VPCMPEQB Y1, Y2, Y3</span><br><span class="line">VPMOVMSKB Y3, SI</span><br><span class="line">CMPL  SI, $<span class="number">0xffffffff</span></span><br><span class="line">JE   success_avx2</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop32</span><br><span class="line">JMP fail_avx2</span><br><span class="line">_33_to_63:</span><br><span class="line">LEAQ <span class="number">1</span>(DI)(DX*<span class="number">1</span>), DX</span><br><span class="line">SUBQ AX, DX</span><br><span class="line">VMOVDQU <span class="number">-32</span>(R8)(AX*<span class="number">1</span>), Y0</span><br><span class="line">VMOVDQU (R8), Y1</span><br><span class="line">loop33to63:</span><br><span class="line">VMOVDQU (DI), Y2</span><br><span class="line">VPCMPEQB Y1, Y2, Y3</span><br><span class="line">VPMOVMSKB Y3, SI</span><br><span class="line">CMPL  SI, $<span class="number">0xffffffff</span></span><br><span class="line">JE   partial_success33to63</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop33to63</span><br><span class="line">JMP fail_avx2</span><br><span class="line">partial_success33to63:</span><br><span class="line">VMOVDQU <span class="number">-32</span>(AX)(DI*<span class="number">1</span>), Y3</span><br><span class="line">VPCMPEQB Y0, Y3, Y4</span><br><span class="line">VPMOVMSKB Y4, SI</span><br><span class="line">CMPL  SI, $<span class="number">0xffffffff</span></span><br><span class="line">JE success_avx2</span><br><span class="line">ADDQ $<span class="number">1</span>,DI</span><br><span class="line">CMPQ DI,DX</span><br><span class="line">JB loop33to63</span><br><span class="line">fail_avx2:</span><br><span class="line">VZEROUPPER</span><br><span class="line">fail:</span><br><span class="line">MOVQ $<span class="number">-1</span>, (R11)</span><br><span class="line">RET</span><br><span class="line">success_avx2:</span><br><span class="line">VZEROUPPER</span><br><span class="line">JMP success</span><br><span class="line">sse42:</span><br><span class="line">CMPB internal∕cpu·X86+const_offsetX86HasSSE42(SB), $<span class="number">1</span></span><br><span class="line">JNE no_sse42</span><br><span class="line">CMPQ AX, $<span class="number">12</span></span><br><span class="line"><span class="comment">// PCMPESTRI is slower than normal compare,</span></span><br><span class="line"><span class="comment">// so using it makes sense only if we advance 4+ bytes per compare</span></span><br><span class="line"><span class="comment">// This value was determined experimentally and is the ~same</span></span><br><span class="line"><span class="comment">// on Nehalem (first with SSE42) and Haswell.</span></span><br><span class="line">JAE _9_or_more</span><br><span class="line">LEAQ <span class="number">16</span>(R8), SI</span><br><span class="line">TESTW $<span class="number">0xff0</span>, SI</span><br><span class="line">JEQ no_sse42</span><br><span class="line">MOVOU (R8), X1</span><br><span class="line">LEAQ <span class="number">-15</span>(DI)(DX*<span class="number">1</span>), SI</span><br><span class="line">MOVQ $<span class="number">16</span>, R9</span><br><span class="line">SUBQ AX, R9 <span class="comment">// We advance by 16-len(sep) each iteration, so precalculate it into R9</span></span><br><span class="line">loop_sse42:</span><br><span class="line"><span class="comment">// 0x0c means: unsigned byte compare (bits 0,1 are 00)</span></span><br><span class="line"><span class="comment">// for equality (bits 2,3 are 11)</span></span><br><span class="line"><span class="comment">// result is not masked or inverted (bits 4,5 are 00)</span></span><br><span class="line"><span class="comment">// and corresponds to first matching byte (bit 6 is 0)</span></span><br><span class="line">PCMPESTRI $<span class="number">0x0c</span>, (DI), X1</span><br><span class="line"><span class="comment">// CX == 16 means no match,</span></span><br><span class="line"><span class="comment">// CX &gt; R9 means partial match at the end of the string,</span></span><br><span class="line"><span class="comment">// otherwise sep is at offset CX from X1 start</span></span><br><span class="line">CMPQ CX, R9</span><br><span class="line">JBE sse42_success</span><br><span class="line">ADDQ R9, DI</span><br><span class="line">CMPQ DI, SI</span><br><span class="line">JB loop_sse42</span><br><span class="line">PCMPESTRI $<span class="number">0x0c</span>, <span class="number">-1</span>(SI), X1</span><br><span class="line">CMPQ CX, R9</span><br><span class="line">JA fail</span><br><span class="line">LEAQ <span class="number">-1</span>(SI), DI</span><br><span class="line">sse42_success:</span><br><span class="line">ADDQ CX, DI</span><br><span class="line">success:</span><br><span class="line">SUBQ R10, DI</span><br><span class="line">MOVQ DI, (R11)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xargin.com/plan9-assembly/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 系列文章3 ：plan9 汇编入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhi
      
    
    </summary>
    
    
      <category term="Compiler" scheme="http://www.dashen.tech/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>底层库的一些tricks</title>
    <link href="http://www.dashen.tech/2021/07/11/%E5%BA%95%E5%B1%82%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9Btricks/"/>
    <id>http://www.dashen.tech/2021/07/11/底层库的一些tricks/</id>
    <published>2021-07-11T13:31:53.000Z</published>
    <updated>2021-07-08T13:31:54.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="位运算代替乘法运算"><a href="#位运算代替乘法运算" class="headerlink" title="位运算代替乘法运算"></a>位运算代替乘法运算</h3><p><br></p><p>   hash = ((hash &lt;&lt; 5) + hash) + (<em>str); //等价hash(i-1) </em> 33 + str[i]。5(2) = 32(10)</p><p>   还有一个事情很有意思，乘以33是用左移和加法实现的。底层库对性能要求高啊。</p><p><a href="https://github.com/golang/go/blob/2ca44fe2213b53ccaf6f555c11858c6e36490624/src/internal/bytealg/bytealg.go#L54" target="_blank" rel="noopener">RK算法中计算 旋转hash值</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primeRK is the prime base used in Rabin-Karp algorithm.</span></span><br><span class="line"><span class="keyword">const</span> primeRK = <span class="number">16777619</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashStr returns the hash and the appropriate multiplicative</span></span><br><span class="line"><span class="comment">// factor for use in Rabin-Karp algorithm.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashStr</span><span class="params">(sep <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">uint32</span>, <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">hash := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sep); i++ &#123;</span><br><span class="line">hash = hash*primeRK + <span class="keyword">uint32</span>(sep[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pow, sq <span class="keyword">uint32</span> = <span class="number">1</span>, primeRK</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(sep); i &gt; <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">pow *= sq</span><br><span class="line">&#125;</span><br><span class="line">sq *= sq</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash, pow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;位运算代替乘法运算&quot;&gt;&lt;a href=&quot;#位运算代替乘法运算&quot; class=&quot;headerlink&quot; title=&quot;位运算代替乘法运算&quot;&gt;&lt;/a&gt;位运算代替乘法运算&lt;/h3&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;   hash = ((hash &amp;lt;&amp;lt; 5) +
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust vs Go:常用语法对比</title>
    <link href="http://www.dashen.tech/2021/07/09/Rust-vs-Go-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.dashen.tech/2021/07/09/Rust-vs-Go-常用语法对比/</id>
    <published>2021-07-09T13:02:52.000Z</published>
    <updated>2021-07-11T14:44:57.659Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://programming-idioms.org/about#about-block-cheatsheets" target="_blank" rel="noopener">这个网站</a> 可以列出某门编程语言的常用语法，也可以对比两种语言的基本语法差别。</p><p>在此对比<a href="https://programming-idioms.org/cheatsheet/Go/Rust" target="_blank" rel="noopener">Go和Rust</a></p><p><br></p><h3 id="1-Print-Hello-World"><a href="#1-Print-Hello-World" class="headerlink" title="1. Print Hello World"></a>1. <font color="d9ed92">Print Hello World</font></h3><p><em>打印Hello World</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rust 输出文字的方式主要有两种：<strong>println!()</strong> 和 <strong>print!()</strong>。这两个”函数”都是向命令行输出字符串的方法，区别仅在于前者会在输出的最后附加输出一个换行符。当用这两个”函数”输出信息的时候，第一个参数是格式字符串，后面是一串可变参数，对应着格式字符串中的”占位符”，这一点与 C 语言/ Go语言 中的 printf 函数很相似。但是，Rust 中格式字符串中的占位符不是”% + 字母”的形式，而是一对 {}。</p></blockquote><p><br></p><h3 id="2-Print-Hello-10-times"><a href="#2-Print-Hello-10-times" class="headerlink" title="2. Print Hello 10 times"></a>2. <font color="b5e48c">Print Hello 10 times</font></h3><p><em>打印10次Hello World</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">"Hello\n"</span>.repeat(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-Create-a-procedure"><a href="#3-Create-a-procedure" class="headerlink" title="3. Create a procedure"></a>3. <font color="99d98c">Create a procedure</font></h3><blockquote><p>Like a function which doesn’t return any value, thus has only side effects (e.g. Print to standard output)</p></blockquote><p><em>创建一个方法，没有返回值，打印一些内容</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finish</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"My job here is done. Good bye "</span> + name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    finish(<span class="string">"Buddy"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">finish</span></span>(name : &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"My job here is done. Goodbye &#123;&#125;"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-Create-a-function-which-returns-the-square-of-an-integer"><a href="#4-Create-a-function-which-returns-the-square-of-an-integer" class="headerlink" title="4. Create a function which returns the square of an integer"></a>4. <font color="76c893">Create a function which returns the square of an integer</font></h3><p><em>创建一个函数,返回一个整数的平方</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x*x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    x * x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> sq = square(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, sq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5-Create-a-2D-Point-data-structure"><a href="#5-Create-a-2D-Point-data-structure" class="headerlink" title="5. Create a 2D Point data structure"></a>5. <font color="52b69a">Create a 2D Point data structure</font></h3><blockquote><p>Declare a container type for two floating-point numbers x and y</p></blockquote><p><em>声明一个容器类型,有x、y两个浮点数</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-1"><a href="#rust-1" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f64</span>,</span><br><span class="line">    y: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">'_</span>&gt;) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"(&#123;&#125;, &#123;&#125;)"</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">2.0</span>, y: -<span class="number">3.5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">f64</span>, <span class="built_in">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">'_</span>&gt;) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"(&#123;&#125;, &#123;&#125;)"</span>, <span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point(<span class="number">2.0</span>, -<span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6-Iterate-over-list-values"><a href="#6-Iterate-over-list-values" class="headerlink" title="6. Iterate over list values"></a>6. <font color="34a0a4">Iterate over list values</font></h3><blockquote><p>Do something with each item x of an array-like collection items, regardless indexes.</p></blockquote><p><em>遍历列表的值</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">    doSomething(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-2"><a href="#rust-2" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> items = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items &#123;</span><br><span class="line">        do_something(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>(n: <span class="built_in">i64</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Number &#123;&#125;"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> items = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line">    items.into_iter().for_each(|x| do_something(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_something</span></span>(n: <span class="built_in">i64</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Number &#123;&#125;"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7-Iterate-over-list-indexes-and-values"><a href="#7-Iterate-over-list-indexes-and-values" class="headerlink" title="7. Iterate over list indexes and values"></a>7. <font color="168aad">Iterate over list indexes and values</font></h3><p><em>遍历列表的索引和值</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Item %d = %v \n"</span>, i, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-3"><a href="#rust-3" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> items = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">    <span class="keyword">for</span> (i, x) <span class="keyword">in</span> items.iter().enumerate() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Item &#123;&#125; = &#123;&#125;"</span>, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> items = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">    items.iter().enumerate().for_each(|(i, x)| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Item &#123;&#125; = &#123;&#125;"</span>, i, x);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="8-Initialize-a-new-map-associative-array"><a href="#8-Initialize-a-new-map-associative-array" class="headerlink" title="8. Initialize a new map (associative array)"></a>8. <font color="1a759f">Initialize a new map (associative array)</font></h3><blockquote><p>Create a new map object x, and provide some (key, value) pairs as initial content.</p></blockquote><p><em>创建一个新的map,提供一些键值对 作为初始内容</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-4"><a href="#rust-4" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = BTreeMap::new();</span><br><span class="line">    x.insert(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">    x.insert(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"one"</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">"two"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: HashMap&lt;&amp;<span class="built_in">str</span>, <span class="built_in">i32</span>&gt; = [</span><br><span class="line">        (<span class="string">"one"</span>, <span class="number">1</span>),</span><br><span class="line">        (<span class="string">"two"</span>, <span class="number">2</span>),</span><br><span class="line">    ].iter().cloned().collect();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"two"</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">"one"</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>分 BTreeMap 和 HashMap，且都需要use进来</p><p><br></p><h3 id="9-Create-a-Binary-Tree-data-structure"><a href="#9-Create-a-Binary-Tree-data-structure" class="headerlink" title="9. Create a Binary Tree data structure"></a>9. <font color="1e6091">Create a Binary Tree data structure</font></h3><blockquote><p>The structure must be recursive because left child and right child are binary trees too. A node has access to children nodes, but not to its parent.</p></blockquote><p><em>创建一个二叉树</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BinTree <span class="keyword">struct</span> &#123;</span><br><span class="line">Value valueType</span><br><span class="line">Left *BinTree</span><br><span class="line">Right *BinTree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinTree</span></span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    left: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;BinTree&lt;T&gt;&gt;&gt;,</span><br><span class="line">    right: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;BinTree&lt;T&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="10-Shuffle-a-list"><a href="#10-Shuffle-a-list" class="headerlink" title="10. Shuffle a list"></a>10. <font color="184e77">Shuffle a list</font></h3><blockquote><p>Generate a random permutation of the elements of list x</p></blockquote><p><em>随机排序一个list</em></p><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">x[i], x[j] = x[j], x[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(x))</span><br><span class="line">perm := rand.Perm(<span class="built_in">len</span>(x))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> perm &#123;</span><br><span class="line">y[v] = x[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand.Shuffle(<span class="built_in">len</span>(x), <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[i], x[j] = x[j], x[i]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(x) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">j := rand.Intn(i + <span class="number">1</span>)</span><br><span class="line">x[i], x[j] = x[j], x[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-5"><a href="#rust-5" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rand;</span><br><span class="line"><span class="keyword">use</span> rand::&#123;Rng, StdRng&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rng = StdRng::new().unwrap();</span><br><span class="line">rng.shuffle(&amp;<span class="keyword">mut</span> x);</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::seq::SliceRandom;</span><br><span class="line"><span class="keyword">use</span> rand::thread_rng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Unshuffled: &#123;:?&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rng = thread_rng();</span><br><span class="line">    x.shuffle(&amp;<span class="keyword">mut</span> rng);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Shuffled:   &#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="11-Pick-a-random-element-from-a-list"><a href="#11-Pick-a-random-element-from-a-list" class="headerlink" title="11. Pick a random element from a list"></a>11. <font color="f72585">Pick a random element from a list</font></h3><p><em>从列表中选择一个随机元素</em></p><h4 id="go-1"><a href="#go-1" class="headerlink" title="go"></a>go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"math/rand"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x[rand.Intn(<span class="built_in">len</span>(x))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickT</span><span class="params">(x []T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x[rand.Intn(<span class="built_in">len</span>(x))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-6"><a href="#rust-6" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::&#123;<span class="keyword">self</span>, Rng&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> choice = x[rand::thread_rng().gen_range(<span class="number">0</span>..x.len())];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I picked &#123;&#125;!"</span>, choice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::seq::SliceRandom;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rng = rand::thread_rng();</span><br><span class="line">    <span class="keyword">let</span> choice = x.choose(&amp;<span class="keyword">mut</span> rng).unwrap();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I picked &#123;&#125;!"</span>, choice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="12-Check-if-list-contains-a-value"><a href="#12-Check-if-list-contains-a-value" class="headerlink" title="12. Check if list contains a value"></a>12. <font color="b5179e">Check if list contains a value</font></h3><blockquote><p>Check if list contains a value x.<br>list is an iterable finite container.</p></blockquote><p><em>检查列表中是否包含一个值</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(list []T, x T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> item == x &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-7"><a href="#rust-7" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list.contains(&amp;num) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; contains &#123;&#125;"</span>, list, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; doesn't contain &#123;&#125;"</span>, list, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> list.contains(&amp;num) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; contains &#123;&#125;"</span>, list, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; doesn't contain &#123;&#125;"</span>, list, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> list.iter().any(|v| v == &amp;x) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; contains &#123;&#125;"</span>, list, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; doesn't contain &#123;&#125;"</span>, list, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&amp;list).into_iter().any(|v| v == &amp;x) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; contains &#123;&#125;"</span>, list, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; doesn't contain &#123;&#125;"</span>, list, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="13-Iterate-over-map-keys-and-values"><a href="#13-Iterate-over-map-keys-and-values" class="headerlink" title="13. Iterate over map keys and values"></a>13. <font color="7209b7">Iterate over map keys and values</font></h3><blockquote><p>Access each key k with its value x from an associative array mymap, and print them</p></blockquote><p><em>遍历关联数组中的每一对 k-v， 并打印出它们</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, x := <span class="keyword">range</span> mymap &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Key ="</span>, k, <span class="string">", Value ="</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mymap = BTreeMap::new();</span><br><span class="line">    mymap.insert(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">    mymap.insert(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">    mymap.insert(<span class="string">"three"</span>, <span class="number">3</span>);</span><br><span class="line">    mymap.insert(<span class="string">"four"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k, x) <span class="keyword">in</span> &amp;mymap &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Key=&#123;key&#125;, Value=&#123;val&#125;"</span>, key = k, val = x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="14-Pick-uniformly-a-random-floating-point-number-in-a-b"><a href="#14-Pick-uniformly-a-random-floating-point-number-in-a-b" class="headerlink" title="14. Pick uniformly a random floating point number in [a..b)"></a>14. <font color="560bad">Pick uniformly a random floating point number in [a..b)</font></h3><blockquote><p>Pick a random number greater than or equals to a, strictly inferior to b. Precondition : a &lt; b.</p></blockquote><p><em>选出一个随机的浮点数，大于或等于a，严格小于b，且a&lt; b</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pick</span><span class="params">(a, b  <span class="keyword">float64</span>)</span>  <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + (rand.Float64() * (b-a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rand;</span><br><span class="line"><span class="keyword">use</span> rand::&#123;thread_rng, Rng&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="number">1.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">let</span> c = thread_rng().gen_range(a..b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="15-Pick-uniformly-a-random-integer-in-a-b"><a href="#15-Pick-uniformly-a-random-integer-in-a-b" class="headerlink" title="15. Pick uniformly a random integer in [a..b]"></a>15. <font color="3f37c9">Pick uniformly a random integer in [a..b]</font></h3><blockquote><p>Pick a random integer greater than or equals to a, inferior or equals to b. Precondition : a &lt; b.</p></blockquote><p><em>选出一个随机的整数，大于或等于a，小于或等于b，且a&lt; b</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pick</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + rand.Intn(b-a+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-8"><a href="#rust-8" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pick</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> between = Range::new(a, b);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rng = rand::thread_rng();</span><br><span class="line">    between.ind_sample(&amp;<span class="keyword">mut</span> rng)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::distributions::Distribution;</span><br><span class="line"><span class="keyword">use</span> rand::distributions::Uniform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = Uniform::new_inclusive(a, b).sample(&amp;<span class="keyword">mut</span> rand::thread_rng());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="17-Create-a-Tree-data-structure"><a href="#17-Create-a-Tree-data-structure" class="headerlink" title="17. Create a Tree data structure"></a>17. <font color="4361ee">Create a Tree data structure</font></h3><blockquote><p>The structure must be recursive. A node may have zero or more children. A node has access to children nodes, but not to its parent.</p></blockquote><p><em>创建树数据结构,<br>该结构必须是递归的。一个节点可以有零个或多个子节点,节点可以访问子节点，但不能访问其父节点</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">Key keyType</span><br><span class="line">Deco valueType</span><br><span class="line">Children []*Tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;Node&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Node&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>&lt;F: <span class="built_in">Fn</span>(&amp;T)&gt;(&amp;<span class="keyword">self</span>, f: F) &#123;</span><br><span class="line">       <span class="keyword">self</span>.dfs_helper(&amp;f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs_helper</span></span>&lt;F: <span class="built_in">Fn</span>(&amp;T)&gt;(&amp;<span class="keyword">self</span>, f: &amp;F) &#123;</span><br><span class="line">        (f)(&amp;<span class="keyword">self</span>.value);</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> &amp;<span class="keyword">self</span>.children &#123;</span><br><span class="line">            child.dfs_helper(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t: Node&lt;<span class="built_in">i32</span>&gt; = Node &#123;</span><br><span class="line">        children: <span class="built_in">vec!</span>[</span><br><span class="line">            Node &#123;</span><br><span class="line">                children: <span class="built_in">vec!</span>[</span><br><span class="line">                    Node &#123;</span><br><span class="line">                        children: <span class="built_in">vec!</span>[],</span><br><span class="line">                        value: <span class="number">14</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                value: <span class="number">28</span></span><br><span class="line">            &#125;,</span><br><span class="line">            Node &#123;</span><br><span class="line">                children: <span class="built_in">vec!</span>[],</span><br><span class="line">                value: <span class="number">80</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        value: <span class="number">50</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t.dfs(|node| &#123; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, node); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">80</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="18-Depth-first-traversing-of-a-tree"><a href="#18-Depth-first-traversing-of-a-tree" class="headerlink" title="18. Depth-first traversing of a tree"></a>18. <font color="4895ef">Depth-first traversing of a tree</font></h3><blockquote><p>Call a function f on every node of a tree, in depth-first prefix order</p></blockquote><p><em>树的深度优先遍历。按照深度优先的前缀顺序，在树的每个节点上调用函数f</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree)</span> <span class="title">Dfs</span><span class="params">(f <span class="keyword">func</span>(*Tree)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f(t)</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> t.Children &#123;</span><br><span class="line">child.Dfs(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span>&lt;T&gt; &#123;</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;Tree&lt;T&gt;&gt;,</span><br><span class="line">    value: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Tree&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(value: T) -&gt; <span class="keyword">Self</span>&#123;</span><br><span class="line">        Tree&#123;</span><br><span class="line">            children: <span class="built_in">vec!</span>[],</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">dfs</span></span>&lt;F: <span class="built_in">Fn</span>(&amp;T)&gt;(&amp;<span class="keyword">self</span>, f: F) &#123;</span><br><span class="line">       <span class="keyword">self</span>.dfs_helper(&amp;f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dfs_helper</span></span>&lt;F: <span class="built_in">Fn</span>(&amp;T)&gt;(&amp;<span class="keyword">self</span>, f: &amp;F) &#123;</span><br><span class="line">        (f)(&amp;<span class="keyword">self</span>.value);</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> &amp;<span class="keyword">self</span>.children &#123;</span><br><span class="line">            child.dfs_helper(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t: Tree&lt;<span class="built_in">i32</span>&gt; = Tree &#123;</span><br><span class="line">        children: <span class="built_in">vec!</span>[</span><br><span class="line">            Tree &#123;</span><br><span class="line">                children: <span class="built_in">vec!</span>[</span><br><span class="line">                    Tree &#123;</span><br><span class="line">                        children: <span class="built_in">vec!</span>[],</span><br><span class="line">                        value: <span class="number">14</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                value: <span class="number">28</span></span><br><span class="line">            &#125;,</span><br><span class="line">            Tree &#123;</span><br><span class="line">                children: <span class="built_in">vec!</span>[],</span><br><span class="line">                value: <span class="number">80</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        value: <span class="number">50</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t.dfs(|node| &#123; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, node); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">80</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="19-Reverse-a-list"><a href="#19-Reverse-a-list" class="headerlink" title="19. Reverse a list"></a>19. <font color="4895ef">Reverse a list</font></h3><blockquote><p>Reverse the order of the elements of list x.<br>This may reverse “in-place” and destroy the original ordering.</p></blockquote><p><em>反转链表</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(x)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">x[i], x[j] = x[j], x[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rust-9"><a href="#rust-9" class="headerlink" title="rust"></a>rust</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">vec!</span>[<span class="string">"Hello"</span>, <span class="string">"World"</span>];</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">Vec</span>&lt;_&gt; = x.iter().rev().collect();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"World"</span>, <span class="string">"Hello"</span>]</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    x.reverse();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="20-Return-two-values"><a href="#20-Return-two-values" class="headerlink" title="20. Return two values"></a>20. <font color="14213d">Return two values</font></h3><blockquote><p>Implement a function search which looks for item x in a 2D matrix m.<br>Return indices i, j of the matching cell.<br>Think of the most idiomatic way in the language to return the two values at the same time.</p></blockquote><p><em>实现在2D矩阵m中寻找元素x，返回匹配单元格的索引 i，j</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(m [][]<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> m[i] &#123;</span><br><span class="line"><span class="keyword">if</span> v == x &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, i, j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">search</span></span>&lt;T: <span class="built_in">Eq</span>&gt;(m: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;T&gt;&gt;, x: &amp;T) -&gt; <span class="built_in">Option</span>&lt;(<span class="built_in">usize</span>, <span class="built_in">usize</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, row) <span class="keyword">in</span> m.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">for</span> (j, column) <span class="keyword">in</span> row.iter().enumerate() &#123;</span><br><span class="line">            <span class="keyword">if</span> *column == *x &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">Some</span>((i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">11</span>],</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">22</span>, <span class="number">33</span>],</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="number">44</span>, <span class="number">55</span>],</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> hit = search(&amp;a, &amp;<span class="number">33</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, hit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Some</span>((<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://programming-idioms.org/about#about-block-cheatsheets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个网站&lt;/a&gt; 可以列出某门编程语言的常用语法，也可以对比两种语言的
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://www.dashen.tech/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Hex-Rays IDA与Hopper Disassembler</title>
    <link href="http://www.dashen.tech/2021/07/08/Hex-Rays-IDA%E4%B8%8EHopper-Disassembler/"/>
    <id>http://www.dashen.tech/2021/07/08/Hex-Rays-IDA与Hopper-Disassembler/</id>
    <published>2021-07-08T13:21:58.000Z</published>
    <updated>2021-07-08T13:21:58.035Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>以多位发明者名字命名的技术和工具</title>
    <link href="http://www.dashen.tech/2021/07/08/%E4%BB%A5%E5%A4%9A%E4%BD%8D%E5%8F%91%E6%98%8E%E8%80%85%E5%90%8D%E5%AD%97%E5%91%BD%E5%90%8D%E7%9A%84%E6%8A%80%E6%9C%AF%E5%92%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.dashen.tech/2021/07/08/以多位发明者名字命名的技术和工具/</id>
    <published>2021-07-08T12:22:35.000Z</published>
    <updated>2021-07-08T01:23:34.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母</p><h3 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h3><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><h3 id="rabin-carp"><a href="#rabin-carp" class="headerlink" title="rabin-carp"></a>rabin-carp</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h3&gt;&lt;p&gt;其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://www.dashen.tech/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>使用Cantor pair</title>
    <link href="http://www.dashen.tech/2021/07/08/%E4%BD%BF%E7%94%A8Cantor-pair/"/>
    <id>http://www.dashen.tech/2021/07/08/使用Cantor-pair/</id>
    <published>2021-07-08T02:15:47.000Z</published>
    <updated>2021-07-08T03:27:38.482Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.cyeam.com/golang/2017/02/07/go-optimize-pair" target="_blank" rel="noopener">https://blog.cyeam.com/golang/2017/02/07/go-optimize-pair</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.cyeam.com/golang/2017/02/07/go-optimize-pair&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.cyeam.com/golang/2017/02/
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用bitset</title>
    <link href="http://www.dashen.tech/2021/07/08/%E4%BD%BF%E7%94%A8bitset/"/>
    <id>http://www.dashen.tech/2021/07/08/使用bitset/</id>
    <published>2021-07-08T02:14:35.000Z</published>
    <updated>2021-07-08T02:14:46.390Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.cyeam.com/golang/2017/01/18/go-optimize-bitset" target="_blank" rel="noopener">https://blog.cyeam.com/golang/2017/01/18/go-optimize-bitset</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.cyeam.com/golang/2017/01/18/go-optimize-bitset&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.cyeam.com/golang/2017/0
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>构建在线小工具</title>
    <link href="http://www.dashen.tech/2021/07/07/%E6%9E%84%E5%BB%BA%E5%9C%A8%E7%BA%BF%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.dashen.tech/2021/07/07/构建在线小工具/</id>
    <published>2021-07-07T13:56:59.000Z</published>
    <updated>2021-07-07T07:48:18.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSON-to-Go"><a href="#JSON-to-Go" class="headerlink" title="JSON-to-Go"></a><a href="http://json2.dashen.tech/" target="_blank" rel="noopener">JSON-to-Go</a></h3><p><br></p><p>Convert JSON to Go struct</p><p>右键网页另存为，会将html文件和js文件夹拷贝到本地。</p><p>将其上传服务器，改一下资源文件夹的名字，以及html文件里引用的地址。然后添加nginx配置</p><p>项目在<code>/home/ubuntu/tools/json2go</code>目录下，nginx配置为<code>tool_json2to.conf</code></p><p>发现没有像预期中的，查看错误日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021/07/07 21:16:53 [crit] 18652#0: *45152 stat() "/home/ubuntu/tools/json2go/static/common.js" failed (13: Permission denied), client: 120.xxx.xxx.xx, server: json2.dashen.tech, request: "GET /static/common.js HTTP/1.1", host: "json2.dashen.tech", referrer: "http://json2.dashen.tech/"</span><br><span class="line">2021/07/07 21:16:53 [crit] 18652#0: *45152 stat() "/home/ubuntu/tools/json2go/static/common.js" failed (13: Permission denied), client: 120.xxx.xxx.xx, server: json2.dashen.tech, request: "GET /static/common.js HTTP/1.1", host: "json2.dashen.tech", referrer: "http://json2.dashen.tech/"</span><br></pre></td></tr></table></figure><p>资源请求失败</p><p>执行 <code>chmod -R 777 static/</code>， 如预期正常显示</p><p><img src="/2021/07/07/构建在线小工具/json2go.png" width="100%" height="50%"></p><p><br></p><hr><p><br></p><h3 id="在线json解析"><a href="#在线json解析" class="headerlink" title="在线json解析"></a><a href="http://json.dashen.tech/" target="_blank" rel="noopener">在线json解析</a></h3><p><br></p><p>路数如上，项目在<code>/home/ubuntu/tools/json</code>目录下，nginx配置为<code>tool_json.conf</code></p><p>并在nginx配置文件里给其添加访问认证(设置后需要输入账号密码才可访问该资源)</p><p><br></p><hr><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JSON-to-Go&quot;&gt;&lt;a href=&quot;#JSON-to-Go&quot; class=&quot;headerlink&quot; title=&quot;JSON-to-Go&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://json2.dashen.tech/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://www.dashen.tech/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>fmt包源码剖析</title>
    <link href="http://www.dashen.tech/2021/07/07/fmt%E5%8C%85%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://www.dashen.tech/2021/07/07/fmt包源码剖析/</id>
    <published>2021-07-07T13:33:24.000Z</published>
    <updated>2021-07-08T08:14:33.657Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/" target="_blank" rel="noopener">https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/</a></p><p><a href="https://blog.cyeam.com/golang/2018/09/10/fmt" target="_blank" rel="noopener">https://blog.cyeam.com/golang/2018/09/10/fmt</a></p><p><a href="https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool" target="_blank" rel="noopener">https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://yourbasic.org/golang/fmt-
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言抢占式调度</title>
    <link href="http://www.dashen.tech/2021/07/07/Go%E8%AF%AD%E8%A8%80%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6/"/>
    <id>http://www.dashen.tech/2021/07/07/Go语言抢占式调度/</id>
    <published>2021-07-07T00:37:13.000Z</published>
    <updated>2021-07-07T02:53:20.686Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dashen.tech/2020/09/15/sysmon-Runtime-Monitoring/" target="_blank" rel="noopener">sysmon–Runtime Monitoring</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">n++</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/07/Go语言抢占式调度/0.png" width="100%" height="50%"></p><p>如果是Go 1.14及以上版本，确实会如预期，一直输出递增的数字；</p><p>但对于Go 1.13及以下版本，居然会发生阻塞。</p><p><br></p><h3 id="1-13及以前"><a href="#1-13及以前" class="headerlink" title="1.13及以前"></a>1.13及以前</h3><p><br></p><p>使用gvm或Goland自带的版本切换功能，切回到Go 1.13.5</p><p>执行代码, 数字打印一段时间后，程序就“静止不动“了。</p><p><img src="/2021/07/07/Go语言抢占式调度/1.png" width="100%" height="50%"></p><p>机器是多核CPU，执行top命令，发现程序仍然在运行中。</p><p>但却没有继续输出，说明负责输出数字的goroutine阻塞了</p><p><img src="/2021/07/07/Go语言抢占式调度/2.png" width="100%" height="50%"></p><p><br></p><h3 id="通过dlv进行调试："><a href="#通过dlv进行调试：" class="headerlink" title="通过dlv进行调试："></a>通过dlv进行调试：</h3><p><br></p><p>拿到程序对应的进程id，执行</p><p><code>dlv attach pid</code></p><p><br></p><p>通过<code>grs</code>查看当前所有的协程</p><p><code>*</code>代表当前调试工具绑定到了该协程。 可通过</p><p><code>gr 6</code> 切换到6号协程；</p><p>然后可以继续 <code>grs</code>，</p><p>通过<code>bt</code>命令查看栈回溯，探究究竟阻塞在哪里</p><p><img src="/2021/07/07/Go语言抢占式调度/3.png" width="100%" height="50%"></p><p>可以看到实际阻塞发生在<a href>runtime.futex</a>这里，再往上倒，会找到<a href>runtime.gcStart</a>。阻塞发生在<em>gcStart</em>所在文件的第1287行。</p><p>定位到这一行，发现是在执行STW时发生了阻塞。</p><p><img src="/2021/07/07/Go语言抢占式调度/4.png" width="100%" height="50%"></p><p><br></p><p>GC开始前需要<em>STW</em>来 进行开启写屏障等准备工作. 所以STW就是要抢占所以的P，让它们暂时放下手中的活儿，让GC得以正常工作。</p><p>而我们(继续执行for{})的1号协程没能被抢占，一直在执行。而STW一直在等待它让出，这样就陷入了僵局</p><p><img src="/2021/07/07/Go语言抢占式调度/5.png" width="100%" height="50%"></p><p><br></p><h3 id="为何如此？"><a href="#为何如此？" class="headerlink" title="为何如此？"></a>为何如此？</h3><p><br></p><p><img src="/2021/07/07/Go语言抢占式调度/6.png" width="100%" height="50%"></p><p>STW时，GC需要抢占所有的P，但这不是值日生喊一嗓子就能清场的问题。</p><p>所以它会记录下自己要等待多少个P让出(<strong>sched.stopwait=gomaxprocs</strong>).</p><p>当该值减为0，目的就达到了</p><p><img src="/2021/07/07/Go语言抢占式调度/7.png" width="100%" height="50%"></p><p><img src="/2021/07/07/Go语言抢占式调度/8.png" width="100%" height="50%"></p><p>对于当前P，以及陷入系统调用中的P(<em>_Psyscall</em>)，还有空闲状态的P(<em>_Pidle</em>),直接将它们设置为<strong>_Pgcstop</strong>状态即可。</p><p><img src="/2021/07/07/Go语言抢占式调度/9.png" width="100%" height="50%"></p><p><img src="/2021/07/07/Go语言抢占式调度/10.png" width="100%" height="50%"></p><p>对于还有g在运行的p，则会将对应的<em>g.stackguard0</em>设置为一个特殊标识runtime.stackPreempt,告诉它GC在等待你让出呢</p><p><img src="/2021/07/07/Go语言抢占式调度/11.png" width="100%" height="50%"></p><p>此外还会设置一个<em>gcwaiting</em>标识 (sched.gcwaiting=1)。</p><p>接下来就通过这两个标识符的配合，来实现运行中的p的抢占。</p><p><img src="/2021/07/07/Go语言抢占式调度/12.png" width="100%" height="50%"></p><p><br></p><p>怎么实现呢？</p><p>goroutine在创建之初，栈的大小是固定的，为了防止栈溢出的情况，编译器会在有明显栈消耗的函数头部插入一些检测代码。通过<em>g.stackguard0</em>来判断是否需要进行栈增长</p><p><img src="/2021/07/07/Go语言抢占式调度/13.png" width="100%" height="50%"></p><p>但如果<em>g.stackguard0</em>被设置为特殊标识<em>runtime.stackPreempt</em>, 便不会去执行栈增长，而是去执行一次调度(schedule())。 在调度执行时，会检测gcwaiting标识。若发现GC在等待执行，便会让出当前p，将其置为_Pgcstop状态。</p><p><img src="/2021/07/07/Go语言抢占式调度/14.png" width="100%" height="50%"></p><p>1号协程之所以没有退出，是因为空的for循环并没有调用函数，也就没机会执行栈增长检测代码。所以它并不知道GC在等待它让出</p><p><br></p><p>依赖栈增长检测代码的方式，不算是真正的抢占式调度。</p><p>Go 1.14中迎来了真正的抢占式调度</p><p><br></p><h3 id="1-14"><a href="#1-14" class="headerlink" title="1.14:"></a>1.14:</h3><p><br></p><p>依赖栈增长检测代码的抢占代码的，遇到没有函数调用的情况就会出现问题。</p><p>在Go 1.14中，实现了基于信号的真正的抢占式调度。</p><p>因为基于信号实现，所以也称为<strong>异步抢占</strong></p><p><img src="/2021/07/07/Go语言抢占式调度/15.png" width="100%" height="50%"></p><p><br></p><p>函数<em>preemptone</em>用来抢占一个p，在1.13中，<em>preemptone</em>主要用来设置g.preempt=true，并将g.tsackguard0设置为特殊标识(stackPreempt)；</p><p>而在1.14中，增加了最后的if语句块，第一个判断用来确认当前硬件环境是否支持这种异步抢占，这个常量值(preemptMSupported)是在编译期间就确定的。</p><p>第二个判断用来检测用户是否允许开启异步抢占(默认允许)。 可通过GODEBUG环境变量来禁用异步抢占。</p><p>这两条验证都通过，则将p.preempt字段设置为true，实际的抢占操作交由<strong>preemptM</strong>函数来完成。</p><p>该函数的主要逻辑是，通过<em>runtime.signalM</em>函数，向指定M发送sigPreempt信号<code>----</code> 会调用操作系统中信号相关的系统调用，将指定信号发送给目标线程。 信号发出去了，异步抢占的前一半工作就算是完成了</p><p><img src="/2021/07/07/Go语言抢占式调度/16.png" width="100%" height="50%"></p><p><img src="/2021/07/07/Go语言抢占式调度/17.png" width="100%" height="50%"></p><p><br></p><p>接收到信号的工作线程 会调用对应的信号<em>handler</em>来处理。Go语言中的信号交由<strong>runtime.sighandler</strong>来处理。</p><p><strong>runtime.sighandler</strong>在确认信号为<em>sigPreempt</em>以后，会调用<em>doSigPreempt</em>函数。</p><p><em>doSigPreempt</em>函数会首先确认runtime是否要对指定的g进行异步抢占<code>----</code>首先指定的g与其对应p的preempt字段都要为true，且指定的g还要处在_Grunning状态；还要确认在当前位置打断g并执行异步抢占是安全的<code>----</code>1.指定的g可以挂起并安全的扫描它的栈和寄存器，并且当前被打断的位置并没有打断写屏障； 2.指定的g还有足够的栈空间来注入一个异步抢占函数调用(asyncPreempt); 3.这里可以安全的和runtime进行交互，主要是确定当前并没有持有runtime相关的锁，继而不会在后续尝试获得锁时造成死锁</p><p>这三点都ok，就可以放心的通过<strong>pushCall</strong>向g的执行上下文中注入异步抢占函数调用了。</p><p>被注入的异步抢占函数(asyncPreempt)是一个汇编函数，它会先把各个寄存器的值保存在栈上，也就是先保存现场到栈上，然后调用runtime.asyncPreempt2函数，这个函数最终会去执行schedule()</p><p><img src="/2021/07/07/Go语言抢占式调度/18.png" width="100%" height="50%"></p><p><img src="/2021/07/07/Go语言抢占式调度/19.png" width="100%" height="50%"></p><p><br></p><h3 id="使用dlv验证是否如此"><a href="#使用dlv验证是否如此" class="headerlink" title="使用dlv验证是否如此"></a>使用dlv验证是否如此</h3><p><br></p><hr><p><br></p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1kL411p7mW" target="_blank" rel="noopener">深度探索Go语言：抢占式调度</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://dashen.tech/2020/09/15/sysmon-Runtime-Monitoring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysmon–Runtime Monitoring&lt;/a&gt;&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust的所有权与生命周期</title>
    <link href="http://www.dashen.tech/2021/07/04/Rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.dashen.tech/2021/07/04/Rust的所有权与生命周期/</id>
    <published>2021-07-04T15:43:46.000Z</published>
    <updated>2021-07-04T16:06:07.345Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1564y1177A?t=2333" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1564y1177A?t=2333</a></p><p>借用 + 生命周期 = 痛苦之源</p><p><a href="https://zhuanlan.zhihu.com/p/104742696" target="_blank" rel="noopener">一个关于rust生命周期的问题分析</a></p><p>数据竞争： 线程安全的一生之敌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1564y1177A?t=2333&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bilibili.com/video/BV1564y1177A?t
      
    
    </summary>
    
    
      <category term="Rust" scheme="http://www.dashen.tech/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>使用FFmpeg将视频转换成音频</title>
    <link href="http://www.dashen.tech/2021/07/02/%E4%BD%BF%E7%94%A8FFmpeg%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E6%88%90%E9%9F%B3%E9%A2%91/"/>
    <id>http://www.dashen.tech/2021/07/02/使用FFmpeg将视频转换成音频/</id>
    <published>2021-07-02T13:32:51.000Z</published>
    <updated>2021-07-03T10:33:39.773Z</updated>
    
    <content type="html"><![CDATA[<p>整理移动硬盘,发现了一段2017年,在西安回民街青旅,素昧平生的三人闲谈,当时为视频录制,时长近一小时40分钟,超过10G.</p><p>听了后感觉很有意思,但没必要使用视频,音频形式空间小,更合适. </p><p><br></p><p>(三人分别为: 作为合伙人兼旅店日常理事的东北青年A,一表人才, 但其健谈程度远不及另外两位; </p><p>在此无偿打工&amp;免费住宿的与我一般大小的青年B,川陕之交的汉中宁强人,在海南读大学; </p><p><a href="https://dashen.tech/2017/04/13/coming-going/" target="_blank" rel="noopener">结束第一份工作</a>, “无房车压力,有过万存款”的C. <a href="https://dashen.tech/2017/05/05/%E9%95%BF%E5%AE%89%E5%8F%A4%E6%84%8F/" target="_blank" rel="noopener">游历古都</a>,<a href="https://dashen.tech/2017/05/30/%E5%8D%8E%E5%B1%B1%E5%88%AB%E4%BC%A0/" target="_blank" rel="noopener">攀登高岳</a>, 便从汴州到杭州,开启了一段996生涯</p><p> 后半段适逢在天津大学读研的俄罗斯西西伯利亚留学生问路华山,和其交谈些许)</p><!-- <img src="使用FFmpeg将视频转换成音频/3.png" width = 90% height = 50% /> --><p><img src="http://qvnyxkfve.hd-bkt.clouddn.com/ffmpeg3" alt></p><p>苦于本地没有视频转音频工具,和同事闲聊时,说”不就是用FFmpeg一行命令的事吗”,豁然开朗.</p><p><br></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><br></p><p>使用 <code>brew install ffmpeg</code> 时,因为依赖过多,(尤其升级Big Sur后),中途可能会报错:</p><!-- <img src="使用FFmpeg将视频转换成音频/1.png" width = 90% height = 50% /> --><p><img src="http://qvnyxkfve.hd-bkt.clouddn.com/ffmpeg1" alt></p><p>这时仅需 <code>brew install 安装失败的依赖名称</code>, 而后再 <code>brew install ffmpeg</code>. 如此往复便可安装成功.</p><p><br></p><h3 id="将视频转换为音频"><a href="#将视频转换为音频" class="headerlink" title="将视频转换为音频"></a>将视频转换为音频</h3><p><br></p><p><code>ffmpeg -i 视频名.MOV -vn  -acodec libmp3lame -ac 2 -qscale:a 4 -ar 48000  想要转成的音频名.mp3</code></p><p>不消几分钟,便可转换成功</p><!-- <img src="使用FFmpeg将视频转换成音频/2.png" width = 90% height = 50% /> --><p><img src="http://qvnyxkfve.hd-bkt.clouddn.com/ffmpeg2" alt></p><p><br></p><h3 id="将音频切分成多段"><a href="#将音频切分成多段" class="headerlink" title="将音频切分成多段"></a>将音频切分成多段</h3><p><br></p><p>需要对音频资源进行裁剪,同样一行命令搞定:</p><p><code>ffmpeg  -i source.mp3  -vn -acodec copy -ss 00:00:00.00 -t 00:30:00 part1.mp3</code></p><ul><li><p>-ss 从 小时：分：秒 处开始切割 </p></li><li><p>-t 持续时间</p></li><li><p>-to 到 <code>小时：分：秒.毫秒</code> 处截止</p></li></ul><p><br></p><!-- <img src="使用FFmpeg将视频转换成音频/4.png" width = 90% height = 50% /> --><p><img src="http://qvnyxkfve.hd-bkt.clouddn.com/ffmpeg4" alt></p><p><br></p><h3 id="将音频转为文字"><a href="#将音频转为文字" class="headerlink" title="将音频转为文字"></a>将音频转为文字</h3><p><br></p><p>音频内容太长,想要转成文字. 目前有很多 提供在线音频转文字 功能的平台,但大多需要收费,或体验不佳.</p><p>多番比选尝试,发现 <a href="https://jianwai.youdao.com/index/0" target="_blank" rel="noopener">网易见外</a> 综合下来最佳</p><!-- <img src="使用FFmpeg将视频转换成音频/6.png" width = 90% height = 50% /> --><p><img src="http://qvnyxkfve.hd-bkt.clouddn.com/ffmpeg6" alt></p><p><br></p><p>那一年,我24岁,相当健谈,天南海北地和人闲聊. 从东北到海南,安康和汉中,天水与兰州,丽江与大理,西西伯利亚和叶尼塞河, 似是都曾去过居住多年.</p><p>几天旅途很快结束，我匆匆回归为一名打工人角色。此后几年，也曾在疲乏和劳累间隙,找寻片刻之机踏上旅途,但再未和陌生人,有如此契阔的闲谈.</p><p><br></p><blockquote><p>少年侠气，交结五都雄。肝胆洞，毛发耸。立谈中，死生同。一诺千金重。推翘勇，矜豪纵。轻盖拥，联飞鞚，斗城东。轰饮酒垆，春色浮寒瓮，吸海垂虹。闲呼鹰嗾犬，白羽摘雕弓，狡穴俄空。乐匆匆。<br><br>似黄粱梦，辞丹凤；明月共，漾孤蓬。官冗从，怀倥偬；落尘笼，簿书丛。鹖弁如云众，供粗用，忽奇功。笳鼓动，渔阳弄，思悲翁。不请长缨，系取天骄种，剑吼西风。恨登山临水，手寄七弦桐，目送归鸿。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理移动硬盘,发现了一段2017年,在西安回民街青旅,素昧平生的三人闲谈,当时为视频录制,时长近一小时40分钟,超过10G.&lt;/p&gt;
&lt;p&gt;听了后感觉很有意思,但没必要使用视频,音频形式空间小,更合适. &lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(三人分别为: 作为合伙人兼旅
      
    
    </summary>
    
    
      <category term="Tools" scheme="http://www.dashen.tech/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Adler32算法</title>
    <link href="http://www.dashen.tech/2021/06/30/Adler32%E7%AE%97%E6%B3%95/"/>
    <id>http://www.dashen.tech/2021/06/30/Adler32算法/</id>
    <published>2021-06-30T13:20:17.000Z</published>
    <updated>2021-06-30T13:20:51.940Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper</p><p>为什么需要Adler-32算法<br>关于校验码算法，我们最熟悉的算法应该是CRC校验算法，那么有了CRC校验算法之后，为什么还要提出这样一个算法呢？</p><p>这个算法比CRC算法更加快速，但是安全性不如CRC．换句话说，就是在安全性和速度之间做了一个权衡．</p><p><a href="https://www.jianshu.com/p/7e983c9c4d69" target="_blank" rel="noopener">https://www.jianshu.com/p/7e983c9c4d69</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ZooKeeper&lt;/p&gt;
&lt;p&gt;为什么需要Adler-32算法&lt;br&gt;关于校验码算法，我们最熟悉的算法应该是CRC校验算法，那么有了CRC校验算法之后，为什么还要提出这样一个算法呢？&lt;/p&gt;
&lt;p&gt;这个算法比CRC算法更加快速，但是安全性不如CRC．换句话说，就是在安全性
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.dashen.tech/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希函数族谱</title>
    <link href="http://www.dashen.tech/2021/06/30/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E6%97%8F%E8%B0%B1/"/>
    <id>http://www.dashen.tech/2021/06/30/哈希函数族谱/</id>
    <published>2021-06-30T03:02:36.000Z</published>
    <updated>2021-07-08T01:34:22.683Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://halfrost.com/go_map_chapter_one/" target="_blank" rel="noopener">https://halfrost.com/go_map_chapter_one/</a></p><p><a href="https://blog.cyeam.com/hash/2018/05/28/hash-method" target="_blank" rel="noopener">https://blog.cyeam.com/hash/2018/05/28/hash-method</a></p><h3 id="DJB，也称Times33"><a href="#DJB，也称Times33" class="headerlink" title="DJB，也称Times33"></a>DJB，也称Times33</h3><p><br></p><p><a href="https://www.cnblogs.com/--zz/p/11141385.html" target="_blank" rel="noopener">Times33 DJB Hash 算法</a></p><h3 id="FNV"><a href="#FNV" class="headerlink" title="FNV"></a>FNV</h3><p><br></p><p>这个算法的厉害之处在于他可以保存状态。比如有个字符串ab，它的哈希值是a<em>E+b=HashAB，如果计算bc的哈希值，可以利用第一次计算的结果(HashAB-a</em>E)*E+c=HashBC。这么一个转换例子里是两个字符效果不明显，如果当前串是100个字符，后移一位的哈希算法性能就会快很多。</p><p><a href="https://blog.cyeam.com/hash/2014/07/28/fnv_md5" target="_blank" rel="noopener">https://blog.cyeam.com/hash/2014/07/28/fnv_md5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://halfrost.com/go_map_chapter_one/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://halfrost.com/go_map_chapter_one/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码辅助阅读工具</title>
    <link href="http://www.dashen.tech/2021/06/23/%E6%BA%90%E7%A0%81%E8%BE%85%E5%8A%A9%E9%98%85%E8%AF%BB%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.dashen.tech/2021/06/23/源码辅助阅读工具/</id>
    <published>2021-06-23T12:52:10.000Z</published>
    <updated>2021-06-23T13:31:12.841Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/378684243" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/378684243</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/378684243&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/378684243&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go unsafe包</title>
    <link href="http://www.dashen.tech/2021/06/22/Go-unsafe%E5%8C%85/"/>
    <id>http://www.dashen.tech/2021/06/22/Go-unsafe包/</id>
    <published>2021-06-22T13:55:08.000Z</published>
    <updated>2021-06-30T07:22:35.725Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://golang.org/src/unsafe/unsafe.go" target="_blank" rel="noopener">src/unsafe</a>路径下只有<em>unsafe.go</em>一个文件:</p><details><summary><b>unsafe.go:</b></summary><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Package unsafe contains operations that step around the type safety of Go programs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Packages that import unsafe may be non-portable and are not protected by the</span></span><br><span class="line"><span class="comment">Go 1 compatibility guidelines.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArbitraryType is here for the purposes of documentation only and is not actually</span></span><br><span class="line"><span class="comment">// part of the unsafe package. It represents the type of an arbitrary Go expression.</span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer represents a pointer to an arbitrary type. There are four special operations</span></span><br><span class="line"><span class="comment">// available for type Pointer that are not available for other types:</span></span><br><span class="line"><span class="comment">//- A pointer value of any type can be converted to a Pointer.</span></span><br><span class="line"><span class="comment">//- A Pointer can be converted to a pointer value of any type.</span></span><br><span class="line"><span class="comment">//- A uintptr can be converted to a Pointer.</span></span><br><span class="line"><span class="comment">//- A Pointer can be converted to a uintptr.</span></span><br><span class="line"><span class="comment">// Pointer therefore allows a program to defeat the type system and read and write</span></span><br><span class="line"><span class="comment">// arbitrary memory. It should be used with extreme care.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The following patterns involving Pointer are valid.</span></span><br><span class="line"><span class="comment">// Code not using these patterns is likely to be invalid today</span></span><br><span class="line"><span class="comment">// or to become invalid in the future.</span></span><br><span class="line"><span class="comment">// Even the valid patterns below come with important caveats.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Running "go vet" can help find uses of Pointer that do not conform to these patterns,</span></span><br><span class="line"><span class="comment">// but silence from "go vet" is not a guarantee that the code is valid.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (1) Conversion of a *T1 to Pointer to *T2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Provided that T2 is no larger than T1 and that the two share an equivalent</span></span><br><span class="line"><span class="comment">// memory layout, this conversion allows reinterpreting data of one type as</span></span><br><span class="line"><span class="comment">// data of another type. An example is the implementation of</span></span><br><span class="line"><span class="comment">// math.Float64bits:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//func Float64bits(f float64) uint64 &#123;</span></span><br><span class="line"><span class="comment">//return *(*uint64)(unsafe.Pointer(&amp;f))</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (2) Conversion of a Pointer to a uintptr (but not back to Pointer).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Converting a Pointer to a uintptr produces the memory address of the value</span></span><br><span class="line"><span class="comment">// pointed at, as an integer. The usual use for such a uintptr is to print it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Conversion of a uintptr back to Pointer is not valid in general.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A uintptr is an integer, not a reference.</span></span><br><span class="line"><span class="comment">// Converting a Pointer to a uintptr creates an integer value</span></span><br><span class="line"><span class="comment">// with no pointer semantics.</span></span><br><span class="line"><span class="comment">// Even if a uintptr holds the address of some object,</span></span><br><span class="line"><span class="comment">// the garbage collector will not update that uintptr's value</span></span><br><span class="line"><span class="comment">// if the object moves, nor will that uintptr keep the object</span></span><br><span class="line"><span class="comment">// from being reclaimed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The remaining patterns enumerate the only valid conversions</span></span><br><span class="line"><span class="comment">// from uintptr to Pointer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (3) Conversion of a Pointer to a uintptr and back, with arithmetic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If p points into an allocated object, it can be advanced through the object</span></span><br><span class="line"><span class="comment">// by conversion to uintptr, addition of an offset, and conversion back to Pointer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//p = unsafe.Pointer(uintptr(p) + offset)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The most common use of this pattern is to access fields in a struct</span></span><br><span class="line"><span class="comment">// or elements of an array:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// equivalent to f := unsafe.Pointer(&amp;s.f)</span></span><br><span class="line"><span class="comment">//f := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// equivalent to e := unsafe.Pointer(&amp;x[i])</span></span><br><span class="line"><span class="comment">//e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x[0])) + i*unsafe.Sizeof(x[0]))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is valid both to add and to subtract offsets from a pointer in this way.</span></span><br><span class="line"><span class="comment">// It is also valid to use &amp;^ to round pointers, usually for alignment.</span></span><br><span class="line"><span class="comment">// In all cases, the result must continue to point into the original allocated object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unlike in C, it is not valid to advance a pointer just beyond the end of</span></span><br><span class="line"><span class="comment">// its original allocation:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: end points outside allocated space.</span></span><br><span class="line"><span class="comment">//var s thing</span></span><br><span class="line"><span class="comment">//end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: end points outside allocated space.</span></span><br><span class="line"><span class="comment">//b := make([]byte, n)</span></span><br><span class="line"><span class="comment">//end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that both conversions must appear in the same expression, with only</span></span><br><span class="line"><span class="comment">// the intervening arithmetic between them:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">//// before conversion back to Pointer.</span></span><br><span class="line"><span class="comment">//u := uintptr(p)</span></span><br><span class="line"><span class="comment">//p = unsafe.Pointer(u + offset)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the pointer must point into an allocated object, so it may not be nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: conversion of nil pointer</span></span><br><span class="line"><span class="comment">//u := unsafe.Pointer(nil)</span></span><br><span class="line"><span class="comment">//p := unsafe.Pointer(uintptr(u) + offset)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (4) Conversion of a Pointer to a uintptr when calling syscall.Syscall.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Syscall functions in package syscall pass their uintptr arguments directly</span></span><br><span class="line"><span class="comment">// to the operating system, which then may, depending on the details of the call,</span></span><br><span class="line"><span class="comment">// reinterpret some of them as pointers.</span></span><br><span class="line"><span class="comment">// That is, the system call implementation is implicitly converting certain arguments</span></span><br><span class="line"><span class="comment">// back from uintptr to pointer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a pointer argument must be converted to uintptr for use as an argument,</span></span><br><span class="line"><span class="comment">// that conversion must appear in the call expression itself:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The compiler handles a Pointer converted to a uintptr in the argument list of</span></span><br><span class="line"><span class="comment">// a call to a function implemented in assembly by arranging that the referenced</span></span><br><span class="line"><span class="comment">// allocated object, if any, is retained and not moved until the call completes,</span></span><br><span class="line"><span class="comment">// even though from the types alone it would appear that the object is no longer</span></span><br><span class="line"><span class="comment">// needed during the call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For the compiler to recognize this pattern,</span></span><br><span class="line"><span class="comment">// the conversion must appear in the argument list:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">//// before implicit conversion back to Pointer during system call.</span></span><br><span class="line"><span class="comment">//u := uintptr(unsafe.Pointer(p))</span></span><br><span class="line"><span class="comment">//syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (5) Conversion of the result of reflect.Value.Pointer or reflect.Value.UnsafeAddr</span></span><br><span class="line"><span class="comment">// from uintptr to Pointer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr</span></span><br><span class="line"><span class="comment">// instead of unsafe.Pointer to keep callers from changing the result to an arbitrary</span></span><br><span class="line"><span class="comment">// type without first importing "unsafe". However, this means that the result is</span></span><br><span class="line"><span class="comment">// fragile and must be converted to Pointer immediately after making the call,</span></span><br><span class="line"><span class="comment">// in the same expression:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As in the cases above, it is invalid to store the result before the conversion:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">//// before conversion back to Pointer.</span></span><br><span class="line"><span class="comment">//u := reflect.ValueOf(new(int)).Pointer()</span></span><br><span class="line"><span class="comment">//p := (*int)(unsafe.Pointer(u))</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As in the previous case, the reflect data structures SliceHeader and StringHeader</span></span><br><span class="line"><span class="comment">// declare the field Data as a uintptr to keep callers from changing the result to</span></span><br><span class="line"><span class="comment">// an arbitrary type without first importing "unsafe". However, this means that</span></span><br><span class="line"><span class="comment">// SliceHeader and StringHeader are only valid when interpreting the content</span></span><br><span class="line"><span class="comment">// of an actual slice or string value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//var s string</span></span><br><span class="line"><span class="comment">//hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1</span></span><br><span class="line"><span class="comment">//hdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)</span></span><br><span class="line"><span class="comment">//hdr.Len = n</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In this usage hdr.Data is really an alternate way to refer to the underlying</span></span><br><span class="line"><span class="comment">// pointer in the string header, not a uintptr variable itself.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In general, reflect.SliceHeader and reflect.StringHeader should be used</span></span><br><span class="line"><span class="comment">// only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual</span></span><br><span class="line"><span class="comment">// slices or strings, never as plain structs.</span></span><br><span class="line"><span class="comment">// A program should not declare or allocate variables of these struct types.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// INVALID: a directly-declared header will not hold Data as a reference.</span></span><br><span class="line"><span class="comment">//var hdr reflect.StringHeader</span></span><br><span class="line"><span class="comment">//hdr.Data = uintptr(unsafe.Pointer(p))</span></span><br><span class="line"><span class="comment">//hdr.Len = n</span></span><br><span class="line"><span class="comment">//s := *(*string)(unsafe.Pointer(&amp;hdr)) // p possibly already lost</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sizeof takes an expression x of any type and returns the size in bytes</span></span><br><span class="line"><span class="comment">// of a hypothetical variable v as if v was declared via var v = x.</span></span><br><span class="line"><span class="comment">// The size does not include any memory possibly referenced by x.</span></span><br><span class="line"><span class="comment">// For instance, if x is a slice, Sizeof returns the size of the slice</span></span><br><span class="line"><span class="comment">// descriptor, not the size of the memory referenced by the slice.</span></span><br><span class="line"><span class="comment">// The return value of Sizeof is a Go constant.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Offsetof returns the offset within the struct of the field represented by x,</span></span><br><span class="line"><span class="comment">// which must be of the form structValue.field. In other words, it returns the</span></span><br><span class="line"><span class="comment">// number of bytes between the start of the struct and the start of the field.</span></span><br><span class="line"><span class="comment">// The return value of Offsetof is a Go constant.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alignof takes an expression x of any type and returns the required alignment</span></span><br><span class="line"><span class="comment">// of a hypothetical variable v as if v was declared via var v = x.</span></span><br><span class="line"><span class="comment">// It is the largest value m such that the address of v is always zero mod m.</span></span><br><span class="line"><span class="comment">// It is the same as the value returned by reflect.TypeOf(x).Align().</span></span><br><span class="line"><span class="comment">// As a special case, if a variable s is of struct type and f is a field</span></span><br><span class="line"><span class="comment">// within that struct, then Alignof(s.f) will return the required alignment</span></span><br><span class="line"><span class="comment">// of a field of that type within a struct. This case is the same as the</span></span><br><span class="line"><span class="comment">// value returned by reflect.TypeOf(s.f).FieldAlign().</span></span><br><span class="line"><span class="comment">// The return value of Alignof is a Go constant.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p></p><p><br></p><p>只有函数的签名和类型定义，但没有实现的代码：无论是 Go(<a href>go:linkname方式</a>) 还是汇编的代码(如<a href>byteag</a>里面的xx就是汇编代码实现)都没有。之所以如此，是因为 unsafe 包的功能需要在层次更低的编译器层面实现，所以这个包其实是内置在编译器里面实现的，<em>unsafe.go</em>这个文件只是为了达到文档记录的目的。</p><p><br></p><p>将注释移除,其实只有以下这几个函数和类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> unsafe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="keyword">type</span> ArbitraryType</span><br><span class="line"><span class="keyword">type</span> Pointer</span><br></pre></td></tr></table></figure><p><br></p><p>其中 <code>ArbitraryType</code> 类型只是为了文档记录的目的而存在，实际并没有参与到 unsafe 包的实现。这个类型代表了任意的 Go 语言表达式。</p><p>所以实际上 unsafe 包就只包含三个函数和一个类型</p><p><br></p><h3 id="func-Sizeof-x-ArbitraryType-uintptr"><a href="#func-Sizeof-x-ArbitraryType-uintptr" class="headerlink" title="func Sizeof(x ArbitraryType) uintptr"></a>func Sizeof(x ArbitraryType) uintptr</h3><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</span><br><span class="line">n1 <span class="keyword">int16</span></span><br><span class="line">n2 <span class="keyword">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Sizeof(X&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出: 4</p><p><br></p><blockquote><p>X 结构体有两个字段，其中每一个都占 2 个字节，所以整个结构体占用 size(n1) + size(n2) + size(X) = 2 + 2 + 0 = 4</p></blockquote><p><br></p><h3 id="func-Offsetof-x-ArbitraryType-uintptr"><a href="#func-Offsetof-x-ArbitraryType-uintptr" class="headerlink" title="func Offsetof(x ArbitraryType) uintptr"></a>func Offsetof(x ArbitraryType) uintptr</h3><p><br></p><p>返回的是 offset（偏移值）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</span><br><span class="line">n1 <span class="keyword">int16</span></span><br><span class="line">n2 <span class="keyword">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Offsetof(X&#123;&#125;.n1))</span><br><span class="line">fmt.Println(unsafe.Offsetof(X&#123;&#125;.n2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:  0 2</p><p><br></p><h3 id="func-Alignof-x-ArbitraryType-uintptr"><a href="#func-Alignof-x-ArbitraryType-uintptr" class="headerlink" title="func Alignof(x ArbitraryType) uintptr"></a>func Alignof(x ArbitraryType) uintptr</h3><p><br></p><p><a href="https://dashen.tech/2020/06/27/%E5%8F%8D%E5%B0%84/#%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">各种数据类型在内存中的结构</a></p><p><a href="https://dashen.tech/2020/02/03/%E6%9C%89%E5%85%B3%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" target="_blank" rel="noopener">有关内存对齐</a></p><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</span><br><span class="line">n1 <span class="keyword">int8</span></span><br><span class="line">n2 <span class="keyword">int16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(unsafe.Sizeof(X&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 4</p><p><br></p><p>为什么不是3?</p><blockquote><p>由于 alignment 机制的要求，n2 的内存起始地址应该是自身大小的整数倍，也就是说它的起始地址只能是 0、2、4、6、8 等偶数，所以 n2 的起始地址没有紧接着 n1 后面，而是空出了 1 个字节。最后导致结构体 X 的大小是 4 而不是 3。机智的读者可能会想到：n1 和 n2 换个位置会怎样呢？这样一来，n2 的起始地址是 0，而 n1 的其实地址是 2，这么一来结构体 X 的大小就变成 3 了吧？答案是……不对的。原因还是因为 alignment，因为 alignment 除了要求字段的其实地址应该是自身大小的整数倍，还要求整个结构体的大小，是结构体中最大的字段的大小的整数倍，这使得结构体可以由多个内存块组成，其中每个内存块的大小都等于最大的字段的大小。可以利用这个tips来减少结构体的内存占用</p></blockquote><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> First <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int64</span></span><br><span class="line">c <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Second <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">c <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(unsafe.Sizeof(First&#123;&#125;), unsafe.Sizeof(Second&#123;&#125;))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为: 24  16</p><blockquote><p>上面两个结构体大小不同，是因为 <em>First</em> 结构体由三个大小为 8 字节的内存块组成：<strong>Sizeof(First.a) + 7 个空闲的字节 + Sizeof(First.b) + Sizeof(First.c) + 7 个空闲的字节 = 24 字节</strong>;  而 <em>Second</em> 结构体只包含  2 个 大小为 8 字节的内存块：<strong>Sizeof(Second.a) + Sizeof(Second.b) + 6 个空闲的字节 + Sizeof(Second.b) = 16 字节</strong>。下次定义结构体的时候可以用上这个小知识(让占空间大的类型尽可能在后面)</p></blockquote><p><br></p><h3 id="总结这三个函数的用法"><a href="#总结这三个函数的用法" class="headerlink" title="总结这三个函数的用法"></a>总结这三个函数的用法</h3><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Size of x: "</span>, unsafe.Sizeof(x))</span><br><span class="line">fmt.Println(<span class="string">"Size of x.c: "</span>, unsafe.Sizeof(x.c))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Alignment of x.a: "</span>, unsafe.Alignof(x.a))</span><br><span class="line">fmt.Println(<span class="string">"Alignment of x.b: "</span>, unsafe.Alignof(x.b))</span><br><span class="line">fmt.Println(<span class="string">"Alignment of x.c: "</span>, unsafe.Alignof(x.c))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"\nOffset of x.a: "</span>, unsafe.Offsetof(x.a))</span><br><span class="line">fmt.Println(<span class="string">"Offset of x.b: "</span>, unsafe.Offsetof(x.b))</span><br><span class="line">fmt.Println(<span class="string">"Offset of x.c: "</span>, unsafe.Offsetof(x.c))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int64</span></span><br><span class="line">b <span class="keyword">bool</span></span><br><span class="line">c <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Size of x:  <span class="number">32</span></span><br><span class="line">Size of x.c:  <span class="number">16</span></span><br><span class="line">Alignment of x.a:  <span class="number">8</span></span><br><span class="line">Alignment of x.b:  <span class="number">1</span></span><br><span class="line">Alignment of x.c:  <span class="number">8</span></span><br><span class="line"></span><br><span class="line">Offset of x.a:  <span class="number">0</span></span><br><span class="line">Offset of x.b:  <span class="number">8</span></span><br><span class="line">Offset of x.c:  <span class="number">16</span></span><br></pre></td></tr></table></figure><p><br></p><p>这三个方法都是在<a href>编译期</a>执行的，这意味着只要编译器没有报错，在运行时也不会有问题发生</p><p>而 <code>unsafe.Pointer</code>则不然,有可能会发生<a href>运行时错误</a></p><p><br></p><h3 id="type-Pointer"><a href="#type-Pointer" class="headerlink" title="type Pointer"></a>type Pointer</h3><p><br></p><p><a href="https://mp.weixin.qq.com/s/MvULt7x0m4IBmz1bNzLvCQ" target="_blank" rel="noopener">Golang 语言中的非类型安全指针</a></p><hr><p><br></p><p>参考:</p><p><a href="https://mp.weixin.qq.com/s/PtAWvFrEUC8qXT3b46F7Rg" target="_blank" rel="noopener">灵魂一问：unsafe 包真的不安全吗？</a></p></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://golang.org/src/unsafe/unsafe.go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;src/unsafe&lt;/a&gt;路径下只有&lt;em&gt;unsafe.go&lt;/em&gt;一个文件:&lt;/p&gt;
&lt;details&gt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go database/sql代码解读</title>
    <link href="http://www.dashen.tech/2021/06/21/Go-database-sql%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://www.dashen.tech/2021/06/21/Go-database-sql代码解读/</id>
    <published>2021-06-21T06:22:38.000Z</published>
    <updated>2021-06-21T06:23:12.332Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zenlife.tk/sql-prepare.md" target="_blank" rel="noopener">sql 库的 prepare 行为设计得真脑残啊</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zenlife.tk/sql-prepare.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sql 库的 prepare 行为设计得真脑残啊&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
      <category term="数据库" scheme="http://www.dashen.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>并发编程中的ABA问题</title>
    <link href="http://www.dashen.tech/2021/06/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.dashen.tech/2021/06/21/并发编程中的ABA问题/</id>
    <published>2021-06-21T04:13:20.000Z</published>
    <updated>2021-06-21T04:14:02.165Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.baidu.com/s?tn=50000021_hao_pg&amp;ie=utf-8&amp;sc=UWd1pgw-pA7EnHc1FMfqnHmzPj01nHnzPHfzPBuW5y99U1Dznzu9m1YLnHnvPjf3Pjf&amp;ssl_sample=normal&amp;srcqid=5385164774958781453&amp;H123Tmp=nunew7&amp;word=ABA+%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">https://www.baidu.com/s?tn=50000021_hao_pg&amp;ie=utf-8&amp;sc=UWd1pgw-pA7EnHc1FMfqnHmzPj01nHnzPHfzPBuW5y99U1Dznzu9m1YLnHnvPjf3Pjf&amp;ssl_sample=normal&amp;srcqid=5385164774958781453&amp;H123Tmp=nunew7&amp;word=ABA+%E5%B9%B6%E5%8F%91</a></p><p><a href="https://www.zenlife.tk/lockfree1.md" target="_blank" rel="noopener">https://www.zenlife.tk/lockfree1.md</a></p><p><a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;srcqid=5385164774958781453&amp;tn=50000021_hao_pg&amp;wd=Hazard%E6%8C%87%E9%92%88&amp;oq=ABA%2520%25E5%25B9%25B6%25E5%258F%2591&amp;rsv_pq=9dd2290a0001d19b&amp;rsv_t=d52bUiod8NUuKWkvL%2B%2BSogJLOaPbuD4X7HWfSc1rklDdv%2B9nQ%2BDLTK3NJy%2BE03aEKyrkTCwJ&amp;rqlang=cn&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_sug3=1&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;rsv_btype=t&amp;inputT=664&amp;rsv_sug4=664" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;srcqid=5385164774958781453&amp;tn=50000021_hao_pg&amp;wd=Hazard%E6%8C%87%E9%92%88&amp;oq=ABA%2520%25E5%25B9%25B6%25E5%258F%2591&amp;rsv_pq=9dd2290a0001d19b&amp;rsv_t=d52bUiod8NUuKWkvL%2B%2BSogJLOaPbuD4X7HWfSc1rklDdv%2B9nQ%2BDLTK3NJy%2BE03aEKyrkTCwJ&amp;rqlang=cn&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_sug3=1&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;rsv_btype=t&amp;inputT=664&amp;rsv_sug4=664</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.baidu.com/s?tn=50000021_hao_pg&amp;amp;ie=utf-8&amp;amp;sc=UWd1pgw-pA7EnHc1FMfqnHmzPj01nHnzPHfzPBuW5y99U1Dznzu9m1YLnHnvPjf3P
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go race dectect</title>
    <link href="http://www.dashen.tech/2021/06/21/Go-race-dectect/"/>
    <id>http://www.dashen.tech/2021/06/21/Go-race-dectect/</id>
    <published>2021-06-20T16:30:21.000Z</published>
    <updated>2021-06-20T16:30:38.640Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zenlife.tk/race-dectect.md" target="_blank" rel="noopener">https://www.zenlife.tk/race-dectect.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zenlife.tk/race-dectect.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zenlife.tk/race-dectect.md&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>fmt.Println与println有多少区别</title>
    <link href="http://www.dashen.tech/2021/06/20/fmt-Println%E4%B8%8Eprintln%E6%9C%89%E5%A4%9A%E5%B0%91%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.dashen.tech/2021/06/20/fmt-Println与println有多少区别/</id>
    <published>2021-06-20T09:02:22.000Z</published>
    <updated>2021-07-06T12:10:36.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> midList []<span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">midList = <span class="built_in">append</span>(midList, <span class="keyword">int64</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> midList &#123;</span><br><span class="line">mid := v</span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">errG := err</span><br><span class="line">fmt.Println(<span class="string">"mid为:"</span>, mid)</span><br><span class="line"><span class="keyword">if</span> errG != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errG</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//println("i 为:", i)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会报错 <code>panic: too many concurrent operations on a single file or socket (max 1048575)</code></p><p>而将fmt.Println换作println,则不会有这个错误</p><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> midList []<span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">midList = <span class="built_in">append</span>(midList, <span class="keyword">int64</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> midList &#123;</span><br><span class="line">mid := v</span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">errG := err</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"mid为:"</span>, mid)</span><br><span class="line"><span class="keyword">if</span> errG != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errG</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//println("i 为:", i)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/20/fmt-Println与println有多少区别/0.png" width="100%" height="50%"></p><p><br></p><p><a href="https://geektutu.com/post/hpg-concurrency-control.html" target="_blank" rel="noopener">控制协程(goroutine)的并发数量</a></p><p><br></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p><br></p><p>使用<code>go build  -gcflags=-m 文件名.go</code>,</p><p>对于fmt.Println,因为其入参是interface,所以会发生逃逸</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">26</span>:<span class="number">15</span>: inlining call to fmt.Println</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">6</span>: moved to heap: g</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">22</span>:<span class="number">8</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">26</span>:<span class="number">16</span>: <span class="string">"mid为:"</span> escapes to heap</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">26</span>:<span class="number">16</span>: mid escapes to heap</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">26</span>:<span class="number">15</span>: []<span class="keyword">interface</span> &#123;&#125;&#123;...&#125; does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure><p>对于println,其入参是字符串,不会发生逃逸</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">21</span>:<span class="number">8</span>: can inline main.func1</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">6</span>: moved to heap: g</span><br><span class="line">./文件名.<span class="keyword">go</span>:<span class="number">21</span>:<span class="number">8</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><a href="http://reusee.github.io/post/escape_analysis/" target="_blank" rel="noopener">golang变量逃逸分析小探</a></p><p><br></p><hr><p><br></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([]<span class="keyword">byte</span>(<span class="string">"a"</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Println([]<span class="keyword">byte</span>(<span class="string">"a"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><p>···go<br>[1/1]0xc00006af67<br>[97]<br>···</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1.&quot;&gt;&lt;/a&gt;1.&lt;/h3&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.dashen.tech/tags/Go/"/>
    
  </entry>
  
</feed>
