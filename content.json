[{"title":"使用govaluate库进行逻辑判断","date":"2022-03-13T13:19:49.000Z","path":"2022/03/13/使用govaluate库进行逻辑判断/","text":"了解了下go生态内的表达式计算库，govaluate评价比较高，目前github有2300多个star 用这个库，比较容易解决某些场景下复杂规则计算的需求 相关使用参考Go 每日一库之 govaluate，以下是对该篇内容的实践与记录 demo1–基础款 使用govaluate计算表达式只需要两步： 调用NewEvaluableExpression()将表达式转为一个表达式对象(一个EvaluableExpression类型的结构体)； 调用表达式对象的Evaluate方法，传入参数，返回表达式的值。 123456789101112131415161718192021package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")func main() &#123; expr, err := govaluate.NewEvaluableExpression(\"10 &gt;= 0\") if err != nil &#123; fmt.Println(\"syntax error:\", err) &#125; result, err := expr.Evaluate(nil) if err != nil &#123; fmt.Println(\"evaluate error:\", err) &#125; fmt.Println(result)&#125; 输出： 1true 使用govaluate计算10 &gt;= 0的值，该表达式不需要参数，所以传给Evaluate()方法nil值。 当然这个例子并不实用。但有时并不知道需要计算的表达式的所有信息，甚至都不知道表达式的结构，这时govaluate的作用就体现出来了。 如果govaluate.NewEvaluableExpression()的表达式是不合法的，则err将不为nil， 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")func main() &#123; // 如果NewEvaluableExpression中的参数不是合法的逻辑表达式，则err会报 Invalid token: '!&gt;=' expr, err := govaluate.NewEvaluableExpression(\"10 !&gt;= 0\") if err != nil &#123; fmt.Println(\"syntax error:\", err) &#125; // 同时expr为nil fmt.Println(\"expr is：\", expr) // 此时需做return之类的判断。继续往下执行,调用为nil的expr的Evaluate，自然会panic: runtime error: invalid memory address or nil pointer dereference result, err := expr.Evaluate(nil) if err != nil &#123; fmt.Println(\"evaluate error:\", err) &#125; fmt.Println(result)&#125; 输出： 123456789syntax error: Invalid token: '!&gt;='expr is： &lt;nil&gt;panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x2 addr=0x0 pc=0x104d463f0]goroutine 1 [running]:main.main() /Users/fliter/go/src/shuang/govaluatee/a.go:17 +0x160exit status 2 demo2–带参数 支持在表达式中使用参数，调用表达式对象的Evaluate()方法时通过map[string]interface{}类型将参数传入运算。 其中map的键为参数名，值为参数值 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")// 省略了err的判断，正常情况需要有，否则可能panicfunc main() &#123; expr, _ := govaluate.NewEvaluableExpression(\"foo &gt; 0\") parameters := make(map[string]interface&#123;&#125;) parameters[\"foo\"] = -1 result, _ := expr.Evaluate(parameters) // 即 -1 &gt; 0 fmt.Println(result) // false expr, _ = govaluate.NewEvaluableExpression(\"(requests_made * requests_succeeded / 100) &gt;= 90\") parameters = make(map[string]interface&#123;&#125;) parameters[\"requests_made\"] = 100 parameters[\"requests_succeeded\"] = 80 result, _ = expr.Evaluate(parameters) // 即 80 &gt;= 90 fmt.Println(result) // false expr, _ = govaluate.NewEvaluableExpression(\"(mem_used / total_mem) * 100\") parameters = make(map[string]interface&#123;&#125;) parameters[\"total_mem\"] = 1024 parameters[\"mem_used\"] = 512 result, _ = expr.Evaluate(parameters) // 即 512/1024 * 100 fmt.Println(result) // 50&#125; 输出： 123falsefalse50 demo3–特殊标识符的处理 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")// demo省略了err的判断，正常情况需要有，否则可能panicfunc main() &#123; expr, err1 := govaluate.NewEvaluableExpression(\"response-time &lt; 100\") if err1 != nil &#123; fmt.Println(\"err1 is:\", err1) &#125; parameters := make(map[string]interface&#123;&#125;) parameters[\"response-time\"] = 80 result, err2 := expr.Evaluate(parameters) if err2 != nil &#123; fmt.Println(\"err2 is:\", err2) &#125; fmt.Println(result)&#125; 输出： 12err2 is: No parameter 'response' found.&lt;nil&gt; 如果NewEvaluableExpression()中的表达式是如同a+b&gt;100,或x-y&lt;50等情况，又想将a+b作为一个整体参数，通过parameters一次性传入，因为Go 代码中标识符中不能出现-、+、$等符号,故而需要转义处理。 主要方式有两种： 将名称用[和]包裹起来，例如[response-time]； 使用\\将紧接着下一个的字符转义。 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")// demo省略了err的判断，正常情况需要有，否则可能panicfunc main() &#123; expr, _ := govaluate.NewEvaluableExpression(\"[response-time] &lt; 100\") parameters := make(map[string]interface&#123;&#125;) parameters[\"response-time\"] = 80 result, _ := expr.Evaluate(parameters) // 80 &lt; 100 fmt.Println(result) //true//因为在字符串中\\本身就需要转义，所以表达式中要使用\\\\。或可使用`response\\-time` &lt; 100 expr, _ = govaluate.NewEvaluableExpression(\"response\\\\-time &lt; 100\") parameters = make(map[string]interface&#123;&#125;) parameters[\"response-time\"] = 80 result, _ = expr.Evaluate(parameters) fmt.Println(result)&#125; 输出： 12truetrue 而如果将response和time作为两个参数，则无需做处理,如下： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")// demo省略了err的判断，正常情况需要有，否则可能panicfunc main() &#123; expr, err1 := govaluate.NewEvaluableExpression(\"response-time &lt; 100\") if err1 != nil &#123; fmt.Println(\"err1 is:\", err1) &#125; parameters := make(map[string]interface&#123;&#125;) //parameters[\"response-time\"] = 80 parameters[\"response\"] = 80 parameters[\"time\"] = 10 result, err2 := expr.Evaluate(parameters) if err2 != nil &#123; fmt.Println(\"err2 is:\", err2) &#125; fmt.Println(result)&#125; 输出： 1true demo4–一次“编译”，多次运行 使用带参数的表达式，可实现一个表达式的一次“编译”，多次运行。只需要调用编译返回的表达式对象的Evaluate()方法即可 123456789101112131415161718192021package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")func main() &#123; expr, _ := govaluate.NewEvaluableExpression(\"a + b\") parameters := make(map[string]interface&#123;&#125;) parameters[\"a\"] = 1 parameters[\"b\"] = 2 result, _ := expr.Evaluate(parameters) fmt.Println(result) parameters = make(map[string]interface&#123;&#125;) parameters[\"a\"] = 10 parameters[\"b\"] = 20 result, _ = expr.Evaluate(parameters) fmt.Println(result)&#125; 输出： 12330 demo5–使用 自定义函数 如果仅仅只能进行常规的算数和逻辑运算，govaluate的功能则会大打折扣。govaluate还提供了强大的自定义函数功能 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")func main() &#123; // 所有自定义函数需要预先定义好，存入一个map[string]govaluate.ExpressionFunction变量中， functions := map[string]govaluate.ExpressionFunction&#123; \"strlen\": func(args ...interface&#123;&#125;) (interface&#123;&#125;, error) &#123; length := len(args[0].(string)) return length, nil &#125;, &#125; exprString := \"strlen('shuang_length')\" // 然后调用govaluate.NewEvaluableExpressionWithFunctions()生成表达式，在表达式中就可以使用该函数了 expr, _ := govaluate.NewEvaluableExpressionWithFunctions(exprString, functions) result, _ := expr.Evaluate(nil) fmt.Println(result)&#125; 输出： 113 函数可以接受任意数量的参数，且可处理嵌套函数调用的问题。所以能写出类似下面这种复杂的表达式： 123sqrt(x1 ** y1, x2 ** y2)max(someValue, abs(anotherValue), 10 * lastValue) demo6–访问器 处理结构体时，一般用不到 demo7–支持的操作和类型 govaluate支持的操作和类型与 Go 语言有些不同：一方面govaluate中的类型和操作不如 Go 丰富，另一方面govaluate也对一些操作进行了扩展。 算数、比较和逻辑运算： + - * / &amp; | ^ ** % &gt;&gt; &lt;&lt; ：加减乘除，按位与，按位或，异或，乘方，取模，左移和右移； &gt; &gt;= &lt; &lt; == =! ==~ !~,其中=~为正则匹配，!~为正则不匹配； || &amp;&amp;：逻辑或和逻辑与。 常量： 数字常量，govaluate中将数字都作为 64 位浮点数处理； 字符串常量，注意在govaluate中，字符串用单引号’； 日期时间常量，格式与字符串相同，govaluate会尝试自动解析字符串是否是日期，只支持 RFC3339、ISO8601等有限的格式； 布尔常量：true、false。 其他： 圆括号可以改变计算优先级； 数组定义在()中，每个元素之间用,分隔，可以支持任意的元素类型，如(1, 2, ‘foo’)。实际上在govaluate中数组是用[]interface{}来表示的； 三目运算符：? : 在下面代码中，govaluate会先将2014-01-02和2014-01-01 23:59:59转为time.Time类型，然后再比较大小： 123456789101112package mainimport ( \"fmt\" \"github.com/Knetic/govaluate\")func main() &#123; expr, _ := govaluate.NewEvaluableExpression(\"'2014-01-02' &gt; '2014-01-01 23:59:59'\") result, _ := expr.Evaluate(nil) fmt.Println(result)&#125; 输出： 1true demo8–错误处理 在创建表达式对象和表达式求值这两个操作中都可能产生错误:在生成表达式对象时，如果表达式有语法错误，则返回错误;表达式求值时，如果传入的参数不合法，或者某些参数缺失，或者访问结构体中不存在的字段都会报错。 demo部分代码","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"向前兼容与向后兼容","date":"2022-02-03T12:26:46.000Z","path":"2022/02/03/向前兼容与向后兼容/","text":"2012年3月发布了Go 1.0,随着 Go 第一个版本发布的还有一份兼容性说明文档。该文档说明，Go 的未来版本会确保向后兼容性，不会破坏现有程序。 即用10年前Go 1.0写的代码，用10年后的Go 1.18版本，依然可以正常运行。即较高版本的程序能正常处理较低版本程序的数据(代码) 反之则不然，如之前遇到过的这个问题：在Mac上用Go 1.16可正常编译&amp;运行的代码，在cvm服务器上Go 1.11版本，则编译不通过； 再如部署Spring Boot项目时遇到的，在Mac上用Java 17开发并打的jar包，在cvm服务器上，用Java 8运行会报错 一般会认为向前兼容是向之前的版本兼容，这理解其实是错误的。 注意要把「前」「后」分别理解成「前进」和「后退」，不可以理解成「从前」和「以后」 线上项目开发中，向后(后退)兼容非常重要; 向后兼容就是新版本的Go/Java，可以保证之前用老版本写的程序依然可以正常使用 前 forward 未来拓展。 后 backward 兼容以前。 向前兼容（Forward Compatibility）：指老版本的软／硬件可以使用或运行新版本的软／硬件产生的数据。“Forward”一词在这里有“未来”的意思，其实翻译成“向未来”更明确一些，汉语中“向前”是指“从前”还是“之后”是有歧义的。是旧版本对新版本的兼容 （即向前 到底是以前还是前面？实际是前面） 向上兼容（Upward Compatibility）：与向前兼容相同。 向后兼容（Backward Compatibility）：指新的版本的软／硬件可以使用或运行老版本的软／硬件产生的数据。是新版本对旧版本的兼容 向下兼容（Downward Compatibility）：与向后兼容相同。 软件的「向前兼容」和「向后兼容」如何区分？","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"部署Spring Boot项目","date":"2022-02-01T15:43:05.000Z","path":"2022/02/01/部署Spring-Boot项目/","text":"上传jar包 之前在新建Spring Boot项目使用mvn install的方式，已经构建出jar包。 通过scp或rz/sz，将该jar包上传到服务器 执行java -jar hello-0.0.1-SNAPSHOT.jar,发生如下报错： 12345678910111213141516171819Exception in thread \"main\" java.lang.UnsupportedClassVersionError: tech/dashen/hello/HelloApplication has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:468) at java.net.URLClassLoader.access$100(URLClassLoader.java:74) at java.net.URLClassLoader$1.run(URLClassLoader.java:369) at java.net.URLClassLoader$1.run(URLClassLoader.java:363) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:362) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:151) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:348) at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:46) at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:88) 这是由于编译环境与运行环境不一致导致: 本机执行 java -version 123openjdk version \"17.0.2\" 2022-01-18OpenJDK Runtime Environment (build 17.0.2+8-86)OpenJDK 64-Bit Server VM (build 17.0.2+8-86, mixed mode, sharing) 服务器上执行 java -version 123java version \"1.8.0_211\"Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) 服务器 安装/更新Java版本 通过cat .bashrc查看之前Java的配置： 12345#javaexport JAVA_HOME=/usr/local/java/jdk1.8.0_211export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 切换到/usr/local/java下： 可发现之前是使用直接下载&amp;编译的方式安装 决定这次依然不使用apt-get的方式。 在 此处 找到对应平台的Java 17，复制下载地址 使用wget + 下载地址下载到当前目录， sudo tar -zxvf jdk-17_linux-x64_bin.tar.gz,解压出jdk-17.0.2文件夹 修改.bashrc中Java的路径： 12345#javaexport JAVA_HOME=/usr/local/java/jdk-17.0.2export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 再去之前的目录下执行java -jar hello-0.0.1-SNAPSHOT.jar命令 可参考此，nohup java -jar hello-0.0.1-SNAPSHOT.jar &gt;temp.txt &amp;,让进程在后台运行。并会把日志文件输入到指定的temp.txt中 服务器 放开8080端口 参考腾讯云服务器安全组设置开放8080端口： 再请求服务器公网ip:8080/cui,如预期 关于Java的版本 依据 一文搞懂JDK8与Java1.8的区别, 从JDK1.5/JDK5开始，命名方式由之前的1.x，改成了x 故而DK1.8/JDK8是新旧命令方式导致的同一个东西的不同称谓。 即 Java8、JDK8、JDK1.8都是同一个东西 当前最新的版本是 Java 17 Java版本历史","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"新建Spring Boot项目","date":"2022-02-01T14:33:38.000Z","path":"2022/02/01/新建Spring-Boot项目/","text":"使用IDEA 来创建: 文件-新建-项目 填写项目元数据 选择依赖项 此处可以先选 web-spring web 关于这些依赖项，更多可参考：IDEA创建Spring boot项目时各依赖的说明（Developer Tools篇） 项目结构介绍 展开项目，此时会有一个以 项目名+Application 命名的java类，里面有main方法，这就是程序入口，run它就类似启动tomcat，表示项目启动了； 同时在resource目录下有个application.properties，这里存放配置文件，spring-boot启动时会来加载该文件 新建ShuangController类 并运行 新建ShuangController类，代码如下： 12345678910111213package tech.dashen.hello;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ShuangController &#123; @RequestMapping(\"cui\") public String shuangSpringBoot() &#123; return \"fliter use springboot\"; &#125;&#125; 访问 http://127.0.0.1:8080/cui，可见到如下输出： 更多运行方式 除去IDE的run，还可以在项目根目录下执行 mvn spring-boot:run 或通过mvn install 生成jar后运行： 在项目根目录下执行mvn install, 之后会在target文件夹下生成一个新的hello-0.0.1-SNAPSHOT.jar包， 执行java -jar hello-0.0.1-SNAPSHOT.jar springboot的三种启动方式 更多参考： 【Spring Boot】IDEA 创建Spring Boot项目（详细步骤） 更多创建Spring Boot的方式，可参考: 创建Spring boot方式 创建 SpringBoot 项目的两种方式","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"探究新版本新多出的协程","date":"2022-01-29T12:18:34.000Z","path":"2022/01/29/探究新版本新多出的协程/","text":"拉取Go 1.11镜像并启动 docker run -it --name golang-1.11 golang:1.11.6 安装vim 不带参数执行,4个协程: 123456789101112131415161718192021222324252627282930313233343536373839404142os.Args: [/tmp/go-build834710657/b001/exe/explore]len(os.Args): 1panic: before timersgoroutine 1 [running]:panic(0xb0160, 0xe5550) /usr/local/go/src/runtime/panic.go:556 +0x2c4 fp=0x400006ef10 sp=0x400006ee80 pc=0x34a14main.main() /go/explore.go:19 +0x1e0 fp=0x400006ef90 sp=0x400006ef10 pc=0x91c30runtime.main() /usr/local/go/src/runtime/proc.go:201 +0x204 fp=0x400006efd0 sp=0x400006ef90 pc=0x364b4runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400006efd0 sp=0x400006efd0 pc=0x5c1b4goroutine 2 [runnable]:runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:243 fp=0x400002cfd0 sp=0x400002cfd0 pc=0x36670runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002cfd0 sp=0x400002cfd0 pc=0x5c1b4created by runtime.init.3 /usr/local/go/src/runtime/proc.go:240 +0x28goroutine 3 [GC sweep wait]:runtime.gopark(0xd82b8, 0x173f80, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:302 +0xcc fp=0x400002d780 sp=0x400002d760 pc=0x3687cruntime.goparkunlock(0x173f80, 0xe140c, 0x1) /usr/local/go/src/runtime/proc.go:308 +0x44 fp=0x400002d7b0 sp=0x400002d780 pc=0x36914runtime.bgsweep(0x400004c000) /usr/local/go/src/runtime/mgcsweep.go:52 +0x90 fp=0x400002d7d0 sp=0x400002d7b0 pc=0x2acf0runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002d7d0 sp=0x400002d7d0 pc=0x5c1b4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:216 +0x4cgoroutine 4 [runnable]:runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:161 fp=0x400002dfd0 sp=0x400002dfd0 pc=0x22780runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002dfd0 sp=0x400002dfd0 pc=0x5c1b4created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x6cexit status 2 带参数执行,5个协程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354os.Args: [/tmp/go-build120473768/b001/exe/explore -111]len(os.Args): 2panic: after timersgoroutine 1 [running]:panic(0xb0160, 0xe5560) /usr/local/go/src/runtime/panic.go:556 +0x2c4 fp=0x4000092f10 sp=0x4000092e80 pc=0x34a14main.main() /go/explore.go:28 +0x1c0 fp=0x4000092f90 sp=0x4000092f10 pc=0x91c10runtime.main() /usr/local/go/src/runtime/proc.go:201 +0x204 fp=0x4000092fd0 sp=0x4000092f90 pc=0x364b4runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x4000092fd0 sp=0x4000092fd0 pc=0x5c1b4goroutine 2 [force gc (idle)]:runtime.gopark(0xd82b8, 0x173e80, 0x1410, 0x1) /usr/local/go/src/runtime/proc.go:302 +0xcc fp=0x400002af70 sp=0x400002af50 pc=0x3687cruntime.goparkunlock(0x173e80, 0x1410, 0x1) /usr/local/go/src/runtime/proc.go:308 +0x44 fp=0x400002afa0 sp=0x400002af70 pc=0x36914runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:251 +0xac fp=0x400002afd0 sp=0x400002afa0 pc=0x3671cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002afd0 sp=0x400002afd0 pc=0x5c1b4created by runtime.init.3 /usr/local/go/src/runtime/proc.go:240 +0x28goroutine 3 [GC sweep wait]:runtime.gopark(0xd82b8, 0x173f80, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:302 +0xcc fp=0x400002b780 sp=0x400002b760 pc=0x3687cruntime.goparkunlock(0x173f80, 0xe140c, 0x1) /usr/local/go/src/runtime/proc.go:308 +0x44 fp=0x400002b7b0 sp=0x400002b780 pc=0x36914runtime.bgsweep(0x400004c000) /usr/local/go/src/runtime/mgcsweep.go:52 +0x90 fp=0x400002b7d0 sp=0x400002b7b0 pc=0x2acf0runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002b7d0 sp=0x400002b7d0 pc=0x5c1b4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:216 +0x4cgoroutine 17 [runnable]:runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:161 fp=0x40000267d0 sp=0x40000267d0 pc=0x22780runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x40000267d0 sp=0x40000267d0 pc=0x5c1b4created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x6cgoroutine 18 [runnable]:runtime.timerproc(0x176be0) /usr/local/go/src/runtime/time.go:224 fp=0x400002a7d0 sp=0x400002a7d0 pc=0x4edc0runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1114 +0x4 fp=0x400002a7d0 sp=0x400002a7d0 pc=0x5c1b4created by runtime.(*timersBucket).addtimerLocked /usr/local/go/src/runtime/time.go:170 +0xf4exit status 2 go 1.13上： go version: go version go1.13.15 linux/arm64 不带参数，5个协程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758os.Args: [/tmp/go-build765375592/b001/exe/explore]len(os.Args): 1panic: before timersgoroutine 1 [running]:panic(0xb1c40, 0xef970) /usr/local/go/src/runtime/panic.go:722 +0x2d0 fp=0x4000052eb0 sp=0x4000052e20 pc=0x38870main.main() /go/explore.go:19 +0x238 fp=0x4000052f50 sp=0x4000052eb0 pc=0x9fc58runtime.main() /usr/local/go/src/runtime/proc.go:203 +0x214 fp=0x4000052fd0 sp=0x4000052f50 pc=0x3a464runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x4000052fd0 sp=0x4000052fd0 pc=0x61e94goroutine 2 [force gc (idle)]:runtime.gopark(0xde210, 0x1848f0, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002cfa0 sp=0x400002cf80 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:253 +0xc0 fp=0x400002cfd0 sp=0x400002cfa0 pc=0x3a6f0runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002cfd0 sp=0x400002cfd0 pc=0x61e94created by runtime.init.4 /usr/local/go/src/runtime/proc.go:242 +0x30goroutine 3 [GC sweep wait]:runtime.gopark(0xde210, 0x184a20, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002d7a0 sp=0x400002d780 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgsweep(0x400004a000) /usr/local/go/src/runtime/mgcsweep.go:70 +0xa8 fp=0x400002d7d0 sp=0x400002d7a0 pc=0x2e2f8runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002d7d0 sp=0x400002d7d0 pc=0x61e94created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:210 +0x54goroutine 4 [GC scavenge wait]:runtime.gopark(0xde210, 0x184b00, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002df30 sp=0x400002df10 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgscavenge(0x400004a000) /usr/local/go/src/runtime/mgcscavenge.go:299 +0xe4 fp=0x400002dfd0 sp=0x400002df30 pc=0x2da04runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002dfd0 sp=0x400002dfd0 pc=0x61e94created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:211 +0x74goroutine 17 [runnable]:runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:161 fp=0x40000287d0 sp=0x40000287d0 pc=0x24310runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x40000287d0 sp=0x40000287d0 pc=0x61e94created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78exit status 2 带参数，6个协程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172os.Args: [/tmp/go-build274885587/b001/exe/explore -123]len(os.Args): 2panic: after timersgoroutine 1 [running]:panic(0xb1c40, 0xef980) /usr/local/go/src/runtime/panic.go:722 +0x2d0 fp=0x4000052eb0 sp=0x4000052e20 pc=0x38870main.main() /go/explore.go:28 +0x21c fp=0x4000052f50 sp=0x4000052eb0 pc=0x9fc3cruntime.main() /usr/local/go/src/runtime/proc.go:203 +0x214 fp=0x4000052fd0 sp=0x4000052f50 pc=0x3a464runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x4000052fd0 sp=0x4000052fd0 pc=0x61e94goroutine 2 [force gc (idle)]:runtime.gopark(0xde210, 0x1848f0, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002afa0 sp=0x400002af80 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:253 +0xc0 fp=0x400002afd0 sp=0x400002afa0 pc=0x3a6f0runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002afd0 sp=0x400002afd0 pc=0x61e94created by runtime.init.4 /usr/local/go/src/runtime/proc.go:242 +0x30goroutine 3 [GC sweep wait]:runtime.gopark(0xde210, 0x184a20, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002b7a0 sp=0x400002b780 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgsweep(0x400004a000) /usr/local/go/src/runtime/mgcsweep.go:70 +0xa8 fp=0x400002b7d0 sp=0x400002b7a0 pc=0x2e2f8runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002b7d0 sp=0x400002b7d0 pc=0x61e94created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:210 +0x54goroutine 4 [GC scavenge wait]:runtime.gopark(0xde210, 0x184b00, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002bf30 sp=0x400002bf10 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgscavenge(0x400004a000) /usr/local/go/src/runtime/mgcscavenge.go:299 +0xe4 fp=0x400002bfd0 sp=0x400002bf30 pc=0x2da04runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002bfd0 sp=0x400002bfd0 pc=0x61e94created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:211 +0x74goroutine 5 [finalizer wait]:runtime.gopark(0xde210, 0x19fde8, 0x1410, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x400002a730 sp=0x400002a710 pc=0x3a840runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xbc fp=0x400002a7d0 sp=0x400002a730 pc=0x243ccruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002a7d0 sp=0x400002a7d0 pc=0x61e94created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78goroutine 6 [syscall]:runtime.notetsleepg(0x187680, 0x12a031252, 0x0) /usr/local/go/src/runtime/lock_futex.go:227 +0x30 fp=0x400002c750 sp=0x400002c720 pc=0x196a0runtime.timerproc(0x187660) /usr/local/go/src/runtime/time.go:311 +0x2a4 fp=0x400002c7d0 sp=0x400002c750 pc=0x54054runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1128 +0x4 fp=0x400002c7d0 sp=0x400002c7d0 pc=0x61e94created by runtime.(*timersBucket).addtimerLocked /usr/local/go/src/runtime/time.go:169 +0x110exit status 2 go 1.14 go versiongo version go1.14.15 linux/arm64 不带参数，5个协程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162os.Args: [/tmp/go-build251948969/b001/exe/explore]len(os.Args): 1panic: before timersgoroutine 1 [running]:panic(0xbe380, 0xfb230) /usr/local/go/src/runtime/panic.go:1064 +0x420 fp=0x400004eed0 sp=0x400004ee10 pc=0x3d0e0main.main() /go/explore.go:19 +0x238 fp=0x400004ef70 sp=0x400004eed0 pc=0xa4c48runtime.main() /usr/local/go/src/runtime/proc.go:203 +0x20c fp=0x400004efd0 sp=0x400004ef70 pc=0x3f97cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x400004efd0 sp=0x400004efd0 pc=0x69c14goroutine 2 [force gc (idle)]:runtime.gopark(0xe7700, 0x195960, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000028fa0 sp=0x4000028f80 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:253 +0xc0 fp=0x4000028fd0 sp=0x4000028fa0 pc=0x3fc00runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x4000028fd0 sp=0x4000028fd0 pc=0x69c14created by runtime.init.5 /usr/local/go/src/runtime/proc.go:242 +0x30goroutine 3 [GC sweep wait]:runtime.gopark(0xe7700, 0x195aa0, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x40000297a0 sp=0x4000029780 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgsweep(0x4000046000) /usr/local/go/src/runtime/mgcsweep.go:70 +0xa8 fp=0x40000297d0 sp=0x40000297a0 pc=0x2e408runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x40000297d0 sp=0x40000297d0 pc=0x69c14created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:214 +0x54goroutine 4 [GC scavenge wait]:runtime.gopark(0xe7700, 0x195a60, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000029f70 sp=0x4000029f50 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgscavenge(0x4000046000) /usr/local/go/src/runtime/mgcscavenge.go:237 +0xe4 fp=0x4000029fd0 sp=0x4000029f70 pc=0x2cc24runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x4000029fd0 sp=0x4000029fd0 pc=0x69c14created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:215 +0x74goroutine 17 [finalizer wait]:runtime.gopark(0xe7700, 0x1bef70, 0x1410, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000024730 sp=0x4000024710 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xbc fp=0x40000247d0 sp=0x4000024730 pc=0x244dcruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x40000247d0 sp=0x40000247d0 pc=0x69c14created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78exit status 2 带参数，也是5个协程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162os.Args: [/tmp/go-build768739727/b001/exe/explore -123]len(os.Args): 2panic: after timersgoroutine 1 [running]:panic(0xbe380, 0xfb240) /usr/local/go/src/runtime/panic.go:1064 +0x420 fp=0x400004eed0 sp=0x400004ee10 pc=0x3d0e0main.main() /go/explore.go:28 +0x21c fp=0x400004ef70 sp=0x400004eed0 pc=0xa4c2cruntime.main() /usr/local/go/src/runtime/proc.go:203 +0x20c fp=0x400004efd0 sp=0x400004ef70 pc=0x3f97cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x400004efd0 sp=0x400004efd0 pc=0x69c14goroutine 2 [force gc (idle)]:runtime.gopark(0xe7700, 0x195960, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000026fa0 sp=0x4000026f80 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:253 +0xc0 fp=0x4000026fd0 sp=0x4000026fa0 pc=0x3fc00runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x4000026fd0 sp=0x4000026fd0 pc=0x69c14created by runtime.init.5 /usr/local/go/src/runtime/proc.go:242 +0x30goroutine 3 [GC sweep wait]:runtime.gopark(0xe7700, 0x195aa0, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x40000277a0 sp=0x4000027780 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgsweep(0x4000046000) /usr/local/go/src/runtime/mgcsweep.go:70 +0xa8 fp=0x40000277d0 sp=0x40000277a0 pc=0x2e408runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x40000277d0 sp=0x40000277d0 pc=0x69c14created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:214 +0x54goroutine 4 [GC scavenge wait]:runtime.gopark(0xe7700, 0x195a60, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000027f70 sp=0x4000027f50 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.bgscavenge(0x4000046000) /usr/local/go/src/runtime/mgcscavenge.go:237 +0xe4 fp=0x4000027fd0 sp=0x4000027f70 pc=0x2cc24runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x4000027fd0 sp=0x4000027fd0 pc=0x69c14created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:215 +0x74goroutine 5 [finalizer wait]:runtime.gopark(0xe7700, 0x1bef70, 0x4000041410, 0x1) /usr/local/go/src/runtime/proc.go:304 +0xd0 fp=0x4000026730 sp=0x4000026710 pc=0x3fd50runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:310runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xbc fp=0x40000267d0 sp=0x4000026730 pc=0x244dcruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1148 +0x4 fp=0x40000267d0 sp=0x40000267d0 pc=0x69c14created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78exit status 2 分了两个步骤： 一个改动发生在1.11到1.13之间，不考虑定时器，同一段代码，协程会多一个。初步猜测是scavenge另一个是同一段代码，如果有定时器，go1.14会比go1.13及之前的少一个协程，少的是addtimerLocked 输出的信息中，有表明这个goroutine被谁created‘","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Rust时间和日期","date":"2022-01-08T14:56:26.000Z","path":"2022/01/08/Rust时间和日期/","text":"以下内容来自 Rust的官方库std::time::不太好用，chrono库用的更多 Cargo.toml: 123456789[package]name = \"time-ex\"version = \"0.1.0\"edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]chrono = \"0.4.19\" main.rs: 1234567891011use chrono::prelude::*;fn main() &#123; // 获取当前零时区的时间，以及当前所在时区的时间 let utc: DateTime&lt;Utc&gt; = Utc::now(); println!(\"零时区的时间为：&#123;:?&#125;\", utc); let local: DateTime&lt;Local&gt; = Local::now(); println!(\"当前时区的时间为： &#123;:?&#125;\", local)&#125; 123456789use chrono::prelude::*;fn main() &#123; //格式化string let date_time = Utc.ymd(1993, 2, 17).and_hms(5, 10, 23); println!(\"&#123;&#125;\", date_time.format(\"%Y-%m-%d %H:%M:%S\").to_string()); println!(\"&#123;&#125;\", date_time.format(\"%Y年%m月%d日: %H小时%M分钟%S秒\").to_string());&#125; 从某个日期开始的下一个周五是几号？ 如从2022.01.09号开始，下一个周五是几号(2022.01.14号)","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"OBS推流","date":"2021-12-14T12:00:58.000Z","path":"2021/12/14/OBS推流/","text":"为深入理解rtmp，推流，互动直播，录制，特意尝试了下使用OBS来推流到(各大)直播平台。。 以斗鱼为例，申请成为主播后，会得到rtmp地址和直播码， 下载OBS 右下角，设置-推流-自定义: 接着设置来源,即想要在直播平台上显示的东西 点击加号，选择 显示器采集， （之前版本坑叫显示捕获），这样整个屏幕都会被推到直播平台 点击右侧开始推流，就会将选定的”来源“（此处即显示器屏幕），推流到斗鱼的房间 使用窗口采集，则只会推这个窗口的信息 还需要再解决下窗口显示不全的问题 更多参考： OBS推流直播快速上手教程","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"二进制分析工具","date":"2021-12-14T01:58:49.000Z","path":"2021/12/14/二进制分析工具/","text":"https://www.google.com.hk/search?q=ar%2C+nm%2C+objdump&amp;oq=ar%2C+nm%2C+objdump&amp;aqs=chrome..69i57j69i61.160j0j1&amp;sourceid=chrome&amp;ie=UTF-8 https://blog.csdn.net/princess9/article/details/6785108 nm https://blog.csdn.net/K346K346/article/details/89088542 https://www.jianshu.com/p/a86bd1b8e4a5 https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html https://blog.csdn.net/weixin_36094492/article/details/112657647 https://www.google.com.hk/search?q=go+tool+nm%E5%91%BD%E4%BB%A4&amp;oq=go+tool+nm%E5%91%BD%E4%BB%A4&amp;aqs=chrome..69i57j69i64l2j69i60.187j0j4&amp;sourceid=chrome&amp;ie=UTF-8 https://segmentfault.com/a/1190000040043628","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"协程调度顺序","date":"2021-12-12T15:37:29.000Z","path":"2021/12/12/协程调度顺序/","text":"本文是对卷卷面试题的学习与记录 go 关键字会被编译器转化为对runtime.newproc函数的调用。该函数的主要逻辑：先切换到系统栈，然后调用newproc1函数，分配并初始化一个新的g，再通过runqput把新的g添加到当前P的本地runq中。 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"runtime\" \"sync\")func main() &#123; // 任一时刻，只允许一个M执行Go代码； 就像单核CPU上的多线程那样 runtime.GOMAXPROCS(1) var wg sync.WaitGroup wg.Add(3) go func(n int) &#123; println(n) wg.Done() &#125;(1) go func(n int) &#123; println(n) wg.Done() &#125;(2) go func(n int) &#123; println(n) wg.Done() &#125;(3) wg.Wait()&#125; 输出: 123312 之所以如此，是因为 P不仅有一个本地runq，还有一个runnext字段，用来保存下次要运行的g。 newproc1中调用runqput时会用到这个runnext 调度goroutine执行时，通过runqget获取待执行的g。runqget也会对runnext特殊处理：优先调度runnext这里记录的g，再按顺序调度本地runq中记录的g 所以是3-1-2 如果创建更多的goroutine，结果也如此吗？ 12345678910111213141516171819202122232425package mainimport ( \"runtime\" \"sync\")func main() &#123; // 任一时刻，只允许一个M执行Go代码； 就像单核CPU上的多线程那样 runtime.GOMAXPROCS(1) var wg sync.WaitGroup for i := 1; i &lt;= 280; i++ &#123; wg.Add(1) go func(n int) &#123; println(n) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 4个goroutine输出的是 4,1,2,35个goroutine输出的是 5,1,2,3,4 直到257个gorutine，都是这样的规律, 即 N,1,2,….,(N-1) 当多于257个goutine时， 第258号goutine会把257号挤走，但本地runq已满，所以第257号goroutine，会和本地runq中前一半的g，一同进入到全局runq中， 先从本地runq中获取待执行的g，没有的话，再从全局runq获取。还没有的话，就去其他P那里steal一部分(一半)， 所以可能会以为，先执行258号，而后是129，130…,256。最后才是全局队列中的1，2，…128，257 实际并非如此… 实际执行会发现，第1号，2号goroutine，会穿插在258，129，….258之间被执行。 这个问题与runq的排队逻辑无关，属于调度逻辑的范畴 runtime.schedule，每隔61个schedtick，就会优先尝试从全局runq中获取goroutine，这是为了避免在每个P的本地runq都很繁忙时，全局runq中的goroutine迟迟得不到调度的情况。 本地runq的排队逻辑(runnext) 全局runq，每隔61个schedtick会优先从全局runq中拿一个goroutine去执行 更多阅读 迷惑的 goroutine 执行顺序 Go 调度的本质","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go内存管理之内存分配","date":"2021-11-24T12:01:36.000Z","path":"2021/11/24/Go内存管理之内存分配/","text":"相关博文 golang中slice扩容一定是double或1.25倍吗 Go内存详解 较好博文： 图解Go语言内存分配 Go内存管理三部曲[1]- 内存分配 https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/ go 内存管理 设计与实现 图解 本篇是对以上内容的学习与记录： Go运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。 Go在程序启动时 先向操作系统申请一块内存，并将其分配到三个区域： arena区域(512GB，64位操作系统)，即堆区，Go动态分配的内存都在该区域，其将内存分割成8KB大小的页，一些页组合起来称为mspan bitmap区域(16GB)，标识arena区域哪些地址保存了对象，并用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是512GB/(4*8B)=16GB spans区域(512MB)：存放mspan（arena分割的页组合起来的内存管理基本单元）的指针，每个指针对应一页，所以spans区域的大小就是512GB/8KB*8B=512MB。(除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充对应的spans区域，在回收object时，根据地址很容易就能找到它所属的mspan) mspan 是Go内存管理的基本单元，mspan是由一片连续的8KB的页组成的大块内存。这里的页和操作系统本身的页不是一回事，它一般是操作系统页大小的几倍。即mspan是一个包含起始地址、mspan规格、页的数量等内容的双端链表 细微的对象切割 极致的多级缓存 精准的位图管理 更多： Go 内存分配器可视化指南","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go内存优化","date":"2021-11-17T05:47:32.000Z","path":"2021/11/17/Go内存优化/","text":"https://wudaijun.com/2019/09/go-performance-optimization/","tags":[]},{"title":"关于零号协程","date":"2021-11-09T05:45:55.000Z","path":"2021/11/09/关于零号协程/","text":"https://mp.weixin.qq.com/s?__biz=Mzg2NTA2NzQ2Nw==&amp;mid=2247483873&amp;idx=1&amp;sn=724560a071a4ca6b620837d05e29a54e https://zhuanlan.zhihu.com/p/344842279","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"统计某月有几篇博文","date":"2021-10-11T15:24:31.000Z","path":"2021/10/11/统计某月有几篇博文/","text":"有插件可以将各个月份博文的数量统计并附在其后，不太喜欢这种展示方式(认为展示出的参差数据，破坏和谐一致的感觉)，自己动手，只统计不展示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( \"fmt\" \"io/ioutil\" \"regexp\" \"strings\" \"time\")var m = make(map[string]int)func main() &#123; basePath := \"/Users/fliter/blog/source/_posts/\" // 获取某目录下的所有文件; 也可以用 files, _ := filepath.Glob(\"*\") files, _ := ioutil.ReadDir(basePath) for _, f := range files &#123; if strings.Contains(f.Name(), \".md\") &#123; //fmt.Println(f.Name()) deal(basePath + f.Name()) &#125; &#125; fmt.Println(m) fmt.Println() fmt.Println(\"下面迭代时会乱序：\") fmt.Println() for k, v := range m &#123; fmt.Printf(\"%s月有%d篇博文\\n\", k, v) &#125;&#125;func deal(filePath string) &#123; //fmt.Println(filePath) // /Users/fliter/blog/source/_posts/16777619与FNV哈希算法.md // read the whole file at once b, err := ioutil.ReadFile(filePath) if err != nil &#123; panic(err) &#125; s := string(b) //fmt.Println(s) // 进行正则匹配 // go - 如何获得两个已知单词之间的字符串？ https://www.coder.work/article/212986 // 或者可以预先将换行符及空格等全部清除掉 re := regexp.MustCompile(`date: (.*?)tags:`) date := re.FindStringSubmatch(s)[1] //fmt.Println(date) // 2021-08-09 22:30:47 t, _ := time.Parse(\"2006-01-02 15:04:05\", date) month := time.Unix(t.Unix(), 0).Format(\"2006-01\") //fmt.Println(month) // 2021-08 m[month] = m[month] + 1 //os.Exit(11)&#125; 执行结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596map[1093-02:23 2010-03:9 2011-04:1 2012-01:2 2012-11:8 2012-12:2 2013-04:5 2014-03:4 2014-04:1 2015-01:2 2015-02:3 2015-03:143 2015-04:3 2015-05:1 2015-06:3 2015-07:2 2015-08:6 2015-09:7 2015-10:7 2015-11:25 2015-12:5 2016-02:3 2016-03:8 2016-04:9 2016-05:4 2016-06:8 2016-07:5 2016-08:4 2016-09:2 2016-10:11 2016-11:6 2016-12:4 2017-01:3 2017-02:9 2017-03:9 2017-04:7 2017-05:10 2017-06:8 2017-07:11 2017-08:6 2017-09:6 2017-10:9 2017-11:4 2017-12:5 2018-01:6 2018-02:7 2018-03:8 2018-04:8 2018-05:8 2018-06:6 2018-07:11 2018-08:10 2018-09:6 2018-10:9 2018-11:6 2018-12:5 2019-01:7 2019-02:10 2019-03:11 2019-04:12 2019-05:8 2019-06:9 2019-07:14 2019-08:9 2019-09:8 2019-10:12 2019-11:9 2019-12:8 2020-01:9 2020-02:9 2020-03:11 2020-04:10 2020-05:13 2020-06:14 2020-07:10 2020-08:7 2020-09:10 2020-10:10 2020-11:11 2020-12:6 2021-01:10 2021-02:8 2021-03:7 2021-04:8 2021-05:8 2021-06:8 2021-07:8 2021-08:4 2021-09:17 2021-10:1 2021-11:3 2021-12:2]下面迭代时会乱序：2015-09月有7篇博文2017-11月有4篇博文2015-06月有3篇博文2020-04月有10篇博文2018-11月有6篇博文2020-03月有11篇博文2019-04月有12篇博文2019-03月有11篇博文2017-09月有6篇博文2015-01月有2篇博文2015-08月有6篇博文2021-02月有8篇博文2021-12月有2篇博文2016-04月有9篇博文2017-04月有7篇博文1093-02月有23篇博文2013-04月有5篇博文2019-08月有9篇博文2018-03月有8篇博文2020-08月有7篇博文2017-01月有3篇博文2015-02月有3篇博文2020-11月有11篇博文2019-11月有9篇博文2016-11月有6篇博文2011-04月有1篇博文2021-11月有3篇博文2018-06月有6篇博文2016-09月有2篇博文2015-11月有25篇博文2021-10月有1篇博文2019-12月有8篇博文2017-07月有11篇博文2017-12月有5篇博文2020-06月有14篇博文2020-12月有6篇博文2019-06月有9篇博文2021-07月有8篇博文2016-03月有8篇博文2015-05月有1篇博文2021-04月有8篇博文2018-09月有6篇博文2016-07月有5篇博文2021-08月有4篇博文2021-06月有8篇博文2021-09月有17篇博文2012-12月有2篇博文2018-07月有11篇博文2018-04月有8篇博文2020-02月有9篇博文2019-02月有10篇博文2010-03月有9篇博文2020-05月有13篇博文2015-07月有2篇博文2012-01月有2篇博文2019-05月有8篇博文2016-02月有3篇博文2017-10月有9篇博文2021-03月有7篇博文2018-08月有10篇博文2016-08月有4篇博文2019-10月有12篇博文2020-10月有10篇博文2016-05月有4篇博文2017-08月有6篇博文2018-05月有8篇博文2015-03月有143篇博文2015-04月有3篇博文2018-10月有9篇博文2021-01月有10篇博文2018-01月有6篇博文2014-03月有4篇博文2020-07月有10篇博文2017-03月有9篇博文2019-07月有14篇博文2014-04月有1篇博文2017-06月有8篇博文2016-06月有8篇博文2017-05月有10篇博文2017-02月有9篇博文2015-10月有7篇博文2012-11月有8篇博文2021-05月有8篇博文2018-02月有7篇博文2016-10月有11篇博文2020-01月有9篇博文2019-09月有8篇博文2015-12月有5篇博文2019-01月有7篇博文2020-09月有10篇博文2016-12月有4篇博文2018-12月有5篇博文 几处可改进点： 并发执行deal(),同时需使用sync.map 将乱序的map改成按序输出 可以将路径及处理的文件类型(此处为*.md),以及匹配的文本(此处为date:和tag:之间的内容), 做成参数形式传递,从而使该方法更通用","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"调试Go源代码","date":"2021-10-11T13:16:38.000Z","path":"2021/10/11/调试Go源代码/","text":"编译源码方式安装新版本Go 通过源代码编译安装go1.18beta1, 12345git clone https://github.com/golang/go.gitcd gogit reset --hard becaeeacd srcvim all.bash all.bash内容如下： 123456789101112131415#!/usr/bin/env bash# Copyright 2009 The Go Authors. All rights reserved.# Use of this source code is governed by a BSD-style# license that can be found in the LICENSE file.set -eif [ ! -f make.bash ]; then echo 'all.bash must be run from $GOROOT/src' 1&gt;&amp;2 exit 1fiOLDPATH=\"$PATH\". ./make.bash \"$@\" --no-bannerbash run.bash --no-rebuildPATH=\"$OLDPATH\"$GOTOOLDIR/dist banner # print build info 注释掉bash run.bash --no-rebuild这一行，这样每次构建时, 不需要重新跑一遍测试脚本，每次都要大概耗时5分钟 将make.bash的./cmd/dist/dist bootstrap -a $vflag $GO_DISTFLAGS &quot;$@&quot;替换为./cmd/dist/dist bootstrap -a -v, 默认 -v 标记不打开, 这样就看不到进度和错误提示 1234567% vim make.bash# 未替换之前的行# ./cmd/dist/dist bootstrap -a $vflag $GO_DISTFLAGS \"$@\"# 替换之后的行, -a 表示所有模块, -v 会输出任何错误提示./cmd/dist/dist bootstrap -a -v# 如果只更改了某个包下的文件, 并不需要重新构建整个项目, 可只指定某一个目录# ./cmd/dist/dist install -v \"runtime\" 执行编译脚本 ./all.bash:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948Building Go cmd/dist using /usr/local/go. (go1.16.7 darwin/arm64)Building Go toolchain1 using /usr/local/go.math/bitsbootstrap/internal/goexperimentbootstrap/math/bitsbootstrap/internal/unsafeheaderbootstrap/internal/goversionbootstrap/internal/racebootstrap/cmd/compile/internal/testbootstrap/sortmathbootstrap/container/heapmath/randbootstrap/strconvstrconvio/ioutilos/execreflectcryptoregexp/syntaxregexpencoding/binaryfmtbootstrap/cmd/internal/sysencoding/base64crypto/sha256crypto/sha1crypto/md5flagbootstrap/cmd/internal/editbootstrap/cmd/internal/pkgpathbootstrap/cmd/internal/biobootstrap/cmd/internal/srcbootstrap/internal/buildcfgbootstrap/debug/dwarfbootstrap/compress/flatego/tokenencoding/jsonbootstrap/math/bignet/urlbootstrap/cmd/internal/quotedbootstrap/cmd/internal/objabibootstrap/cmd/internal/gcproggo/scannerbootstrap/cmd/compile/internal/syntaxbootstrap/cmd/internal/dwarftext/template/parsebootstrap/cmd/internal/goobjbootstrap/cmd/asm/internal/flagsbootstrap/compress/zlibbootstrap/cmd/asm/internal/lexbootstrap/cmd/internal/objgo/astbootstrap/cmd/internal/archivecompress/flatebootstrap/debug/elfbootstrap/debug/machobootstrap/debug/pebootstrap/internal/xcoffcompress/gzipbootstrap/cmd/internal/codesigngo/parsergo/printergo/docbootstrap/cmd/internal/obj/armbootstrap/cmd/internal/obj/arm64bootstrap/cmd/internal/obj/mipsbootstrap/cmd/internal/obj/ppc64bootstrap/cmd/internal/obj/riscvbootstrap/cmd/internal/obj/s390xbootstrap/cmd/internal/obj/wasmbootstrap/cmd/internal/obj/x86bootstrap/cmd/cgobootstrap/cmd/compile/internal/basebootstrap/go/constantbootstrap/cmd/compile/internal/logoptbootstrap/cmd/compile/internal/bitvecgo/buildruntime/pprofbootstrap/cmd/link/internal/symbootstrap/cmd/compile/internal/typesbootstrap/cmd/compile/internal/types2bootstrap/cmd/link/internal/loaderbootstrap/cmd/link/internal/dwtestbootstrap/cmd/link/internal/benchmarkbootstrap/cmd/asm/internal/archbootstrap/cmd/compile/internal/typebitsbootstrap/cmd/compile/internal/irbootstrap/cmd/link/internal/loadelfbootstrap/cmd/link/internal/loadpebootstrap/cmd/link/internal/loadmachobootstrap/cmd/asm/internal/asmbootstrap/cmd/link/internal/loadxcoffbootstrap/cmd/link/internal/ldbootstrap/cmd/asmbootstrap/cmd/compile/internal/objwbootstrap/cmd/compile/internal/abibootstrap/cmd/compile/internal/deadcodebootstrap/cmd/compile/internal/typecheckbootstrap/cmd/compile/internal/importerbootstrap/cmd/link/internal/amd64bootstrap/cmd/link/internal/armbootstrap/cmd/link/internal/arm64bootstrap/cmd/link/internal/riscv64bootstrap/cmd/link/internal/mipsbootstrap/cmd/link/internal/ppc64bootstrap/cmd/link/internal/mips64bootstrap/cmd/link/internal/s390xbootstrap/cmd/link/internal/wasmbootstrap/cmd/link/internal/x86bootstrap/cmd/linkbootstrap/cmd/compile/internal/inlinebootstrap/cmd/compile/internal/devirtualizebootstrap/cmd/compile/internal/staticdatabootstrap/cmd/compile/internal/escapebootstrap/cmd/compile/internal/reflectdatabootstrap/cmd/compile/internal/staticinitbootstrap/cmd/compile/internal/ssabootstrap/cmd/compile/internal/pkginitbootstrap/cmd/compile/internal/livenessbootstrap/cmd/compile/internal/ssagenbootstrap/cmd/compile/internal/amd64bootstrap/cmd/compile/internal/mipsbootstrap/cmd/compile/internal/ppc64bootstrap/cmd/compile/internal/arm64bootstrap/cmd/compile/internal/dwarfgenbootstrap/cmd/compile/internal/armbootstrap/cmd/compile/internal/mips64bootstrap/cmd/compile/internal/walkbootstrap/cmd/compile/internal/riscv64bootstrap/cmd/compile/internal/s390xbootstrap/cmd/compile/internal/wasmbootstrap/cmd/compile/internal/x86bootstrap/cmd/compile/internal/noderbootstrap/cmd/compile/internal/gcbootstrap/cmd/compileBuilding Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.runtimeinternal/abiruntime/internal/mathruntime/internal/sysinternal/goexperimentinternal/cpuruntime/internal/atomicinternal/goosinternal/goarchinternal/bytealgcmd/gocmd/go/internal/runcmd/go/internal/fmtcmdcmd/go/internal/toolcmd/go/internal/tracecmd/go/internal/modgetcmd/go/internal/envcmdcmd/go/internal/cleancmd/go/internal/versionerrorscmd/go/internal/helpcmd/go/internal/lockedfileos/signalcmd/internal/traceviewercmd/go/internal/strdebug/buildinfounicoderegexpcmd/go/internal/workcmdinternal/reflectlitefmtcmd/go/internal/lockedfile/internal/filelockinternal/xcoffcontextsyscallinternal/unsafeheaderdebug/dwarfcmd/go/internal/testcmd/go/internal/bugstringscmd/go/internal/getbufioio/fscmd/go/internal/searchoscmd/go/internal/workstrconvcmd/go/internal/modfetchlogcmd/go/internal/generateinternal/execabscmd/go/internal/modloadsync/atomiccmd/vendor/golang.org/x/mod/modfilecmd/go/internal/modcmdcmd/go/internal/cachetext/templatecmd/go/internal/doccmd/go/internal/listencoding/jsonunicode/utf8iogo/buildcmd/internal/quotedcmd/go/internal/fsyssortbytessyncpath/filepathcmd/go/internal/webnet/urlreflectcmd/go/internal/fixinternal/buildcfgcmd/go/internal/vcsdebug/elfos/execcmd/go/internal/basedebug/machoruntime/debugencoding/hexgo/tokendebug/pego/parsercrypto/sha256hashencoding/binarycmd/vendor/golang.org/x/mod/sumdb/dirhashencoding/base64archive/zipcmd/go/internal/vetcmd/go/internal/cfgcmd/go/internal/loadcmd/internal/syscmd/go/internal/cmdflagcmd/go/internal/parmathinternal/cfgcmd/vendor/golang.org/x/mod/semvercmd/go/internal/importscmd/vendor/golang.org/x/mod/modulego/scannergo/internal/typeparamsgo/astgo/build/constraintunicode/utf16internal/goversionencodinggo/docinternal/gorootio/ioutilinternal/syscall/execenvflagpathtimeinternal/fmtsortencoding/xmlinternal/singleflightcmd/go/internal/modinfointernal/lazytemplatemath/bitscryptomath/randhash/crc32compress/flatecmd/vendor/golang.org/x/xerrorsinternal/lazyregexpinternal/raceinternal/oserrorcmd/vendor/golang.org/x/mod/internal/lazyregexpcmd/vendor/golang.org/x/xerrors/internalregexp/syntaxtext/template/parseinternal/itoacmd/internal/test2jsoncompress/zlibhash/adler32cmd/internal/pkgpathcrypto/sha1cmd/internal/buildidcmd/vendor/golang.org/x/mod/zipcmd/go/internal/robustiocmd/go/internal/modfetch/codehostcmd/internal/codesigncmd/go/internal/mvscmd/go/internal/modconvcontainer/heapcmd/internal/objabiinternal/pollinternal/testloginternal/syscall/unixBuilding Go toolchain2 using go_bootstrap and Go toolchain1.internal/raceinternal/unsafeheaderinternal/goarchinternal/goexperimentinternal/goosunicodeinternal/cpusync/atomicunicode/utf8internal/abiruntime/internal/mathinternal/itoaruntime/internal/sysmath/bitsencodingunicode/utf16internal/goversioninternal/bytealgruntime/internal/atomicmathruntimeinternal/reflectlitesyncinternal/testlogmath/randerrorssortinternal/oserrorpathiostrconvcontainer/heapsyscallbyteshashtext/tabwriterstringshash/adler32hash/crc32reflectcryptobufiogo/build/constraintregexp/syntaxhtmlinternal/syscall/execenvinternal/syscall/unixtimeregexpcontextinternal/pollio/fsosinternal/fmtsortencoding/binarycmd/internal/syscrypto/sha1encoding/base64crypto/md5crypto/sha256io/ioutilfmtpath/filepathinternal/lazyregexpos/execloginternal/execabsflaginternal/buildcfgcmd/internal/editcmd/internal/srctext/scannerdebug/dwarfcmd/internal/pkgpathcompress/flatecmd/internal/biogo/tokenencoding/jsonruntime/debugmath/bignet/urlgo/scannercmd/internal/gcprogencoding/hexgo/astcmd/compile/internal/syntaxcmd/internal/objabicmd/internal/quotedcompress/zlibtext/template/parseinternal/gorootcmd/internal/dwarfcmd/internal/goobjcmd/asm/internal/flagscmd/internal/objcmd/asm/internal/lexgo/internal/typeparamsgo/parsergo/printercmd/internal/archivecompress/gzipruntime/pproftext/templatedebug/elfdebug/machodebug/peinternal/xcoffgo/constantruntime/tracecmd/link/internal/benchmarkcmd/internal/codesigncmd/cgocmd/internal/obj/armcmd/internal/obj/mipscmd/internal/obj/riscvcmd/internal/obj/ppc64cmd/internal/obj/arm64cmd/internal/obj/s390xcmd/internal/obj/wasmcmd/internal/obj/x86cmd/compile/internal/basecmd/compile/internal/logoptcmd/compile/internal/types2cmd/compile/internal/typescmd/compile/internal/bitvecgo/docgo/buildcmd/compile/internal/ircmd/compile/internal/typebitscmd/link/internal/symcmd/link/internal/loadercmd/asm/internal/archcmd/link/internal/loadelfcmd/link/internal/loadpecmd/link/internal/loadmachocmd/link/internal/loadxcoffcmd/asm/internal/asmcmd/link/internal/ldcmd/asmcmd/compile/internal/objwcmd/compile/internal/deadcodecmd/compile/internal/abicmd/compile/internal/typecheckcmd/compile/internal/importercmd/link/internal/mipscmd/link/internal/mips64cmd/link/internal/armcmd/link/internal/arm64cmd/link/internal/amd64cmd/link/internal/ppc64cmd/compile/internal/escapecmd/compile/internal/inlinecmd/compile/internal/staticdatacmd/compile/internal/devirtualizecmd/link/internal/riscv64cmd/link/internal/s390xcmd/link/internal/wasmcmd/link/internal/x86cmd/linkcmd/compile/internal/reflectdatacmd/compile/internal/staticinitcmd/compile/internal/ssacmd/compile/internal/pkginitcmd/compile/internal/livenesscmd/compile/internal/ssagencmd/compile/internal/mipscmd/compile/internal/amd64cmd/compile/internal/armcmd/compile/internal/mips64cmd/compile/internal/arm64cmd/compile/internal/dwarfgencmd/compile/internal/ppc64cmd/compile/internal/walkcmd/compile/internal/riscv64cmd/compile/internal/s390xcmd/compile/internal/wasmcmd/compile/internal/nodercmd/compile/internal/x86cmd/compile/internal/gccmd/compileBuilding Go toolchain3 using go_bootstrap and Go toolchain2.internal/unsafeheaderinternal/goosinternal/goarchunicodeinternal/raceinternal/goexperimentunicode/utf8internal/itoaruntime/internal/mathruntime/internal/sysmath/bitsencodingunicode/utf16internal/goversionsync/atomicinternal/abiinternal/cpumathruntime/internal/atomicinternal/bytealgruntimesyncinternal/reflectliteinternal/testlogmath/randerrorssortinternal/oserrorpathiostrconvcontainer/heapsyscalltext/tabwriterbyteshashstringshash/adler32hash/crc32reflectcryptogo/build/constraintbufiohtmlregexp/syntaxinternal/syscall/unixtimeinternal/syscall/execenvregexpcontextinternal/pollio/fsosinternal/fmtsortencoding/binaryinternal/lazyregexpfmtpath/filepathio/ioutilcrypto/sha1crypto/md5encoding/base64cmd/internal/syscrypto/sha256os/execlogflagcmd/internal/srctext/scannercmd/internal/editinternal/buildcfgdebug/dwarfinternal/execabscompress/flatego/tokencmd/internal/bioencoding/jsoncmd/internal/pkgpathcmd/internal/objabicmd/internal/quotedgo/scannerruntime/debugmath/bigcmd/internal/dwarfcmd/asm/internal/flagscmd/internal/goobjcmd/asm/internal/lexgo/astnet/urlcmd/internal/gcprogencoding/hexcmd/compile/internal/syntaxtext/template/parsecmd/internal/objcompress/zlibinternal/gorootgo/internal/typeparamsgo/printergo/parserdebug/elfdebug/machodebug/peinternal/xcoffcmd/internal/archivecompress/gzipruntime/traceruntime/pprofcmd/internal/codesigntext/templatecmd/internal/obj/armcmd/internal/obj/arm64cmd/internal/obj/mipscmd/internal/obj/ppc64cmd/internal/obj/riscvcmd/internal/obj/s390xcmd/internal/obj/wasmcmd/internal/obj/x86cmd/cgocmd/compile/internal/basego/constantcmd/compile/internal/logoptgo/doccmd/compile/internal/types2cmd/compile/internal/typescmd/compile/internal/bitvecgo/buildcmd/link/internal/benchmarkcmd/link/internal/symcmd/compile/internal/ircmd/compile/internal/typebitscmd/link/internal/loadercmd/link/internal/loadelfcmd/link/internal/loadxcoffcmd/link/internal/loadpecmd/link/internal/loadmachocmd/asm/internal/archcmd/link/internal/ldcmd/asm/internal/asmcmd/asmcmd/compile/internal/deadcodecmd/compile/internal/abicmd/compile/internal/typecheckcmd/compile/internal/objwcmd/compile/internal/importercmd/link/internal/arm64cmd/link/internal/armcmd/link/internal/mipscmd/link/internal/mips64cmd/link/internal/amd64cmd/link/internal/ppc64cmd/link/internal/riscv64cmd/link/internal/s390xcmd/link/internal/wasmcmd/link/internal/x86cmd/linkcmd/compile/internal/escapecmd/compile/internal/inlinecmd/compile/internal/devirtualizecmd/compile/internal/staticdatacmd/compile/internal/reflectdatacmd/compile/internal/staticinitcmd/compile/internal/ssacmd/compile/internal/pkginitcmd/compile/internal/livenesscmd/compile/internal/ssagencmd/compile/internal/mipscmd/compile/internal/arm64cmd/compile/internal/dwarfgencmd/compile/internal/armcmd/compile/internal/amd64cmd/compile/internal/mips64cmd/compile/internal/ppc64cmd/compile/internal/walkcmd/compile/internal/riscv64cmd/compile/internal/s390xcmd/compile/internal/wasmcmd/compile/internal/x86cmd/compile/internal/nodercmd/compile/internal/gccmd/compileBuilding packages and commands for darwin/arm64.container/listconstraintscontainer/ringcrypto/internal/subtlecrypto/subtlevendor/golang.org/x/crypto/cryptobyte/asn1internal/nettracecompress/bzip2debug/plan9objdebug/gosymcmd/vendor/golang.org/x/arch/ppc64/ppc64asmcmd/vendor/golang.org/x/arch/arm/armasmcmd/vendor/golang.org/x/arch/arm64/arm64asmcmd/vendor/golang.org/x/arch/x86/x86asmarchive/zipcompress/lzwcrypto/ciphercrypto/internal/randutilcrypto/dsacrypto/aescrypto/descrypto/sha512crypto/elliptic/internal/fiatencoding/asn1crypto/randcrypto/ed25519/internal/edwards25519/fieldcrypto/hmaccrypto/rc4vendor/golang.org/x/crypto/cryptobytecrypto/ed25519/internal/edwards25519crypto/rsacrypto/x509/internal/macoscrypto/ed25519crypto/x509/pkixencoding/peminternal/godebugvendor/golang.org/x/net/dns/dnsmessagevendor/golang.org/x/net/routeinternal/interninternal/singleflightvendor/golang.org/x/crypto/internal/subtlevendor/golang.org/x/crypto/internal/poly1305vendor/golang.org/x/crypto/chacha20net/netipvendor/golang.org/x/crypto/curve25519/internal/fieldruntime/cgovendor/golang.org/x/crypto/chacha20poly1305vendor/golang.org/x/crypto/hkdfdatabase/sql/driverembedvendor/golang.org/x/crypto/curve25519cmd/internal/objfiledebug/buildinfodatabase/sqlcrypto/elliptic/internal/nistecencoding/ascii85encoding/base32encoding/csvencoding/gobencoding/xmlvendor/golang.org/x/text/transformcrypto/ellipticvendor/golang.org/x/text/unicode/bidicmd/addr2linevendor/golang.org/x/text/unicode/normvendor/golang.org/x/text/secure/bidirulevendor/golang.org/x/net/http2/hpackmimemime/quotedprintablenet/http/internalnet/http/internal/asciigo/formatgo/typeshash/crc64hash/fnvhash/maphashhtml/templateimage/colorindex/suffixarrayinternal/cfginternal/fuzzimageimage/color/paletteinternal/lazytemplateinternal/obscuretestdataimage/internal/imageutilinternal/profileimage/drawos/usernetimage/gifvendor/golang.org/x/net/idnaimage/jpegimage/pnginternal/sysinfotestinginternal/tracemath/cmplxnet/http/internal/testcertnet/internal/socktestos/exec/internal/fdtestos/signalos/signal/internal/ptypluginreflect/internal/example1reflect/internal/example2runtime/metricsruntime/racetesting/iotestinternal/testenvtesting/fstesttesting/internal/testdepstesting/quicktime/tzdatavendor/golang.org/x/sys/cpucmd/internal/buildidcmd/buildidcmd/compile/internal/testcmd/internal/browsercmd/vendor/golang.org/x/tools/covercmd/distcmd/vendor/golang.org/x/mod/semvercmd/covercmd/doccmd/internal/diffcmd/fixarchive/tarcmd/go/internal/strcmd/go/internal/fsyscmd/go/internal/lockedfile/internal/filelockcmd/go/internal/cfgcmd/go/internal/lockedfilecmd/go/internal/parcmd/go/internal/basecmd/go/internal/importscmd/go/internal/robustiocmd/internal/traceviewercmd/go/internal/cachecmd/go/internal/searchcmd/go/internal/tracecmd/vendor/golang.org/x/mod/internal/lazyregexpcmd/vendor/golang.org/x/xerrors/internalcmd/vendor/golang.org/x/crypto/ed25519cmd/vendor/golang.org/x/mod/sumdb/tlogcmd/vendor/golang.org/x/xerrorscmd/vendor/golang.org/x/mod/sumdb/dirhashcrypto/ecdsacmd/vendor/golang.org/x/mod/sumdb/notecmd/go/internal/modinfocmd/vendor/golang.org/x/mod/modulecmd/go/internal/doccmd/go/internal/cmdflagcmd/internal/test2jsoncmd/go/internal/toolcmd/go/internal/versioncmd/go/internal/test/internal/genflagscmd/vendor/golang.org/x/sync/semaphorecmd/vendor/golang.org/x/mod/zipcmd/vendor/golang.org/x/mod/modfilecmd/go/internal/mvscmd/gofmtcmd/link/internal/dwtestcmd/nmcmd/objdumpcmd/packcmd/vendor/github.com/google/pprof/internal/elfexeccmd/vendor/github.com/google/pprof/profilecmd/vendor/github.com/ianlancetaylor/demanglecmd/vendor/github.com/google/pprof/third_party/d3cmd/vendor/github.com/google/pprof/third_party/d3flamegraphcmd/vendor/github.com/google/pprof/third_party/svgpancmd/go/internal/modconvcmd/vendor/golang.org/x/sys/internal/unsafeheadercmd/test2jsoncmd/vendor/golang.org/x/sys/unixcmd/vendor/golang.org/x/crypto/ed25519/internal/edwards25519cmd/vendor/golang.org/x/tools/internal/lsp/fuzzycmd/vendor/golang.org/x/tools/go/cfgcmd/vendor/golang.org/x/tools/txtarvendor/golang.org/x/net/http/httpproxylog/syslognet/textprotocrypto/x509vendor/golang.org/x/net/nettestvendor/golang.org/x/net/http/httpgutsmime/multipartnet/mailcmd/vendor/golang.org/x/termcmd/vendor/github.com/google/pprof/internal/measurementcmd/vendor/github.com/google/pprof/internal/graphcrypto/tlsgo/internal/srcimportercmd/vendor/golang.org/x/tools/go/analysis/passes/internal/analysisutilcmd/vendor/golang.org/x/tools/internal/typeparamsgo/internal/gccgoimportercmd/apigo/internal/gcimportercmd/vendor/golang.org/x/tools/go/ast/astutilcmd/vendor/golang.org/x/tools/go/ast/inspectorcmd/vendor/golang.org/x/tools/go/types/objectpathgo/importercmd/vendor/golang.org/x/tools/internal/analysisinternalcmd/vendor/golang.org/x/tools/go/types/typeutilcmd/vendor/golang.org/x/tools/go/analysiscmd/vendor/golang.org/x/tools/go/analysis/internal/analysisflagscmd/vendor/golang.org/x/tools/go/analysis/passes/buildtagcmd/vendor/golang.org/x/tools/go/analysis/passes/inspectcmd/vendor/golang.org/x/tools/go/analysis/internal/factscmd/vendor/golang.org/x/tools/go/analysis/passes/asmdeclcmd/vendor/golang.org/x/tools/go/analysis/passes/cgocallcmd/vendor/golang.org/x/tools/go/analysis/passes/framepointercmd/vendor/golang.org/x/tools/go/analysis/passes/assigncmd/vendor/golang.org/x/tools/go/analysis/passes/atomiccmd/vendor/golang.org/x/tools/go/analysis/passes/boolscmd/vendor/golang.org/x/tools/go/analysis/passes/compositecmd/vendor/golang.org/x/tools/go/analysis/passes/copylockcmd/vendor/golang.org/x/tools/go/analysis/passes/ctrlflowcmd/vendor/golang.org/x/tools/go/analysis/passes/errorsascmd/vendor/golang.org/x/tools/go/analysis/passes/httpresponsecmd/vendor/golang.org/x/tools/go/analysis/passes/ifaceassertcmd/vendor/golang.org/x/tools/go/analysis/passes/loopclosurecmd/vendor/golang.org/x/tools/go/analysis/passes/nilfunccmd/vendor/golang.org/x/tools/go/analysis/passes/printfcmd/vendor/golang.org/x/tools/go/analysis/passes/lostcancelcmd/vendor/golang.org/x/tools/go/analysis/passes/shiftcmd/vendor/golang.org/x/tools/go/analysis/passes/sigchanyzercmd/vendor/golang.org/x/tools/go/analysis/passes/stdmethodscmd/vendor/golang.org/x/tools/go/analysis/passes/stringintconvcmd/vendor/golang.org/x/tools/go/analysis/passes/structtagcmd/vendor/golang.org/x/tools/go/analysis/passes/testinggoroutinecmd/vendor/golang.org/x/tools/go/analysis/passes/testscmd/vendor/golang.org/x/tools/go/analysis/passes/unmarshalcmd/vendor/golang.org/x/tools/go/analysis/passes/unreachablecmd/vendor/golang.org/x/tools/go/analysis/passes/unsafeptrcmd/vendor/golang.org/x/tools/go/analysis/passes/unusedresultcmd/vendor/golang.org/x/tools/go/analysis/unitcheckercmd/vetnet/http/httptracenet/smtpnet/httpexpvarnet/http/cginet/http/httptestnet/http/cookiejarnet/http/pprofcmd/go/internal/authnet/rpcnet/http/httputilcmd/vendor/golang.org/x/mod/sumdbcmd/vendor/github.com/google/pprof/internal/plugincmd/go/internal/webcmd/tracenet/http/fcginet/rpc/jsonrpccmd/vendor/github.com/google/pprof/internal/binutilscmd/vendor/github.com/google/pprof/internal/reportcmd/vendor/github.com/google/pprof/internal/symbolzcmd/go/internal/modfetch/codehostcmd/go/internal/vcscmd/vendor/github.com/google/pprof/internal/transportcmd/vendor/github.com/google/pprof/internal/symbolizercmd/go/internal/modfetchcmd/vendor/github.com/google/pprof/internal/drivercmd/go/internal/modloadcmd/vendor/github.com/google/pprof/drivercmd/pprofcmd/go/internal/workcmdcmd/go/internal/helpcmd/go/internal/loadcmd/go/internal/fmtcmdcmd/go/internal/modcmdcmd/go/internal/workcmd/go/internal/envcmdcmd/go/internal/fixcmd/go/internal/generatecmd/go/internal/runcmd/go/internal/modgetcmd/go/internal/cleancmd/go/internal/getcmd/go/internal/listcmd/go/internal/testcmd/go/internal/vetcmd/go/internal/bugcmd/go---Installed Go for darwin/arm64 in /Users/fliter/source_lab/goInstalled commands in /Users/fliter/source_lab/go/bin---Installed Go for darwin/arm64 in /Users/fliter/source_lab/goInstalled commands in /Users/fliter/source_lab/go/bin*** You need to add /Users/fliter/source_lab/go/bin to your PATH. 这时在bin目录下，就有刚刚编译好的二进制文件。 将该目录起一个别名(如go_dev)加到 ~/.zshrc中：alias go_dev=/Users/fliter/source_lab/go/bin/go 并执行source .zshrc 执行 go_dev version: 调试源码 修改runtime/map.go 在src/runtime/map.go func makemap(t maptype, hint int, h hmap) *hmap {}第一行插入新代码 println(&quot;fliter debug source code&quot;) (之所以不用fmt.Println，是因为会有循环引用，即runtime包和fmt包相互引用) 执行./all.bash重新编译源码 (因为只改了runtime包，并不需要重新构建整个项目,所以可在make.bash中 通过./cmd/dist/dist install -v &quot;runtime&quot; 仅指定runtime目录) 12345678package mainfunc main() &#123; m := make(map[int]string, 10) m[1] = \"cuishuang\" println(m[1])&#125; 这段代码正常执行该输出cuishuang 而使用go_dev run 如上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253fliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source codefliter debug source code# runtime/internal/syscompile: cannot use concurrent backend compilation with provided flags; invoked as [/usr/local/go/pkg/tool/darwin_arm64/compile -o $WORK/b008/_pkg_.a -trimpath $WORK/b008=&gt; -p runtime/internal/sys -std -+ -complete -buildid M2oPX2HiuTsx5AMULRO_/M2oPX2HiuTsx5AMULRO_ -shared -c=4 -nolocalimports -importcfg $WORK/b008/importcfg -pack /usr/local/go/src/runtime/internal/sys/arch.go /usr/local/go/src/runtime/internal/sys/arch_arm64.go /usr/local/go/src/runtime/internal/sys/intrinsics.go /usr/local/go/src/runtime/internal/sys/intrinsics_common.go /usr/local/go/src/runtime/internal/sys/stubs.go /usr/local/go/src/runtime/internal/sys/sys.go /usr/local/go/src/runtime/internal/sys/zgoarch_arm64.go /usr/local/go/src/runtime/internal/sys/zgoos_darwin.go /usr/local/go/src/runtime/internal/sys/zversion.go]fliter debug source codefliter debug source codefliter debug source codefliter debug source code# internal/cpucompile: cannot use concurrent backend compilation with provided flags; invoked as [/usr/local/go/pkg/tool/darwin_arm64/compile -o $WORK/b004/_pkg_.a -trimpath $WORK/b004=&gt; -p internal/cpu -std -+ -buildid bZn0-nG2D-qVhCGWsVek/bZn0-nG2D-qVhCGWsVek -symabis $WORK/b004/symabis -shared -c=4 -nolocalimports -importcfg $WORK/b004/importcfg -pack -asmhdr $WORK/b004/go_asm.h /usr/local/go/src/internal/cpu/cpu.go /usr/local/go/src/internal/cpu/cpu_arm64.go /usr/local/go/src/internal/cpu/cpu_arm64_darwin.go /usr/local/go/src/internal/cpu/cpu_no_name.go]# runtime/internal/atomiccompile: cannot use concurrent backend compilation with provided flags; invoked as [/usr/local/go/pkg/tool/darwin_arm64/compile -o $WORK/b006/_pkg_.a -trimpath $WORK/b006=&gt; -p runtime/internal/atomic -std -+ -buildid Wh4PYLD6KyWgsgy5uHLX/Wh4PYLD6KyWgsgy5uHLX -symabis $WORK/b006/symabis -shared -c=4 -nolocalimports -importcfg $WORK/b006/importcfg -pack -asmhdr $WORK/b006/go_asm.h /usr/local/go/src/runtime/internal/atomic/atomic_arm64.go /usr/local/go/src/runtime/internal/atomic/stubs.go /usr/local/go/src/runtime/internal/atomic/unaligned.go] 可见某个步骤发生了问题 参考： go 源码分析 调试安装 调试源代码","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"代码搜索技巧","date":"2021-10-08T13:56:53.000Z","path":"2021/10/08/代码搜索技巧/","text":"在IDE中搜索代码时，经常会被相近的无关代码干扰，如筛选所有使用协程的代码段， 可见有大量“噪音”。 可使用IDE提供的正则表达式功能 如 使用 \\bgo,即匹配go开头的，且之后为空格的所有选项 使用 \\bgo func,即匹配到了所有使用协程的代码段 IDE还提供了常用正则表达式语法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164Summary of regular-expression constructsConstruct Matches Charactersx The character x\\\\ The backslash character\\0n The character with octal value 0n (0 &lt;= n &lt;= 7)\\0nn The character with octal value 0nn (0 &lt;= n &lt;= 7)\\0mnn The character with octal value 0mnn (0 &lt;= m &lt;= 3, 0 &lt;= n &lt;= 7)\\xhh The character with hexadecimal value 0xhh\\uhhhh The character with hexadecimal value 0xhhhh\\t The tab character ('\\u0009')\\n The newline (line feed) character ('\\u000A')\\r The carriage-return character ('\\u000D')\\f The form-feed character ('\\u000C')\\a The alert (bell) character ('\\u0007')\\e The escape character ('\\u001B')\\cx The control character corresponding to x Character classes[abc] a, b, or c (simple class)[^abc] Any character except a, b, or c (negation)[a-zA-Z] a through z or A through Z, inclusive (range)[a-d[m-p]] a through d, or m through p: [a-dm-p] (union)[a-z&amp;&amp;[def]] d, e, or f (intersection)[a-z&amp;&amp;[^bc]] a through z, except for b and c: [ad-z] (subtraction)[a-z&amp;&amp;[^m-p]] a through z, and not m through p: [a-lq-z(subtraction) Predefined character classes. Any character (may or may not match line terminators)\\d A digit: [0-9]\\D A non-digit: [^0-9]\\s A whitespace character: [ \\t\\n\\x0B\\f\\r]\\S A non-whitespace character: [^\\s]\\w A word character: [a-zA-Z_0-9]\\W A non-word character: [^\\w] POSIX character classes (US-ASCII only)\\p&#123;Lower&#125; A lower-case alphabetic character: [a-z]\\p&#123;Upper&#125; An upper-case alphabetic character:[A-Z]\\p&#123;ASCII&#125; All ASCII:[\\x00-\\x7F]\\p&#123;Alpha&#125; An alphabetic character:[\\p&#123;Lower&#125;\\p&#123;Upper&#125;]\\p&#123;Digit&#125; A decimal digit: [0-9]\\p&#123;Alnum&#125; An alphanumeric character:[\\p&#123;Alpha&#125;\\p&#123;Digit&#125;]\\p&#123;Punct&#125; Punctuation: One of !\"#$%&amp;'()*+,-./:;=&gt;?@[\\]^_`&#123;|&#125;~\\p&#123;Graph&#125; A visible character: [\\p&#123;Alnum&#125;\\p&#123;Punct&#125;]\\p&#123;Print&#125; A printable character: [\\p&#123;Graph&#125;\\x20]\\p&#123;Blank&#125; A space or a tab: [ \\t]\\p&#123;Cntrl&#125; A control character: [\\x00-\\x1F\\x7F]\\p&#123;XDigit&#125; A hexadecimal digit: [0-9a-fA-F]\\p&#123;Space&#125; A whitespace character: [ \\t\\n\\x0B\\f\\r] java.lang.Character classes (simple java character type)\\p&#123;javaLowerCase&#125; Equivalent to java.lang.Character.isLowerCase()\\p&#123;javaUpperCase&#125; Equivalent to java.lang.Character.isUpperCase()\\p&#123;javaWhitespace&#125; Equivalent to java.lang.Character.isWhitespace()\\p&#123;javaMirrored&#125; Equivalent to java.lang.Character.isMirrored() Classes for Unicode blocks and categories\\p&#123;InGreek&#125; A character in the Greek block (simple block)\\p&#123;Lu&#125; An uppercase letter (simple category)\\p&#123;Sc&#125; A currency symbol\\P&#123;InGreek&#125; Any character except one in the Greek block (negation)[\\p&#123;L&#125;&amp;&amp;[^\\p&#123;Lu&#125;]] Any letter except an uppercase letter (subtraction) Boundary matchers^ The beginning of a line$ The end of a line\\b A word boundary\\B A non-word boundary\\A The beginning of the input\\G The end of the previous match\\Z The end of the input but for the final terminator, if any\\z The end of the input Greedy quantifiersX? X, once or not at allX* X, zero or more timesX+ X, one or more timesX&#123;n&#125; X, exactly n timesX&#123;n,&#125; X, at least n timesX&#123;n,m&#125; X, at least n but not more than m times Reluctant quantifiersX?? X, once or not at allX*? X, zero or more timesX+? X, one or more timesX&#123;n&#125;? X, exactly n timesX&#123;n,&#125;? X, at least n timesX&#123;n,m&#125;? X, at least n but not more than m times Possessive quantifiersX?+ X, once or not at allX*+ X, zero or more timesX++ X, one or more timesX&#123;n&#125;+ X, exactly n timesX&#123;n,&#125;+ X, at least n timesX&#123;n,m&#125;+ X, at least n but not more than m times Logical operatorsXY X followed by YX|Y Either X or Y(X) X, as a capturing group Back references\\n Whatever the nth capturing group matched Quotation \\ Nothing, but quotes the following character\\Q Nothing, but quotes all characters until \\E\\E Nothing, but ends quoting started by \\Q Special constructs (non-capturing) (?:X) X, as a non-capturing group(?idmsux-idmsux) Nothing, but turns match flags on - off(?idmsux-idmsux:X) X, as a non-capturing group with the given flags on - off(?=X) X, via zero-width positive lookahead(?!X) X, via zero-width negative lookahead(?&lt;=X) X, via zero-width positive lookbehind(?&lt;!X) X, via zero-width negative lookbehind(?&gt;X) X, as an independent, non-capturing groupMore on Regular Expressions: Full Java Regular Expressions syntax description, Using Regular Expressions in Java.","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"SubQuery入门指南II","date":"2021-09-25T13:56:23.000Z","path":"2021/09/25/SubQuery入门指南II/","text":"SubQuery开发者指南丨Hello World (由SubQuery 托管) 创建项目 subql init –starter Cui_subql 1234cd Cui_subqlnpm installnpm run-script codegennpm run-script build 创建 GitHub 存储库 git@github.com:cuishuang/subql_demo.git 推送到 GitHub 1234567cd Cui_subqlgit initgit remote add origin git@github.com:cuishuang/subql_demo.git //将远程存储库设置为 git@github.com:cuishuang/subql_demo.gitgit add .git commit -m\"first commit\"git push --set-upstream origin master 创建项目 点击project.subquery.network并使用github登录 GitHub 帐户：如果有多个 GitHub 帐户，请选择将在哪个帐户下创建此项目。 在 GitHub 组织帐户中创建的项目在该组织的成员之间共享。 项目名称：在此处为项目命名。 副标题：为项目提供副标题。 描述：解释 SubQuery 项目的用途。 GitHub 存储库 URL：这必须是包含 SubQuery 项目的公共存储库的有效 GitHub URL。schema.graphql 文件必须位于目录的根目录中。 隐藏项目：如果选中，这将在公共 SubQuery 浏览器中隐藏项目。 如果想与社区共享您的 SubQuery 项目，请不要选择此项！ 单击创建后，将跳转到控制面板。这上面包含许多有用信息，如它使用的网络、它运行的源代码的 GitHub 存储库 URL、它的创建时间和上次更新时间，尤其是部署的详细信息 部署项目 现在已在 SubQuery Projects 中创建了项目，下一步是部署项目使其可操作。 部署一个版本会触发新的 SubQuery 索引操作启动，并设置所需的查询服务以开始接受 GraphQL 请求。 还可以在此处将新版本部署到现有项目。 可以选择部署到各种环境，例如生产槽或暂存槽。 在这里，将部署到生产槽。 单击“部署”按钮会显示如下： 新版本的 Commit Hash：从 GitHub 中选择您要部署的 SubQuery 项目代码库的正确交付 (因为只有一个交付/提交，所以下拉菜单中只有一个选项) 索引器版本：这是要在其上运行此SubQuery项目的SubQuery节点服务的版本。 可登录此网址参考 查询版本：这是要在其上运行此 SubQuery 项目的 SubQuery 查询服务的版本。 可登录此网址参考 将使用最新版本的索引器和查询版本，因此此处接受默认值，然后单击“部署更新” 然后，将看到部署处于“正在处理”状态。 在这里，代码正在部署到 SubQuery 的托管基础架构上。 服务器正在按需启动并准备提供服务，这将需要几分钟的时间。 测试项目 运行一个简单的 GET 查询 Query Endpoint: https://api.subquery.network/sq/cuishuang/blockchain","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"SubQuery入门指南","date":"2021-09-25T13:20:46.000Z","path":"2021/09/25/SubQuery入门指南/","text":"SubQuery是波卡生态的 The Graph(以太坊生态的数据服务提供者) SubQuery可以让开发者专注于其核心用例和前端，而无需浪费时间来构建用于数据处理的后端。 下载SubQuery CLI npm install -g @subql/cli subql help 初始化 Starter SubQuery 项目 subql init –starter Shuang_subql Git 存储库（可选）：提供指向此 SubQuery 项目的，并将在其中托管的存储库的 Git URL（当托管在 SubQuery Explorer 中时）。 RPC 端点（必需）：提供一个 wss URL给一个正在运行的 RPC 端点，该端点将默认用于此项目。 您可以快速访问不同 Polkadot 网络的公共端点，甚至可以使用 OnFinality，或仅使用默认的 Polkadot 端点创建您自己的私有专用节点。 作者（必填）：在此处输入此 SubQuery 项目的所有者。 描述（可选）：您可以提供关于您项目的简短段落，描述项目包含哪些数据以及用户可以使用它做什么。 版本（必填）：输入自定义版本号或使用默认版本 (1.0.0)。 许可证（必需）：提供此项目的软件许可证或接受默认（Apache-2.0）。 cd Shuang_test npm install 配置和构建入门项目 之后的开发将主要处理以下文件： project.yaml 中的清单 schema.graphql 中的 GraphQL 架构 src/mappings/ 目录中的映射函数 GraphQL 模型生成 npm run-script codegen 此时会自动新建/src/types/models文件夹，里面是自动生成的文件 构建项目 npm run-script build 运行 SubQuery 项目 打开本地的Docker，然后执行 docker-compose pull &amp;&amp; docker-compose up 查询新建的项目 打开浏览器并前往 http://localhost:3000 这时会看到 GraphQL playground 显示在资源管理器中，其模式是准备查询。 在 Playground 的右上角，会找到一个 Docs 按钮，该按钮将打开文档绘图。 该文档是自动生成的，能帮助找到可以查询的实体和方法。 对于新的 SubQuery 入门项目，可以尝试以下查询以了解其工作原理或了解有关 GraphQL 查询语言的更多信息。 123456789101112&#123; query&#123; starterEntities(first:10)&#123; nodes&#123; field1 field2 field3 id &#125; &#125; &#125;&#125; 现在有一个本地运行的 SubQuery 项目，该项目接受 GraphQL API 对示例数据的请求~ 下一篇将向展示如何将新项目发布到 SubQuery Projects, 并使用ta们的资源管理器去查询 参考 SubQuery丨开发者快速入门指南 SubQuery丨Hello world 入门简介 SubQuery开发者指南丨Hello World Explained !!!SubQuery开发者指南丨清单文件（Manifest File）","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"搭建substrate开发环境","date":"2021-09-19T13:46:30.000Z","path":"2021/09/19/搭建substrate开发环境/","text":"安装Substrate依赖 curl https://getsubstrate.io/-o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 实际的shell为:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/bin/bash# Copyright 2015-2020 Parity Technologies (UK) Ltd.if [[ \"$OSTYPE\" == \"linux-gnu\" ]]; then set -e if [[ $(whoami) == \"root\" ]]; then MAKE_ME_ROOT= else MAKE_ME_ROOT=sudo fi if [ -f /etc/redhat-release ]; then echo \"Redhat Linux detected.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1 elif [ -f /etc/SuSE-release ]; then echo \"Suse Linux detected.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1 elif [ -f /etc/arch-release ]; then echo \"Arch Linux detected.\" $MAKE_ME_ROOT pacman -Syu --needed --noconfirm cmake gcc openssl-1.0 pkgconf git clang export OPENSSL_LIB_DIR=\"/usr/lib/openssl-1.0\"; export OPENSSL_INCLUDE_DIR=\"/usr/include/openssl-1.0\" elif [ -f /etc/mandrake-release ]; then echo \"Mandrake Linux detected.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1 elif [ -f /etc/debian_version ]; then echo \"Ubuntu/Debian Linux detected.\" $MAKE_ME_ROOT apt update $MAKE_ME_ROOT apt install -y cmake pkg-config libssl-dev git gcc build-essential git clang libclang-dev else echo \"Unknown Linux distribution.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1 fielif [[ \"$OSTYPE\" == \"darwin\"* ]]; then set -e echo \"Mac OS (Darwin) detected.\" if ! which brew &gt;/dev/null 2&gt;&amp;1; then /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" fi brew update brew install openssl cmake llvmelif [[ \"$OSTYPE\" == \"freebsd\"* ]]; then echo \"FreeBSD detected.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1else echo \"Unknown operating system.\" echo \"This OS is not supported with this script at present. Sorry.\" echo \"Please refer to https://github.com/paritytech/substrate for setup information.\" exit 1fiif ! which rustup &gt;/dev/null 2&gt;&amp;1; then curl https://sh.rustup.rs -sSf | sh -s -- -y source ~/.cargo/env rustup default stableelse rustup update rustup default stablefirustup update nightlyrustup target add wasm32-unknown-unknown --toolchain nightlyif [[ \"$1\" == \"--fast\" ]]; then echo \"Skipped cargo install of 'substrate' and 'subkey'\" echo \"You can install manually by cloning the https://github.com/paritytech/substrate repo,\" echo \"and using cargo to install 'substrate' and 'subkey' from the repo path.\"else g=$(mktemp -d) git clone https://github.com/paritytech/substrate \"$g\" pushd \"$g\" cargo install --force --path ./bin/node/cli #substrate cargo install --force --path ./bin/utils/subkey subkey popdfiecho \"Run source ~/.cargo/env now to update environment\" (wasm-gc，可以压缩wasm二进制文件的大小) 使用node template git clone git@github.com:substrate-developer-hub/substrate-node-template.git （cd substrate-node-template） cargo build –release (编译确实非常慢) ./target/release/node-template purge-chain –dev ./target/release/node-template –dev 可使用 ./target/release/node-template -h 查看所有命令： ./target/release/node-template -h:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179node-template 3.0.0-monthly-2021-09+1-3b547c9-aarch64-macosSubstrate DevHub &lt;https://github.com/substrate-developer-hub&gt;A fresh FRAME-based Substrate node, ready for hacking.USAGE: node-template [FLAGS] [OPTIONS] node-template &lt;SUBCOMMAND&gt;FLAGS: --alice Shortcut for `--name Alice --validator` with session keys for `Alice` added to keystore --allow-private-ipv4 Always accept connecting to private IPv4 addresses (as specified in [RFC1918](https://tools.ietf.org/html/rfc1918)). Enabled by default for chains marked as \"local\" in their chain specifications, or when `--dev` is passed --bob Shortcut for `--name Bob --validator` with session keys for `Bob` added to keystore --charlie Shortcut for `--name Charlie --validator` with session keys for `Charlie` added to keystore --dave Shortcut for `--name Dave --validator` with session keys for `Dave` added to keystore --dev Specify the development chain --disable-log-color Disable log color output --disable-log-reloading Disable feature to dynamically update and reload the log filter --discover-local Enable peer discovery on local networks --eve Shortcut for `--name Eve --validator` with session keys for `Eve` added to keystore --ferdie Shortcut for `--name Ferdie --validator` with session keys for `Ferdie` added to keystore --force-authoring Enable authoring even when offline -h, --help Prints help information --ipfs-server Join the IPFS network and serve transactions over bitswap protocol --kademlia-disjoint-query-paths Require iterative Kademlia DHT queries to use disjoint paths for increased resiliency in the presence of potentially adversarial nodes --light Experimental: Run in light client mode --no-grandpa Disable GRANDPA voter when running in validator mode, otherwise disable the GRANDPA observer --no-mdns Disable mDNS discovery --no-private-ipv4 Always forbid connecting to private IPv4 addresses (as specified in [RFC1918](https://tools.ietf.org/html/rfc1918)), unless the address was passed with `--reserved-nodes` or `--bootnodes`. Enabled by default for chains marked as \"live\" in their chain specifications --no-prometheus Do not expose a Prometheus exporter endpoint --no-telemetry Disable connecting to the Substrate telemetry server --one Shortcut for `--name One --validator` with session keys for `One` added to keystore --password-interactive Use interactive shell for entering the password used by the keystore --prometheus-external Expose Prometheus exporter on all interfaces --reserved-only Whether to only synchronize the chain with reserved nodes --rpc-external Listen to all RPC interfaces --storage-chain Enable storage chain mode --tmp Run a temporary node --two Shortcut for `--name Two --validator` with session keys for `Two` added to keystore --unsafe-pruning Force start with unsafe pruning settings --unsafe-rpc-external Listen to all RPC interfaces --unsafe-ws-external Listen to all Websocket interfaces --validator Enable validator mode -V, --version Prints version information --ws-external Listen to all Websocket interfacesOPTIONS: -d, --base-path &lt;PATH&gt; Specify custom base path --bootnodes &lt;ADDR&gt;... Specify a list of bootnodes --chain &lt;CHAIN_SPEC&gt; Specify the chain specification --database &lt;DB&gt; Select database backend to use [possible values: rocksdb, paritydb-experimental, auto] --db-cache &lt;MiB&gt; Limit the memory the database cache can use --offchain-worker &lt;ENABLED&gt; Should execute offchain workers on every block [default: WhenValidating] [possible values: Always, Never, WhenValidating] --execution &lt;STRATEGY&gt; The execution strategy that should be used by all execution contexts [possible values: Native, Wasm, Both, NativeElseWasm] --execution-block-construction &lt;STRATEGY&gt; The means of execution used when calling into the runtime while constructing blocks [possible values: Native, Wasm, Both, NativeElseWasm] --execution-import-block &lt;STRATEGY&gt; The means of execution used when calling into the runtime for general block import (including locally authored blocks) [possible values: Native, Wasm, Both, NativeElseWasm] --execution-offchain-worker &lt;STRATEGY&gt; The means of execution used when calling into the runtime while using an off-chain worker [possible values: Native, Wasm, Both, NativeElseWasm] --execution-other &lt;STRATEGY&gt; The means of execution used when calling into the runtime while not syncing, importing or constructing blocks [possible values: Native, Wasm, Both, NativeElseWasm] --execution-syncing &lt;STRATEGY&gt; The means of execution used when calling into the runtime for importing blocks as part of an initial sync [possible values: Native, Wasm, Both, NativeElseWasm] --in-peers &lt;COUNT&gt; Specify the maximum number of incoming connections we're accepting [default: 25] --enable-offchain-indexing &lt;ENABLE_OFFCHAIN_INDEXING&gt; Enable Offchain Indexing API, which allows block import to write to Offchain DB --ipc-path &lt;PATH&gt; Specify IPC RPC server path --keep-blocks &lt;COUNT&gt; Specify the number of finalized blocks to keep in the database --keystore-path &lt;PATH&gt; Specify custom keystore path --keystore-uri &lt;keystore-uri&gt; Specify custom URIs to connect to for keystore-services --listen-addr &lt;LISTEN_ADDR&gt;... Listen on this multiaddress -l, --log &lt;LOG_PATTERN&gt;... Sets a custom logging filter. Syntax is &lt;target&gt;=&lt;level&gt;, e.g. -lsync=debug --max-parallel-downloads &lt;COUNT&gt; Maximum number of peers from which to ask for the same blocks in parallel [default: 5] --max-runtime-instances &lt;max-runtime-instances&gt; The size of the instances cache for each runtime --name &lt;NAME&gt; The human-readable name for this node --node-key &lt;KEY&gt; The secret key to use for libp2p networking --node-key-file &lt;FILE&gt; The file from which to read the node's secret key to use for libp2p networking --node-key-type &lt;TYPE&gt; The type of secret key to use for libp2p networking [default: Ed25519] [possible values: Ed25519] --out-peers &lt;COUNT&gt; Specify the number of outgoing connections we're trying to maintain [default: 25] --password &lt;password&gt; Password used by the keystore. This allows appending an extra user-defined secret to the seed --password-filename &lt;PATH&gt; File that contains the password used by the keystore --pool-kbytes &lt;COUNT&gt; Maximum number of kilobytes of all transactions stored in the pool [default: 20480] --pool-limit &lt;COUNT&gt; Maximum number of transactions in the transaction pool [default: 8192] --port &lt;PORT&gt; Specify p2p protocol TCP port --prometheus-port &lt;PORT&gt; Specify Prometheus exporter TCP Port --pruning &lt;PRUNING_MODE&gt; Specify the state pruning mode, a number of blocks to keep or 'archive' --public-addr &lt;PUBLIC_ADDR&gt;... The public address that other nodes will use to connect to it. This can be used if there's a proxy in front of this node --reserved-nodes &lt;ADDR&gt;... Specify a list of reserved node addresses --rpc-cors &lt;ORIGINS&gt; Specify browser Origins allowed to access the HTTP &amp; WS RPC servers --rpc-http-threads &lt;COUNT&gt; Size of the RPC HTTP server thread pool --rpc-max-payload &lt;rpc-max-payload&gt; Set the the maximum RPC payload size for both requests and responses (both http and ws), in megabytes. Default is 15MiB --rpc-methods &lt;METHOD SET&gt; RPC methods to expose. [default: Auto] [possible values: Auto, Safe, Unsafe] --rpc-port &lt;PORT&gt; Specify HTTP RPC server TCP port --state-cache-size &lt;Bytes&gt; Specify the state cache size [default: 67108864] --sync &lt;SYNC_MODE&gt; Blockchain syncing mode [default: Full] --telemetry-url &lt;URL VERBOSITY&gt;... The URL of the telemetry server to connect to --tracing-receiver &lt;RECEIVER&gt; Receiver to process tracing messages [default: Log] [possible values: Log] --tracing-targets &lt;TARGETS&gt; Sets a custom profiling filter. Syntax is the same as for logging: &lt;target&gt;=&lt;level&gt; --wasm-execution &lt;METHOD&gt; Method for executing Wasm runtime code [default: Compiled] [possible values: interpreted-i-know- what-i-do, compiled] --wasm-runtime-overrides &lt;PATH&gt; Specify the path where local WASM runtimes are stored --ws-max-connections &lt;COUNT&gt; Maximum number of WS RPC server connections --ws-port &lt;PORT&gt; Specify WebSockets RPC server TCP portSUBCOMMANDS: benchmark Benchmark runtime pallets. build-spec Build a chain specification check-block Validate blocks export-blocks Export blocks export-state Export the state of a given block into a chain spec help Prints this message or the help of the given subcommand(s) import-blocks Import blocks key Key management cli utilities purge-chain Remove the whole chain revert Revert the chain to a previous state 使用交互工具 apps 方法一，使用官方的apps：https://polkadot.js.org/apps/#/accounts https://polkadot.js.org/apps/#/explorer 方法二，(编译)安装本地的apps，安装步骤参考项目的readme文档其实是一个react的项目 https://github.com/polkadot-js/apps#development 配置IDE VSCode 插件 Better toml Rust-analyzer：https://github.com/rust-analyzer/rust-analyzer Intellij IDEA Keybindings Settings Sync(将配置保存到github，换机器时好同步) IntelliJ IDEA 插件： Rust 国内资源加速 crates.io 中科大Rust crates源，修改 ~/.cargo/config; （之前没有设置过，则需新建config文件） 修改如下： 123456[source.crates-io]registry = \"https://github.com/rust-lang/crates.io-index\"replace-with = 'ustc'[source.ustc]registry = \"git://mirrors.ustc.edu.cn/crates.io-index\" 国内资源加速Github 方法一： 使用代理 Shadowsocks，通过https协议拉取最新代码 方法二： 将Github的代码仓库映射到国内的代码托管网站 如gitee.com 文档参见","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"使用Selenium获取网站信息","date":"2021-09-18T13:36:16.000Z","path":"2021/09/18/使用Selenium获取网站信息/","text":"想要爬取这个网站的内容，先使用了ChromeWeb Scraper插件 的Element Click功能来获取分页数据,但发现几次请求后就出现错误。 使用Go实现了该功能，获取每一页html内容，而后通过字符串匹配得到想要的信息，但发现这个网站会封禁IP&amp;对内容加盐… 不想折腾IP代理池，而直接使用 WEB自动化工具 Selenium,早前就见到过测试同学有使用，正好借此契机，也体验一下。 Selenium对Firefox支持较好。 另需要安装所用系统对应的geckodriver来驱动Firefox。将解压后的二进制文件所在的位置加到系统路径下。 juzi.py123456789101112131415161718192021222324252627282930313233343536373839404142# !/usr/bin/env python# encoding: utf-8from selenium import webdriverfrom lxml import etreedef get_content(): for i in range(1, 5): url = \"https://www.mingyantong.com/writer/%E5%BC%A0%E7%88%B1%E7%8E%B2?page=&#123;&#125;\".format(i) browser = webdriver.Firefox() browser.get(url) html = browser.page_source html = etree.HTML(html, etree.HTMLParser()) juzi_list = html.xpath('//div[@class=\"view-content\"]//div') for juzi in juzi_list: content = juzi.xpath('./div/div/a[@class = \"xlistju\"]/text()') author = juzi.xpath('./div/div[@class=\"xqjulistwafo\"]/a/text()') book = juzi.xpath('./div/div[@class=\"xqjulistwafo\"]/span/a/text()') all_content = &#123; \"content\": content, \"author\": author, \"book\": book, &#125; if not (content == [] and author == [] and book == []): #print(content,author,book) #print(all_content) if len(book) == 0 : print(content[0]) print() else: print(content[0] + \"---&lt;\" + book[0] + \"&gt;\") print()if __name__ == '__main__': get_content() 调整页码，执行python3 juzi.py &gt; result.txt即可~ 注: 请求频率太快，也会被该网站的防爬策略识别并封禁。建议增加适当的time.Sleep 若使用browser = webdriver.Chrome()，需安装Chrome的驱动，方法如下： 解决selenium.common.exceptions.WebDriverException: Message: ‘chromedriver‘ 关于selenium，更多操作可参考 python selenium –browser 操作","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Rust vs Go:常用语法对比(13)","date":"2021-09-14T15:43:58.000Z","path":"2021/09/14/Rust-vs-Go-常用语法对比-13/","text":"241. Yield priority to other threads Explicitly decrease the priority of the current process, so that other execution threads have a better chance to execute now. Then resume normal execution and call function busywork. 将优先权让给其他线程 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"runtime\" \"time\")func main() &#123; go fmt.Println(\"aaa\") go fmt.Println(\"bbb\") go fmt.Println(\"ccc\") go fmt.Println(\"ddd\") go fmt.Println(\"eee\") runtime.Gosched() busywork() time.Sleep(100 * time.Millisecond)&#125;func busywork() &#123; fmt.Println(\"main\")&#125; After Gosched, the execution of the current goroutine resumes automatically. 123456aaaeeecccbbbdddmain 12::std::thread::yield_now();busywork(); 242. Iterate over a set Call a function f on each element e of a set x. 迭代一个集合 12345678910111213141516171819202122232425262728package mainimport \"fmt\"type T stringfunc main() &#123; // declare a Set (implemented as a map) x := make(map[T]bool) // add some elements x[\"A\"] = true x[\"B\"] = true x[\"B\"] = true x[\"C\"] = true x[\"D\"] = true // remove an element delete(x, \"C\") for e := range x &#123; f(e) &#125;&#125;func f(e T) &#123; fmt.Printf(\"contains element %v \\n\", e)&#125; 123contains element A contains element B contains element D 123456789101112131415use std::collections::HashSet;fn main() &#123; let mut x = HashSet::new(); x.insert(\"a\"); x.insert(\"b\"); for item in &amp;x &#123; f(item); &#125;&#125;fn f(s: &amp;&amp;str) &#123; println!(\"Element &#123;&#125;\", s);&#125; x is a HashSet 12Element aElement b 243. Print list Print the contents of list a on the standard output. 打印 list 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\")func main() &#123; &#123; a := []int&#123;11, 22, 33&#125; fmt.Println(a) &#125; &#123; a := []string&#123;\"aa\", \"bb\"&#125; fmt.Println(a) &#125; &#123; type Person struct &#123; First string Last string &#125; x := Person&#123; First: \"Jane\", Last: \"Doe\", &#125; y := Person&#123; First: \"John\", Last: \"Doe\", &#125; a := []Person&#123;x, y&#125; fmt.Println(a) &#125; &#123; x, y := 11, 22 a := []*int&#123;&amp;x, &amp;y&#125; fmt.Println(a) &#125;&#125; 1234[11 22 33][aa bb][&#123;Jane Doe&#125; &#123;John Doe&#125;][0xc000018080 0xc000018088] 12345fn main() &#123; let a = [11, 22, 33]; println!(\"&#123;:?&#125;\", a);&#125; [11, 22, 33] 244. Print map Print the contents of map m to the standard output: keys and values. 打印 map 123456789101112131415161718192021222324package mainimport ( \"fmt\")func main() &#123; &#123; m := map[string]int&#123; \"eleven\": 11, \"twenty-two\": 22, &#125; fmt.Println(m) &#125; &#123; x, y := 7, 8 m := map[string]*int&#123; \"seven\": &amp;x, \"eight\": &amp;y, &#125; fmt.Println(m) &#125;&#125; 12map[eleven:11 twenty-two:22]map[eight:0xc000100040 seven:0xc000100028] 12345678use std::collections::HashMap;fn main() &#123; let mut m = HashMap::new(); m.insert(\"Áron\".to_string(), 23); m.insert(\"Béla\".to_string(), 35); println!(\"&#123;:?&#125;\", m);&#125; {&quot;Béla&quot;: 35, &quot;Áron&quot;: 23} 245. Print value of custom type Print the value of object x having custom type T, for log or debug. 打印自定义类型的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\")// T represents a tank. It doesn't implement fmt.Stringer.type T struct &#123; name string weight int firePower int&#125;// Person implement fmt.Stringer.type Person struct &#123; FirstName string LastName string YearOfBirth int&#125;func (p Person) String() string &#123; return fmt.Sprintf(\"%s %s, born %d\", p.FirstName, p.LastName, p.YearOfBirth)&#125;func main() &#123; &#123; x := T&#123; name: \"myTank\", weight: 100, firePower: 90, &#125; fmt.Println(x) &#125; &#123; x := Person&#123; FirstName: \"John\", LastName: \"Doe\", YearOfBirth: 1958, &#125; fmt.Println(x) &#125;&#125; Will be more relevant if T implements fmt.Stringer 12&#123;myTank 100 90&#125;John Doe, born 1958 123456789101112131415161718#[derive(Debug)]// T represents a tankstruct T&lt;'a&gt; &#123; name: &amp;'a str, weight: &amp;'a i32, fire_power: &amp;'a i32,&#125;fn main() &#123; let x = T &#123; name: \"mytank\", weight: &amp;100, fire_power: &amp;90, &#125;; println!(\"&#123;:?&#125;\", x);&#125; Implement fmt::Debug or fmt::Display for T T { name: &quot;mytank&quot;, weight: 100, fire_power: 90 } 246. Count distinct elements Set c to the number of distinct elements in list items. 计算不同的元素的数量 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; type T string items := []T&#123;\"a\", \"b\", \"b\", \"aaa\", \"c\", \"a\", \"d\"&#125; fmt.Println(\"items has\", len(items), \"elements\") distinct := make(map[T]bool) for _, v := range items &#123; distinct[v] = true &#125; c := len(distinct) fmt.Println(\"items has\", c, \"distinct elements\")&#125; 12items has 7 elementsitems has 5 distinct elements 1234567use itertools::Itertools;fn main() &#123; let items = vec![\"víz\", \"árvíz\", \"víz\", \"víz\", \"ár\", \"árvíz\"]; let c = items.iter().unique().count(); println!(\"&#123;&#125;\", c);&#125; 3 247. Filter list in-place Remove all the elements from list x that don’t satisfy the predicate p, without allocating a new list.Keep all the elements that do satisfy p.For languages that don’t have mutable lists, refer to idiom #57 instead. 就地筛选列表 123456789101112131415161718192021package mainimport \"fmt\"type T intfunc main() &#123; x := []T&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; p := func(t T) bool &#123; return t%2 == 0 &#125; j := 0 for i, v := range x &#123; if p(v) &#123; x[j] = x[i] j++ &#125; &#125; x = x[:j] fmt.Println(x)&#125; [2 4 6 8 10] or 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"type T intfunc main() &#123; var x []*T for _, v := range []T&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; &#123; t := new(T) *t = v x = append(x, t) &#125; p := func(t *T) bool &#123; return *t%2 == 0 &#125; j := 0 for i, v := range x &#123; if p(v) &#123; x[j] = x[i] j++ &#125; &#125; for k := j; k &lt; len(x); k++ &#123; x[k] = nil &#125; x = x[:j] for _, pt := range x &#123; fmt.Print(*pt, \" \") &#125;&#125; 2 4 6 8 10 12345678910111213141516fn p(t: i32) -&gt; bool &#123; t % 2 == 0&#125;fn main() &#123; let mut x = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let mut j = 0; for i in 0..x.len() &#123; if p(x[i]) &#123; x[j] = x[i]; j += 1; &#125; &#125; x.truncate(j); println!(\"&#123;:?&#125;\", x);&#125; [2, 4, 6, 8, 10] or 1234567891011fn p(t: &amp;i64) -&gt; bool &#123; t % 2 == 0&#125;fn main() &#123; let mut x: Vec&lt;i64&gt; = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; x.retain(p); println!(\"&#123;:?&#125;\", x);&#125; [2, 4, 6, 8, 10] 249. Declare and assign multiple variables Define variables a, b and c in a concise way.Explain if they need to have the same type. 声明并分配多个变量 1234567891011121314package mainimport ( \"fmt\")func main() &#123; // a, b and c don't need to have the same type. a, b, c := 42, \"hello\", 5.0 fmt.Println(a, b, c) fmt.Printf(\"%T %T %T \\n\", a, b, c)&#125; 1242 hello 5int string float64 1234567fn main() &#123; // a, b and c don't need to have the same type. let (a, b, c) = (42, \"hello\", 5.0); println!(\"&#123;&#125; &#123;&#125; &#123;&#125;\", a, b, c);&#125; 42 hello 5 251. Parse binary digits Extract integer value i from its binary string representation s (in radix 2)E.g. “1101” -&gt; 13 解析二进制数字 12345678910111213141516171819package mainimport ( \"fmt\" \"reflect\" \"strconv\")func main() &#123; s := \"1101\" fmt.Println(\"s is\", reflect.TypeOf(s), s) i, err := strconv.ParseInt(s, 2, 0) if err != nil &#123; panic(err) &#125; fmt.Println(\"i is\", reflect.TypeOf(i), i)&#125; 12s is string 1101i is int64 13 1234567fn main() &#123; let s = \"1101\"; // binary digits let i = i32::from_str_radix(s, 2).expect(\"Not a binary number!\"); println!(\"&#123;&#125;\", i);&#125; 13 252. Conditional assignment Assign to variable x the value “a” if calling the function condition returns true, or the value “b” otherwise. 条件赋值 1234567891011121314151617181920package mainimport ( \"fmt\")func main() &#123; var x string if condition() &#123; x = \"a\" &#125; else &#123; x = \"b\" &#125; fmt.Println(x)&#125;func condition() bool &#123; return \"Socrates\" == \"dog\"&#125; b 1x = if condition() &#123; \"a\" &#125; else &#123; \"b\" &#125;; 258. Convert list of strings to list of integers Convert the string values from list a into a list of integers b. 将字符串列表转换为整数列表 123456789101112131415161718192021package mainimport ( \"fmt\" \"strconv\")func main() &#123; a := []string&#123;\"11\", \"22\", \"33\"&#125; b := make([]int, len(a)) var err error for i, s := range a &#123; b[i], err = strconv.Atoi(s) if err != nil &#123; panic(err) &#125; &#125; fmt.Println(b)&#125; [11 22 33] 1234567fn main() &#123; let a: Vec&lt;&amp;str&gt; = vec![\"11\", \"-22\", \"33\"]; let b: Vec&lt;i64&gt; = a.iter().map(|x| x.parse::&lt;i64&gt;().unwrap()).collect(); println!(\"&#123;:?&#125;\", b);&#125; [11, -22, 33] 259. Split on several separators Build list parts consisting of substrings of input string s, separated by any of the characters ‘,’ (comma), ‘-‘ (dash), ‘_’ (underscore). 在几个分隔符上拆分 123456789101112131415package mainimport ( \"fmt\" \"regexp\")func main() &#123; s := \"2021-03-11,linux_amd64\" re := regexp.MustCompile(\"[,\\\\-_]\") parts := re.Split(s, -1) fmt.Printf(\"%q\", parts)&#125; [&quot;2021&quot; &quot;03&quot; &quot;11&quot; &quot;linux&quot; &quot;amd64&quot;] 1234567fn main() &#123; let s = \"2021-03-11,linux_amd64\"; let parts: Vec&lt;_&gt; = s.split(&amp;[',', '-', '_'][..]).collect(); println!(\"&#123;:?&#125;\", parts);&#125; [&quot;2021&quot;, &quot;03&quot;, &quot;11&quot;, &quot;linux&quot;, &quot;amd64&quot;] 266. Repeating string Assign to string s the value of string v, repeated n times and write it out.E.g. v=”abc”, n=5 ⇒ s=”abcabcabcabcabc” 重复字符串 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; v := \"abc\" n := 5 s := strings.Repeat(v, n) fmt.Println(s)&#125; abcabcabcabcabc 1234567fn main() &#123; let v = \"abc\"; let n = 5; let s = v.repeat(n); println!(\"&#123;&#125;\", s);&#125; abcabcabcabcabc","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(12)","date":"2021-09-13T14:43:58.000Z","path":"2021/09/13/Rust-vs-Go-常用语法对比-12/","text":"221. Remove all non-digits characters Create string t from string s, keeping only digit characters 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. 删除所有非数字字符 123456789101112131415package mainimport ( \"fmt\" \"regexp\")func main() &#123; s := `height=\"168px\"` re := regexp.MustCompile(\"[^\\\\d]\") t := re.ReplaceAllLiteralString(s, \"\") fmt.Println(t)&#125; 168 12345678fn main() &#123; let t: String = \"Today is the 14th of July\" .chars() .filter(|c| c.is_digit(10)) .collect(); dbg!(t);&#125; [src/main.rs:7] t = &quot;14&quot; 222. Find first index of an element in list Set i to the first index in list items at which the element x can be found, or -1 if items does not contain x. 在列表中查找元素的第一个索引 1234567891011121314151617181920package mainimport ( \"fmt\")func main() &#123; items := []string&#123;\"huey\", \"dewey\", \"louie\"&#125; x := \"dewey\" i := -1 for j, e := range items &#123; if e == x &#123; i = j break &#125; &#125; fmt.Printf(\"Found %q at position %d in %q\", x, i, items)&#125; Found &quot;dewey&quot; at position 1 in [&quot;huey&quot; &quot;dewey&quot; &quot;louie&quot;] 123456789fn main() &#123; let items = ['A', '🎂', '㍗']; let x = '💩'; match items.iter().position(|y| *y == x) &#123; Some(i) =&gt; println!(\"Found &#123;&#125; at position &#123;&#125;.\", x, i), None =&gt; println!(\"There is no &#123;&#125; in the list.\", x), &#125;&#125; There is no 💩 in the list. or 12345678910111213141516171819fn main() &#123; let items = [42, -3, 12]; &#123; let x = 12; let i = items.iter().position(|y| *y == x).map_or(-1, |n| n as i32); println!(\"&#123;&#125; =&gt; &#123;&#125;\", x, i) &#125; &#123; let x = 13; let i = items.iter().position(|y| *y == x).map_or(-1, |n| n as i32); println!(\"&#123;&#125; =&gt; &#123;&#125;\", x, i) &#125;&#125; 1212 =&gt; 213 =&gt; -1 223. for else loop Loop through list items checking a condition. Do something else if no matches are found.A typical use case is looping through a series of containers looking for one that matches a condition. If found, an item is inserted; otherwise, a new container is created.These are mostly used as an inner nested loop, and in a location where refactoring inner logic into a separate function reduces clarity. for else循环 1234567891011121314151617181920package mainimport ( \"fmt\")func main() &#123; items := []string&#123;\"foo\", \"bar\", \"baz\", \"qux\"&#125; for _, item := range items &#123; if item == \"baz\" &#123; fmt.Println(\"found it\") goto forelse &#125; &#125; &#123; fmt.Println(\"never found it\") &#125; forelse:&#125; found it 123456789101112131415fn main() &#123; let items: &amp;[&amp;str] = &amp;[\"foo\", \"bar\", \"baz\", \"qux\"]; let mut found = false; for item in items &#123; if item == &amp;\"baz\" &#123; println!(\"found it\"); found = true; break; &#125; &#125; if !found &#123; println!(\"never found it\"); &#125;&#125; found it or 1234567fn main() &#123; let items: &amp;[&amp;str] = &amp;[\"foo\", \"bar\", \"baz\", \"qux\"]; if let None = items.iter().find(|&amp;&amp;item| item == \"rockstar programmer\") &#123; println!(\"NotFound\"); &#125;;&#125; NotFound or 1234567891011fn main() &#123; let items: &amp;[&amp;str] = &amp;[\"foo\", \"bar\", \"baz\", \"qux\"]; items .iter() .find(|&amp;&amp;item| item == \"rockstar programmer\") .or_else(|| &#123; println!(\"NotFound\"); Some(&amp;\"rockstar programmer\") &#125;);&#125; NotFound 224. Add element to the beginning of the list Insert element x at the beginning of list items. 将元素添加到列表的开头 12345678910111213141516package mainimport ( \"fmt\")type T intfunc main() &#123; items := []T&#123;42, 1337&#125; var x T = 7 items = append([]T&#123;x&#125;, items...) fmt.Println(items)&#125; [7 42 1337] or 123456789101112131415161718package mainimport ( \"fmt\")type T intfunc main() &#123; items := []T&#123;42, 1337&#125; var x T = 7 items = append(items, x) copy(items[1:], items) items[0] = x fmt.Println(items)&#125; [7 42 1337] 123456789101112use std::collections::VecDeque;fn main() &#123; let mut items = VecDeque::new(); items.push_back(22); items.push_back(33); let x = 11; items.push_front(x); println!(\"&#123;:?&#125;\", items);&#125; [11, 22, 33] 225. Declare and use an optional argument Declare an optional integer argument x to procedure f, printing out “Present” and its value if it is present, “Not present” otherwise 声明并使用可选参数 1234567891011121314package mainfunc f(x ...int) &#123; if len(x) &gt; 0 &#123; println(\"Present\", x[0]) &#125; else &#123; println(\"Not present\") &#125;&#125;func main() &#123; f() f(1)&#125; Go does not have optional arguments, but to some extend, they can be mimicked with a variadic parameter.x is a variadic parameter, which must be the last parameter for the function f.Strictly speaking, x is a list of integers, which might have more than one element. These additional elements are ignored. 12Not presentPresent 1 123456fn f(x: Option&lt;()&gt;) &#123; match x &#123; Some(x) =&gt; println!(\"Present &#123;&#125;\", x), None =&gt; println!(\"Not present\"), &#125;&#125; 226. Delete last element from list Remove the last element from list items. 从列表中删除最后一个元素 12345678910111213package mainimport ( \"fmt\")func main() &#123; items := []string&#123;\"banana\", \"apple\", \"kiwi\"&#125; fmt.Println(items) items = items[:len(items)-1] fmt.Println(items)&#125; 12[banana apple kiwi][banana apple] 1234567fn main() &#123; let mut items = vec![11, 22, 33]; items.pop(); println!(\"&#123;:?&#125;\", items);&#125; [11, 22] 227. Copy list Create new list y containing the same elements as list x.Subsequent modifications of y must not affect x (except for the contents referenced by the elements themselves if they contain pointers). 复制列表 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; type T string x := []T&#123;\"Never\", \"gonna\", \"shower\"&#125; y := make([]T, len(x)) copy(y, x) y[2] = \"give\" y = append(y, \"you\", \"up\") fmt.Println(x) fmt.Println(y)&#125; 12[Never gonna shower][Never gonna give you up] 123456789fn main() &#123; let mut x = vec![4, 3, 2]; let y = x.clone(); x[0] = 99; println!(\"x is &#123;:?&#125;\", x); println!(\"y is &#123;:?&#125;\", y);&#125; 12x is [99, 3, 2]y is [4, 3, 2] 228. Copy a file Copy the file at path src to dst. 复制文件 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() &#123; src, dst := \"/tmp/file1\", \"/tmp/file2\" err := copy(dst, src) if err != nil &#123; log.Fatalln(err) &#125; stat, err := os.Stat(dst) if err != nil &#123; log.Fatalln(err) &#125; fmt.Println(dst, \"exists, it has size\", stat.Size(), \"and mode\", stat.Mode())&#125;func copy(dst, src string) error &#123; data, err := ioutil.ReadFile(src) if err != nil &#123; return err &#125; stat, err := os.Stat(src) if err != nil &#123; return err &#125; return ioutil.WriteFile(dst, data, stat.Mode())&#125;func init() &#123; data := []byte(\"Hello\") err := ioutil.WriteFile(\"/tmp/file1\", data, 0644) if err != nil &#123; log.Fatalln(err) &#125;&#125; /tmp/file2 exists, it has size 5 and mode -rw-r--r-- or 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() &#123; src, dst := \"/tmp/file1\", \"/tmp/file2\" err := copy(dst, src) if err != nil &#123; log.Fatalln(err) &#125; stat, err := os.Stat(dst) if err != nil &#123; log.Fatalln(err) &#125; fmt.Println(dst, \"exists, it has size\", stat.Size(), \"and mode\", stat.Mode())&#125;func copy(dst, src string) error &#123; data, err := ioutil.ReadFile(src) if err != nil &#123; return err &#125; stat, err := os.Stat(src) if err != nil &#123; return err &#125; err = ioutil.WriteFile(dst, data, stat.Mode()) if err != nil &#123; return err &#125; return os.Chmod(dst, stat.Mode())&#125;func init() &#123; data := []byte(\"Hello\") err := ioutil.WriteFile(\"/tmp/file1\", data, 0777) if err != nil &#123; log.Fatalln(err) &#125; err = os.Chmod(\"/tmp/file1\", 0777) if err != nil &#123; log.Fatalln(err) &#125;&#125; /tmp/file2 exists, it has size 5 and mode -rwxrwxrwx or 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( \"fmt\" \"io\" \"io/ioutil\" \"log\" \"os\")func main() &#123; src, dst := \"/tmp/file1\", \"/tmp/file2\" err := copy(dst, src) if err != nil &#123; log.Fatalln(err) &#125; stat, err := os.Stat(dst) if err != nil &#123; log.Fatalln(err) &#125; fmt.Println(dst, \"exists, it has size\", stat.Size(), \"and mode\", stat.Mode())&#125;func copy(dst, src string) error &#123; f, err := os.Open(src) if err != nil &#123; return err &#125; defer f.Close() stat, err := f.Stat() if err != nil &#123; return err &#125; g, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, stat.Mode()) if err != nil &#123; return err &#125; defer g.Close() _, err = io.Copy(g, f) if err != nil &#123; return err &#125; return os.Chmod(dst, stat.Mode())&#125;func init() &#123; data := []byte(\"Hello\") err := ioutil.WriteFile(\"/tmp/file1\", data, 0777) if err != nil &#123; log.Fatalln(err) &#125; err = os.Chmod(\"/tmp/file1\", 0777) if err != nil &#123; log.Fatalln(err) &#125;&#125; /tmp/file2 exists, it has size 5 and mode -rwxrwxrwx 12345678910111213use std::fs;fn main() &#123; let src = \"/etc/fstabZ\"; let dst = \"fstab.bck\"; let r = fs::copy(src, dst); match r &#123; Ok(v) =&gt; println!(\"Copied &#123;:?&#125; bytes\", v), Err(e) =&gt; println!(\"error copying &#123;:?&#125; to &#123;:?&#125;: &#123;:?&#125;\", src, dst, e), &#125;&#125; error copying &quot;/etc/fstabZ&quot; to &quot;fstab.bck&quot;: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; } 231. Test if bytes are a valid UTF-8 string Set b to true if the byte sequence s consists entirely of valid UTF-8 character code points, false otherwise. 测试字节是否是有效的UTF-8字符串 12345678910111213141516171819package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; &#123; s := []byte(\"Hello, 世界\") b := utf8.Valid(s) fmt.Println(b) &#125; &#123; s := []byte&#123;0xff, 0xfe, 0xfd&#125; b := utf8.Valid(s) fmt.Println(b) &#125;&#125; 12truefalse 123456789101112131415fn main() &#123; &#123; let bytes = [0xc3, 0x81, 0x72, 0x76, 0xc3, 0xad, 0x7a]; let b = std::str::from_utf8(&amp;bytes).is_ok(); println!(\"&#123;&#125;\", b); &#125; &#123; let bytes = [0xc3, 0x81, 0x81, 0x76, 0xc3, 0xad, 0x7a]; let b = std::str::from_utf8(&amp;bytes).is_ok(); println!(\"&#123;&#125;\", b); &#125;&#125; 12truefalse 234. Encode bytes to base64 Assign to string s the standard base64 encoding of the byte array data, as specified by RFC 4648. 将字节编码为base64 123456789101112package mainimport ( \"encoding/base64\" \"fmt\")func main() &#123; data := []byte(\"Hello world\") s := base64.StdEncoding.EncodeToString(data) fmt.Println(s)&#125; SGVsbG8gd29ybGQ= 12345678//use base64;fn main() &#123; let d = \"Hello, World!\"; let b64txt = base64::encode(d); println!(\"&#123;&#125;\", b64txt);&#125; SGVsbG8sIFdvcmxkIQ== 235. Decode base64 Assign to byte array data the bytes represented by the base64 string s, as specified by RFC 4648. 解码base64 123456789101112131415161718package mainimport ( \"encoding/base64\" \"fmt\")func main() &#123; str := \"SGVsbG8gd29ybGQ=\" data, err := base64.StdEncoding.DecodeString(str) if err != nil &#123; fmt.Println(\"error:\", err) return &#125; fmt.Printf(\"%q\\n\", data)&#125; &quot;Hello world&quot; 123456789//use base64;fn main() &#123; let d = \"SGVsbG8sIFdvcmxkIQ==\"; let bytes = base64::decode(d).unwrap(); println!(\"Hex: &#123;:x?&#125;\", bytes); println!(\"Txt: &#123;&#125;\", std::str::from_utf8(&amp;bytes).unwrap());&#125; 12Hex: [48, 65, 6c, 6c, 6f, 2c, 20, 57, 6f, 72, 6c, 64, 21]Txt: Hello, World! 237. Xor integers Assign to c the result of (a xor b) 异或运算 异或整数 123456789101112131415package mainimport ( \"fmt\")func main() &#123; a, b := 230, 42 c := a ^ b fmt.Printf(\"a is %12b\\n\", a) fmt.Printf(\"b is %12b\\n\", b) fmt.Printf(\"c is %12b\\n\", c) fmt.Println(\"c ==\", c)&#125; 1234a is 11100110b is 101010c is 11001100c == 204 or 1234567891011121314151617package mainimport ( \"fmt\" \"math/big\")func main() &#123; a, b := big.NewInt(230), big.NewInt(42) c := new(big.Int) c.Xor(a, b) fmt.Printf(\"a is %12b\\n\", a) fmt.Printf(\"b is %12b\\n\", b) fmt.Printf(\"c is %12b\\n\", c) fmt.Println(\"c ==\", c)&#125; 1234a is 11100110b is 101010c is 11001100c == 204 1234567fn main() &#123; let a = 230; let b = 42; let c = a ^ b; println!(\"&#123;&#125;\", c);&#125; 204 238. Xor byte arrays Write in a new byte array c the xor result of byte arrays a and b.a and b have the same size. 异或字节数组 1234567891011121314151617181920package mainimport ( \"fmt\")func main() &#123; a, b := []byte(\"Hello\"), []byte(\"world\") c := make([]byte, len(a)) for i := range a &#123; c[i] = a[i] ^ b[i] &#125; fmt.Printf(\"a is %08b\\n\", a) fmt.Printf(\"b is %08b\\n\", b) fmt.Printf(\"c is %08b\\n\", c) fmt.Println(\"c ==\", c) fmt.Printf(\"c as string would be %q\\n\", string(c))&#125; 12345a is [01001000 01100101 01101100 01101100 01101111]b is [01110111 01101111 01110010 01101100 01100100]c is [00111111 00001010 00011110 00000000 00001011]c == [63 10 30 0 11]c as string would be \"?\\n\\x1e\\x00\\v\" or 123456789101112131415161718192021222324package mainimport ( \"fmt\")type T [5]bytefunc main() &#123; var a, b T copy(a[:], \"Hello\") copy(b[:], \"world\") var c T for i := range a &#123; c[i] = a[i] ^ b[i] &#125; fmt.Printf(\"a is %08b\\n\", a) fmt.Printf(\"b is %08b\\n\", b) fmt.Printf(\"c is %08b\\n\", c) fmt.Println(\"c ==\", c) fmt.Printf(\"c as string would be %q\\n\", string(c[:]))&#125; 12345a is [01001000 01100101 01101100 01101100 01101111]b is [01110111 01101111 01110010 01101100 01100100]c is [00111111 00001010 00011110 00000000 00001011]c == [63 10 30 0 11]c as string would be \"?\\n\\x1e\\x00\\v\" 12345678fn main() &#123; let a: &amp;[u8] = \"Hello\".as_bytes(); let b: &amp;[u8] = \"world\".as_bytes(); let c: Vec&lt;_&gt; = a.iter().zip(b).map(|(x, y)| x ^ y).collect(); println!(\"&#123;:?&#125;\", c);&#125; [63, 10, 30, 0, 11] 239. Find first regular expression match Assign to string x the first word of string s consisting of exactly 3 digits, or the empty string if no such match exists.A word containing more digits, or 3 digits as a substring fragment, must not match. 查找第一个正则表达式匹配项 123456789101112131415161718192021package mainimport ( \"fmt\" \"regexp\")func main() &#123; re := regexp.MustCompile(`\\b\\d\\d\\d\\b`) for _, s := range []string&#123; \"\", \"12\", \"123\", \"1234\", \"I have 12 goats, 3988 otters, 224 shrimps and 456 giraffes\", \"See p.456, for word boundaries\", &#125; &#123; x := re.FindString(s) fmt.Printf(\"%q -&gt; %q\\n\", s, x) &#125;&#125; 123456\"\" -&gt; \"\"\"12\" -&gt; \"\"\"123\" -&gt; \"123\"\"1234\" -&gt; \"\"\"I have 12 goats, 3988 otters, 224 shrimps and 456 giraffes\" -&gt; \"224\"\"See p.456, for word boundaries\" -&gt; \"456\" 1234567891011121314151617use regex::Regex;fn main() &#123; let sentences = vec![ \"\", \"12\", \"123\", \"1234\", \"I have 12 goats, 3988 otters, 224 shrimps and 456 giraffes\", \"See p.456, for word boundaries\", ]; for s in sentences &#123; let re = Regex::new(r\"\\b\\d\\d\\d\\b\").expect(\"failed to compile regex\"); let x = re.find(s).map(|x| x.as_str()).unwrap_or(\"\"); println!(\"[&#123;&#125;] -&gt; [&#123;&#125;]\", &amp;s, &amp;x); &#125;&#125; 123456[] -&gt; [][12] -&gt; [][123] -&gt; [123][1234] -&gt; [][I have 12 goats, 3988 otters, 224 shrimps and 456 giraffes] -&gt; [224][See p.456, for word boundaries] -&gt; [456] 240. Sort 2 lists together Lists a and b have the same length. Apply the same permutation to a and b to have them sorted based on the values of a. 将两个列表排序在一起.列表a和b的长度相同。对a和b应用相同的排列，根据a的值对它们进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"fmt\" \"sort\")type K inttype T stringtype sorter struct &#123; k []K t []T&#125;func (s *sorter) Len() int &#123; return len(s.k)&#125;func (s *sorter) Swap(i, j int) &#123; // Swap affects 2 slices at once. s.k[i], s.k[j] = s.k[j], s.k[i] s.t[i], s.t[j] = s.t[j], s.t[i]&#125;func (s *sorter) Less(i, j int) bool &#123; return s.k[i] &lt; s.k[j]&#125;func main() &#123; a := []K&#123;9, 3, 4, 8&#125; b := []T&#123;\"nine\", \"three\", \"four\", \"eight\"&#125; sort.Sort(&amp;sorter&#123; k: a, t: b, &#125;) fmt.Println(a) fmt.Println(b)&#125; 12[3 4 8 9][three four eight nine] 12345678910fn main() &#123; let a = vec![30, 20, 40, 10]; let b = vec![101, 102, 103, 104]; let mut tmp: Vec&lt;_&gt; = a.iter().zip(b).collect(); tmp.as_mut_slice().sort_by_key(|(&amp;x, _y)| x); let (aa, bb): (Vec&lt;i32&gt;, Vec&lt;i32&gt;) = tmp.into_iter().unzip(); println!(\"&#123;:?&#125;, &#123;:?&#125;\", aa, bb);&#125; [10, 20, 30, 40], [104, 102, 101, 103]","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(11)","date":"2021-09-12T14:43:58.000Z","path":"2021/09/12/Rust-vs-Go-常用语法对比-11/","text":"202. Sum of squares Calculate the sum of squares s of data, an array of floating point values. 计算平方和 1234567891011121314package mainimport ( \"math\")func main() &#123; data := []float64&#123;0.06, 0.82, -0.01, -0.34, -0.55&#125; var s float64 for _, d := range data &#123; s += math.Pow(d, 2) &#125; println(s)&#125; +1.094200e+000 1234567fn main() &#123; let data: Vec&lt;f32&gt; = vec![2.0, 3.5, 4.0]; let s = data.iter().map(|x| x.powi(2)).sum::&lt;f32&gt;(); println!(\"&#123;&#125;\", s);&#125; 32.25 205. Get an environment variable Read an environment variable with the name “FOO” and assign it to the string variable foo. If it does not exist or if the system does not support environment variables, assign a value of “none”. 获取环境变量 123456789101112131415package mainimport ( \"fmt\" \"os\")func main() &#123; foo, ok := os.LookupEnv(\"FOO\") if !ok &#123; foo = \"none\" &#125; fmt.Println(foo)&#125; none or 123456789101112131415package mainimport ( \"fmt\" \"os\")func main() &#123; foo := os.Getenv(\"FOO\") if foo == \"\" &#123; foo = \"none\" &#125; fmt.Println(foo)&#125; none 1234567891011121314151617use std::env;fn main() &#123; let foo; match env::var(\"FOO\") &#123; Ok(val) =&gt; foo = val, Err(_e) =&gt; foo = \"none\".to_string(), &#125; println!(\"&#123;&#125;\", foo); let user; match env::var(\"USER\") &#123; Ok(val) =&gt; user = val, Err(_e) =&gt; user = \"none\".to_string(), &#125; println!(\"&#123;&#125;\", user);&#125; 12noneplayground or 123456789use std::env;fn main() &#123; let foo = env::var(\"FOO\").unwrap_or(\"none\".to_string()); println!(\"&#123;&#125;\", foo); let user = env::var(\"USER\").unwrap_or(\"none\".to_string()); println!(\"&#123;&#125;\", user);&#125; 12noneplayground or 123456789101112131415use std::env;fn main() &#123; let foo = match env::var(\"FOO\") &#123; Ok(val) =&gt; val, Err(_e) =&gt; \"none\".to_string(), &#125;; println!(\"&#123;&#125;\", foo); let user = match env::var(\"USER\") &#123; Ok(val) =&gt; val, Err(_e) =&gt; \"none\".to_string(), &#125;; println!(\"&#123;&#125;\", user);&#125; 12noneplayground or 1234use std::env;if let Ok(tnt_root) = env::var(\"TNT_ROOT\") &#123; //&#125; 206. Switch statement with strings Execute different procedures foo, bar, baz and barfl if the string str contains the name of the respective procedure. Do it in a way natural to the language. switch语句 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\")func main() &#123; str := \"baz\" switch str &#123; case \"foo\": foo() case \"bar\": bar() case \"baz\": baz() case \"barfl\": barfl() &#125;&#125;func foo() &#123; fmt.Println(\"Called foo\")&#125;func bar() &#123; fmt.Println(\"Called bar\")&#125;func baz() &#123; fmt.Println(\"Called baz\")&#125;func barfl() &#123; fmt.Println(\"Called barfl\")&#125; Called baz 1234567891011121314fn main() &#123; fn foo() &#123;&#125; fn bar() &#123;&#125; fn baz() &#123;&#125; fn barfl() &#123;&#125; let str_ = \"x\"; match str_ &#123; \"foo\" =&gt; foo(), \"bar\" =&gt; bar(), \"baz\" =&gt; baz(), \"barfl\" =&gt; barfl(), _ =&gt; &#123;&#125; &#125;&#125; 207. Allocate a list that is automatically deallocated Allocate a list a containing n elements (n assumed to be too large for a stack) that is automatically deallocated when the program exits the scope it is declared in. 分配一个自动解除分配的列表 12345678910111213package mainimport ( \"fmt\")type T bytefunc main() &#123; n := 10_000_000 a := make([]T, n) fmt.Println(len(a))&#125; Elements have type T.a is garbage-collected after the program exits its scope, unless we let it “escape” by taking its reference.The runtime decides if a lives in the stack on in the heap. 10000000 1let a = vec![0; n]; Heap allocations are deallocated when the variable goes out of scope. 208. Formula with arrays Given the arrays a,b,c,d of equal length and the scalar e, calculate a = e(a+bc+cos(d)).Store the results in a. 对数组元素进行运算 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"math\")func applyFormula(a, b, c, d []float64, e float64) &#123; for i, v := range a &#123; a[i] = e * (v + b[i] + c[i] + math.Cos(d[i])) &#125;&#125;func main() &#123; a := []float64&#123;1, 2, 3, 4&#125; b := []float64&#123;5.5, 6.6, 7.7, 8.8&#125; c := []float64&#123;9, 10, 11, 12&#125; d := []float64&#123;13, 14, 15, 16&#125; e := 42.0 fmt.Println(\"a is \", a) applyFormula(a, b, c, d, e) fmt.Println(\"a is now\", a)&#125; 12a is [1 2 3 4]a is now [689.1127648209083 786.9429631647291 879.4931076599294 1001.3783018264178] 123456789101112131415fn main() &#123; let mut a: [f32; 5] = [5., 2., 8., 9., 0.5]; // we want it to be mutable let b: [f32; 5] = [7., 9., 8., 0.965, 0.98]; let c: [f32; 5] = [0., 0.8, 789456., 123456., 0.0003]; let d: [f32; 5] = [332., 0.1, 8., 9874., 0.3]; const e: f32 = 85.; for i in 0..a.len() &#123; a[i] = e * (a[i] + b[i] * c[i] + d[i].cos()); &#125; println!(\"&#123;:?&#125;\", a); //Don't have any idea about the output&#125; [470.29297, 866.57544, 536830750.0, 10127158.0, 123.7286] 209. Type with automatic deep deallocation Declare a type t which contains a string s and an integer array n with variable size, and allocate a variable v of type t. Allocate v.s and v.n and set them to the values “Hello, world!” for s and [1,4,9,16,25], respectively. Deallocate v, automatically deallocating v.s and v.n (no memory leaks). 自动深度解除分配的类型 12345678910111213141516171819202122package mainfunc main() &#123; f()&#125;func f() &#123; type t struct &#123; s string n []int &#125; v := t&#123; s: \"Hello, world!\", n: []int&#123;1, 4, 9, 16, 25&#125;, &#125; // Pretend to use v (otherwise this is a compile error) _ = v // When f exits, v and all its fields are garbage-collected, recursively&#125; After v goes out of scope, v and all its fields will be garbage-collected, recursively 1234567891011struct T &#123; s: String, n: Vec&lt;usize&gt;,&#125;fn main() &#123; let v = T &#123; s: \"Hello, world!\".into(), n: vec![1,4,9,16,25] &#125;;&#125; When a variable goes out of scope, all member variables are deallocated recursively. 211. Create folder Create the folder at path on the filesystem 创建文件夹 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"os\")func main() &#123; path := \"foo\" _, err := os.Stat(path) b := !os.IsNotExist(err) fmt.Println(path, \"exists:\", b) err = os.Mkdir(path, os.ModeDir) if err != nil &#123; panic(err) &#125; info, err2 := os.Stat(path) b = !os.IsNotExist(err2) fmt.Println(path, \"exists:\", b) fmt.Println(path, \"is a directory:\", info.IsDir())&#125; 123foo exists: falsefoo exists: truefoo is a directory: true or 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"os\")func main() &#123; path := \"foo/bar\" _, err := os.Stat(path) b := !os.IsNotExist(err) fmt.Println(path, \"exists:\", b) err = os.Mkdir(path, os.ModeDir) if err != nil &#123; fmt.Println(\"Could not create\", path, \"with os.Mkdir\") &#125; info, err2 := os.Stat(path) b = !os.IsNotExist(err2) fmt.Println(path, \"exists:\", b) err = os.MkdirAll(path, os.ModeDir) if err != nil &#123; fmt.Println(\"Could not create\", path, \"with os.MkdirAll\") &#125; info, err2 = os.Stat(path) b = !os.IsNotExist(err2) fmt.Println(path, \"exists:\", b) fmt.Println(path, \"is a directory:\", info.IsDir())&#125; 12345foo/bar exists: falseCould not create foo/bar with os.Mkdirfoo/bar exists: falsefoo/bar exists: truefoo/bar is a directory: true 1234567891011121314151617181920use std::fs;use std::path::Path;fn main() &#123; let path = \"/tmp/goofy\"; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125; exists: &#123;&#125;\", path, b); let r = fs::create_dir(path); match r &#123; Err(e) =&gt; &#123; println!(\"error creating &#123;&#125;: &#123;&#125;\", path, e); std::process::exit(1); &#125; Ok(_) =&gt; println!(\"created &#123;&#125;: OK\", path), &#125; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125; exists: &#123;&#125;\", path, b);&#125; 123/tmp/goofy exists: falsecreated /tmp/goofy: OK/tmp/goofy exists: true or 12345678910111213141516171819202122232425262728use std::fs;use std::path::Path;fn main() &#123; let path = \"/tmp/friends/goofy\"; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125; exists: &#123;&#125;\", path, b); // fs::create_dir can't create parent folders let r = fs::create_dir(path); match r &#123; Err(e) =&gt; println!(\"error creating &#123;&#125;: &#123;&#125;\", path, e), Ok(_) =&gt; println!(\"created &#123;&#125;: OK\", path), &#125; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125; exists: &#123;&#125;\", path, b); // fs::create_dir_all does create parent folders let r = fs::create_dir_all(path); match r &#123; Err(e) =&gt; println!(\"error creating &#123;&#125;: &#123;&#125;\", path, e), Ok(_) =&gt; println!(\"created &#123;&#125;: OK\", path), &#125; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125; exists: &#123;&#125;\", path, b);&#125; 12345/tmp/friends/goofy exists: falseerror creating /tmp/friends/goofy: No such file or directory (os error 2)/tmp/friends/goofy exists: falsecreated /tmp/friends/goofy: OK/tmp/friends/goofy exists: true 212. Check if folder exists Set boolean b to true if path exists on the filesystem and is a directory; false otherwise. 检查文件夹是否存在 12345678910111213141516171819202122package mainimport ( \"fmt\" \"os\")func main() &#123; path := \"foo\" info, err := os.Stat(path) b := !os.IsNotExist(err) &amp;&amp; info.IsDir() fmt.Println(path, \"is a directory:\", b) err = os.Mkdir(path, os.ModeDir) if err != nil &#123; panic(err) &#125; info, err = os.Stat(path) b = !os.IsNotExist(err) &amp;&amp; info.IsDir() fmt.Println(path, \"is a directory:\", b)&#125; 12foo is a directory: falsefoo is a directory: true 1234567891011use std::path::Path;fn main() &#123; let path = \"/etc\"; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125;: &#123;&#125;\", path, b); let path = \"/goofy\"; let b: bool = Path::new(path).is_dir(); println!(\"&#123;&#125;: &#123;&#125;\", path, b);&#125; 12/etc: true/goofy: false 215. Pad string on the left Prepend extra character c at the beginning of string s to make sure its length is at least m.The length is the number of characters, not the number of bytes. 左侧补齐字符串 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"strings\" \"unicode/utf8\")func main() &#123; m := 3 c := \"-\" for _, s := range []string&#123; \"\", \"a\", \"ab\", \"abc\", \"abcd\", \"é\", &#125; &#123; if n := utf8.RuneCountInString(s); n &lt; m &#123; s = strings.Repeat(c, m-n) + s &#125; fmt.Println(s) &#125;&#125; 123456-----a-ababcabcd--é 12345678910111213use unicode_width::&#123;UnicodeWidthChar, UnicodeWidthStr&#125;;if let Some(columns_short) = m.checked_sub(s.width()) &#123; let padding_width = c .width() .filter(|n| *n &gt; 0) .expect(\"padding character should be visible\"); // Saturate the columns_short let padding_needed = columns_short + padding_width - 1 / padding_width; let mut t = String::with_capacity(s.len() + padding_needed); t.extend((0..padding_needed).map(|_| c) t.push_str(&amp;s); s = t;&#125; *This uses the Unicode display width to determine the padding needed. This will be appropriate for most uses of monospaced text. It assumes that m won’t combine with other characters to form a grapheme.* 217. Create a Zip archive Create a zip-file with filename name and add the files listed in list to that zip-file. 创建压缩文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( \"archive/zip\" \"bytes\" \"io\" \"io/ioutil\" \"log\" \"os\")func main() &#123; list := []string&#123; \"readme.txt\", \"gopher.txt\", \"todo.txt\", &#125; name := \"archive.zip\" err := makeZip(list, name) if err != nil &#123; log.Fatal(err) &#125;&#125;func makeZip(list []string, name string) error &#123; // Create a buffer to write our archive to. buf := new(bytes.Buffer) // Create a new zip archive. w := zip.NewWriter(buf) // Add some files to the archive. for _, filename := range list &#123; // Open file for reading input, err := os.Open(filename) if err != nil &#123; return err &#125; // Create ZIP entry for writing output, err := w.Create(filename) if err != nil &#123; return err &#125; _, err = io.Copy(output, input) if err != nil &#123; return err &#125; &#125; // Make sure to check the error on Close. err := w.Close() if err != nil &#123; return err &#125; N := buf.Len() err = ioutil.WriteFile(name, buf.Bytes(), 0777) if err != nil &#123; return err &#125; log.Println(\"Written a ZIP file of\", N, \"bytes\") return nil&#125;func init() &#123; // Create some files in the filesystem. var files = []struct &#123; Name, Body string &#125;&#123; &#123;\"readme.txt\", \"This archive contains some text files.\"&#125;, &#123;\"gopher.txt\", \"Gopher names:\\nGeorge\\nGeoffrey\\nGonzo\"&#125;, &#123;\"todo.txt\", \"Get animal handling licence.\\nWrite more examples.\"&#125;, &#125; for _, file := range files &#123; err := ioutil.WriteFile(file.Name, []byte(file.Body), 0777) if err != nil &#123; log.Fatal(err) &#125; &#125;&#125; list contains filenames of files existing in the filesystem.In this example, the zip data is buffered in memory before writing to the filesystem. 2009/11/10 23:00:00 Written a ZIP file of 492 bytes 123456use zip::write::FileOptions;let path = std::path::Path::new(_name);let file = std::fs::File::create(&amp;path).unwrap();let mut zip = zip::ZipWriter::new(file); zip.start_file(\"readme.txt\", FileOptions::default())?; zip.write_all(b\"Hello, World!\\n\")?;zip.finish()?; or 123456789101112use zip::write::FileOptions;fn zip(_name: &amp;str, _list: Vec&lt;&amp;str&gt;) -&gt; zip::result::ZipResult&lt;()&gt;&#123; let path = std::path::Path::new(_name); let file = std::fs::File::create(&amp;path).unwrap(); let mut zip = zip::ZipWriter::new(file); for i in _list.iter() &#123; zip.start_file(i as &amp;str, FileOptions::default())?; &#125; zip.finish()?; Ok(())&#125; 218. List intersection Create list c containing all unique elements that are contained in both lists a and b.c should not contain any duplicates, even if a and b do.The order of c doesn’t matter. 列表的交集 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\")type T intfunc main() &#123; a := []T&#123;4, 5, 6, 7, 8, 9, 10&#125; b := []T&#123;1, 3, 9, 5, 7, 9, 7, 7&#125; // Convert to sets seta := make(map[T]bool, len(a)) for _, x := range a &#123; seta[x] = true &#125; setb := make(map[T]bool, len(a)) for _, y := range b &#123; setb[y] = true &#125; // Iterate in one pass var c []T for x := range seta &#123; if setb[x] &#123; c = append(c, x) &#125; &#125; fmt.Println(c)&#125; [5 7 9] 123456789101112use std::collections::HashSet;fn main() &#123; let a = vec![1, 2, 3, 4]; let b = vec![2, 4, 6, 8, 2, 2]; let unique_a = a.iter().collect::&lt;HashSet&lt;_&gt;&gt;(); let unique_b = b.iter().collect::&lt;HashSet&lt;_&gt;&gt;(); let c = unique_a.intersection(&amp;unique_b).collect::&lt;Vec&lt;_&gt;&gt;(); println!(\"c: &#123;:?&#125;\", c);&#125; c: [2, 4] or 123456789101112use std::collections::HashSet;fn main() &#123; let a = vec![1, 2, 3, 4]; let b = vec![2, 4, 6, 8, 2, 2]; let set_a: HashSet&lt;_&gt; = a.into_iter().collect(); let set_b: HashSet&lt;_&gt; = b.into_iter().collect(); let c = set_a.intersection(&amp;set_b); println!(\"c: &#123;:?&#125;\", c);&#125; c: [2, 4] 219. Replace multiple spaces with single space Create string t from the value of string s with each sequence of spaces replaced by a single space.Explain if only the space characters will be replaced, or the other whitespaces as well: tabs, newlines. 用单个空格替换多个空格 1234567891011121314151617181920package mainimport ( \"fmt\" \"regexp\")// regexp created only once, and then reusedvar whitespaces = regexp.MustCompile(`\\s+`)func main() &#123; s := ` one two three ` t := whitespaces.ReplaceAllString(s, \" \") fmt.Printf(\"t=%q\", t)&#125; t=&quot; one two three &quot; 1234567891011use regex::Regex;fn main() &#123; let s = \" one two three \"; let re = Regex::new(r\"\\s+\").unwrap(); let t = re.replace_all(s, \" \"); println!(\"&#123;&#125;\", t);&#125; one two three 220. Create a tuple value Create t consisting of 3 values having different types.Explain if the elements of t are strongly typed or not. 创建元组值a 12345t := []interface&#123;&#125;&#123; 2.5, \"hello\", make(chan int),&#125; A slice of empty interface may hold any values (not strongly typed). 123456fn main() &#123; let mut t = (2.5, \"hello\", -1); t.2 -= 4; println!(\"&#123;:?&#125;\", t);&#125; (2.5, &quot;hello&quot;, -5)","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(10)","date":"2021-09-11T14:43:58.000Z","path":"2021/09/11/Rust-vs-Go-常用语法对比-10/","text":"182. Quine program Output the source of the program. 输出程序的源代码 1234567891011121314151617package mainimport \"fmt\"func main() &#123; fmt.Printf(\"%s%c%s%c\\n\", s, 0x60, s, 0x60)&#125;var s = `package mainimport \"fmt\"func main() &#123; fmt.Printf(\"%s%c%s%c\\n\", s, 0x60, s, 0x60)&#125;var s = ` 输出： 1234567891011121314151617package mainimport \"fmt\"func main() &#123; fmt.Printf(\"%s%c%s%c\\n\", s, 0x60, s, 0x60)&#125;var s = `package mainimport \"fmt\"func main() &#123; fmt.Printf(\"%s%c%s%c\\n\", s, 0x60, s, 0x60)&#125;var s = ` 另一种写法： //go:embed 入门 Quine 是一种可以输出自身源码的程序。利用 go:embed 我们可以轻松实现 quine 程序： 12345678910111213package mainimport ( _ \"embed\" \"fmt\")//go:embed quine.govar src stringfunc main() &#123; fmt.Print(src)&#125; 1234567fn main() &#123; let x = \"fn main() &#123;\\n let x = \"; let y = \"print!(\\\"&#123;&#125;&#123;:?&#125;;\\n let y = &#123;:?&#125;;\\n &#123;&#125;\\\", x, x, y, y)\\n&#125;\\n\"; print!(\"&#123;&#125;&#123;:?&#125;; let y = &#123;:?&#125;; &#123;&#125;\", x, x, y, y)&#125; 输出： 1234567fn main() &#123; let x = \"fn main() &#123;\\n let x = \"; let y = \"print!(\\\"&#123;&#125;&#123;:?&#125;;\\n let y = &#123;:?&#125;;\\n &#123;&#125;\\\", x, x, y, y)\\n&#125;\\n\"; print!(\"&#123;&#125;&#123;:?&#125;; let y = &#123;:?&#125;; &#123;&#125;\", x, x, y, y)&#125; or 1fn main()&#123;print!(\"&#123;&#125;,&#123;0:?&#125;)&#125;&#125;\",\"fn main()&#123;print!(\\\"&#123;&#125;,&#123;0:?&#125;)&#125;&#125;\\\"\")&#125; 输出： fn main(){print!(&quot;{},{0:?})}}&quot;,&quot;fn main(){print!(\\&quot;{},{0:?})}}\\&quot;&quot;)} 184. Tomorrow Assign to variable t a string representing the day, month and year of the day after the current date. 明天的日期 12import \"time\"t := time.Now().Add(24 * time.Hour).Format(\"2006-01-02\") 1234fn main() &#123; let t = chrono::Utc::now().date().succ().to_string(); println!(\"&#123;&#125;\", t);&#125; 2021-07-18UTC 185. Execute function in 30 seconds Schedule the execution of f(42) in 30 seconds. 30秒内执行功能 123456import \"time\"timer := time.AfterFunc( 30*time.Second, func() &#123; f(42) &#125;) or 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"time\")func main() &#123; fmt.Println(\"Scheduling f(42)\") go func() &#123; time.Sleep(3 * time.Second) f(42) &#125;() // Poor man's waiting of completion of f. // Don't do this in prod, use proper synchronization instead. time.Sleep(4 * time.Second)&#125;func f(i int) &#123; fmt.Println(\"Received\", i)&#125; Scheduling f(42) 1234use std::time::Duration;use std::thread::sleep;sleep(Duration::new(30, 0));f(42); 186. Exit program cleanly Exit a program cleanly indicating no error to OS 干净地退出程序 123456789101112package mainimport ( \"fmt\" \"os\")func main() &#123; fmt.Println(\"A\") os.Exit(0) fmt.Println(\"B\")&#125; A or 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"os\")func main() &#123; process1() process2() process3()&#125;func process1() &#123; fmt.Println(\"process 1\")&#125;func process2() &#123; fmt.Println(\"process 2\") defer fmt.Println(\"A\") defer os.Exit(0) defer fmt.Println(\"B\") fmt.Println(\"C\")&#125;func process3() &#123; fmt.Println(\"process 3\")&#125; 1234process 1process 2CB 1234567use std::process::exit;fn main() &#123; println!(\"A\"); exit(0); println!(\"B\");&#125; A 189. Filter and transform list Produce a new list y containing the result of function T applied to all elements e of list x that match the predicate P. 过滤和转换列表 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\")func P(e int) bool &#123; // Predicate \"is even\" return e%2 == 0&#125;type Result = intfunc T(e int) Result &#123; // Transformation \"square\" return e * e&#125;func main() &#123; x := []int&#123;4, 5, 6, 7, 8, 9, 10&#125; var y []Result for _, e := range x &#123; if P(e) &#123; y = append(y, T(e)) &#125; &#125; fmt.Println(y)&#125; [16 36 64 100] 1234let y = x.iter() .filter(P) .map(T) .collect::&lt;Vec&lt;_&gt;&gt;(); 190. Call an external C function Declare an external C function with the prototypevoid foo(double *a, int n);and call it, passing an array (or a list) of size 10 to a and 10 to n.Use only standard features of your language. 调用外部C函数 12345// void foo(double *a, int n);// double a[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;import \"C\"C.foo(C.a, 10) 123456789101112extern \"C\" &#123; /// # Safety /// /// `a` must point to an array of at least size 10 fn foo(a: *mut libc::c_double, n: libc::c_int);&#125;let mut a = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];let n = 10;unsafe &#123; foo(a.as_mut_ptr(), n);&#125; 191. Check if any value in a list is larger than a limit Given a one-dimensional array a, check if any value is larger than x, and execute the procedure f if that is the case 检查列表中是否有任何值大于限制 1234567891011121314151617181920package mainimport ( \"fmt\")func f() &#123; fmt.Println(\"Larger found\")&#125;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; x := 4 for _, v := range a &#123; if v &gt; x &#123; f() break &#125; &#125;&#125; Larger found 123456789101112131415161718192021fn main() &#123; let a = [5, 6, 8, -20, 9, 42]; let x = 35; if a.iter().any(|&amp;elem| elem &gt; x) &#123; f() &#125; let x = 50; if a.iter().any(|&amp;elem| elem &gt; x) &#123; g() &#125;&#125;fn f() &#123; println!(\"F\")&#125;fn g() &#123; println!(\"G\")&#125; F 192. Declare a real variable with at least 20 digits Declare a real variable a with at least 20 digits; if the type does not exist, issue an error at compile time. 声明一个至少有20位数字的实变量 123456789101112131415package mainimport ( \"fmt\" \"math/big\")func main() &#123; a, _, err := big.ParseFloat(\"123456789.123456789123465789\", 10, 200, big.ToZero) if err != nil &#123; panic(err) &#125; fmt.Println(a)&#125; 1.234567891234567891234657889999999999999999999999999999999999e+08 123use rust_decimal::Decimal;use std::str::FromStr;let a = Decimal::from_str(\"1234567890.123456789012345\").unwrap(); 197. Get a list of lines from a file Retrieve the contents of file at path into a list of strings lines, in which each element is a line of the file. 从文件中获取行列表.将文件路径中的内容检索到字符串行列表中，其中每个元素都是文件的一行。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"strings\")func readLines(path string) ([]string, error) &#123; b, err := ioutil.ReadFile(path) if err != nil &#123; return nil, err &#125; lines := strings.Split(string(b), \"\\n\") return lines, nil&#125;func main() &#123; lines, err := readLines(\"/tmp/file1\") if err != nil &#123; log.Fatalln(err) &#125; for i, line := range lines &#123; fmt.Printf(\"line %d: %s\\n\", i, line) &#125;&#125;func init() &#123; data := []byte(`foobarbaz`) err := ioutil.WriteFile(\"/tmp/file1\", data, 0644) if err != nil &#123; log.Fatalln(err) &#125;&#125; 123line 0: fooline 1: barline 2: baz 12345678910111213use std::fs::File;use std::io::prelude::*;use std::io::BufReader;fn main() &#123; let path = \"/etc/hosts\"; let lines = BufReader::new(File::open(path).unwrap()) .lines() .collect::&lt;Vec&lt;_&gt;&gt;(); println!(\"&#123;:?&#125;\", lines);&#125; [Ok(&quot;127.0.0.1\\tlocalhost&quot;), Ok(&quot;::1\\tlocalhost ip6-localhost ip6-loopback&quot;), Ok(&quot;fe00::0\\tip6-localnet&quot;), Ok(&quot;ff00::0\\tip6-mcastprefix&quot;), Ok(&quot;ff02::1\\tip6-allnodes&quot;), Ok(&quot;ff02::2\\tip6-allrouters&quot;)] 198. Abort program execution with error condition Abort program execution with error condition x (where x is an integer value) 出现错误情况时中止程序执行 12345678910package mainimport ( \"os\")func main() &#123; x := 1 os.Exit(x)&#125; Program exited: status 1. 12use std::process;process::exit(x); 200. Return hypotenuse Returns the hypotenuse h of the triangle where the sides adjacent to the square angle have lengths x and y. 返回三角形的斜边h，其中与直角相邻的边的长度为x和y。 1234567891011121314package mainimport ( \"fmt\" \"math\")func main() &#123; x := 1.0 y := 1.0 h := math.Hypot(x, y) fmt.Println(h)&#125; 1.4142135623730951 12345678910fn main() &#123; let (x, y) = (1.0, 1.0); let h = hypot(x, y); println!(\"&#123;&#125;\", h);&#125;fn hypot(x: f64, y: f64) -&gt; f64 &#123; let num = x.powi(2) + y.powi(2); num.powf(0.5)&#125; 1.4142135623730951","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(9)","date":"2021-09-10T13:43:58.000Z","path":"2021/09/10/Rust-vs-Go-常用语法对比-9/","text":"161. Multiply all the elements of a list Multiply all the elements of the list elements by a constant c 将list中的每个元素都乘以一个数 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; const c = 5.5 elements := []float64&#123;2, 4, 9, 30&#125; fmt.Println(elements) for i := range elements &#123; elements[i] *= c &#125; fmt.Println(elements)&#125; 12[2 4 9 30][11 22 49.5 165] 12345678fn main() &#123; let elements: Vec&lt;f32&gt; = vec![2.0, 3.5, 4.0]; let c = 2.0; let elements = elements.into_iter().map(|x| c * x).collect::&lt;Vec&lt;_&gt;&gt;(); println!(\"&#123;:?&#125;\", elements);&#125; [4.0, 7.0, 8.0] 162. Execute procedures depending on options execute bat if b is a program option and fox if f is a program option. 根据选项执行程序 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"flag\" \"fmt\" \"os\")func init() &#123; // Just for testing in the Playground, let's simulate // the user called this program with command line // flags -f and -b os.Args = []string&#123;\"program\", \"-f\", \"-b\"&#125;&#125;var b = flag.Bool(\"b\", false, \"Do bat\")var f = flag.Bool(\"f\", false, \"Do fox\")func main() &#123; flag.Parse() if *b &#123; bar() &#125; if *f &#123; fox() &#125; fmt.Println(\"The end.\")&#125;func bar() &#123; fmt.Println(\"BAR\")&#125;func fox() &#123; fmt.Println(\"FOX\")&#125; 123BARFOXThe end. 1234567891011if let Some(arg) = ::std::env::args().nth(1) &#123; if &amp;arg == \"f\" &#123; fox(); &#125; else if &amp;arg = \"b\" &#123; bat(); &#125; else &#123; eprintln!(\"invalid argument: &#123;&#125;\", arg), &#125;&#125; else &#123; eprintln!(\"missing argument\");&#125; or 123456789if let Some(arg) = ::std::env::args().nth(1) &#123; match arg.as_str() &#123; \"f\" =&gt; fox(), \"b\" =&gt; box(), _ =&gt; eprintln!(\"invalid argument: &#123;&#125;\", arg), &#125;;&#125; else &#123; eprintln!(\"missing argument\");&#125; 163. Print list elements by group of 2 Print all the list elements, two by two, assuming list length is even. 两个一组打印数组元素 12345678910111213package mainimport ( \"fmt\")func main() &#123; list := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"&#125; for i := 0; i+1 &lt; len(list); i += 2 &#123; fmt.Println(list[i], list[i+1]) &#125;&#125; 123a bc de f 123456fn main() &#123; let list = [1,2,3,4,5,6]; for pair in list.chunks(2) &#123; println!(\"(&#123;&#125;, &#123;&#125;)\", pair[0], pair[1]); &#125;&#125; 123(1, 2)(3, 4)(5, 6) 164. Open URL in default browser Open the URL s in the default browser.Set boolean b to indicate whether the operation was successful. 在默认浏览器中打开链接 12import \"github.com/skratchdot/open-golang/open\"b := open.Start(s) == nil or 123456789101112131415161718func openbrowser(url string) &#123; var err error switch runtime.GOOS &#123; case \"linux\": err = exec.Command(\"xdg-open\", url).Start() case \"windows\": err = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start() case \"darwin\": err = exec.Command(\"open\", url).Start() default: err = fmt.Errorf(\"unsupported platform\") &#125; if err != nil &#123; log.Fatal(err) &#125;&#125; 12use webbrowser;webbrowser::open(s).expect(\"failed to open URL\"); 165. Last element of list Assign to variable x the last element of list items. 列表中的最后一个元素 12345678910111213package mainimport ( \"fmt\")func main() &#123; items := []string&#123; \"what\", \"a\", \"mess\" &#125; x := items[len(items)-1] fmt.Println(x)&#125; mess 12345fn main() &#123; let items = vec![5, 6, 8, -20, 9, 42]; let x = items[items.len()-1]; println!(\"&#123;:?&#125;\", x);&#125; 42 or 12345fn main() &#123; let items = [5, 6, 8, -20, 9, 42]; let x = items.last().unwrap(); println!(\"&#123;:?&#125;\", x);&#125; 42 166. Concatenate two lists Create list ab containing all the elements of list a, followed by all elements of list b. 连接两个列表 1234567891011121314package mainimport ( \"fmt\")func main() &#123; a := []string&#123;\"The \", \"quick \"&#125; b := []string&#123;\"brown \", \"fox \"&#125; ab := append(a, b...) fmt.Printf(\"%q\", ab)&#125; [&quot;The &quot; &quot;quick &quot; &quot;brown &quot; &quot;fox &quot;] or 1234567891011121314151617package mainimport ( \"fmt\")func main() &#123; type T string a := []T&#123;\"The \", \"quick \"&#125; b := []T&#123;\"brown \", \"fox \"&#125; var ab []T ab = append(append(ab, a...), b...) fmt.Printf(\"%q\", ab)&#125; [&quot;The &quot; &quot;quick &quot; &quot;brown &quot; &quot;fox &quot;] or 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; type T string a := []T&#123;\"The \", \"quick \"&#125; b := []T&#123;\"brown \", \"fox \"&#125; ab := make([]T, len(a)+len(b)) copy(ab, a) copy(ab[len(a):], b) fmt.Printf(\"%q\", ab)&#125; [&quot;The &quot; &quot;quick &quot; &quot;brown &quot; &quot;fox &quot;] 123456fn main() &#123; let a = vec![1, 2]; let b = vec![3, 4]; let ab = [a, b].concat(); println!(\"&#123;:?&#125;\", ab);&#125; [1, 2, 3, 4] 167. Trim prefix Create string t consisting of string s with its prefix p removed (if s starts with p). 移除前缀 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"café-society\" p := \"café\" t := strings.TrimPrefix(s, p) fmt.Println(t)&#125; -society 123456789101112131415fn main() &#123; &#123; let s = \"pre_thing\"; let p = \"pre_\"; let t = s.trim_start_matches(p); println!(\"&#123;&#125;\", t); &#125; &#123; // Warning: trim_start_matches removes several leading occurrences of p, if present. let s = \"pre_pre_thing\"; let p = \"pre_\"; let t = s.trim_start_matches(p); println!(\"&#123;&#125;\", t); &#125;&#125; 12thingthing or 1234567fn main() &#123; let s = \"pre_pre_thing\"; let p = \"pre_\"; let t = if s.starts_with(p) &#123; &amp;s[p.len()..] &#125; else &#123; s &#125;; println!(\"&#123;&#125;\", t);&#125; pre_thing or 123456789101112131415fn main() &#123; &#123; let s = \"pre_thing\"; let p = \"pre_\"; let t = s.strip_prefix(p).unwrap_or_else(|| s); println!(\"&#123;&#125;\", t); &#125; &#123; // If prefix p is repeated in s, it is removed only once by strip_prefix let s = \"pre_pre_thing\"; let p = \"pre_\"; let t = s.strip_prefix(p).unwrap_or_else(|| s); println!(\"&#123;&#125;\", t); &#125;&#125; 12thingpre_thing 168. Trim suffix Create string t consisting of string s with its suffix w removed (if s ends with w). 移除后缀 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"café-society\" w := \"society\" t := strings.TrimSuffix(s, w) fmt.Println(t)&#125; café- 12345678910111213141516fn main() &#123; let s = \"thing_suf\"; let w = \"_suf\"; let t = s.trim_end_matches(w); println!(\"&#123;&#125;\", t); let s = \"thing\"; let w = \"_suf\"; let t = s.trim_end_matches(w); // s does not end with w, it is left intact println!(\"&#123;&#125;\", t); let s = \"thing_suf_suf\"; let w = \"_suf\"; let t = s.trim_end_matches(w); // removes several occurrences of w println!(\"&#123;&#125;\", t);&#125; 123thingthingthing or 12345678910111213141516fn main() &#123; let s = \"thing_suf\"; let w = \"_suf\"; let t = s.strip_suffix(w).unwrap_or(s); println!(\"&#123;&#125;\", t); let s = \"thing\"; let w = \"_suf\"; let t = s.strip_suffix(w).unwrap_or(s); // s does not end with w, it is left intact println!(\"&#123;&#125;\", t); let s = \"thing_suf_suf\"; let w = \"_suf\"; let t = s.strip_suffix(w).unwrap_or(s); // only 1 occurrence of w is removed println!(\"&#123;&#125;\", t);&#125; 123thingthingthing_suf 169. String length Assign to integer n the number of characters of string s. Make sure that multibyte characters are properly handled.n can be different from the number of bytes of s. 字符串长度 1234567891011package mainimport \"fmt\"import \"unicode/utf8\"func main() &#123; s := \"Hello, 世界\" n := utf8.RuneCountInString(s) fmt.Println(n)&#125; 9 1234567fn main() &#123; let s = \"世界\"; let n = s.chars().count(); println!(\"&#123;&#125; characters\", n);&#125; 2 characters 170. Get map size Set n to the number of elements stored in mymap.This is not always equal to the map capacity. 获取map的大小 123456789package mainimport \"fmt\"func main() &#123; mymap := map[string]int&#123;\"a\": 1, \"b\": 2, \"c\": 3&#125; n := len(mymap) fmt.Println(n)&#125; 3 12345678910use std::collections::HashMap;fn main() &#123; let mut mymap: HashMap&lt;&amp;str, i32&gt; = [(\"one\", 1), (\"two\", 2)].iter().cloned().collect(); mymap.insert(\"three\", 3); let n = mymap.len(); println!(\"mymap has &#123;:?&#125; entries\", n);&#125; mymap has 3 entries 171. Add an element at the end of a list Append element x to the list s. 在list尾部添加元素 123456789101112package mainimport \"fmt\"func main() &#123; s := []int&#123;1, 1, 2, 3, 5, 8, 13&#125; x := 21 s = append(s, x) fmt.Println(s)&#125; [1 1 2 3 5 8 13 21] 12345678fn main() &#123; let mut s = vec![1, 2, 3]; let x = 99; s.push(x); println!(\"&#123;:?&#125;\", s);&#125; [1, 2, 3, 99] 172. Insert entry in map Insert value v for key k in map m. 向map中写入元素 12345678910111213package mainimport \"fmt\"func main() &#123; m := map[string]int&#123;\"one\": 1, \"two\": 2&#125; k := \"three\" v := 3 m[k] = v fmt.Println(m)&#125; map[one:1 three:3 two:2] 1234567891011use std::collections::HashMap;fn main() &#123; let mut m: HashMap&lt;&amp;str, i32&gt; = [(\"one\", 1), (\"two\", 2)].iter().cloned().collect(); let (k, v) = (\"three\", 3); m.insert(k, v); println!(\"&#123;:?&#125;\", m);&#125; {&quot;three&quot;: 3, &quot;one&quot;: 1, &quot;two&quot;: 2} 173. Format a number with grouped thousands Number will be formatted with a comma separator between every group of thousands. 按千位格式化数字 1234567891011121314151617181920package mainimport ( \"fmt\" \"golang.org/x/text/language\" \"golang.org/x/text/message\")// The Playground doesn't work with import of external packages.// However, you may copy this source and test it on your workstation.func main() &#123; p := message.NewPrinter(language.English) s := p.Sprintf(\"%d\\n\", 1000) fmt.Println(s) // Output: // 1,000&#125; 1,000 or 12345678910111213141516171819package mainimport ( \"fmt\" \"github.com/floscodes/golang-thousands\" \"strconv\")// The Playground takes more time when importing external packages.// However, you may want to copy this source and test it on your workstation.func main() &#123; n := strconv.Itoa(23489) s := thousands.Separate(n, \"en\") fmt.Println(s) // Output: // 23,489&#125; 23,489 12use separator::Separatable;println!(\"&#123;&#125;\", 1000.separated_string()); 174. Make HTTP POST request Make a HTTP request with method POST to URL u 发起http POST请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"fmt\" \"io\" \"io/ioutil\" \"net\" \"net/http\")func main() &#123; contentType := \"text/plain\" var body io.Reader u := \"http://\" + localhost + \"/hello\" response, err := http.Post(u, contentType, body) check(err) buffer, err := ioutil.ReadAll(response.Body) check(err) fmt.Println(\"POST response:\", response.StatusCode, string(buffer)) response, err = http.Get(u) check(err) buffer, err = ioutil.ReadAll(response.Body) check(err) fmt.Println(\"GET response:\", response.StatusCode, string(buffer))&#125;const localhost = \"127.0.0.1:3000\"func init() &#123; http.HandleFunc(\"/hello\", myHandler) startServer()&#125;func myHandler(w http.ResponseWriter, r *http.Request) &#123; if r.Method != \"POST\" &#123; w.WriteHeader(http.StatusBadRequest) fmt.Fprintf(w, \"Refusing request verb %q\", r.Method) return &#125; fmt.Fprintf(w, \"Hello POST :)\")&#125;func startServer() &#123; listener, err := net.Listen(\"tcp\", localhost) check(err) go http.Serve(listener, nil)&#125;func check(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 12POST response: 200 Hello Alice (POST)GET response: 400 Refusing request verb &quot;GET&quot; or 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"io/ioutil\" \"net\" \"net/http\" \"net/url\")func main() &#123; formValues := url.Values&#123; \"who\": []string&#123;\"Alice\"&#125;, &#125; u := \"http://\" + localhost + \"/hello\" response, err := http.PostForm(u, formValues) check(err) buffer, err := ioutil.ReadAll(response.Body) check(err) fmt.Println(\"POST response:\", response.StatusCode, string(buffer)) response, err = http.Get(u) check(err) buffer, err = ioutil.ReadAll(response.Body) check(err) fmt.Println(\"GET response:\", response.StatusCode, string(buffer))&#125;const localhost = \"127.0.0.1:3000\"func init() &#123; http.HandleFunc(\"/hello\", myHandler) startServer()&#125;func myHandler(w http.ResponseWriter, r *http.Request) &#123; if r.Method != \"POST\" &#123; w.WriteHeader(http.StatusBadRequest) fmt.Fprintf(w, \"Refusing request verb %q\", r.Method) return &#125; fmt.Fprintf(w, \"Hello %s (POST)\", r.FormValue(\"who\"))&#125;func startServer() &#123; listener, err := net.Listen(\"tcp\", localhost) check(err) go http.Serve(listener, nil)&#125;func check(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; 12345678[dependencies]error-chain = \"0.12.4\"reqwest = &#123; version = \"0.11.2\", features = [\"blocking\"] &#125;use error_chain::error_chain;use std::io::Read;let client = reqwest::blocking::Client::new();let mut response = client.post(u).body(\"abc\").send()?; 175. Bytes to hex string From array a of n bytes, build the equivalent hex string s of 2n digits.Each byte (256 possible values) is encoded as two hexadecimal characters (16 possible values per digit). 字节转十六进制字符串 1234567891011121314package mainimport ( \"encoding/hex\" \"fmt\")func main() &#123; a := []byte(\"Hello\") s := hex.EncodeToString(a) fmt.Println(s)&#125; 48656c6c6f 1234567891011121314use core::fmt::Write;fn main() -&gt; core::fmt::Result &#123; let a = vec![22, 4, 127, 193]; let n = a.len(); let mut s = String::with_capacity(2 * n); for byte in a &#123; write!(s, \"&#123;:02X&#125;\", byte)?; &#125; dbg!(s); Ok(())&#125; [src/main.rs:12] s = &quot;16047FC1&quot; 176. Hex string to byte array From hex string s of 2n digits, build the equivalent array a of n bytes.Each pair of hexadecimal characters (16 possible values per digit) is decoded into one byte (256 possible values). 十六进制字符串转字节数组 12345678910111213141516171819package mainimport ( \"encoding/hex\" \"fmt\" \"log\")func main() &#123; s := \"48656c6c6f\" a, err := hex.DecodeString(s) if err != nil &#123; log.Fatal(err) &#125; fmt.Println(a) fmt.Println(string(a))&#125; 12[72 101 108 108 111]Hello 12use hex::FromHexlet a: Vec&lt;u8&gt; = Vec::from_hex(s).expect(\"Invalid Hex String\"); 178. Check if point is inside rectangle Set boolean b to true if if the point with coordinates (x,y) is inside the rectangle with coordinates (x1,y1,x2,y2) , or to false otherwise. Describe if the edges are considered to be inside the rectangle. 检查点是否在矩形内 123456789101112131415161718192021package mainimport ( \"fmt\" \"image\")func main() &#123; x1, y1, x2, y2 := 1, 1, 50, 100 r := image.Rect(x1, y1, x2, y2) x, y := 10, 10 p := image.Pt(x, y) b := p.In(r) fmt.Println(b) x, y = 100, 100 p = image.Pt(x, y) b = p.In(r) fmt.Println(b)&#125; 12truefalse 123456789101112struct Rect &#123; x1: i32, x2: i32, y1: i32, y2: i32,&#125;impl Rect &#123; fn contains(&amp;self, x: i32, y: i32) -&gt; bool &#123; return self.x1 &lt; x &amp;&amp; x &lt; self.x2 &amp;&amp; self.y1 &lt; y &amp;&amp; y &lt; self.y2; &#125;&#125; 179. Get center of a rectangle Return the center c of the rectangle with coördinates(x1,y1,x2,y2) 获取矩形的中心 12import \"image\"c := image.Pt((x1+x2)/2, (y1+y2)/2) 1234567891011121314151617181920212223struct Rectangle &#123; x1: f64, y1: f64, x2: f64, y2: f64,&#125;impl Rectangle &#123; pub fn center(&amp;self) -&gt; (f64, f64) &#123; ((self.x1 + self.x2) / 2.0, (self.y1 + self.y2) / 2.0) &#125;&#125;fn main() &#123; let r = Rectangle &#123; x1: 5., y1: 5., x2: 10., y2: 10., &#125;; println!(\"&#123;:?&#125;\", r.center());&#125; (7.5, 7.5) 180. List files in directory Create list x containing the contents of directory d.x may contain files and subfolders.No recursive subfolder listing. 列出目录中的文件 1234567891011121314151617181920package mainimport ( \"fmt\" \"io/ioutil\" \"log\")func main() &#123; d := \"/\" x, err := ioutil.ReadDir(d) if err != nil &#123; log.Fatal(err) &#125; for _, f := range x &#123; fmt.Println(f.Name()) &#125;&#125; 1234567891011121314.dockerenvbindevetchomeliblib64procrootsystmptmpfsusrvar 123456789101112use std::fs;fn main() &#123; let d = \"/etc\"; let x = fs::read_dir(d).unwrap(); for entry in x &#123; let entry = entry.unwrap(); println!(\"&#123;:?&#125;\", entry.path()); &#125;&#125; or 123456789101112fn main() &#123; let d = \"/etc\"; let x = std::fs::read_dir(d) .unwrap() .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;() .unwrap(); for entry in x &#123; println!(\"&#123;:?&#125;\", entry.path()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\"/etc/issue.net\"\"/etc/bindresvport.blacklist\"\"/etc/rc1.d\"\"/etc/hostname\"\"/etc/xattr.conf\"\"/etc/resolv.conf\"\"/etc/pam.conf\"\"/etc/mke2fs.conf\"\"/etc/e2scrub.conf\"\"/etc/update-motd.d\"\"/etc/terminfo\"\"/etc/alternatives\"\"/etc/ld.so.cache\"\"/etc/networks\"\"/etc/profile\"\"/etc/debconf.conf\"\"/etc/security\"\"/etc/.pwd.lock\"\"/etc/gai.conf\"\"/etc/dpkg\"\"/etc/rc3.d\"\"/etc/fstab\"\"/etc/gshadow\"\"/etc/sysctl.conf\"\"/etc/rc2.d\"\"/etc/selinux\"\"/etc/ld.so.conf.d\"\"/etc/os-release\"\"/etc/libaudit.conf\"\"/etc/login.defs\"\"/etc/skel\"\"/etc/shells\"\"/etc/rc4.d\"\"/etc/cron.d\"\"/etc/default\"\"/etc/lsb-release\"\"/etc/apt\"\"/etc/debian_version\"\"/etc/machine-id\"\"/etc/deluser.conf\"\"/etc/group\"\"/etc/legal\"\"/etc/rc6.d\"\"/etc/init.d\"\"/etc/sysctl.d\"\"/etc/pam.d\"\"/etc/passwd\"\"/etc/rc5.d\"\"/etc/bash.bashrc\"\"/etc/hosts\"\"/etc/rc0.d\"\"/etc/environment\"\"/etc/cron.daily\"\"/etc/shadow\"\"/etc/ld.so.conf\"\"/etc/subgid\"\"/etc/opt\"\"/etc/logrotate.d\"\"/etc/subuid\"\"/etc/profile.d\"\"/etc/adduser.conf\"\"/etc/issue\"\"/etc/rmt\"\"/etc/host.conf\"\"/etc/rcS.d\"\"/etc/nsswitch.conf\"\"/etc/systemd\"\"/etc/kernel\"\"/etc/mtab\"\"/etc/shadow-\"\"/etc/passwd-\"\"/etc/subuid-\"\"/etc/gshadow-\"\"/etc/subgid-\"\"/etc/group-\"\"/etc/ethertypes\"\"/etc/logcheck\"\"/etc/gss\"\"/etc/bash_completion.d\"\"/etc/X11\"\"/etc/perl\"\"/etc/ca-certificates\"\"/etc/protocols\"\"/etc/ca-certificates.conf\"\"/etc/python2.7\"\"/etc/localtime\"\"/etc/xdg\"\"/etc/timezone\"\"/etc/mailcap.order\"\"/etc/emacs\"\"/etc/ssh\"\"/etc/magic.mime\"\"/etc/services\"\"/etc/ssl\"\"/etc/ldap\"\"/etc/rpc\"\"/etc/mime.types\"\"/etc/magic\"\"/etc/mailcap\"\"/etc/inputrc\"","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(8)","date":"2021-09-09T11:43:58.000Z","path":"2021/09/09/Rust-vs-Go-常用语法对比-8/","text":"141. Iterate in sequence over two lists Iterate in sequence over the elements of the list items1 then items2. For each iteration print the element. 依次迭代两个列表依次迭代列表项1和项2的元素。每次迭代打印元素。 1234567891011121314151617package mainimport ( \"fmt\")func main() &#123; items1 := []string&#123;\"a\", \"b\", \"c\"&#125; items2 := []string&#123;\"A\", \"B\", \"C\"&#125; for _, v := range items1 &#123; fmt.Println(v) &#125; for _, v := range items2 &#123; fmt.Println(v) &#125;&#125; 123456abcABC 1234567fn main() &#123; let item1 = vec![\"1\", \"2\", \"3\"]; let item2 = vec![\"a\", \"b\", \"c\"]; for i in item1.iter().chain(item2.iter()) &#123; print!(\"&#123;&#125; \", i); &#125;&#125; 1 2 3 a b c 142. Hexadecimal digits of an integer Assign to string s the hexadecimal representation (base 16) of integer x.E.g. 999 -&gt; “3e7” 将整数x的十六进制表示(16进制)赋给字符串s。 1234567891011package mainimport \"fmt\"import \"strconv\"func main() &#123; x := int64(999) s := strconv.FormatInt(x, 16) fmt.Println(s)&#125; 3e7 or 12345678910111213package mainimport ( \"fmt\" \"math/big\")func main() &#123; x := big.NewInt(999) s := fmt.Sprintf(\"%x\", x) fmt.Println(s)&#125; 3e7 123456789fn main() &#123; let x = 999; let s = format!(\"&#123;:X&#125;\", x); println!(\"&#123;&#125;\", s); let s = format!(\"&#123;:x&#125;\", x); println!(\"&#123;&#125;\", s);&#125; {:X} produces uppercase hex.{:x} produces lowercase hex. 123E73e7 143. Iterate alternatively over two lists Iterate alternatively over the elements of the list items1 and items2. For each iteration, print the element.Explain what happens if items1 and items2 have different size. 交替迭代两个列表 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; items1 := []string&#123;\"a\", \"b\"&#125; items2 := []string&#123;\"A\", \"B\", \"C\"&#125; for i := 0; i &lt; len(items1) || i &lt; len(items2); i++ &#123; if i &lt; len(items1) &#123; fmt.Println(items1[i]) &#125; if i &lt; len(items2) &#123; fmt.Println(items2[i]) &#125; &#125;&#125; 12345aAbBC 123456789101112extern crate itertools;use itertools::izip;fn main() &#123; let items1 = [5, 15, 25]; let items2 = [10, 20, 30]; for pair in izip!(&amp;items1, &amp;items2) &#123; println!(\"&#123;&#125;\", pair.0); println!(\"&#123;&#125;\", pair.1); &#125;&#125; 12345651015202530 144. Check if file exists Set boolean b to true if file at path fp exists on filesystem; false otherwise.Beware that you should never do this and then in the next instruction assume the result is still valid, this is a race condition on any multitasking OS. 检查文件是否存在 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"io/ioutil\" \"os\")func main() &#123; fp := \"foo.txt\" _, err := os.Stat(fp) b := !os.IsNotExist(err) fmt.Println(fp, \"exists:\", b) fp = \"bar.txt\" _, err = os.Stat(fp) b = !os.IsNotExist(err) fmt.Println(fp, \"exists:\", b)&#125;func init() &#123; ioutil.WriteFile(\"foo.txt\", []byte(`abc`), 0644)&#125; There’s no specific existence check func in standard library, so we have to inspect an error return value. 12foo.txt exists: truebar.txt exists: false 123456789fn main() &#123; let fp = \"/etc/hosts\"; let b = std::path::Path::new(fp).exists(); println!(\"&#123;&#125;: &#123;&#125;\", fp, b); let fp = \"/etc/kittens\"; let b = std::path::Path::new(fp).exists(); println!(\"&#123;&#125;: &#123;&#125;\", fp, b);&#125; 12/etc/hosts: true/etc/kittens: false 145. Print log line with datetime Print message msg, prepended by current date and time.Explain what behavior is idiomatic: to stdout or stderr, and what the date format is. 打印带时间的日志 123456789101112package mainimport \"log\"func main() &#123; msg := \"Hello, playground\" log.Println(msg) // The date is fixed in the past in the Playground, never mind.&#125;// See http://www.programming-idioms.org/idiom/145/print-log-line-with-date/1815/go 2009/11/10 23:00:00 Hello, playground 1234fn main() &#123; let msg = \"Hello\"; eprintln!(\"[&#123;&#125;] &#123;&#125;\", humantime::format_rfc3339_seconds(std::time::SystemTime::now()), msg);&#125; [2021-07-17T07:14:03Z] Hello 146. Convert string to floating point number Extract floating point value f from its string representation s 字符串转换为浮点型 1234567891011121314151617package mainimport ( \"fmt\" \"strconv\")func main() &#123; s := \"3.1415926535\" f, err := strconv.ParseFloat(s, 64) fmt.Printf(\"%T, %v, err=%v\\n\", f, f, err)&#125;//// http://www.programming-idioms.org/idiom/146/convert-string-to-floating-point-number/1819/go// float64, 3.1415926535, err=&lt;nil&gt; 123456fn main() &#123; let s = \"3.14159265359\"; let f = s.parse::&lt;f32&gt;().unwrap(); println!(\"&#123;&#125;² = &#123;&#125;\" , f, f * f);&#125; 3.1415927² = 9.869605 or 123456fn main() &#123; let s = \"3.14159265359\"; let f: f32 = s.parse().unwrap(); println!(\"&#123;&#125;² = &#123;&#125;\", f, f * f);&#125; 3.1415927² = 9.869605 147. Remove all non-ASCII characters Create string t from string s, keeping only ASCII characters 移除所有的非ASCII字符 123456789101112131415package mainimport ( \"fmt\" \"regexp\")func main() &#123; s := \"dæmi : пример : příklad : thí dụ\" re := regexp.MustCompile(\"[[:^ascii:]]\") t := re.ReplaceAllLiteralString(s, \"\") fmt.Println(t)&#125; dmi : : pklad : th d or 123456789101112131415161718package mainimport ( \"fmt\" \"strings\" \"unicode\")func main() &#123; s := \"5#∑∂ƒ∞645eyfu\" t := strings.Map(func(r rune) rune &#123; if r &gt; unicode.MaxASCII &#123; return -1 &#125; return r &#125;, s) fmt.Println(t)&#125; 5#645eyfu 123fn main() &#123; println!(\"&#123;&#125;\", \"do👍ot\".replace(|c: char| !c.is_ascii(), \"\"))&#125; doot or 123fn main() &#123; println!(\"&#123;&#125;\", \"do👍ot\".replace(|c: char| !c.is_ascii(), \"\"))&#125; doot 148. Read list of integers from stdin Read a list of integer numbers from the standard input, until EOF. 从stdin(标准输入)中读取整数列表 12345678910111213141516171819202122232425262728293031package mainimport ( \"bufio\" \"fmt\" \"log\" \"strconv\" \"strings\")func main() &#123; var ints []int s := bufio.NewScanner(osStdin) s.Split(bufio.ScanWords) for s.Scan() &#123; i, err := strconv.Atoi(s.Text()) if err == nil &#123; ints = append(ints, i) &#125; &#125; if err := s.Err(); err != nil &#123; log.Fatal(err) &#125; fmt.Println(ints)&#125;// osStdin simulates os.Stdinvar osStdin = strings.NewReader(`112233 `) [11 22 33] 1234567891011121314151617181920212223use std::&#123; io::&#123;self, Read&#125;, str::FromStr,&#125;;// dummy io::stdinfn io_stdin() -&gt; impl Read &#123; \"123456789\" .as_bytes()&#125;fn main() -&gt; io::Result&lt;()&gt; &#123; let mut string = String::new(); io_stdin().read_to_string(&amp;mut string)?; let result = string .lines() .map(i32::from_str) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;(); println!(\"&#123;:#?&#125;\", result); Ok(())&#125; 1234567Ok( [ 123, 456, 789, ],) 150. Remove trailing slash Remove last character from string p, if this character is a slash /. 去除末尾的 / 1234567891011121314package mainimport ( \"fmt\" \"strings\")func main() &#123; p := \"/usr/bin/\" p = strings.TrimSuffix(p, \"/\") fmt.Println(p)&#125; /usr/bin 1234567fn main() &#123; let mut p = String::from(\"Dddd/\"); if p.ends_with('/') &#123; p.pop(); &#125; println!(\"&#123;&#125;\", p);&#125; Dddd 151. Remove string trailing path separator Remove last character from string p, if this character is the file path separator of current platform.Note that this also transforms unix root path “/“ into the empty string! 删除字符串尾部路径分隔符 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"io/ioutil\" \"os\" \"strings\")func main() &#123; p := somePath() fmt.Println(p) sep := fmt.Sprintf(\"%c\", os.PathSeparator) p = strings.TrimSuffix(p, sep) fmt.Println(p)&#125;func somePath() string &#123; dir, err := ioutil.TempDir(\"\", \"\") if err != nil &#123; panic(err) &#125; p := fmt.Sprintf(\"%s%c%s%c\", dir, os.PathSeparator, \"foobar\", os.PathSeparator) return p&#125; 12/tmp/067319278/foobar//tmp/067319278/foobar or 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"io/ioutil\" \"os\" \"path/filepath\" \"strings\")func main() &#123; p := somePath() fmt.Println(p) sep := fmt.Sprintf(\"%c\", filepath.Separator) p = strings.TrimSuffix(p, sep) fmt.Println(p)&#125;func somePath() string &#123; dir, err := ioutil.TempDir(\"\", \"\") if err != nil &#123; panic(err) &#125; p := fmt.Sprintf(\"%s%c%s%c\", dir, os.PathSeparator, \"foobar\", os.PathSeparator) return p&#125; 12/tmp/065654753/foobar//tmp/065654753/foobar 12345678910111213141516171819202122232425fn main() &#123; &#123; let p = \"/tmp/\"; let p = if ::std::path::is_separator(p.chars().last().unwrap()) &#123; &amp;p[0..p.len() - 1] &#125; else &#123; p &#125;; println!(\"&#123;&#125;\", p); &#125; &#123; let p = \"/tmp\"; let p = if ::std::path::is_separator(p.chars().last().unwrap()) &#123; &amp;p[0..p.len() - 1] &#125; else &#123; p &#125;; println!(\"&#123;&#125;\", p); &#125;&#125; 12/tmp/tmp or 1234567891011121314151617fn main() &#123; &#123; let mut p = \"/tmp/\"; p = p.strip_suffix(std::path::is_separator).unwrap_or(p); println!(\"&#123;&#125;\", p); &#125; &#123; let mut p = \"/tmp\"; p = p.strip_suffix(std::path::is_separator).unwrap_or(p); println!(\"&#123;&#125;\", p); &#125;&#125; 12/tmp/tmp 152. Turn a character into a string Create string s containing only the character c. 将字符转换成字符串 1234567891011121314package mainimport ( \"fmt\" \"os\")func main() &#123; var c rune = os.PathSeparator fmt.Printf(\"%c \\n\", c) s := fmt.Sprintf(\"%c\", c) fmt.Printf(\"%#v \\n\", s)&#125; 12/ \"/\" 1234567fn main() &#123; let c = 'a'; let s = c.to_string(); println!(\"&#123;&#125;\", s);&#125; a 153. Concatenate string with integer Create string t as the concatenation of string s and integer i. 连接字符串和整数 1234567891011121314package mainimport ( \"fmt\")func main() &#123; s := \"Hello\" i := 123 t := fmt.Sprintf(\"%s%d\", s, i) fmt.Println(t)&#125; Hello123 1234567fn main() &#123; let s = \"Foo\"; let i = 1; let t = format!(\"&#123;&#125;&#123;&#125;\", s, i); println!(\"&#123;&#125;\" , t);&#125; Foo1 154. Halfway between two hex color codes Find color c, the average between colors c1, c2.c, c1, c2 are strings of hex color codes: 7 chars, beginning with a number sign # .Assume linear computations, ignore gamma corrections. 求两个十六进制颜色代码的中间值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"strconv\" \"strings\")// For concision, halfway assume valid inputs.// Caller must have explicitly checked that c1, c2 are well-formed color codes.func halfway(c1, c2 string) string &#123; r1, _ := strconv.ParseInt(c1[1:3], 16, 0) r2, _ := strconv.ParseInt(c2[1:3], 16, 0) r := (r1 + r2) / 2 g1, _ := strconv.ParseInt(c1[3:5], 16, 0) g2, _ := strconv.ParseInt(c2[3:5], 16, 0) g := (g1 + g2) / 2 b1, _ := strconv.ParseInt(c1[5:7], 16, 0) b2, _ := strconv.ParseInt(c2[5:7], 16, 0) b := (b1 + b2) / 2 c := fmt.Sprintf(\"#%02X%02X%02X\", r, g, b) return c&#125;func main() &#123; c1 := \"#15293E\" c2 := \"#012549\" if err := checkFormat(c1); err != nil &#123; panic(fmt.Errorf(\"Wrong input %q: %v\", c1, err)) &#125; if err := checkFormat(c2); err != nil &#123; panic(fmt.Errorf(\"Wrong input %q: %v\", c2, err)) &#125; c := halfway(c1, c2) fmt.Println(\"The average of\", c1, \"and\", c2, \"is\", c)&#125;func checkFormat(color string) error &#123; if len(color) != 7 &#123; return fmt.Errorf(\"Hex colors have exactly 7 chars\") &#125; if color[0] != '#' &#123; return fmt.Errorf(\"Hex colors start with #\") &#125; isNotDigit := func(c rune) bool &#123; return (c &lt; '0' || c &gt; '9') &amp;&amp; (c &lt; 'a' || c &gt; 'f') &#125; if strings.IndexFunc(strings.ToLower(color[1:]), isNotDigit) != -1 &#123; return fmt.Errorf(\"Forbidden char\") &#125; return nil&#125; The average of #15293E and #012549 is #0B2743 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"strconv\" \"strings\")// For concision, halfway assume valid inputs.// Caller must have explicitly checked that c1, c2 are well-formed color codes.func halfway(c1, c2 string) string &#123; var buf [7]byte buf[0] = '#' for i := 0; i &lt; 3; i++ &#123; sub1 := c1[1+2*i : 3+2*i] sub2 := c2[1+2*i : 3+2*i] v1, _ := strconv.ParseInt(sub1, 16, 0) v2, _ := strconv.ParseInt(sub2, 16, 0) v := (v1 + v2) / 2 sub := fmt.Sprintf(\"%02X\", v) copy(buf[1+2*i:3+2*i], sub) &#125; c := string(buf[:]) return c&#125;func main() &#123; c1 := \"#15293E\" c2 := \"#012549\" if err := checkFormat(c1); err != nil &#123; panic(fmt.Errorf(\"Wrong input %q: %v\", c1, err)) &#125; if err := checkFormat(c2); err != nil &#123; panic(fmt.Errorf(\"Wrong input %q: %v\", c2, err)) &#125; c := halfway(c1, c2) fmt.Println(\"The average of\", c1, \"and\", c2, \"is\", c)&#125;func checkFormat(color string) error &#123; if len(color) != 7 &#123; return fmt.Errorf(\"Hex colors have exactly 7 chars\") &#125; if color[0] != '#' &#123; return fmt.Errorf(\"Hex colors start with #\") &#125; isNotDigit := func(c rune) bool &#123; return (c &lt; '0' || c &gt; '9') &amp;&amp; (c &lt; 'a' || c &gt; 'f') &#125; if strings.IndexFunc(strings.ToLower(color[1:]), isNotDigit) != -1 &#123; return fmt.Errorf(\"Forbidden char\") &#125; return nil&#125; The average of #15293E and #012549 is #0B2743 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354use std::str::FromStr;use std::fmt;#[derive(Debug)]struct Colour &#123; r: u8, g: u8, b: u8&#125;#[derive(Debug)]enum ColourError &#123; MissingHash, InvalidRed, InvalidGreen, InvalidBlue&#125;impl fmt::Display for Colour &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, \"#&#123;:02x&#125;&#123;:02x&#125;&#123;:02x&#125;\", self.r, self.g, self.b) &#125;&#125;impl FromStr for Colour &#123; type Err = ColourError; fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; &#123; if !s.starts_with('#') &#123; Err(ColourError::MissingHash) &#125; else &#123; Ok(Colour &#123; r: u8::from_str_radix(&amp;s[1..3], 16).map_err(|_| ColourError::InvalidRed)?, g: u8::from_str_radix(&amp;s[3..5], 16).map_err(|_| ColourError::InvalidGreen)?, b: u8::from_str_radix(&amp;s[5..7], 16).map_err(|_| ColourError::InvalidBlue)? &#125;) &#125; &#125;&#125;fn mid_colour(c1: &amp;str, c2: &amp;str) -&gt; Result&lt;String, ColourError&gt; &#123; let c1 = c1.parse::&lt;Colour&gt;()?; let c2 = c2.parse::&lt;Colour&gt;()?; let c = Colour &#123; r: (((c1.r as u16) + (c2.r as u16))/2) as u8, g: (((c1.g as u16) + (c2.g as u16))/2) as u8, b: (((c1.b as u16) + (c2.b as u16))/2) as u8 &#125;; Ok(format!(\"&#123;&#125;\", c))&#125;fn main() &#123; println!(\"&#123;&#125;\", mid_colour(\"#15293E\", \"#012549\").unwrap())&#125; #0b2743 155. Delete file Delete from filesystem the file having path filepath. 删除文件 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"io/ioutil\" \"os\")func main() &#123; for _, filepath := range []string&#123; \"/tmp/foo.txt\", \"/tmp/bar.txt\", \"/tmp/foo.txt\", &#125; &#123; err := os.Remove(filepath) if err == nil &#123; fmt.Println(\"Removed\", filepath) &#125; else &#123; fmt.Fprintln(os.Stderr, err) &#125; &#125;&#125;func init() &#123; err := ioutil.WriteFile(\"/tmp/foo.txt\", []byte(`abc`), 0644) if err != nil &#123; panic(err) &#125;&#125; 123Removed /tmp/foo.txtremove /tmp/bar.txt: no such file or directoryremove /tmp/foo.txt: no such file or directory 123456789101112131415161718use std::fs;fn main() &#123; let filepath = \"/tmp/abc\"; println!(\"Creating &#123;&#125;\", filepath); let _file = fs::File::create(filepath); let b = std::path::Path::new(filepath).exists(); println!(\"&#123;&#125; exists: &#123;&#125;\", filepath, b); println!(\"Deleting &#123;&#125;\", filepath); let r = fs::remove_file(filepath); println!(\"&#123;:?&#125;\", r); let b = std::path::Path::new(filepath).exists(); println!(\"&#123;&#125; exists: &#123;&#125;\", filepath, b);&#125; 12345Creating /tmp/abc/tmp/abc exists: trueDeleting /tmp/abcOk(())/tmp/abc exists: false 156. Format integer with zero-padding Assign to string s the value of integer i in 3 decimal digits. Pad with zeros if i &lt; 100. Keep all digits if i ≥ 1000. 用零填充格式化整数 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; for _, i := range []int&#123; 0, 8, 64, 256, 2048, &#125; &#123; s := fmt.Sprintf(\"%03d\", i) fmt.Println(s) &#125;&#125; 123450000080642562048 123456789101112fn main() &#123; let i = 1; let s = format!(\"&#123;:03&#125;\", i); println!(\"&#123;&#125;\", s); let i = 1000; let s = format!(\"&#123;:03&#125;\", i); println!(\"&#123;&#125;\", s);&#125; 120011000 157. Declare constant string Initialize a constant planet with string value “Earth”. 声明常量字符串 1234567891011package mainimport ( \"fmt\")const planet = \"Earth\"func main() &#123; fmt.Println(\"We live on planet\", planet)&#125; We live on planet Earth 12345fn main() &#123; const PLANET: &amp;str = \"Earth\"; println!(\"&#123;&#125;\", PLANET);&#125; Earth 158. Random sublist Create a new list y from randomly picking exactly k elements from list x. It is assumed that x has at least k elements.Each element must have same probability to be picked.Each element from x must be picked at most once.Explain if the original ordering is preserved or not. 随机子列表 123456789101112131415161718192021package mainimport ( \"fmt\" \"math/rand\")func main() &#123; type T string x := []T&#123;\"Alice\", \"Bob\", \"Carol\", \"Dan\", \"Eve\", \"Frank\", \"Grace\", \"Heidi\"&#125; k := 4 y := make([]T, k) perm := rand.Perm(len(x)) for i, v := range perm[:k] &#123; y[i] = x[v] &#125; fmt.Printf(\"%q\", y)&#125; [&quot;Frank&quot; &quot;Eve&quot; &quot;Carol&quot; &quot;Grace&quot;] 123use rand::prelude::*;let mut rng = &amp;mut rand::thread_rng();let y = x.choose_multiple(&amp;mut rng, k).cloned().collect::&lt;Vec&lt;_&gt;&gt;(); 159. Trie Define a Trie data structure, where entries have an associated value.(Not all nodes are entries) 前缀树/字典树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( \"fmt\" \"unicode/utf8\")type Trie struct &#123; c rune children map[rune]*Trie isLeaf bool value V&#125;type V intfunc main() &#123; t := NewTrie(0) for s, v := range map[string]V&#123; \"to\": 7, \"tea\": 3, \"ted\": 4, \"ten\": 12, \"A\": 15, \"i\": 11, \"in\": 5, \"inn\": 9, &#125; &#123; t.insert(s, v) &#125; fmt.Println(t.startsWith(\"te\", \"\"))&#125;func NewTrie(c rune) *Trie &#123; t := new(Trie) t.c = c t.children = map[rune]*Trie&#123;&#125; return t&#125;func (t *Trie) insert(s string, value V) &#123; if s == \"\" &#123; t.isLeaf = true t.value = value return &#125; c, tail := cut(s) child, exists := t.children[c] if !exists &#123; child = NewTrie(c) t.children[c] = child &#125; child.insert(tail, value)&#125;func (t *Trie) startsWith(p string, accu string) []string &#123; if t == nil &#123; return nil &#125; if p == \"\" &#123; var result []string if t.isLeaf &#123; result = append(result, accu) &#125; for c, child := range t.children &#123; rec := child.startsWith(\"\", accu+string(c)) result = append(result, rec...) &#125; return result &#125; c, tail := cut(p) return t.children[c].startsWith(tail, accu+string(c))&#125;func cut(s string) (head rune, tail string) &#123; r, size := utf8.DecodeRuneInString(s) return r, s[size:]&#125; [ten tea ted] 1234struct Trie &#123; val: String, nodes: Vec&lt;Trie&gt;&#125; 160. Detect if 32-bit or 64-bit architecture Execute f32() if platform is 32-bit, or f64() if platform is 64-bit.This can be either a compile-time condition (depending on target) or a runtime detection. 检测是32位还是64位架构 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"strconv\")func main() &#123; if strconv.IntSize == 32 &#123; f32() &#125; if strconv.IntSize == 64 &#123; f64() &#125;&#125;func f32() &#123; fmt.Println(\"I am 32-bit\")&#125;func f64() &#123; fmt.Println(\"I am 64-bit\")&#125; I am 64-bit 123456789101112131415fn main() &#123; match std::mem::size_of::&lt;&amp;char&gt;() &#123; 4 =&gt; f32(), 8 =&gt; f64(), _ =&gt; &#123;&#125; &#125;&#125;fn f32() &#123; println!(\"I am 32-bit\");&#125;fn f64() &#123; println!(\"I am 64-bit\");&#125; I am 64-bit","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(7)","date":"2021-09-08T11:43:55.000Z","path":"2021/09/08/Rust-vs-Go-常用语法对比-7/","text":"121. UDP listen and read Listen UDP traffic on port p and read 1024 bytes into buffer b. 听端口p上的UDP流量，并将1024字节读入缓冲区b。 123456789101112131415161718192021import ( \"fmt\" \"net\" \"os\")ServerAddr,err := net.ResolveUDPAddr(\"udp\",p)if err != nil &#123; return err&#125;ServerConn, err := net.ListenUDP(\"udp\", ServerAddr)if err != nil &#123; return err&#125;defer ServerConn.Close()n,addr,err := ServerConn.ReadFromUDP(b[:1024])if err != nil &#123; return err&#125;if n&lt;1024 &#123; return fmt.Errorf(\"Only %d bytes could be read.\", n)&#125; 1234use std::net::UdpSocket;let mut b = [0 as u8; 1024];let sock = UdpSocket::bind((\"localhost\", p)).unwrap();sock.recv_from(&amp;mut b).unwrap(); 122. Declare enumeration Create an enumerated type Suit with 4 possible values SPADES, HEARTS, DIAMONDS, CLUBS. 声明枚举值 123456789101112131415161718package mainimport ( \"fmt\")type Suit intconst ( Spades Suit = iota Hearts Diamonds Clubs)func main() &#123; fmt.Printf(\"Hearts has type %T and value %d\", Hearts, Hearts)&#125; Hearts has type main.Suit and value 1 12345678910enum Suit &#123; Spades, Hearts, Diamonds, Clubs,&#125;fn main() &#123; let _x = Suit::Diamonds;&#125; 123. Assert condition Verify that predicate isConsistent returns true, otherwise report assertion violation.Explain if the assertion is executed even in production environment or not. 断言条件 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"//// The code may look fine, but// obviously we have a bug.//func main() &#123; salary = 65000 employees = 120000 totalPayroll = salary * employees if !isConsistent() &#123; panic(\"State consistency violated\") &#125; fmt.Println(\"Everything fine\")&#125;var salary int32var employees int32var totalPayroll int32func isConsistent() bool &#123; return salary &gt;= 0 &amp;&amp; employees &gt;= 0 &amp;&amp; totalPayroll &gt;= 0&#125; 1234567891011fn main() &#123; // i is odd let i = 23687; let ii = i * i; let is_consistent = ii % 2 == 1; // i*i must be odd assert!(is_consistent); println!(\"Cool.\")&#125; Cool. 124. Binary search for a value in sorted array Write function binarySearch which returns the index of an element having value x in sorted array a, or -1 if no such element. 排序数组中值的二分搜索法 二分查找 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"func binarySearch(a []T, x T) int &#123; imin, imax := 0, len(a)-1 for imin &lt;= imax &#123; imid := (imin + imax) / 2 switch &#123; case a[imid] == x: return imid case a[imid] &lt; x: imin = imid + 1 default: imax = imid - 1 &#125; &#125; return -1&#125;type T intfunc main() &#123; a := []T&#123;-2, -1, 0, 1, 1, 1, 6, 8, 8, 9, 10&#125; for x := T(-5); x &lt;= 15; x++ &#123; i := binarySearch(a, x) if i == -1 &#123; fmt.Println(\"Value\", x, \"not found\") &#125; else &#123; fmt.Println(\"Value\", x, \"found at index\", i) &#125; &#125;&#125; or 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"sort\")func binarySearch(a []int, x int) int &#123; i := sort.SearchInts(a, x) if i &lt; len(a) &amp;&amp; a[i] == x &#123; return i &#125; return -1&#125;func main() &#123; a := []int&#123;-2, -1, 0, 1, 1, 1, 6, 8, 8, 9, 10&#125; for x := -5; x &lt;= 15; x++ &#123; i := binarySearch(a, x) if i == -1 &#123; fmt.Println(\"Value\", x, \"not found\") &#125; else &#123; fmt.Println(\"Value\", x, \"found at index\", i) &#125; &#125;&#125; or 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"sort\")func binarySearch(a []T, x T) int &#123; f := func(i int) bool &#123; return a[i] &gt;= x &#125; i := sort.Search(len(a), f) if i &lt; len(a) &amp;&amp; a[i] == x &#123; return i &#125; return -1&#125;type T intfunc main() &#123; a := []T&#123;-2, -1, 0, 1, 1, 1, 6, 8, 8, 9, 10&#125; for x := T(-5); x &lt;= 15; x++ &#123; i := binarySearch(a, x) if i == -1 &#123; fmt.Println(\"Value\", x, \"not found\") &#125; else &#123; fmt.Println(\"Value\", x, \"found at index\", i) &#125; &#125;&#125; 12 125. Measure function call duration measure the duration t, in nano seconds, of a call to the function foo. Print this duration. 函数调用时间 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main() &#123; t1 := time.Now() foo() t := time.Since(t1) ns := int64(t / time.Nanosecond) // Note that the clock is fixed in the Playground, so the resulting duration is always zero fmt.Printf(\"%dns\\n\", ns)&#125;func foo() &#123; fmt.Println(\"Hello\")&#125; 12Hello0ns or 123456789101112131415161718package mainimport ( \"fmt\" \"time\")func main() &#123; t1 := time.Now() foo() t := time.Since(t1) ns := t.Nanoseconds() fmt.Printf(\"%dns\\n\", ns)&#125;func foo() &#123; fmt.Println(\"Hello\")&#125; 12Hello0ns 12345use std::time::&#123;Duration, Instant&#125;;let start = Instant::now();foo();let duration = start.elapsed();println!(\"&#123;&#125;\", duration); 126. Multiple return values Write a function foo that returns a string and a boolean value. 多个返回值 1234567891011121314package mainimport ( \"fmt\")func main() &#123; s, b := foo() fmt.Println(s, b)&#125;func foo() (string, bool) &#123; return \"Too good to be\", true&#125; Too good to be true 1234567fn foo() -&gt; (String, bool) &#123; (String::from(\"bar\"), true)&#125;fn main() &#123; println!(\"&#123;:?&#125;\", foo());&#125; (&quot;bar&quot;, true) 128. Breadth-first traversing of a tree Call a function f on every node of a tree, in breadth-first prefix order 树的广度优先遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport \"fmt\"func (root *Tree) Bfs(f func(*Tree)) &#123; if root == nil &#123; return &#125; queue := []*Tree&#123;root&#125; for len(queue) &gt; 0 &#123; t := queue[0] queue = queue[1:] f(t) queue = append(queue, t.Children...) &#125;&#125;type key stringtype value stringtype Tree struct &#123; Key key Deco value Children []*Tree&#125;func (this *Tree) AddChild(x key, v value) &#123; child := &amp;Tree&#123;Key: x, Deco: v&#125; this.Children = append(this.Children, child)&#125;func NodePrint(node *Tree) &#123; fmt.Printf(\"%v (%v)\\n\", node.Key, node.Deco)&#125;func main() &#123; tree := &amp;Tree&#123;Key: \"World\", Deco: \"Our planet\"&#125; tree.AddChild(\"Europe\", \"A continent\") tree.Children[0].AddChild(\"Germany\", \"A country\") tree.Children[0].AddChild(\"Ireland\", \"A country\") tree.Children[0].AddChild(\"Mediterranean Sea\", \"A sea\") tree.AddChild(\"Asia\", \"A continent\") tree.Children[0].AddChild(\"Japan\", \"A country\") tree.Children[0].AddChild(\"Thailand\", \"A country\") tree.Bfs(NodePrint)&#125; 12345678World (Our planet)Europe (A continent)Asia (A continent)Germany (A country)Ireland (A country)Mediterranean Sea (A sea)Japan (A country)Thailand (A country) 1234567891011121314151617181920212223242526272829303132333435363738use std::collections::VecDeque;struct Tree&lt;V&gt; &#123; children: Vec&lt;Tree&lt;V&gt;&gt;, value: V&#125;impl&lt;V&gt; Tree&lt;V&gt; &#123; fn bfs(&amp;self, f: impl Fn(&amp;V)) &#123; let mut q = VecDeque::new(); q.push_back(self); while let Some(t) = q.pop_front() &#123; (f)(&amp;t.value); for child in &amp;t.children &#123; q.push_back(child); &#125; &#125; &#125;&#125;fn main() &#123; let t = Tree &#123; children: vec![ Tree &#123; children: vec![ Tree &#123; children: vec![], value: 5 &#125;, Tree &#123; children: vec![], value: 6 &#125; ], value: 2 &#125;, Tree &#123; children: vec![], value: 3 &#125;, Tree &#123; children: vec![], value: 4 &#125;, ], value: 1 &#125;; t.bfs(|v| println!(\"&#123;&#125;\", v));&#125; 123456123456 129. Breadth-first traversing in a graph Call a function f on every vertex accessible from vertex start, in breadth-first prefix order 图的广度优先遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport \"fmt\"func (start *Vertex) Bfs(f func(*Vertex)) &#123; queue := []*Vertex&#123;start&#125; seen := map[*Vertex]bool&#123;start: true&#125; for len(queue) &gt; 0 &#123; v := queue[0] queue = queue[1:] f(v) for next, isEdge := range v.Neighbours &#123; if isEdge &amp;&amp; !seen[next] &#123; queue = append(queue, next) seen[next] = true &#125; &#125; &#125;&#125;type Vertex struct &#123; Id int Label string Neighbours map[*Vertex]bool&#125;type Graph []*Vertexfunc NewVertex(id int, label string) *Vertex &#123; return &amp;Vertex&#123; Id: id, Label: label, Neighbours: make(map[*Vertex]bool), &#125;&#125;func (v *Vertex) AddNeighbour(w *Vertex) &#123; v.Neighbours[w] = true&#125;func VertexPrint(v *Vertex) &#123; fmt.Printf(\"%v (%v)\\n\", v.Id, v.Label)&#125;func main() &#123; // Some cities london := NewVertex(0, \"London\") ny := NewVertex(1, \"New York City\") berlin := NewVertex(2, \"Berlin\") paris := NewVertex(3, \"Paris\") tokyo := NewVertex(4, \"Tokyo\") g := Graph&#123; london, ny, berlin, paris, tokyo, &#125; _ = g london.AddNeighbour(paris) london.AddNeighbour(ny) ny.AddNeighbour(london) ny.AddNeighbour(paris) ny.AddNeighbour(tokyo) tokyo.AddNeighbour(paris) paris.AddNeighbour(tokyo) paris.AddNeighbour(berlin) london.Bfs(VertexPrint)&#125; 123450 (London)3 (Paris)1 (New York City)2 (Berlin)4 (Tokyo) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869use std::rc::&#123;Rc, Weak&#125;;use std::cell::RefCell;struct Vertex&lt;V&gt; &#123; value: V, neighbours: Vec&lt;Weak&lt;RefCell&lt;Vertex&lt;V&gt;&gt;&gt;&gt;,&#125;type RcVertex&lt;V&gt; = Rc&lt;RefCell&lt;Vertex&lt;V&gt;&gt;&gt;;struct Graph&lt;V&gt; &#123; vertices: Vec&lt;RcVertex&lt;V&gt;&gt;,&#125;impl&lt;V&gt; Graph&lt;V&gt; &#123; fn new() -&gt; Self &#123; Graph &#123; vertices: vec![] &#125; &#125; fn new_vertex(&amp;mut self, value: V) -&gt; RcVertex&lt;V&gt; &#123; self.add_vertex(Vertex &#123; value, neighbours: Vec::new() &#125;) &#125; fn add_vertex(&amp;mut self, v: Vertex&lt;V&gt;) -&gt; RcVertex&lt;V&gt; &#123; let v = Rc::new(RefCell::new(v)); self.vertices.push(Rc::clone(&amp;v)); v &#125; fn add_edge(&amp;mut self, v1: &amp;RcVertex&lt;V&gt;, v2: &amp;RcVertex&lt;V&gt;) &#123; v1.borrow_mut().neighbours.push(Rc::downgrade(&amp;v2)); v2.borrow_mut().neighbours.push(Rc::downgrade(&amp;v1)); &#125; fn bft(start: RcVertex&lt;V&gt;, f: impl Fn(&amp;V)) &#123; let mut q = vec![start]; let mut i = 0; while i &lt; q.len() &#123; let v = Rc::clone(&amp;q[i]); i += 1; (f)(&amp;v.borrow().value); for n in &amp;v.borrow().neighbours &#123; let n = n.upgrade().expect(\"Invalid neighbour\"); if q.iter().all(|v| v.as_ptr() != n.as_ptr()) &#123; q.push(n); &#125; &#125; &#125; &#125;&#125;fn main() &#123; let mut g = Graph::new(); let v1 = g.new_vertex(1); let v2 = g.new_vertex(2); let v3 = g.new_vertex(3); let v4 = g.new_vertex(4); let v5 = g.new_vertex(5); g.add_edge(&amp;v1, &amp;v2); g.add_edge(&amp;v1, &amp;v3); g.add_edge(&amp;v1, &amp;v4); g.add_edge(&amp;v2, &amp;v5); g.add_edge(&amp;v3, &amp;v4); g.add_edge(&amp;v4, &amp;v5); Graph::bft(v1, |v| println!(\"&#123;&#125;\", v));&#125; 1234512345 130. Depth-first traversing in a graph Call a function f on every vertex accessible for vertex v, in depth-first prefix order 图的深度优先遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport \"fmt\"func (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) &#123; seen[v] = true f(v) for next, isEdge := range v.Neighbours &#123; if isEdge &amp;&amp; !seen[next] &#123; next.Dfs(f, seen) &#125; &#125;&#125;type Vertex struct &#123; Id int Label string Neighbours map[*Vertex]bool&#125;type Graph []*Vertexfunc NewVertex(id int, label string) *Vertex &#123; return &amp;Vertex&#123; Id: id, Label: label, Neighbours: make(map[*Vertex]bool), &#125;&#125;func (v *Vertex) AddNeighbour(w *Vertex) &#123; v.Neighbours[w] = true&#125;func VertexPrint(v *Vertex) &#123; fmt.Printf(\"%v (%v)\\n\", v.Id, v.Label)&#125;func main() &#123; // Some cities london := NewVertex(0, \"London\") ny := NewVertex(1, \"New York City\") berlin := NewVertex(2, \"Berlin\") paris := NewVertex(3, \"Paris\") tokyo := NewVertex(4, \"Tokyo\") g := Graph&#123; london, ny, berlin, paris, tokyo, &#125; _ = g london.AddNeighbour(paris) london.AddNeighbour(ny) ny.AddNeighbour(london) ny.AddNeighbour(paris) ny.AddNeighbour(tokyo) tokyo.AddNeighbour(paris) paris.AddNeighbour(tokyo) paris.AddNeighbour(berlin) alreadySeen := map[*Vertex]bool&#123;&#125; london.Dfs(VertexPrint, alreadySeen)&#125; 123450 (London)3 (Paris)4 (Tokyo)2 (Berlin)1 (New York City) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869use std::rc::&#123;Rc, Weak&#125;;use std::cell::RefCell;struct Vertex&lt;V&gt; &#123; value: V, neighbours: Vec&lt;Weak&lt;RefCell&lt;Vertex&lt;V&gt;&gt;&gt;&gt;,&#125;type RcVertex&lt;V&gt; = Rc&lt;RefCell&lt;Vertex&lt;V&gt;&gt;&gt;;struct Graph&lt;V&gt; &#123; vertices: Vec&lt;RcVertex&lt;V&gt;&gt;,&#125;impl&lt;V&gt; Graph&lt;V&gt; &#123; fn new() -&gt; Self &#123; Graph &#123; vertices: vec![] &#125; &#125; fn new_vertex(&amp;mut self, value: V) -&gt; RcVertex&lt;V&gt; &#123; self.add_vertex(Vertex &#123; value, neighbours: Vec::new() &#125;) &#125; fn add_vertex(&amp;mut self, v: Vertex&lt;V&gt;) -&gt; RcVertex&lt;V&gt; &#123; let v = Rc::new(RefCell::new(v)); self.vertices.push(Rc::clone(&amp;v)); v &#125; fn add_edge(&amp;mut self, v1: &amp;RcVertex&lt;V&gt;, v2: &amp;RcVertex&lt;V&gt;) &#123; v1.borrow_mut().neighbours.push(Rc::downgrade(&amp;v2)); v2.borrow_mut().neighbours.push(Rc::downgrade(&amp;v1)); &#125; fn dft(start: RcVertex&lt;V&gt;, f: impl Fn(&amp;V)) &#123; let mut s = vec![]; Self::dft_helper(start, &amp;f, &amp;mut s); &#125; fn dft_helper(start: RcVertex&lt;V&gt;, f: &amp;impl Fn(&amp;V), s: &amp;mut Vec&lt;*const Vertex&lt;V&gt;&gt;) &#123; s.push(start.as_ptr()); (f)(&amp;start.borrow().value); for n in &amp;start.borrow().neighbours &#123; let n = n.upgrade().expect(\"Invalid neighbor\"); if s.iter().all(|&amp;p| p != n.as_ptr()) &#123; Self::dft_helper(n, f, s); &#125; &#125; &#125;&#125;fn main() &#123; let mut g = Graph::new(); let v1 = g.new_vertex(1); let v2 = g.new_vertex(2); let v3 = g.new_vertex(3); let v4 = g.new_vertex(4); let v5 = g.new_vertex(5); g.add_edge(&amp;v1, &amp;v2); g.add_edge(&amp;v1, &amp;v4); g.add_edge(&amp;v1, &amp;v5); g.add_edge(&amp;v2, &amp;v3); g.add_edge(&amp;v3, &amp;v4); g.add_edge(&amp;v4, &amp;v5); Graph::dft(v1, |v| println!(\"&#123;&#125;\", v));&#125; 1234512345 131. Successive conditions Execute f1 if condition c1 is true, or else f2 if condition c2 is true, or else f3 if condition c3 is true.Don’t evaluate a condition when a previous condition was true. 连续条件判等 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"strings\")func conditional(x string) &#123; switch &#123; case c1(x): f1() case c2(x): f2() case c3(x): f3() &#125;&#125;func main() &#123; conditional(\"dog Snoopy\") conditional(\"fruit Raspberry\")&#125;func f1() &#123; fmt.Println(\"I'm a Human\")&#125;func f2() &#123; fmt.Println(\"I'm a Dog\")&#125;func f3() &#123; fmt.Println(\"I'm a Fruit\")&#125;var c1, c2, c3 = prefixCheck(\"human\"), prefixCheck(\"dog\"), prefixCheck(\"fruit\")func prefixCheck(prefix string) func(string) bool &#123; return func(x string) bool &#123; return strings.HasPrefix(x, prefix) &#125;&#125; 12I'm a DogI'm a Fruit 1if c1 &#123; f1() &#125; else if c2 &#123; f2() &#125; else if c3 &#123; f3() &#125; or 123456match true &#123; _ if c1 =&gt; f1(), _ if c2 =&gt; f2(), _ if c3 =&gt; f3(), _ =&gt; (),&#125; 132. Measure duration of procedure execution Run procedure f, and return the duration of the execution of f. 度量程序执行时间 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"regexp\" \"strings\" \"time\")func clock(f func()) time.Duration &#123; t := time.Now() f() return time.Since(t)&#125;func f() &#123; re := regexp.MustCompilePOSIX(\"|A+&#123;300&#125;\") re.FindAllString(strings.Repeat(\"A\", 299), -1)&#125;func main() &#123; d := clock(f) // The result is always zero in the playground, which has a fixed clock! // Try it on your workstation instead. fmt.Println(d)&#125; 0s 1234use std::time::Instant;let start = Instant::now();f();let duration = start.elapsed(); 133. Case-insensitive string contains Set boolean ok to true if string word is contained in string s as a substring, even if the case doesn’t match, or to false otherwise. 不区分大小写的字符串包含 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"strings\")// Package _strings has no case-insensitive version of _Contains, so// we have to make our own.func containsCaseInsensitive(s, word string) bool &#123; lowerS, lowerWord := strings.ToLower(s), strings.ToLower(word) ok := strings.Contains(lowerS, lowerWord) return ok&#125;func main() &#123; s := \"Let's dance the macarena\" word := \"Dance\" ok := containsCaseInsensitive(s, word) fmt.Println(ok) word = \"dance\" ok = containsCaseInsensitive(s, word) fmt.Println(ok) word = \"Duck\" ok = containsCaseInsensitive(s, word) fmt.Println(ok)&#125; 123truetruefalse 123456789101112131415161718192021222324252627282930extern crate regex;use regex::Regex;fn main() &#123; let s = \"Let's dance the macarena\"; &#123; let word = \"Dance\"; let re = Regex::new(&amp;format!(\"(?i)&#123;&#125;\", regex::escape(word))).unwrap(); let ok = re.is_match(&amp;s); println!(\"&#123;&#125;\", ok); &#125; &#123; let word = \"dance\"; let re = Regex::new(&amp;format!(\"(?i)&#123;&#125;\", regex::escape(word))).unwrap(); let ok = re.is_match(&amp;s); println!(\"&#123;&#125;\", ok); &#125; &#123; let word = \"Duck\"; let re = Regex::new(&amp;format!(\"(?i)&#123;&#125;\", regex::escape(word))).unwrap(); let ok = re.is_match(&amp;s); println!(\"&#123;&#125;\", ok); &#125;&#125; 123truetruefalse or 123456789101112131415use regex::RegexBuilder;fn main() &#123; let s = \"FooBar\"; let word = \"foo\"; let re = RegexBuilder::new(&amp;regex::escape(word)) .case_insensitive(true) .build() .unwrap(); let ok = re.is_match(s); println!(\"&#123;:?&#125;\", ok);&#125; true or 123456789101112131415161718192021fn main() &#123; let s = \"Let's dance the macarena\"; &#123; let word = \"Dance\"; let ok = s.to_ascii_lowercase().contains(&amp;word.to_ascii_lowercase()); println!(\"&#123;&#125;\", ok); &#125; &#123; let word = \"dance\"; let ok = s.to_ascii_lowercase().contains(&amp;word.to_ascii_lowercase()); println!(\"&#123;&#125;\", ok); &#125; &#123; let word = \"Duck\"; let ok = s.to_ascii_lowercase().contains(&amp;word.to_ascii_lowercase()); println!(\"&#123;&#125;\", ok); &#125;&#125; 123truetruefalse 134. Create a new list创建一个新list 123456789101112131415package mainimport ( \"fmt\")func main() &#123; var a, b, c T = \"This\", \"is\", \"wonderful\" items := []T&#123;a, b, c&#125; fmt.Println(items)&#125;type T string [This is wonderful] 1234567fn main() &#123; let (a, b, c) = (11, 22, 33); let items = vec![a, b, c]; println!(\"&#123;:?&#125;\", items);&#125; [11, 22, 33] 135. Remove item from list, by its value Remove at most 1 item from list items, having value x.This will alter the original list or return a new list, depending on which is more idiomatic.If there are several occurrences of x in items, remove only one of them. If x is absent, keep items unchanged. 移除列表中的值 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; items := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"&#125; fmt.Println(items) x := \"c\" for i, y := range items &#123; if y == x &#123; items = append(items[:i], items[i+1:]...) break &#125; &#125; fmt.Println(items)&#125; 12[a b c d e f][a b d e f] or 12345678for i, y := range items &#123; if y == x &#123; copy(items[i:], items[i+1:]) items[len(items)-1] = nil items = items[:len(items)-1] break &#125;&#125; 123if let Some(i) = items.first(&amp;x) &#123; items.remove(i);&#125; 136. Remove all occurrences of a value from a list Remove all occurrences of value x from list items.This will alter the original list or return a new list, depending on which is more idiomatic. 从列表中删除所有出现的值 12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; items := []T&#123;\"b\", \"a\", \"b\", \"a\", \"r\"&#125; fmt.Println(items) var x T = \"b\" items2 := make([]T, 0, len(items)) for _, v := range items &#123; if v != x &#123; items2 = append(items2, v) &#125; &#125; fmt.Println(items2)&#125;type T string 12[b a b a r][a a r] or 123456789101112131415161718192021222324package mainimport ( \"fmt\")func main() &#123; items := []T&#123;\"b\", \"a\", \"b\", \"a\", \"r\"&#125; fmt.Println(items) x := T(\"b\") j := 0 for i, v := range items &#123; if v != x &#123; items[j] = items[i] j++ &#125; &#125; items = items[:j] fmt.Println(items)&#125;type T string 12[b a b a r][a a r] or 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"runtime\")func main() &#123; var items []*image &#123; red := newUniform(rgb&#123;0xFF, 0, 0&#125;) white := newUniform(rgb&#123;0xFF, 0xFF, 0xFF&#125;) items = []*image&#123;red, white, red&#125; // Like the flag of Austria fmt.Println(\"items =\", items) x := red j := 0 for i, v := range items &#123; if v != x &#123; items[j] = items[i] j++ &#125; &#125; for k := j; k &lt; len(items); k++ &#123; items[k] = nil &#125; items = items[:j] &#125; // At this point, red can be garbage collected printAllocInfo() fmt.Println(\"items =\", items) // Not the original flag anymore... fmt.Println(\"items undelying =\", items[:3])&#125;type image [1024][1024]rgbtype rgb [3]bytefunc newUniform(color rgb) *image &#123; im := new(image) for x := range im &#123; for y := range im[x] &#123; im[x][y] = color &#125; &#125; return im&#125;func printAllocInfo() &#123; var stats runtime.MemStats runtime.GC() runtime.ReadMemStats(&amp;stats) fmt.Println(\"Bytes allocated (total):\", stats.TotalAlloc) fmt.Println(\"Bytes still allocated: \", stats.Alloc)&#125; 12345items = [0xc000180000 0xc000480000 0xc000180000]Bytes allocated (total): 6416688Bytes still allocated: 3259024items = [0xc000480000]items undelying = [0xc000480000 &lt;nil&gt; &lt;nil&gt;] 12345678fn main() &#123; let x = 1; let mut items = vec![1, 2, 3, 1, 2, 3]; items = items.into_iter().filter(|&amp;item| item != x).collect(); println!(\"&#123;:?&#125;\", items);&#125; [2, 3, 2, 3] 137. Check if string contains only digits Set boolean b to true if string s contains only characters in range ‘0’..’9’, false otherwise. 检查字符串是否只包含数字 12345678910111213141516171819202122232425package mainimport ( \"fmt\")func main() &#123; for _, s := range []string&#123; \"123\", \"\", \"abc123def\", \"abc\", \"123.456\", \"123 456\", &#125; &#123; b := true for _, c := range s &#123; if c &lt; '0' || c &gt; '9' &#123; b = false break &#125; &#125; fmt.Println(s, \"=&gt;\", b) &#125;&#125; 123456123 =&gt; true =&gt; trueabc123def =&gt; falseabc =&gt; false123.456 =&gt; false123 456 =&gt; false or 123456789101112131415161718192021package mainimport ( \"fmt\" \"strings\")func main() &#123; for _, s := range []string&#123; \"123\", \"\", \"abc123def\", \"abc\", \"123.456\", \"123 456\", &#125; &#123; isNotDigit := func(c rune) bool &#123; return c &lt; '0' || c &gt; '9' &#125; b := strings.IndexFunc(s, isNotDigit) == -1 fmt.Println(s, \"=&gt;\", b) &#125;&#125; 123456123 =&gt; true =&gt; trueabc123def =&gt; falseabc =&gt; false123.456 =&gt; false123 456 =&gt; false 123456fn main() &#123; let s = \"1023\"; let chars_are_numeric: Vec&lt;bool&gt; = s.chars().map(|c|c.is_numeric()).collect(); let b = !chars_are_numeric.contains(&amp;false); println!(\"&#123;&#125;\", b);&#125; true or 1234fn main() &#123; let b = \"0129\".chars().all(char::is_numeric); println!(\"&#123;&#125;\", b);&#125; true 138. Create temp file Create a new temporary file on filesystem. 创建一个新的临时文件 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"io/ioutil\" \"log\" \"os\")func main() &#123; content := []byte(\"Big bag of misc data\") log.Println(\"Opening new temp file\") tmpfile, err := ioutil.TempFile(\"\", \"example\") if err != nil &#123; log.Fatal(err) &#125; tmpfilename := tmpfile.Name() defer os.Remove(tmpfilename) // clean up log.Println(\"Opened new file\", tmpfilename) log.Println(\"Writing [[\", string(content), \"]]\") if _, err := tmpfile.Write(content); err != nil &#123; log.Fatal(err) &#125; if err := tmpfile.Close(); err != nil &#123; log.Fatal(err) &#125; log.Println(\"Closed\", tmpfilename) log.Println(\"Opening\", tmpfilename) buffer, err := ioutil.ReadFile(tmpfilename) if err != nil &#123; log.Fatal(err) &#125; log.Println(\"Read[[\", string(buffer), \"]]\")&#125; 1234562009/11/10 23:00:00 Opening new temp file2009/11/10 23:00:00 Opened new file /tmp/example0673192782009/11/10 23:00:00 Writing [[ Big bag of misc data ]]2009/11/10 23:00:00 Closed /tmp/example0673192782009/11/10 23:00:00 Opening /tmp/example0673192782009/11/10 23:00:00 Read[[ Big bag of misc data ]] 1234use tempdir::TempDir;use std::fs::File;let temp_dir = TempDir::new(\"prefix\")?;let temp_file = File::open(temp_dir.path().join(\"file_name\"))?; 139. Create temp directory Create a new temporary folder on filesystem, for writing. 创建一个临时目录 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"os\" \"path/filepath\")func main() &#123; content := []byte(\"temporary file's content\") dir, err := ioutil.TempDir(\"\", \"\") if err != nil &#123; log.Fatal(err) &#125; defer os.RemoveAll(dir) // clean up inspect(dir) tmpfn := filepath.Join(dir, \"tmpfile\") err = ioutil.WriteFile(tmpfn, content, 0666) if err != nil &#123; log.Fatal(err) &#125; inspect(dir)&#125;func inspect(dirpath string) &#123; files, err := ioutil.ReadDir(dirpath) if err != nil &#123; log.Fatal(err) &#125; fmt.Println(dirpath, \"contains\", len(files), \"files\")&#125; 12/tmp/067319278 contains 0 files/tmp/067319278 contains 1 files 123extern crate tempdir;use tempdir::TempDir;let tmp = TempDir::new(\"prefix\")?; 140. Delete map entry从map中删除某个key 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; m := map[string]int&#123; \"uno\": 1, \"dos\": 2, \"tres\": 3, &#125; delete(m, \"dos\") delete(m, \"cinco\") fmt.Println(m)&#125; map[tres:3 uno:1] 1234567891011fn main() &#123; use std::collections::HashMap; let mut m = HashMap::new(); m.insert(5, \"a\"); m.insert(17, \"b\"); println!(\"&#123;:?&#125;\", m); m.remove(&amp;5); println!(\"&#123;:?&#125;\", m);&#125; 12&#123;17: \"b\", 5: \"a\"&#125;&#123;17: \"b\"&#125;","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(6)","date":"2021-09-07T13:31:07.000Z","path":"2021/09/07/Rust-vs-Go-常用语法对比-6/","text":"101. Load from HTTP GET request into a string Make an HTTP request with method GET to URL u, then store the body of the response in string s. 发起http请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"io/ioutil\" \"net\" \"net/http\")func main() &#123; u := \"http://\" + localhost + \"/hello?name=Inigo+Montoya\" res, err := http.Get(u) check(err) buffer, err := ioutil.ReadAll(res.Body) res.Body.Close() check(err) s := string(buffer) fmt.Println(\"GET response:\", res.StatusCode, s)&#125;const localhost = \"127.0.0.1:3000\"func init() &#123; http.HandleFunc(\"/hello\", myHandler) startServer()&#125;func myHandler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"Hello %s\", r.FormValue(\"name\"))&#125;func startServer() &#123; listener, err := net.Listen(\"tcp\", localhost) check(err) go http.Serve(listener, nil)&#125;func check(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; res has type *http.Response.buffer has type []byte.It is idiomatic and strongly recommended to check errors at each step. GET response: 200 Hello Inigo Montoya 1234extern crate reqwest;use reqwest::Client;let client = Client::new();let s = client.get(u).send().and_then(|res| res.text())?; or 123[dependencies]ureq = \"1.0\"let s = ureq::get(u).call().into_string()?; or 123456789[dependencies]error-chain = \"0.12.4\"reqwest = &#123; version = \"0.11.2\", features = [\"blocking\"] &#125;use error_chain::error_chain;use std::io::Read;let mut response = reqwest::blocking::get(u)?;let mut s = String::new();response.read_to_string(&amp;mut s)?; 102. Load from HTTP GET request into a file Make an HTTP request with method GET to URL u, then store the body of the response in file result.txt. Try to save the data as it arrives if possible, without having all its content in memory at once. 发起http请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport ( \"fmt\" \"io\" \"io/ioutil\" \"net\" \"net/http\" \"os\")func main() &#123; err := saveGetResponse() check(err) err = readFile() check(err) fmt.Println(\"Done.\")&#125;func saveGetResponse() error &#123; u := \"http://\" + localhost + \"/hello?name=Inigo+Montoya\" fmt.Println(\"Making GET request\") resp, err := http.Get(u) if err != nil &#123; return err &#125; defer resp.Body.Close() if resp.StatusCode != 200 &#123; return fmt.Errorf(\"Status: %v\", resp.Status) &#125; fmt.Println(\"Saving data to file\") out, err := os.Create(\"/tmp/result.txt\") if err != nil &#123; return err &#125; defer out.Close() _, err = io.Copy(out, resp.Body) if err != nil &#123; return err &#125; return nil&#125;func readFile() error &#123; fmt.Println(\"Reading file\") buffer, err := ioutil.ReadFile(\"/tmp/result.txt\") if err != nil &#123; return err &#125; fmt.Printf(\"Saved data is %q\\n\", string(buffer)) return nil&#125;const localhost = \"127.0.0.1:3000\"func init() &#123; http.HandleFunc(\"/hello\", myHandler) startServer()&#125;func myHandler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"Hello %s\", r.FormValue(\"name\"))&#125;func startServer() &#123; listener, err := net.Listen(\"tcp\", localhost) check(err) go http.Serve(listener, nil)&#125;func check(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; resp has type *http.Response.It is idiomatic and strongly recommended to check errors at each step, except for the calls to Close. 12345Making GET requestSaving data to fileReading fileSaved data is \"Hello Inigo Montoya\"Done. 1234567891011extern crate reqwest;use reqwest::Client;use std::fs::File;let client = Client::new();match client.get(&amp;u).send() &#123; Ok(res) =&gt; &#123; let file = File::create(\"result.txt\")?; ::std::io::copy(res, file)?; &#125;, Err(e) =&gt; eprintln!(\"failed to send request: &#123;&#125;\", e),&#125;; 105. Current executable name Assign to string s the name of the currently executing program (but not its full path). 当前可执行文件名称 将当前正在执行的程序的名称分配给字符串s(但不是它的完整路径)。 12345678910111213141516package mainimport ( \"fmt\" \"os\" \"path/filepath\")func main() &#123; var s string path := os.Args[0] s = filepath.Base(path) fmt.Println(s)&#125; play 1234567891011fn get_exec_name() -&gt; Option&lt;String&gt; &#123; std::env::current_exe() .ok() .and_then(|pb| pb.file_name().map(|s| s.to_os_string())) .and_then(|s| s.into_string().ok())&#125;fn main() -&gt; () &#123; let s = get_exec_name().unwrap(); println!(\"&#123;&#125;\", s);&#125; playground or 12345678910fn main() &#123; let s = std::env::current_exe() .expect(\"Can't get the exec path\") .file_name() .expect(\"Can't get the exec name\") .to_string_lossy() .into_owned(); println!(\"&#123;&#125;\", s);&#125; playground 106. Get program working directory Assign to string dir the path of the working directory.(This is not necessarily the folder containing the executable itself) 获取程序的工作路径 1234567891011package mainimport ( \"fmt\" \"os\")func main() &#123; dir, err := os.Getwd() fmt.Println(dir, err)&#125; / &lt;nil&gt; 1234567use std::env;fn main() &#123; let dir = env::current_dir().unwrap(); println!(\"&#123;:?&#125;\", dir);&#125; &quot;/playground&quot; 107. Get folder containing current program Assign to string dir the path of the folder containing the currently running executable.(This is not necessarily the working directory, though.) 获取包含当前程序的文件夹 1234567891011121314151617181920package mainimport ( \"fmt\" \"os\" \"path/filepath\")func main() &#123; var dir string programPath := os.Args[0] absolutePath, err := filepath.Abs(programPath) if err != nil &#123; panic(err) &#125; dir = filepath.Dir(absolutePath) fmt.Println(dir)&#125; /tmpfs 1234567let dir = std::env::current_exe()? .canonicalize() .expect(\"the current exe should exist\") .parent() .expect(\"the current exe should be a file\") .to_string_lossy() .to_owned(); Rust doesn’t represent paths as Strings, so we need to convert the Path returned from Path::parent. This code chooses to do this lossily, replacing characters it doesn’t recognize with � 109. Number of bytes of a type Set n to the number of bytes of a variable t (of type T). 获取某个类型的字节数 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"reflect\")func main() &#123; var t T tType := reflect.TypeOf(t) n := tType.Size() fmt.Println(\"A\", tType, \"object is\", n, \"bytes.\")&#125;type Person struct &#123; FirstName string Age int&#125;// T is a type alias, to stick to the idiom statement.// T has the same memory footprint per value as Person.type T Person A main.T object is 24 bytes. 123456789// T has (8 + 4) == 12 bytes of datastruct T(f64, i32);fn main() &#123; let n = ::std::mem::size_of::&lt;T&gt;(); println!(\"&#123;&#125; bytes\", n); // T has size 16, which is \"the offset in bytes between successive elements in an array with item type T\"&#125; 16 bytes 110. Check if string is blank Set boolean blank to true if string s is empty, or null, or contains only whitespace ; false otherwise. 检查字符串是否空白 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"strings\")func main() &#123; for _, s := range []string&#123; \"\", \"a\", \" \", \"\\t \\n\", \"_\", &#125; &#123; blank := strings.TrimSpace(s) == \"\" if blank &#123; fmt.Printf(\"%q is blank\\n\", s) &#125; else &#123; fmt.Printf(\"%q is not blank\\n\", s) &#125; &#125;&#125; 12345\"\" is blank\"a\" is not blank\" \" is blank\"\\t \\n\" is blank\"_\" is not blank 123456789101112fn main() &#123; let list = vec![\"\", \" \", \" \", \"\\t\", \"\\n\", \"a\", \" b \"]; for s in list &#123; let blank = s.trim().is_empty(); if blank &#123; println!(\"&#123;:?&#125;\\tis blank\", s) &#125; else &#123; println!(\"&#123;:?&#125;\\tis not blank\", s) &#125; &#125;&#125; 1234567\"\" is blank\" \" is blank\" \" is blank\"\\t\" is blank\"\\n\" is blank\"a\" is not blank\" b \" is not blank 111. Launch other program From current process, run program x with command-line parameters “a”, “b”. 运行其他程序 1234567891011package mainimport ( \"fmt\" \"os/exec\")func main() &#123; err := exec.Command(\"x\", \"a\", \"b\").Run() fmt.Println(err)&#125; exec: &quot;x&quot;: executable file not found in $PATH 12345678910111213use std::process::Command;fn main() &#123; let child = Command::new(\"ls\") .args(&amp;[\"/etc\"]) .spawn() .expect(\"failed to execute process\"); let output = child.wait_with_output().expect(\"Failed to wait on child\"); let output = String::from_utf8(output.stdout).unwrap(); println!(\"&#123;&#125;\", output);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899X11adduser.confalternativesaptbash.bashrcbash_completion.dbindresvport.blacklistca-certificatesca-certificates.confcron.dcron.dailydebconf.confdebian_versiondefaultdeluser.confdpkge2scrub.confemacsenvironmentethertypesfstabgai.confgroupgroup-gshadowgshadow-gsshost.confhostnamehostsinit.dinputrcissueissue.netkernelld.so.cacheld.so.confld.so.conf.dldaplegallibaudit.conflocaltimelogchecklogin.defslogrotate.dlsb-releasemachine-idmagicmagic.mimemailcapmailcap.ordermime.typesmke2fs.confmtabnetworksnsswitch.confoptos-releasepam.confpam.dpasswdpasswd-perlprofileprofile.dprotocolspython2.7rc0.drc1.drc2.drc3.drc4.drc5.drc6.drcS.dresolv.confrmtrpcsecurityselinuxservicesshadowshadow-shellsskelsshsslsubgidsubgid-subuidsubuid-sysctl.confsysctl.dsystemdterminfotimezoneupdate-motd.dxattr.confxdg or 123456789101112use std::process::Command;fn main() &#123; let output = Command::new(\"ls\") .args(&amp;[\"/etc\"]) .output() .expect(\"failed to execute process\"); let output = String::from_utf8(output.stdout).unwrap(); println!(\"&#123;&#125;\", output);&#125; or 1234567891011use std::process::Command;fn main() &#123; let status = Command::new(\"ls\") .args(&amp;[\"/etc\"]) .status() .expect(\"failed to execute process\"); // exit code is outputted after _ls_ runs println!(\"&#123;&#125;\", status);&#125; 112. Iterate over map entries, ordered by keys Print each key k with its value x from an associative array mymap, in ascending order of k. 遍历map，按key排序 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"sort\")func main() &#123; mymap := map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, &#125; keys := make([]string, 0, len(mymap)) for k := range mymap &#123; keys = append(keys, k) &#125; sort.Strings(keys) for _, k := range keys &#123; x := mymap[k] fmt.Println(\"Key =\", k, \", Value =\", x) &#125;&#125; 1234Key = four , Value = 4Key = one , Value = 1Key = three , Value = 3Key = two , Value = 2 12345678910111213141516use std::collections::BTreeMap;fn main() &#123; let mut mymap = BTreeMap::new(); mymap.insert(\"one\", 1); mymap.insert(\"two\", 2); mymap.insert(\"three\", 3); mymap.insert(\"four\", 4); mymap.insert(\"five\", 5); mymap.insert(\"six\", 6); // Iterate over map entries, ordered by keys, which is NOT the numerical order for (k, x) in mymap &#123; println!(\"(&#123;&#125;, &#123;&#125;)\", k, x); &#125;&#125; 123456(five, 5)(four, 4)(one, 1)(six, 6)(three, 3)(two, 2) 113. Iterate over map entries, ordered by values Print each key k with its value x from an associative array mymap, in ascending order of x.Note that multiple entries may exist for the same value x. 遍历map，按值排序 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"sort\")type entry struct &#123; key string value int&#125;type entries []entryfunc (list entries) Len() int &#123; return len(list) &#125;func (list entries) Less(i, j int) bool &#123; return list[i].value &lt; list[j].value &#125;func (list entries) Swap(i, j int) &#123; list[i], list[j] = list[j], list[i] &#125;func main() &#123; mymap := map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"dos\": 2, \"deux\": 2, &#125; entries := make(entries, 0, len(mymap)) for k, x := range mymap &#123; entries = append(entries, entry&#123;key: k, value: x&#125;) &#125; sort.Sort(entries) for _, e := range entries &#123; fmt.Println(\"Key =\", e.key, \", Value =\", e.value) &#125;&#125; 123456Key = one , Value = 1Key = dos , Value = 2Key = deux , Value = 2Key = two , Value = 2Key = three , Value = 3Key = four , Value = 4 or 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"sort\")func main() &#123; mymap := map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"dos\": 2, \"deux\": 2, &#125; type entry struct &#123; key string value int &#125; entries := make([]entry, 0, len(mymap)) for k, x := range mymap &#123; entries = append(entries, entry&#123;key: k, value: x&#125;) &#125; sort.Slice(entries, func(i, j int) bool &#123; return entries[i].value &lt; entries[j].value &#125;) for _, e := range entries &#123; fmt.Println(\"Key =\", e.key, \", Value =\", e.value) &#125;&#125; 123456Key = one , Value = 1Key = two , Value = 2Key = dos , Value = 2Key = deux , Value = 2Key = three , Value = 3Key = four , Value = 4 1234567891011121314use itertools::Itertools;use std::collections::HashMap;fn main() &#123; let mut mymap = HashMap::new(); mymap.insert(1, 3); mymap.insert(2, 6); mymap.insert(3, 4); mymap.insert(4, 1); for (k, x) in mymap.iter().sorted_by_key(|x| x.1) &#123; println!(\"[&#123;&#125;,&#123;&#125;]\", k, x); &#125;&#125; 1234[4,1][1,3][3,4][2,6] or 123456789101112131415use std::collections::HashMap;fn main() &#123; let mut mymap = HashMap::new(); mymap.insert(1, 3); mymap.insert(2, 6); mymap.insert(3, 4); mymap.insert(4, 1); let mut items: Vec&lt;_&gt; = mymap.iter().collect(); items.sort_by_key(|item| item.1); for (k, x) in items &#123; println!(\"[&#123;&#125;,&#123;&#125;]\", k, x); &#125;&#125; 1234[4,1][1,3][3,4][2,6] 114. Test deep equality Set boolean b to true if objects x and y contain the same values, recursively comparing all referenced elements in x and y.Tell if the code correctly handles recursive types. 深度判等 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"fmt\" \"reflect\")func main() &#123; x := Foo&#123;9, \"Hello\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 1.0, 2: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125; list := []Foo&#123; &#123;9, \"Bye\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 1.0, 2: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125;, &#123;9, \"Hello\", []bool&#123;false, false&#125;, map[int]float64&#123;1: 1.0, 2: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125;, &#123;9, \"Hello\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 3.0, 2: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125;, &#123;9, \"Hello\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 1.0, 5: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125;, &#123;9, \"Hello\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 1.0, 2: 2.0&#125;, &amp;Bar&#123;\"Batman\"&#125;&#125;, &#123;9, \"Hello\", []bool&#123;false, true&#125;, map[int]float64&#123;1: 1.0, 2: 2.0&#125;, &amp;Bar&#123;\"Babar\"&#125;&#125;, &#125; for i, y := range list &#123; b := reflect.DeepEqual(x, y) if b &#123; fmt.Println(\"x deep equals list[\", i, \"]\") &#125; else &#123; fmt.Println(\"x doesn't deep equal list[\", i, \"]\") &#125; &#125;&#125;type Foo struct &#123; int str string bools []bool mapping map[int]float64 bar *Bar&#125;type Bar struct &#123; name string&#125; 123456x doesn't deep equal list[ 0 ]x doesn't deep equal list[ 1 ]x doesn't deep equal list[ 2 ]x doesn't deep equal list[ 3 ]x doesn't deep equal list[ 4 ]x deep equals list[ 5 ] 1let b = x == y; The == operator can only be used by having a type implement PartialEq. 115. Compare dates Set boolean b to true if date d1 is strictly before date d2 ; false otherwise. 日期比较 123456789101112131415package mainimport ( \"fmt\" \"time\")func main() &#123; d1 := time.Now() d2 := time.Date(2020, time.November, 10, 23, 0, 0, 0, time.UTC) b := d1.Before(d2) fmt.Println(b)&#125; true 123extern crate chrono;use chrono::prelude::*;let b = d1 &lt; d2; doc – Struct chrono::Date 116. Remove occurrences of word from string Remove all occurrences of string w from string s1, and store the result in s2. 去除指定字符串 1234567891011package mainimport \"fmt\"import \"strings\"func main() &#123; var s1 = \"foobar\" var w = \"foo\" s2 := strings.Replace(s1, w, \"\", -1) fmt.Println(s2)&#125; bar 123456fn main() &#123; let s1 = \"foobar\"; let w = \"foo\"; let s2 = s1.replace(w, \"\"); println!(\"&#123;&#125;\", s2);&#125; bar or 12345678fn main() &#123; let s1 = \"foobar\"; let w = \"foo\"; let s2 = str::replace(s1, w, \"\"); println!(\"&#123;&#125;\", s2);&#125; bar 117. Get list size获取list的大小 123456789101112131415package mainimport \"fmt\"func main() &#123; // x is a slice x := []string&#123;\"a\", \"b\", \"c\"&#125; n := len(x) fmt.Println(n) // y is an array y := [4]string&#123;\"a\", \"b\", \"c\"&#125; n = len(y) fmt.Println(n)&#125; 1234 1234567fn main() &#123; let x = vec![11, 22, 33]; let n = x.len(); println!(\"x has &#123;&#125; elements\", n);&#125; x has 3 elements 118. List to set Create set y from list x.x may contain duplicates. y is unordered and has no repeated values. 从list到set 123456789101112131415package mainimport \"fmt\"func main() &#123; x := []string&#123;\"b\", \"a\", \"b\", \"c\"&#125; fmt.Println(\"x =\", x) y := make(map[string]struct&#123;&#125;, len(x)) for _, v := range x &#123; y[v] = struct&#123;&#125;&#123;&#125; &#125; fmt.Println(\"y =\", y)&#125; 12x = [b a b c]y = map[a:&#123;&#125; b:&#123;&#125; c:&#123;&#125;] 123456789use std::collections::HashSet;fn main() &#123; let x: Vec&lt;i32&gt; = vec![1, 7, 3, 1]; println!(\"x: &#123;:?&#125;\", x); let y: HashSet&lt;_&gt; = x.into_iter().collect(); println!(\"y: &#123;:?&#125;\", y);&#125; 12x: [1, 7, 3, 1]y: &#123;1, 7, 3&#125; 119. Deduplicate list Remove duplicates from list x.Explain if original order is preserved. list去重 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; type T string x := []T&#123;\"b\", \"a\", \"b\", \"c\"&#125; fmt.Println(\"x =\", x) y := make(map[T]struct&#123;&#125;, len(x)) for _, v := range x &#123; y[v] = struct&#123;&#125;&#123;&#125; &#125; x2 := make([]T, 0, len(y)) for _, v := range x &#123; if _, ok := y[v]; ok &#123; x2 = append(x2, v) delete(y, v) &#125; &#125; x = x2 fmt.Println(\"x =\", x)&#125; 12x = [b a b c]x = [b a c] or 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; type T string x := []T&#123;\"b\", \"a\", \"b\", \"b\", \"c\", \"b\", \"a\"&#125; fmt.Println(\"x =\", x) seen := make(map[T]bool) j := 0 for _, v := range x &#123; if !seen[v] &#123; x[j] = v j++ seen[v] = true &#125; &#125; x = x[:j] fmt.Println(\"x =\", x)&#125; 12x = [b a b b c b a]x = [b a c] or 1234567891011121314151617181920212223242526272829303132333435363738package mainimport \"fmt\"type T *int64func main() &#123; var a, b, c, d int64 = 11, 22, 33, 11 x := []T&#123;&amp;b, &amp;a, &amp;b, &amp;b, &amp;c, &amp;b, &amp;a, &amp;d&#125; print(x) seen := make(map[T]bool) j := 0 for _, v := range x &#123; if !seen[v] &#123; x[j] = v j++ seen[v] = true &#125; &#125; for i := j; i &lt; len(x); i++ &#123; // Avoid memory leak x[i] = nil &#125; x = x[:j] // Now x has only distinct pointers (even if some point to int64 values that are the same) print(x)&#125;func print(a []T) &#123; glue := \"\" for _, p := range a &#123; fmt.Printf(\"%s%d\", glue, *p) glue = \", \" &#125; fmt.Println()&#125; 1222, 11, 22, 22, 33, 22, 11, 1122, 11, 33, 11 1234567fn main() &#123; let mut x = vec![1, 2, 3, 4, 3, 2, 2, 2, 2, 2, 2]; x.sort(); x.dedup(); println!(\"&#123;:?&#125;\", x);&#125; [1, 2, 3, 4] or 12345678use itertools::Itertools;fn main() &#123; let x = vec![1, 2, 3, 4, 3, 2, 2, 2, 2, 2, 2]; let dedup: Vec&lt;_&gt; = x.iter().unique().collect(); println!(\"&#123;:?&#125;\", dedup);&#125; [1, 2, 3, 4] 120. Read integer from stdin Read an integer value from the standard input into variable n 从标准输入中读取整数 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"io/ioutil\" \"os\")// This string simulates the keyboard entry.var userInput string = `42 017`func main() &#123; var i int _, err := fmt.Scan(&amp;i) fmt.Println(i, err) // The second value starts with 0, thus is interpreted as octal! var j int _, err = fmt.Scan(&amp;j) fmt.Println(j, err)&#125;// The Go Playground doesn't actually read os.Stdin, so this// workaround writes some data on virtual FS in a file, and then// sets this file as the new Stdin.//// Note that the init func is run before main.func init() &#123; err := ioutil.WriteFile(\"/tmp/stdin\", []byte(userInput), 0644) if err != nil &#123; panic(err) &#125; fileIn, err := os.Open(\"/tmp/stdin\") if err != nil &#123; panic(err) &#125; os.Stdin = fileIn&#125; 1242 &lt;nil&gt;15 &lt;nil&gt; or 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"io/ioutil\" \"os\")// This string simulates the keyboard entry.var userInput string = `42 017`func main() &#123; var i int _, err := fmt.Scanf(\"%d\", &amp;i) fmt.Println(i, err) var j int _, err = fmt.Scanf(\"%d\", &amp;j) fmt.Println(j, err)&#125;// The Go Playground doesn't actually read os.Stdin, so this// workaround writes some data on virtual FS in a file, and then// sets this file as the new Stdin.//// Note that the init func is run before main.func init() &#123; err := ioutil.WriteFile(\"/tmp/stdin\", []byte(userInput), 0644) if err != nil &#123; panic(err) &#125; fileIn, err := os.Open(\"/tmp/stdin\") if err != nil &#123; panic(err) &#125; os.Stdin = fileIn&#125; 1242 &lt;nil&gt;17 &lt;nil&gt; 1234567fn get_input() -&gt; String &#123; let mut buffer = String::new(); std::io::stdin().read_line(&amp;mut buffer).expect(\"Failed\"); buffer&#125;let n = get_input().trim().parse::&lt;i64&gt;().unwrap(); or 1234use std::io;let mut input = String::new();io::stdin().read_line(&amp;mut input).unwrap();let n: i32 = input.trim().parse().unwrap();s or 12345678910use std::io::BufRead;let n: i32 = std::io::stdin() .lock() .lines() .next() .expect(\"stdin should be available\") .expect(\"couldn't read from stdin\") .trim() .parse() .expect(\"input was not an integer\");","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(5)","date":"2021-09-06T15:51:58.000Z","path":"2021/09/06/Rust-vs-Go-常用语法对比-5/","text":"81. Round floating point number to integer Declare integer y and initialize it with the rounded value of floating point number x .Ties (when the fractional part of x is exactly .5) must be rounded up (to positive infinity). 按规则取整 1234567891011121314151617package mainimport ( \"fmt\" \"math\")func round(x float64) int &#123; y := int(math.Floor(x + 0.5)) return y&#125;func main() &#123; for _, x := range []float64&#123;-1.1, -0.9, -0.5, -0.1, 0., 0.1, 0.5, 0.9, 1.1&#125; &#123; fmt.Printf(\"%5.1f %5d\\n\", x, round(x)) &#125;&#125; 123456789-1.1 -1-0.9 -1-0.5 0-0.1 0 0.0 0 0.1 0 0.5 1 0.9 1 1.1 1 123456fn main() &#123; let x : f64 = 2.71828; let y = x.round() as i64; println!(\"&#123;&#125; &#123;&#125;\", x, y);&#125; 2.71828 3 82. Count substring occurrences统计子字符串出现次数 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"Romaromamam\" t := \"mam\" x := strings.Count(s, t) fmt.Println(x)&#125; 1 12345678fn main() &#123; let s = \"lorem ipsum lorem ipsum lorem ipsum lorem ipsum\"; let t = \"ipsum\"; let c = s.matches(t).count(); println!(\"&#123;&#125; occurrences\", c);&#125; Disjoint matches: overlapping occurrences are not counted. 4 occurrences 83. Regex with character repetition Declare regular expression r matching strings “http”, “htttp”, “httttp”, etc. 正则表达式匹配重复字符 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"regexp\")func main() &#123; r := regexp.MustCompile(\"htt+p\") for _, s := range []string&#123; \"hp\", \"htp\", \"http\", \"htttp\", \"httttp\", \"htttttp\", \"htttttp\", \"word htttp in a sentence\", &#125; &#123; fmt.Println(s, \"=&gt;\", r.MatchString(s)) &#125;&#125; 12345678hp =&gt; falsehtp =&gt; falsehttp =&gt; truehtttp =&gt; truehttttp =&gt; truehtttttp =&gt; truehtttttp =&gt; trueword htttp in a sentence =&gt; true 12345678910extern crate regex;use regex::Regex;fn main() &#123; let r = Regex::new(r\"htt+p\").unwrap(); assert!(r.is_match(\"http\")); assert!(r.is_match(\"htttp\")); assert!(r.is_match(\"httttp\"));&#125; 84. Count bits set in integer binary representationCount number c of 1s in the integer i in base 2.E.g. i=6 → c=2 计算十进制整型的二进制表示中 1的个数 12345678910111213141516171819202122232425262728293031323334353637package mainimport \"fmt\"func PopCountUInt64(i uint64) (c int) &#123; // bit population count, see // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel i -= (i &gt;&gt; 1) &amp; 0x5555555555555555 i = (i&gt;&gt;2)&amp;0x3333333333333333 + i&amp;0x3333333333333333 i += i &gt;&gt; 4 i &amp;= 0x0f0f0f0f0f0f0f0f i *= 0x0101010101010101 return int(i &gt;&gt; 56)&#125;func PopCountUInt32(i uint32) (n int) &#123; // bit population count, see // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel i -= (i &gt;&gt; 1) &amp; 0x55555555 i = (i&gt;&gt;2)&amp;0x33333333 + i&amp;0x33333333 i += i &gt;&gt; 4 i &amp;= 0x0f0f0f0f i *= 0x01010101 return int(i &gt;&gt; 24)&#125;func main() &#123; for i := uint64(0); i &lt; 16; i++ &#123; c := PopCountUInt64(i) fmt.Printf(\"%4d %04[1]b %d\\n\", i, c) &#125; for i := uint32(0); i &lt; 16; i++ &#123; c := PopCountUInt32(i) fmt.Printf(\"%4d %04[1]b %d\\n\", i, c) &#125;&#125; 1234567891011121314151617181920212223242526272829303132 0 0000 0 1 0001 1 2 0010 1 3 0011 2 4 0100 1 5 0101 2 6 0110 2 7 0111 3 8 1000 1 9 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 0 0000 0 1 0001 1 2 0010 1 3 0011 2 4 0100 1 5 0101 2 6 0110 2 7 0111 3 8 1000 1 9 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 This was useful only before go 1.9.See math/bits.OnesCount instead or 12345678910111213package mainimport ( \"fmt\" \"math/bits\")func main() &#123; for i := uint(0); i &lt; 16; i++ &#123; c := bits.OnesCount(i) fmt.Printf(\"%4d %04[1]b %d\\n\", i, c) &#125;&#125; 12345678910111213141516 0 0000 0 1 0001 1 2 0010 1 3 0011 2 4 0100 1 5 0101 2 6 0110 2 7 0111 3 8 1000 1 9 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 123fn main() &#123; println!(\"&#123;&#125;\", 6usize.count_ones())&#125; 2 85. Check if integer addition will overflow检查两个整型相加是否溢出 12345678910111213141516package mainimport ( \"fmt\" \"math\")func willAddOverflow(a, b int64) bool &#123; return a &gt; math.MaxInt64-b&#125;func main() &#123; fmt.Println(willAddOverflow(11111111111111111, 2))&#125; false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586fn adding_will_overflow(x: usize, y: usize) -&gt; bool &#123; x.checked_add(y).is_none()&#125;fn main() &#123; &#123; let (x, y) = (2345678, 9012345); let overflow = adding_will_overflow(x, y); println!( \"&#123;&#125; + &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (2345678901, 9012345678); let overflow = adding_will_overflow(x, y); println!( \"&#123;&#125; + &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (2345678901234, 9012345678901); let overflow = adding_will_overflow(x, y); println!( \"&#123;&#125; + &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (23456789012345678, 90123456789012345); let overflow = adding_will_overflow(x, y); println!( \"&#123;&#125; + &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (12345678901234567890, 9012345678901234567); let overflow = adding_will_overflow(x, y); println!( \"&#123;&#125; + &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125;&#125; 123452345678 + 9012345 doesn't overflow2345678901 + 9012345678 doesn't overflow2345678901234 + 9012345678901 doesn't overflow23456789012345678 + 90123456789012345 doesn't overflow12345678901234567890 + 9012345678901234567 overflows 86. Check if integer multiplication will overflow检查整型相乘是否溢出 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\")func multiplyWillOverflow(x, y uint64) bool &#123; if x &lt;= 1 || y &lt;= 1 &#123; return false &#125; d := x * y return d/y != x&#125;func main() &#123; &#123; var x, y uint64 = 2345, 6789 if multiplyWillOverflow(x, y) &#123; fmt.Println(x, \"*\", y, \"overflows\") &#125; else &#123; fmt.Println(x, \"*\", y, \"doesn't overflow\") &#125; &#125; &#123; var x, y uint64 = 2345678, 9012345 if multiplyWillOverflow(x, y) &#123; fmt.Println(x, \"*\", y, \"overflows\") &#125; else &#123; fmt.Println(x, \"*\", y, \"doesn't overflow\") &#125; &#125; &#123; var x, y uint64 = 2345678901, 9012345678 if multiplyWillOverflow(x, y) &#123; fmt.Println(x, \"*\", y, \"overflows\") &#125; else &#123; fmt.Println(x, \"*\", y, \"doesn't overflow\") &#125; &#125;&#125; 1232345 * 6789 doesn't overflow2345678 * 9012345 doesn't overflow2345678901 * 9012345678 overflows 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354fn main() &#123; &#123; let (x, y) = (2345, 6789); let overflow = multiply_will_overflow(x, y); println!( \"&#123;&#125; * &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (2345678, 9012345); let overflow = multiply_will_overflow(x, y); println!( \"&#123;&#125; * &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125; &#123; let (x, y) = (2345678901, 9012345678); let overflow = multiply_will_overflow(x, y); println!( \"&#123;&#125; * &#123;&#125; &#123;&#125;\", x, y, if overflow &#123; \"overflows\" &#125; else &#123; \"doesn't overflow\" &#125; ); &#125;&#125;fn multiply_will_overflow(x: i64, y: i64) -&gt; bool &#123; x.checked_mul(y).is_none()&#125; 1232345 * 6789 doesn't overflow2345678 * 9012345 doesn't overflow2345678901 * 9012345678 overflows 87. Stop program Exit immediately. If some extra cleanup work is executed by the program runtime (not by the OS itself), describe it. 停止程序,立即退出。 12345678910package mainimport \"os\"func main() &#123; os.Exit(1) print(2222)&#125; 1234fn main() &#123; std::process::exit(1); println!(\"42\");&#125; 88. Allocate 1M bytes分配1M内存 1234567891011121314package mainimport \"fmt\"func main() &#123; buf := make([]byte, 1000000) for i, b := range buf &#123; if b != 0 &#123; fmt.Println(\"Found unexpected value\", b, \"at position\", i) &#125; &#125; fmt.Println(\"Buffer was correctly initialized with zero values.\")&#125; Buffer was correctly initialized with zero values. 1234fn main() &#123; let buf: Vec&lt;u8&gt; = Vec::with_capacity(1024 * 1024); println!(\"&#123;:?&#125;\", buf.capacity());&#125; 1048576 89. Handle invalid argument处理无效参数 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"// NewSquareMatrix creates a N-by-N matrixfunc NewSquareMatrix(N int) ([][]float64, error) &#123; if N &lt; 0 &#123; return nil, fmt.Errorf(\"Invalid size %d: order cannot be negative\", N) &#125; matrix := make([][]float64, N) for i := range matrix &#123; matrix[i] = make([]float64, N) &#125; return matrix, nil&#125;func main() &#123; N1 := 3 matrix1, err1 := NewSquareMatrix(N1) if err1 == nil &#123; fmt.Println(matrix1) &#125; else &#123; fmt.Println(err1) &#125; N2 := -2 matrix2, err2 := NewSquareMatrix(N2) if err2 == nil &#123; fmt.Println(matrix2) &#125; else &#123; fmt.Println(err2) &#125;&#125; 12[[0 0 0] [0 0 0] [0 0 0]]Invalid size -2: order cannot be negative 123456#[derive(Debug, PartialEq, Eq)]enum CustomError &#123; InvalidAnswer &#125;fn do_stuff(x: i32) -&gt; Result&lt;i32, CustomError&gt; &#123; if x != 42 &#123;%2 90. Read-only outside外部只读 1234567type Foo struct &#123; x int&#125;func (f *Foo) X() int &#123; return f.x&#125; 12x is private, because it is not capitalized.(*Foo).X is a public getter (a read accessor). 12345678910111213struct Foo &#123; x: usize&#125;impl Foo &#123; pub fn new(x: usize) -&gt; Self &#123; Foo &#123; x &#125; &#125; pub fn x&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a usize &#123; &amp;self.x &#125;&#125; 91. Load JSON file into structjson转结构体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport \"fmt\"import \"io/ioutil\"import \"encoding/json\"func readJSONFile() error &#123; var x Person buffer, err := ioutil.ReadFile(filename) if err != nil &#123; return err &#125; err = json.Unmarshal(buffer, &amp;x) if err != nil &#123; return err &#125; fmt.Println(x) return nil&#125;func main() &#123; err := readJSONFile() if err != nil &#123; panic(err) &#125;&#125;type Person struct &#123; FirstName string Age int&#125;const filename = \"/tmp/data.json\"func init() &#123; err := ioutil.WriteFile(filename, []byte(` &#123; \"FirstName\":\"Napoléon\", \"Age\": 51 &#125;`), 0644) if err != nil &#123; panic(err) &#125;&#125; {Napoléon 51} or 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"os\")func readJSONFile() error &#123; var x Person r, err := os.Open(filename) if err != nil &#123; return err &#125; decoder := json.NewDecoder(r) err = decoder.Decode(&amp;x) if err != nil &#123; return err &#125; fmt.Println(x) return nil&#125;func main() &#123; err := readJSONFile() if err != nil &#123; panic(err) &#125;&#125;type Person struct &#123; FirstName string Age int&#125;const filename = \"/tmp/data.json\"func init() &#123; err := ioutil.WriteFile(filename, []byte(` &#123; \"FirstName\":\"Napoléon\", \"Age\": 51 &#125;`), 0644) if err != nil &#123; panic(err) &#125;&#125; {Napoléon 51} 1234#[macro_use] extern crate serde_derive;extern crate serde_json;use std::fs::File;let x = ::serde_json::from_reader(File::open(\"data.json\")?)?; 92. Save object into JSON file将json对象写入文件 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"import \"io/ioutil\"import \"encoding/json\"func writeJSONFile() error &#123; x := Person&#123; FirstName: \"Napoléon\", Age: 51, &#125; buffer, err := json.MarshalIndent(x, \"\", \" \") if err != nil &#123; return err &#125; return ioutil.WriteFile(filename, buffer, 0644)&#125;func main() &#123; err := writeJSONFile() if err != nil &#123; panic(err) &#125; fmt.Println(\"Done.\")&#125;type Person struct &#123; FirstName string Age int&#125;const filename = \"/tmp/data.json\" json.MarshalIndent is more human-readable than json.Marshal. Done. 12345extern crate serde_json;#[macro_use] extern crate serde_derive;use std::fs::File;::serde_json::to_writer(&amp;File::create(\"data.json\")?, &amp;x)? 93. Pass a runnable procedure as parameter Implement procedure control which receives one parameter f, and runs f. 以函数作为参数 1234567891011121314151617package mainimport \"fmt\"func main() &#123; control(greet)&#125;func control(f func()) &#123; fmt.Println(\"Before f\") f() fmt.Println(\"After f\")&#125;func greet() &#123; fmt.Println(\"Hello, developers\")&#125; Go supports first class functions, higher-order functions, user-defined function types, function literals, and closures. 123Before fHello, developersAfter f 123456789101112fn control(f: impl Fn()) &#123; f();&#125;fn hello() &#123; println!(\"Hello,\");&#125;fn main() &#123; control(hello); control(|| &#123; println!(\"Is there anybody in there?\"); &#125;);&#125; 12Hello,Is there anybody in there? 94. Print type of variable打印变量的类型 1234567891011121314151617181920package mainimport ( \"fmt\" \"os\" \"reflect\")func main() &#123; var x interface&#123;&#125; x = \"Hello\" fmt.Println(reflect.TypeOf(x)) x = 4 fmt.Println(reflect.TypeOf(x)) x = os.NewFile(0777, \"foobar.txt\") fmt.Println(reflect.TypeOf(x))&#125; 123stringint*os.File or 12345678910111213141516171819202122package mainimport ( \"fmt\" \"os\")func main() &#123; var x interface&#123;&#125; x = \"Hello\" fmt.Printf(\"%T\", x) fmt.Println() x = 4 fmt.Printf(\"%T\", x) fmt.Println() x = os.NewFile(0777, \"foobar.txt\") fmt.Printf(\"%T\", x) fmt.Println()&#125; 123stringint*os.File 12345678910#![feature(core_intrinsics)]fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(\"&#123;&#125;\", std::intrinsics::type_name::&lt;T&gt;())&#125;fn main() &#123; let x: i32 = 1; println!(\"&#123;&#125;\", type_of(&amp;x));&#125; i32 95. Get file size获取文件的大小 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"io/ioutil\" \"os\")func main() &#123; err := printSize(\"file.txt\") if err != nil &#123; panic(err) &#125;&#125;func printSize(path string) error &#123; info, err := os.Stat(path) if err != nil &#123; return err &#125; x := info.Size() fmt.Println(x) return nil&#125;func init() &#123; // The file will only contains the characters \"Hello\", no newlines. buffer := []byte(\"Hello\") err := ioutil.WriteFile(\"file.txt\", buffer, 0644) if err != nil &#123; panic(err) &#125;&#125; 5 123456789101112use std::fs;fn filesize(path: &amp;str) -&gt; Result&lt;u64, std::io::Error&gt; &#123; let x = fs::metadata(path)?.len(); Ok(x)&#125;fn main() &#123; let path = \"/etc/hosts\"; let x = filesize(path); println!(\"&#123;&#125;: &#123;:?&#125; bytes\", path, x.unwrap());&#125; /etc/hosts: 150 bytes or 123456789101112use std::path::Path;fn filesize(path: &amp;std::path::Path) -&gt; Result&lt;u64, std::io::Error&gt; &#123; let x = path.metadata()?.len(); Ok(x)&#125;fn main() &#123; let path = Path::new(\"/etc/hosts\"); let x = filesize(path); println!(\"&#123;:?&#125;: &#123;:?&#125; bytes\", path, x.unwrap());&#125; &quot;/etc/hosts&quot;: 150 bytes 96. Check string prefix Set boolean b to true if string s starts with prefix prefix, false otherwise. 检查两个字符串前缀是否一致 12345678910111213141516171819202122package mainimport ( \"fmt\" \"strings\")func check(s, prefix string) &#123; b := strings.HasPrefix(s, prefix) if b &#123; fmt.Println(s, \"starts with\", prefix) &#125; else &#123; fmt.Println(s, \"doesn't start with\", prefix) &#125;&#125;func main() &#123; check(\"bar\", \"foo\") check(\"foobar\", \"foo\")&#125; 12bar doesn't start with foofoobar starts with foo 12345678fn main() &#123; let s = \"bananas\"; let prefix = \"bana\"; let b = s.starts_with(prefix); println!(\"&#123;:?&#125;\", b);&#125; true 97. Check string suffix Set boolean b to true if string s ends with string suffix, false otherwise. 检查字符串后缀 12345678910111213141516171819202122package mainimport ( \"fmt\" \"strings\")func check(s, suffix string) &#123; b := strings.HasSuffix(s, suffix) if b &#123; fmt.Println(s, \"ends with\", suffix) &#125; else &#123; fmt.Println(s, \"doesn't end with\", suffix) &#125;&#125;func main() &#123; check(\"foo\", \"bar\") check(\"foobar\", \"bar\")&#125; 12foo doesn't end with barfoobar ends with bar 12345678fn main() &#123; let s = \"bananas\"; let suffix = \"nas\"; let b = s.ends_with(suffix); println!(\"&#123;:?&#125;\", b);&#125; true 98. Epoch seconds to date object Convert a timestamp ts (number of seconds in epoch-time) to a date with time d. E.g. 0 -&gt; 1970-01-01 00:00:00 时间戳转日期 12345678910111213package mainimport ( \"fmt\" \"time\")func main() &#123; ts := int64(1451606400) d := time.Unix(ts, 0) fmt.Println(d)&#125; 2016-01-01 00:00:00 +0000 UTC 12345678extern crate chrono;use chrono::prelude::*;fn main() &#123; let ts = 1451606400; let d = NaiveDateTime::from_timestamp(ts, 0); println!(\"&#123;&#125;\", d);&#125; 2016-01-01 00:00:00 99. Format date YYYY-MM-DD Assign to string x the value of fields (year, month, day) of date d, in format YYYY-MM-DD. 时间格式转换 1234567891011121314package mainimport ( \"fmt\" \"time\")func main() &#123; d := time.Now() x := d.Format(\"2006-01-02\") fmt.Println(x) // The output may be \"2009-11-10\" because the Playground's clock is fixed in the past.&#125; 2009-11-10 1234567extern crate chrono;use chrono::prelude::*;fn main() &#123; println!(\"&#123;&#125;\", Utc::today().format(\"%Y-%m-%d\"))&#125; 2021-07-17 100. Sort by a comparator Sort elements of array-like collection items, using a comparator c. 根据某个字段排序 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"import \"sort\"type Item struct &#123; label string p int lang string&#125;// c returns true if x is \"inferior to\" y (in a custom way)func c(x, y Item) bool &#123; return x.p &lt; y.p&#125;type ItemCSorter []Itemfunc (s ItemCSorter) Len() int &#123; return len(s) &#125;func (s ItemCSorter) Less(i, j int) bool &#123; return c(s[i], s[j]) &#125;func (s ItemCSorter) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125;func sortItems(items []Item) &#123; sorter := ItemCSorter(items) sort.Sort(sorter)&#125;func main() &#123; items := []Item&#123; &#123;\"twelve\", 12, \"english\"&#125;, &#123;\"six\", 6, \"english\"&#125;, &#123;\"eleven\", 11, \"english\"&#125;, &#123;\"zero\", 0, \"english\"&#125;, &#123;\"two\", 2, \"english\"&#125;, &#125; fmt.Println(\"Unsorted: \", items) sortItems(items) fmt.Println(\"Sorted: \", items)&#125; c has type func(Item, Item) bool. 12Unsorted: [&#123;twelve 12 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;zero 0 english&#125; &#123;two 2 english&#125;]Sorted: [&#123;zero 0 english&#125; &#123;two 2 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;twelve 12 english&#125;] or 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport \"fmt\"import \"sort\"type Item struct &#123; label string p int lang string&#125;type ItemsSorter struct &#123; items []Item c func(x, y Item) bool&#125;func (s ItemsSorter) Len() int &#123; return len(s.items) &#125;func (s ItemsSorter) Less(i, j int) bool &#123; return s.c(s.items[i], s.items[j]) &#125;func (s ItemsSorter) Swap(i, j int) &#123; s.items[i], s.items[j] = s.items[j], s.items[i] &#125;func sortItems(items []Item, c func(x, y Item) bool) &#123; sorter := ItemsSorter&#123; items, c, &#125; sort.Sort(sorter)&#125;func main() &#123; items := []Item&#123; &#123;\"twelve\", 12, \"english\"&#125;, &#123;\"six\", 6, \"english\"&#125;, &#123;\"eleven\", 11, \"english\"&#125;, &#123;\"zero\", 0, \"english\"&#125;, &#123;\"two\", 2, \"english\"&#125;, &#125; fmt.Println(\"Unsorted: \", items) c := func(x, y Item) bool &#123; return x.p &lt; y.p &#125; sortItems(items, c) fmt.Println(\"Sorted: \", items)&#125; ItemsSorter contains c, which can be any comparator decided at runtime. 12Unsorted: [&#123;twelve 12 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;zero 0 english&#125; &#123;two 2 english&#125;]Sorted: [&#123;zero 0 english&#125; &#123;two 2 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;twelve 12 english&#125;] or 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"import \"sort\"type Item struct &#123; label string p int lang string&#125;// c returns true if x is \"inferior to\" y (in a custom way)func c(x, y Item) bool &#123; return x.p &lt; y.p&#125;func main() &#123; items := []Item&#123; &#123;\"twelve\", 12, \"english\"&#125;, &#123;\"six\", 6, \"english\"&#125;, &#123;\"eleven\", 11, \"english\"&#125;, &#123;\"zero\", 0, \"english\"&#125;, &#123;\"two\", 2, \"english\"&#125;, &#125; fmt.Println(\"Unsorted: \", items) sort.Slice(items, func(i, j int) bool &#123; return c(items[i], items[j]) &#125;) fmt.Println(\"Sorted: \", items)&#125; Since Go 1.8, a single func parameter is sufficient to sort a slice. 12Unsorted: [&#123;twelve 12 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;zero 0 english&#125; &#123;two 2 english&#125;]Sorted: [&#123;zero 0 english&#125; &#123;two 2 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;twelve 12 english&#125;] 12345fn main() &#123; let mut items = [1, 7, 5, 2, 3]; items.sort_by(i32::cmp); println!(\"&#123;:?&#125;\", items);&#125; [1, 2, 3, 5, 7]","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(4)","date":"2021-09-05T13:40:04.000Z","path":"2021/09/05/Rust-vs-Go-常用语法对比-4/","text":"61. Get current date获取当前时间 123456789101112package mainimport ( \"fmt\" \"time\")func main() &#123; d := time.Now() fmt.Println(\"Now is\", d) // The Playground has a special sandbox, so you may get a Time value fixed in the past.&#125; Now is 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 12extern crate time;let d = time::now(); or 123456use std::time::SystemTime;fn main() &#123; let d = SystemTime::now(); println!(\"&#123;:?&#125;\", d);&#125; SystemTime { tv_sec: 1526318418, tv_nsec: 699329521 } 62. Find substring position字符串查找 查找子字符串位置 12345678910111213141516171819202122package mainimport ( \"fmt\" \"strings\")func main() &#123; x := \"été chaud\" &#123; y := \"chaud\" i := strings.Index(x, y) fmt.Println(i) &#125; &#123; y := \"froid\" i := strings.Index(x, y) fmt.Println(i) &#125;&#125; i is the byte index of y in x, not the character (rune) index.i will be -1 if y is not found in x. 126-1 1234567891011fn main() &#123; let x = \"été chaud\"; let y = \"chaud\"; let i = x.find(y); println!(\"&#123;:?&#125;\", i); let y = \"froid\"; let i = x.find(y); println!(\"&#123;:?&#125;\", i);&#125; 12Some(6)None 63. Replace fragment of a string替换字符串片段 1234567891011121314package mainimport ( \"fmt\" \"strings\")func main() &#123; x := \"oink oink oink\" y := \"oink\" z := \"moo\" x2 := strings.Replace(x, y, z, -1) fmt.Println(x2)&#125; moo moo moo 123456789fn main() &#123; let x = \"lorem ipsum dolor lorem ipsum\"; let y = \"lorem\"; let z = \"LOREM\"; let x2 = x.replace(&amp;y, &amp;z); println!(\"&#123;&#125;\", x2);&#125; LOREM ipsum dolor LOREM ipsum 64. Big integer : value 3 power 247超大整数 12345678910package mainimport \"fmt\"import \"math/big\"func main() &#123; x := new(big.Int) x.Exp(big.NewInt(3), big.NewInt(247), nil) fmt.Println(x)&#125; 7062361041362837614435796717454722507454089864783271756927542774477268334591598635421519542453366332460075473278915787 12345678extern crate num;use num::bigint::ToBigInt;fn main() &#123; let a = 3.to_bigint().unwrap(); let x = num::pow(a, 247); println!(\"&#123;&#125;\", x)&#125; 7062361041362837614435796717454722507454089864783271756927542774477268334591598635421519542453366332460075473278915787 65. Format decimal number格式化十进制数 123456789package mainimport \"fmt\"func main() &#123; x := 0.15625 s := fmt.Sprintf(\"%.1f%%\", 100.0*x) fmt.Println(s)&#125; 15.6% 123456fn main() &#123; let x = 0.15625f64; let s = format!(\"&#123;:.1&#125;%\", 100.0 * x); println!(\"&#123;&#125;\", s);&#125; 15.6% 66. Big integer exponentiation大整数幂运算 123456789101112131415161718package mainimport \"fmt\"import \"math/big\"func exp(x *big.Int, n int) *big.Int &#123; nb := big.NewInt(int64(n)) var z big.Int z.Exp(x, nb, nil) return &amp;z&#125;func main() &#123; x := big.NewInt(3) n := 5 z := exp(x, n) fmt.Println(z)&#125; 243 1234567extern crate num;use num::bigint::BigInt;fn main() &#123; let x = BigInt::parse_bytes(b\"600000000000\", 10).unwrap(); let n = 42% 67. Binomial coefficient “n choose k” Calculate binom(n, k) = n! / (k! * (n-k)!). Use an integer type able to handle huge numbers. 二项式系数“n选择k” 12345678910111213141516package mainimport ( \"fmt\" \"math/big\")func main() &#123; z := new(big.Int) z.Binomial(4, 2) fmt.Println(z) z.Binomial(133, 71) fmt.Println(z)&#125; 126555687036928510235891585199545206017600 123456789101112131415161718192021extern crate num;use num::bigint::BigInt;use num::bigint::ToBigInt;use num::traits::One;fn binom(n: u64, k: u64) -&gt; BigInt &#123; let mut res = BigInt::one(); for i in 0..k &#123; res = (res * (n - i).to_bigint().unwrap()) / (i + 1).to_bigint().unwrap(); &#125; res&#125;fn main() &#123; let n = 133; let k = 71; println!(\"&#123;&#125;\", binom(n, k));&#125; 555687036928510235891585199545206017600 68. Create a bitset创建位集合 12345678910111213141516package mainimport ( \"fmt\" \"math/big\")func main() &#123; var x *big.Int = new(big.Int) x.SetBit(x, 42, 1) for _, y := range []int&#123;13, 42&#125; &#123; fmt.Println(\"x has bit\", y, \"set to\", x.Bit(y)) &#125;&#125; 12x has bit 13 set to 0x has bit 42 set to 1 or 1234567891011121314151617package mainimport ( \"fmt\")const n = 1024func main() &#123; x := make([]bool, n) x[42] = true for _, y := range []int&#123;13, 42&#125; &#123; fmt.Println(\"x has bit\", y, \"set to\", x[y]) &#125;&#125; 12x has bit 13 set to falsex has bit 42 set to true or 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\")func main() &#123; const n = 1024 x := NewBitset(n) x.SetBit(13) x.SetBit(42) x.ClearBit(13) for _, y := range []int&#123;13, 42&#125; &#123; fmt.Println(\"x has bit\", y, \"set to\", x.GetBit(y)) &#125;&#125;type Bitset []uint64func NewBitset(n int) Bitset &#123; return make(Bitset, (n+63)/64)&#125;func (b Bitset) GetBit(index int) bool &#123; pos := index / 64 j := index % 64 return (b[pos] &amp; (uint64(1) &lt;&lt; j)) != 0&#125;func (b Bitset) SetBit(index int) &#123; pos := index / 64 j := index % 64 b[pos] |= (uint64(1) &lt;&lt; j)&#125;func (b Bitset) ClearBit(index int) &#123; pos := index / 64 j := index % 64 b[pos] ^= (uint64(1) &lt;&lt; j)&#125; 12x has bit 13 set to falsex has bit 42 set to true 12345678fn main() &#123; let n = 20; let mut x = vec![false; n]; x[3] = true; println!(\"&#123;:?&#125;\", x);&#125; [false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false] 69. Seed random generator Use seed s to initialize a random generator. If s is constant, the generator output will be the same each time the program runs. If s is based on the current value of the system clock, the generator output will be different each time. 随机种子生成器 123456789101112package mainimport ( \"fmt\" \"math/rand\")func main() &#123; var s int64 = 42 rand.Seed(s) fmt.Println(rand.Int())&#125; 3440579354231278675 or 123456789101112package mainimport ( \"fmt\" \"math/rand\")func main() &#123; var s int64 = 42 r := rand.New(rand.NewSource(s)) fmt.Println(r.Int())&#125; 3440579354231278675 12345678use rand::&#123;Rng, SeedableRng, rngs::StdRng&#125;;fn main() &#123; let s = 32; let mut rng = StdRng::seed_from_u64(s); println!(\"&#123;:?&#125;\", rng.gen::&lt;f32&gt;());&#125; 0.35038823 70. Use clock as random generator seed Get the current datetime and provide it as a seed to a random generator. The generator sequence will be different at each run. 使用时钟作为随机生成器的种子 123456789101112131415package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; rand.Seed(time.Now().UnixNano()) // Well, the playground date is actually fixed in the past, and the // output is cached. // But if you run this on your workstation, the output will vary. fmt.Println(rand.Intn(999))&#125; 524 or 123456789101112131415package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) // Well, the playground date is actually fixed in the past, and the // output is cached. // But if you run this on your workstation, the output will vary. fmt.Println(r.Intn(999))&#125; 524 1234567891011use rand::&#123;Rng, SeedableRng, rngs::StdRng&#125;;use std::time::SystemTime;fn main() &#123; let d = SystemTime::now() .duration_since(SystemTime::UNIX_EPOCH) .expect(\"Duration since UNIX_EPOCH failed\"); let mut rng = StdRng::seed_from_u64(d.as_secs()); println!(\"&#123;:?&#125;\", rng.gen::&lt;f32&gt;());&#125; 0.7326781 71. Echo program implementation Basic implementation of the Echo program: Print all arguments except the program name, separated by space, followed by newline.The idiom demonstrates how to skip the first argument if necessary, concatenate arguments as strings, append newline and print it to stdout. 实现 Echo 程序 1234567package mainimport \"fmt\"import \"os\"import \"strings\"func main() &#123; fmt.Println(strings.Join(os.Args[1:], \" \"))&#125; 12345use std::env;fn main() &#123; println!(\"&#123;&#125;\", env::args().skip(1).collect::&lt;Vec&lt;_&gt;&gt;().join(\" \"));&#125; or 12use itertools::Itertools;println!(\"&#123;&#125;\", std::env::args().skip(1).format(\" \")); 74. Compute GCD Compute the greatest common divisor x of big integers a and b. Use an integer type able to handle huge numbers. 计算大整数a和b的最大公约数x。使用能够处理大数的整数类型。 123456789101112package mainimport \"fmt\"import \"math/big\"func main() &#123; a, b, x := new(big.Int), new(big.Int), new(big.Int) a.SetString(\"6000000000000\", 10) b.SetString(\"9000000000000\", 10) x.GCD(nil, nil, a, b) fmt.Println(x)&#125; 3000000000000 12345678910111213extern crate num;use num::Integer;use num::bigint::BigInt;fn main() &#123; let a = BigInt::parse_bytes(b\"6000000000000\", 10).unwrap(); let b = BigInt::parse_bytes(b\"9000000000000\", 10).unwrap(); let x = a.gcd(&amp;b); println!(\"&#123;&#125;\", x);&#125; 3000000000000 75. Compute LCM计算大整数a和b的最小公倍数x。使用能够处理大数的整数类型。 Compute the least common multiple x of big integers a and b. Use an integer type able to handle huge numbers. 12345678910111213package mainimport \"fmt\"import \"math/big\"func main() &#123; a, b, gcd, x := new(big.Int), new(big.Int), new(big.Int), new(big.Int) a.SetString(\"6000000000000\", 10) b.SetString(\"9000000000000\", 10) gcd.GCD(nil, nil, a, b) x.Div(a, gcd).Mul(x, b) fmt.Println(x)&#125; 18000000000000 1234567891011extern crate num;use num::bigint::BigInt;use num::Integer;fn main() &#123; let a = BigInt::parse_bytes(b\"6000000000000\", 10).unwrap(); let b = BigInt::parse_bytes(b\"9000000000000\", 10).unwrap(); let x = a.lcm(&amp;b); println!(\"x = &#123;&#125;\", x);&#125; x = 18000000000000 76. Binary digits from an integer Create the string s of integer x written in base 2. E.g. 13 -&gt; “1101” 将十进制整数转换为二进制数字 1234567891011package mainimport \"fmt\"import \"strconv\"func main() &#123; x := int64(13) s := strconv.FormatInt(x, 2) fmt.Println(s)&#125; 1101 or 12345678910111213package mainimport ( \"fmt\" \"math/big\")func main() &#123; x := big.NewInt(13) s := fmt.Sprintf(\"%b\", x) fmt.Println(s)&#125; 1101 123456fn main() &#123; let x = 13; let s = format!(\"&#123;:b&#125;\", x); println!(\"&#123;&#125;\", s);&#125; 1101 77. SComplex number Declare a complex x and initialize it with value (3i - 2). Then multiply it by i. 复数 1234567891011121314package mainimport ( \"fmt\" \"reflect\")func main() &#123; x := 3i - 2 x *= 1i fmt.Println(x) fmt.Print(reflect.TypeOf(x))&#125; 12(-3-2i)complex128 12345678extern crate num;use num::Complex;fn main() &#123; let mut x = Complex::new(-2, 3); x *= Complex::i(); println!(\"&#123;&#125;\", x);&#125; -3-2i 78. “do while” loop Execute a block once, then execute it again as long as boolean condition c is true. 循环执行 123456789101112131415161718192021package mainimport ( \"fmt\" \"math/rand\")func main() &#123; for &#123; x := rollDice() fmt.Println(\"Got\", x) if x == 3 &#123; break &#125; &#125;&#125;func rollDice() int &#123; return 1 + rand.Intn(6)&#125; Go has no do while loop, use the for loop, instead. 12345678Got 6Got 4Got 6Got 6Got 2Got 1Got 2Got 3 or 123456789101112131415161718package mainimport ( \"fmt\" \"math/rand\")func main() &#123; for done := false; !done; &#123; x := rollDice() fmt.Println(\"Got\", x) done = x == 3 &#125;&#125;func rollDice() int &#123; return 1 + rand.Intn(6)&#125; 12345678Got 6Got 4Got 6Got 6Got 2Got 1Got 2Got 3 1234loop &#123; doStuff(); if !c &#123; break; &#125;&#125; Rust has no do-while loop with syntax sugar. Use loop and break. 79. Convert integer to floating point number Declare floating point number y and initialize it with the value of integer x . 整型转浮点型 声明浮点数y并用整数x的值初始化它。 123456789101112131415package mainimport ( \"fmt\" \"reflect\")func main() &#123; x := 5 y := float64(x) fmt.Println(y) fmt.Printf(\"%.2f\\n\", y) fmt.Println(reflect.TypeOf(y))&#125; 12355.00float64 123456fn main() &#123; let i = 5; let f = i as f64; println!(\"int &#123;:?&#125;, float &#123;:?&#125;\", i, f);&#125; 1int 5, float 5.0 80. Truncate floating point number to integer Declare integer y and initialize it with the value of floating point number x . Ignore non-integer digits of x .Make sure to truncate towards zero: a negative x must yield the closest greater integer (not lesser). 浮点型转整型 123456789101112package mainimport \"fmt\"func main() &#123; a := -6.4 b := 6.4 c := 6.6 fmt.Println(int(a)) fmt.Println(int(b)) fmt.Println(int(c))&#125; 123-666 12345fn main() &#123; let x = 41.59999999f64; let y = x as i32; println!(\"&#123;&#125;\", y);&#125; 41","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(3)","date":"2021-09-04T12:51:13.000Z","path":"2021/09/04/Rust-vs-Go-常用语法对比-3/","text":"41. Reverse a string反转字符串 123456789101112131415161718package mainimport \"fmt\"func Reverse(s string) string &#123; runes := []rune(s) for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 &#123; runes[i], runes[j] = runes[j], runes[i] &#125; return string(runes)&#125;func main() &#123; input := \"The quick brown 狐 jumped over the lazy 犬\" fmt.Println(Reverse(input)) // Original string unaltered fmt.Println(input)&#125; 输出 12犬 yzal eht revo depmuj 狐 nworb kciuq ehTThe quick brown 狐 jumped over the lazy 犬 1let t = s.chars().rev().collect::&lt;String&gt;(); or 12345fn main() &#123; let s = \"lorém ipsüm dolör sit amor ❤ \"; let t: String = s.chars().rev().collect(); println!(\"&#123;&#125;\", t);&#125; 输出 ❤ roma tis rölod müspi mérol 42. Continue outer loop Print each item v of list a which in not contained in list b.For this, write an outer loop to iterate on a and an inner loop to iterate on b. 打印列表a中不包含在列表b中的每个项目v。为此，编写一个外部循环来迭代a，编写一个内部循环来迭代b。 123456789101112131415161718192021package mainimport \"fmt\"func printSubtraction(a []int, b []int) &#123;mainloop: for _, v := range a &#123; for _, w := range b &#123; if v == w &#123; continue mainloop &#125; &#125; fmt.Println(v) &#125;&#125;func main() &#123; a := []int&#123;1, 2, 3, 4&#125; b := []int&#123;2, 4, 6, 8&#125; printSubtraction(a, b)&#125; mainloop is a label used to refer to the outer loop. 输出 1213 12345678910111213fn main() &#123; let a = ['a', 'b', 'c', 'd', 'e']; let b = [ 'b', 'd' ]; 'outer: for va in &amp;a &#123; for vb in &amp;b &#123; if va == vb &#123; continue 'outer; &#125; &#125; println!(\"&#123;&#125;\", va); &#125;&#125; ‘outer is a label used to refer to the outer loop. Labels in Rust start with a ‘. 输出 123ace 43. Break outer loop Look for a negative value v in 2D integer matrix m. Print it and stop searching. 在2D整数矩阵m中寻找一个负值v，打印出来，停止搜索。 1234567891011121314151617181920212223242526package mainimport \"fmt\"import \"os\"var m = [][]int&#123; &#123;1, 2, 3&#125;, &#123;11, 0, 30&#125;, &#123;5, -20, 55&#125;, &#123;0, 0, -60&#125;,&#125;func main() &#123;mainloop: for i, line := range m &#123; fmt.Fprintln(os.Stderr, \"Searching in line\", i) for _, v := range line &#123; if v &lt; 0 &#123; fmt.Println(\"Found \", v) break mainloop &#125; &#125; &#125; fmt.Println(\"Done.\")&#125; mainloop is a label used to refer to the outer loop. 输出 12345Searching in line 0Searching in line 1Searching in line 2Found -20Done. 1234567891011121314151617fn main() &#123; let m = vec![ vec![1, 2, 3], vec![11, 0, 30], vec![5, -20, 55], vec![0, 0, -60], ]; 'outer: for v in m &#123; 'inner: for i in v &#123; if i &lt; 0 &#123; println!(\"Found &#123;&#125;\", i); break 'outer; &#125; &#125; &#125;&#125; Loop label syntax is similar to lifetimes. 输出 Found -20 44. Insert element in list Insert element x at position i in list s. Further elements must be shifted to the right. 在列表s的位置I插入元素x。其他元素必须向右移动。 12345678910111213141516171819package mainimport \"fmt\"func main() &#123; s := make([]int, 2) s[0] = 0 s[1] = 2 fmt.Println(s) // insert one at index one s = append(s, 0) copy(s[2:], s[1:]) s[1] = 1 fmt.Println(s)&#125; 输出 12[0 2][0 1 2] 12345678fn main() &#123; let mut vec = vec![1, 2, 3]; vec.insert(1, 4); assert_eq!(vec, [1, 4, 2, 3]); vec.insert(4, 5); assert_eq!(vec, [1, 4, 2, 3, 5]); &#125; 45. Pause execution for 5 seconds在继续下一个指令之前，在当前线程中休眠5秒钟。 1234567891011package mainimport ( \"fmt\" \"time\")func main() &#123; time.Sleep(5 * time.Second) fmt.Println(\"Done.\")&#125; 12use std::&#123;thread, time&#125;;thread::sleep(time::Duration::from_secs(5)); 46. Extract beginning of string (prefix) Create string t consisting of the 5 first characters of string s.Make sure that multibyte characters are properly handled. 创建由字符串s的前5个字符组成的字符串t。确保正确处理多字节字符。 12345678910package mainimport \"fmt\"func main() &#123; s := \"Привет\" t := string([]rune(s)[:5]) fmt.Println(t)&#125; 输出 1Приве 1234567fn main() &#123; let s = \"été 😁 torride\"; let t = s.char_indices().nth(5).map_or(s, |(i, _)| &amp;s[..i]); println!(\"&#123;&#125;\", t);&#125; 输出 été 😁 47. Extract string suffix Create string t consisting in the 5 last characters of string s.Make sure that multibyte characters are properly handled. 创建由字符串s的最后5个字符组成的字符串t。确保正确处理多字节字符 123456789package mainimport \"fmt\"func main() &#123; s := \"hello, world! 문자\" t := string([]rune(s)[len([]rune(s))-5:]) fmt.Println(t)&#125; 输出 d! 문자 123456fn main() &#123; let s = \"tükörfúrógép\"; let last5ch = s.chars().count() - 5; let s2: String = s.chars().skip(last5ch).collect(); println!(\"&#123;&#125;\", s2);&#125; 输出 rógép 48. Multi-line string literal Assign to variable s a string literal consisting in several lines of text, including newlines. 给变量s赋值一个由几行文本组成的字符串，包括换行符。 12345678910111213package mainimport ( \"fmt\")func main() &#123; s := `HueyDeweyLouie` fmt.Println(s)&#125; 输出 123HueyDeweyLouie 1234567fn main() &#123; let s = \"line 1line 2line 3\"; print!(\"&#123;&#125;\", &amp;s);&#125; 输出 123line 1line 2line 3 or 1234567fn main() &#123; let s = r#\"HueyDeweyLouie\"#; print!(\"&#123;&#125;\", &amp;s);&#125; 输出 123HueyDeweyLouie 49. Split a space-separated string拆分用空格分隔的字符串 Build list chunks consisting in substrings of input string s, separated by one or more space characters. 构建由输入字符串的子字符串组成的列表块，由一个或多个空格字符分隔。 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"Un dos tres\" chunks := strings.Split(s, \" \") fmt.Println(len(chunks)) fmt.Println(chunks) s = \" Un dos tres \" chunks = strings.Split(s, \" \") fmt.Println(len(chunks)) fmt.Println(chunks) s = \"Un dos\" chunks = strings.Split(s, \" \") fmt.Println(len(chunks)) fmt.Println(chunks)&#125; 输出 1234563[Un dos tres]5[ Un dos tres ]3[Un dos] or 12345678910111213package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"hello world\" chunks := strings.Fields(s) fmt.Println(chunks)&#125; 输出为 1[hello world] and 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"Un dos tres\" chunks := strings.Fields(s) fmt.Println(len(chunks)) fmt.Println(chunks) s = \" Un dos tres \" chunks = strings.Fields(s) fmt.Println(len(chunks)) fmt.Println(chunks) s = \"Un dos\" chunks = strings.Fields(s) fmt.Println(len(chunks)) fmt.Println(chunks)&#125; 输出 1234563[Un dos tres]3[Un dos tres]2[Un dos] strings.Fields 就只能干这个事儿 1234567fn main() &#123; let s = \"What a mess\"; let chunks: Vec&lt;_&gt; = s.split_whitespace().collect(); println!(\"&#123;:?&#125;\", chunks);&#125; 输出 1[\"What\", \"a\", \"mess\"] or 1234567fn main() &#123; let s = \"What a mess\"; let chunks: Vec&lt;_&gt; = s.split_ascii_whitespace().collect(); println!(\"&#123;:?&#125;\", chunks);&#125; 输出 1[\"What\", \"a\", \"mess\"] or 1234567fn main() &#123; let s = \"What a mess\"; let chunks: Vec&lt;_&gt; = s.split(' ').collect(); println!(\"&#123;:?&#125;\", chunks);&#125; 输出 1[\"What\", \"a\", \"\", \"mess\"] 50. Make an infinite loop写一个无限循环 123for &#123; // Do something&#125; 1234567891011121314package mainimport \"fmt\"func main() &#123; k := 0 for &#123; fmt.Println(\"Hello, playground\") k++ if k == 5 &#123; break &#125; &#125;&#125; 输出 12345Hello, playgroundHello, playgroundHello, playgroundHello, playgroundHello, playground 123loop &#123; // Do something&#125; 51. Check if map contains key Determine whether map m contains an entry for key k 检查map是否有某个key 123456789101112131415161718192021package mainimport ( \"fmt\")func main() &#123; m := map[string]int&#123; \"uno\": 1, \"dos\": 2, \"tres\": 3, &#125; k := \"cinco\" _, ok := m[k] fmt.Printf(\"m contains key %q: %v\\n\", k, ok) k = \"tres\" _, ok = m[k] fmt.Printf(\"m contains key %q: %v\\n\", k, ok)&#125; 输出 12m contains key \"cinco\": falsem contains key \"tres\": true 12345678910111213use std::collections::HashMap;fn main() &#123; let mut m = HashMap::new(); m.insert(1, \"a\"); m.insert(2, \"b\"); let k = 2; let hit = m.contains_key(&amp;k); println!(\"&#123;:?&#125;\", hit);&#125; 52. Check if map contains value检查map中是否有某个值 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\")func containsValue(m map[K]T, v T) bool &#123; for _, x := range m &#123; if x == v &#123; return true &#125; &#125; return false&#125;// Arbitrary types for K, T.type K stringtype T intfunc main() &#123; m := map[K]T&#123; \"uno\": 1, \"dos\": 2, \"tres\": 3, &#125; var v T = 5 ok := containsValue(m, v) fmt.Printf(\"m contains value %d: %v\\n\", v, ok) v = 3 ok = containsValue(m, v) fmt.Printf(\"m contains value %d: %v\\n\", v, ok)&#125; 输出 12m contains value 5: falsem contains value 3: true 12345678910111213141516171819use std::collections::BTreeMap;fn main() &#123; let mut m = BTreeMap::new(); m.insert(11, \"one\"); m.insert(22, \"twenty-two\"); &#123; let v = \"eight\"; let does_contain = m.values().any(|&amp;val| *val == *v); println!(\"&#123;:?&#125;\", does_contain); &#125; &#123; let v = \"twenty-two\"; let does_contain = m.values().any(|&amp;val| *val == *v); println!(\"&#123;:?&#125;\", does_contain); &#125;&#125; 53. Join a list of strings字符串连接 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; x := []string&#123;\"xxx\", \"bbb\", \"aaa\"&#125; y := strings.Join(x, \"&amp;\") fmt.Println(y)&#125; 输出 xxx&amp;bbb&amp;aaa 关于 strings.Joins 12345fn main() &#123; let x = vec![\"Lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\"]; let y = x.join(\", \"); println!(\"&#123;&#125;\", y);&#125; 输出 1Lorem, ipsum, dolor, sit, amet 54. Compute sum of integers计算整数之和 123456789101112package mainimport \"fmt\"func main() &#123; x := []int&#123;1, 2, 3&#125; s := 0 for _, v := range x &#123; s += v &#125; fmt.Println(s)&#125; 输出 6 12345fn main() &#123; let x: Vec&lt;usize&gt; = (0..=10_000).collect(); eprintln!(\"Sum of 0-10,000 = &#123;&#125;\", x.iter().sum::&lt;usize&gt;())&#125; 输出 Sum of 0-10,000 = 50005000 55. Convert integer to string将整数转换为字符串 123456789101112package mainimport ( \"fmt\" \"strconv\")func main() &#123; var i int = 1234 s := strconv.Itoa(i) fmt.Println(s)&#125; 输出 1234 or 123456789101112package mainimport ( \"fmt\" \"strconv\")func main() &#123; var i int64 = 1234 s := strconv.FormatInt(i, 10) fmt.Println(s)&#125; 输出 1234 or 123456789101112131415161718package mainimport \"fmt\"import \"math/big\"func main() &#123; var i int = 1234 s := fmt.Sprintf(\"%d\", i) fmt.Println(s) var j int = 5678 s = fmt.Sprintf(\"%d\", j) fmt.Println(s) var k *big.Int = big.NewInt(90123456) s = fmt.Sprintf(\"%d\", k) fmt.Println(s)&#125; 输出 1231234567890123456 123456fn main() &#123; let i = 123; let s = i.to_string(); println!(\"&#123;&#125;\", s);&#125; 输出 123 or 123456fn main() &#123; let i = 123; let s = format!(\"&#123;&#125;\", i); println!(\"&#123;&#125;\", s);&#125; 输出 123 56. Launch 1000 parallel tasks and wait for completion Fork-join : launch the concurrent execution of procedure f with parameter i from 1 to 1000.Tasks are independent and f(i) doesn’t return any value.Tasks need not run all at the same time, so you may use a pool.Wait for the completion of the 1000 tasks and then print “Finished”. 创建1000个并行任务，并等待其完成 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")func f(i int) &#123; d := rand.Int() % 10000 time.Sleep(time.Duration(d)) fmt.Printf(\"Hello %v\\n\", i)&#125;func main() &#123; var wg sync.WaitGroup wg.Add(1000) for i := 1; i &lt;= 1000; i++ &#123; go func(i int) &#123; f(i) wg.Done() &#125;(i) &#125; wg.Wait() fmt.Println(\"Finished\")&#125; 输出 12345Hello 741Hello 651Hello 49...（共计1000个）Hello xxx 12345678910111213use std::thread;fn f(i: i32) &#123; i + 1;&#125;fn main() &#123; let threads: Vec&lt;_&gt; = (0..10).map(|i| thread::spawn(move || f(i))).collect(); for t in threads &#123; t.join(); &#125;&#125; 57. Filter list Create list y containing items from list x satisfying predicate p. Respect original ordering. Don’t modify x in-place. 过滤list中的值 12345678910111213141516171819package mainimport \"fmt\"type T intfunc main() &#123; x := []T&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; p := func(t T) bool &#123; return t%2 == 0 &#125; y := make([]T, 0, len(x)) for _, v := range x &#123; if p(v) &#123; y = append(y, v) &#125; &#125; fmt.Println(y)&#125; or 12345678910111213141516171819202122232425package mainimport \"fmt\"type T intfunc main() &#123; x := []T&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; p := func(t T) bool &#123; return t%2 == 0 &#125; n := 0 for _, v := range x &#123; if p(v) &#123; n++ &#125; &#125; y := make([]T, 0, n) for _, v := range x &#123; if p(v) &#123; y = append(y, v) &#125; &#125; fmt.Println(y)&#125; 输出 1[2 4 6 8 10] 123456789fn main() &#123; let x = vec![1, 2, 3, 4, 5, 6]; let y: Vec&lt;_&gt; = x.iter() .filter(|&amp;x| x % 2 == 0) .collect(); println!(\"&#123;:?&#125;\", y);&#125; 输出 1[2, 4, 6] 58. Extract file content to a string提取字符串的文件内容 12345678910111213141516171819202122232425package mainimport \"fmt\"import \"io/ioutil\"func main() &#123; f := \"data.txt\" b, err := ioutil.ReadFile(f) if err != nil &#123; panic(err) &#125; lines := string(b) fmt.Println(lines)&#125;// Create file in fake FS of the Playground. init is executed before main.func init() &#123; err := ioutil.WriteFile(\"data.txt\", []byte(`UnDosTres`), 0644) if err != nil &#123; panic(err) &#125;&#125; 输出 123UnDosTres 123456789101112131415use std::fs::File;use std::io::prelude::*;fn main() -&gt; Result&lt;(), ()&gt; &#123; let f = \"Cargo.toml\"; let mut file = File::open(f).expect(\"Can't open file.\"); let mut lines = String::new(); file.read_to_string(&amp;mut lines) .expect(\"Can't read file contents.\"); println!(\"&#123;&#125;\", lines); Ok(())&#125; or 123456789use std::fs;fn main() &#123; let f = \"Cargo.toml\"; let lines = fs::read_to_string(f).expect(\"Can't read file.\"); println!(\"&#123;&#125;\", lines);&#125; 59. Write to standard error stream Print the message “x is negative” to standard error (stderr), with integer x value substitution (e.g. “-2 is negative”). 写入标准错误流 1234567891011package mainimport ( \"fmt\" \"os\")func main() &#123; x := -2 fmt.Fprintln(os.Stderr, x, \"is negative\")&#125; 输出 1-2 is negative 1234fn main() &#123; let x = -3; eprintln!(\"&#123;&#125; is negative\", x);&#125; 输出 1-3 is negative 60. Read command line argument读取命令行参数 12import \"os\"x := os.Args[1] 12345678910use std::env;fn main() &#123; let first_arg = env::args().skip(1).next(); let fallback = \"\".to_owned(); let x = first_arg.unwrap_or(fallback); println!(\"&#123;:?&#125;\", x);&#125; 输出 &quot;&quot;","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比(2)","date":"2021-09-02T17:35:16.000Z","path":"2021/09/03/Rust-vs-Go-常用语法对比-2/","text":"21. Swap values交换变量a和b的值 1a, b = b, a 1234567891011package mainimport \"fmt\"func main() &#123; a := 3 b := 10 a, b = b, a fmt.Println(a) fmt.Println(b)&#125; 12103 12345678fn main() &#123; let a = 3; let b = 10; let (a, b) = (b, a); println!(\"a: &#123;a&#125;, b: &#123;b&#125;\", a=a, b=b);&#125; 输出 a: 10, b: 3 or 123456789fn main() &#123; let (a, b) = (12, 42); println!(\"a = &#123;&#125;, b = &#123;&#125;\", a, b); let (a, b) = (b, a); println!(\"a = &#123;&#125;, b = &#123;&#125;\", a, b);&#125; 输出 12a = 12, b = 42a = 42, b = 12 22. Convert string to integer将字符串转换为整型 12import \"strconv\"i, err := strconv.Atoi(s) 12345678910111213141516171819202122package mainimport ( \"fmt\" \"reflect\" \"strconv\")func main() &#123; // create a string s := \"123\" fmt.Println(s) fmt.Println(\"type:\", reflect.TypeOf(s)) // convert string to int i, err := strconv.Atoi(s) if err != nil &#123; panic(err) &#125; fmt.Println(i) fmt.Println(\"type:\", reflect.TypeOf(i))&#125; 1234123type: string123type: int or 12import \"strconv\"i, err := strconv.ParseInt(s, 10, 0) 12345678910111213141516171819package mainimport ( \"fmt\" \"reflect\" \"strconv\")func main() &#123; s := \"123\" fmt.Println(\"s is\", reflect.TypeOf(s), s) i, err := strconv.ParseInt(s, 10, 0) if err != nil &#123; panic(err) &#125; fmt.Println(\"i is\", reflect.TypeOf(i), i)&#125; 12s is string 123i is int64 123 1234567891011fn main() &#123; // This prints 123 let mut s = \"123\"; let mut i = s.parse::&lt;i32&gt;().unwrap(); println!(\"&#123;:?&#125;\", i); // This panics s = \"12u3\"; i = s.parse::&lt;i32&gt;().unwrap(); println!(\"&#123;:?&#125;\", i);&#125; or 123456789fn main() &#123; let mut s = \"123\"; let mut i: i32 = s.parse().unwrap_or(0); println!(\"&#123;:?&#125;\", i); s = \"12u3\"; i = s.parse().unwrap_or(0); println!(\"&#123;:?&#125;\", i);&#125; 输出 121230 or 123456789101112131415fn main() &#123; let mut s = \"123\"; let mut i = match s.parse::&lt;i32&gt;() &#123; Ok(i) =&gt; i, Err(_e) =&gt; -1, &#125;; println!(\"&#123;:?&#125;\", i); s = \"12u3\"; i = match s.parse::&lt;i32&gt;() &#123; Ok(i) =&gt; i, Err(_e) =&gt; -1, &#125;; println!(\"&#123;:?&#125;\", i);&#125; 输出 12123-1 23. Convert real number to string with 2 decimal places Given a real number x, create its string representation s with 2 decimal digits following the dot. 给定一个实数，小数点后保留两位小数 123456789package mainimport \"fmt\"func main() &#123; x := 3.14159 s := fmt.Sprintf(\"%.2f\", x) fmt.Println(s)&#125; 输出 3.14 123456fn main() &#123; let x = 42.1337; let s = format!(\"&#123;:.2&#125;\", x); println!(\"&#123;&#125;\", s);&#125; 输出 42.13 24. Assign to string the japanese word ネコ Declare a new string s and initialize it with the literal value “ネコ” (which means “cat” in japanese) 声明一个新的字符串s，并用文字值“ネコ”初始化它(在日语中是“cat”的意思) 12345678package mainimport \"fmt\"func main() &#123; s := \"ネコ\" fmt.Println(s)&#125; 1234fn main() &#123; let s = \"ネコ\"; println!(\"&#123;&#125;\", s);&#125; 25. Send a value to another thread Share the string value “Alan” with an existing running process which will then display “Hello, Alan” 将字符串值“Alan”与现有的正在运行的进程共享，该进程将显示“你好，Alan” 1ch &lt;- \"Alan\" 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main() &#123; ch := make(chan string) go func() &#123; v := &lt;-ch fmt.Printf(\"Hello, %v\\n\", v) &#125;() ch &lt;- \"Alan\" // Make sure the non-main goroutine had the chance to finish. time.Sleep(time.Second)&#125; Hello, Alan The receiver goroutine blocks reading the string channel ch.The current goroutine sends the value to ch.A goroutine is like a thread, but more lightweight. 123456789101112131415use std::thread;use std::sync::mpsc::channel;fn main() &#123; let (send, recv) = channel(); let handle = thread::spawn(move || loop &#123; let msg = recv.recv().unwrap(); println!(\"Hello, &#123;:?&#125;\", msg); &#125;); send.send(\"Alan\").unwrap(); handle.join().unwrap();&#125; 输出 Hello, &quot;Alan&quot; 26. Create a 2-dimensional array Declare and initialize a matrix x having m rows and n columns, containing real numbers. 创建一个二维数组 声明并初始化一个有m行n列的矩阵x，包含实数。 12const m, n = 3, 4var x [m][n]float64 1234567891011package mainimport \"fmt\"func main() &#123; const m, n = 3, 4 var x [m][n]float64 x[1][2] = 8 fmt.Println(x)&#125; [[0 0 0 0] [0 0 8 0] [0 0 0 0]] or 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; x := make2D(2, 3) x[1][1] = 8 fmt.Println(x)&#125;func make2D(m, n int) [][]float64 &#123; buf := make([]float64, m*n) x := make([][]float64, m) for i := range x &#123; x[i] = buf[:n:n] buf = buf[n:] &#125; return x&#125; [[0 0 0] [0 8 0]] 12345678fn main() &#123; const M: usize = 4; const N: usize = 6; let x = vec![vec![0.0f64; N]; M]; println!(\"&#123;:#?&#125;\", x);&#125; 输出 12345678910111213141516171819202122232425262728293031323334[ [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ], [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ], [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ], [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ],] 123456789fn main() &#123; const M: usize = 3; const N: usize = 4; let mut x = [[0.0; N] ; M]; x[1][3] = 5.0; println!(\"&#123;:#?&#125;\", x);&#125; 输出 1234567891011121314151617181920[ [ 0.0, 0.0, 0.0, 0.0, ], [ 0.0, 0.0, 0.0, 5.0, ], [ 0.0, 0.0, 0.0, 0.0, ],] 27. Create a 3-dimensional array Declare and initialize a 3D array x, having dimensions boundaries m, n, p, and containing real numbers. 创建一个三维数组 声明并初始化一个三维数组x，它有m，n，p维边界，并且包含实数。 12const m, n, p = 2, 2, 3var x [m][n][p]float64 12345678910111213141516package mainimport \"fmt\"func main() &#123; const m, n, p = 2, 2, 3 var x [m][n][p]float64 x[1][0][2] = 9 // Value of x fmt.Println(x) // Type of x fmt.Printf(\"%T\", x)&#125; 12[[[0 0 0] [0 0 0]] [[0 0 9] [0 0 0]]][2][2][3]float64 or 12345678910111213func make3D(m, n, p int) [][][]float64 &#123; buf := make([]float64, m*n*p) x := make([][][]float64, m) for i := range x &#123; x[i] = make([][]float64, n) for j := range x[i] &#123; x[i][j] = buf[:p:p] buf = buf[p:] &#125; &#125; return x&#125; 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; x := make3D(2, 2, 3) x[1][0][2] = 9 fmt.Println(x)&#125;func make3D(m, n, p int) [][][]float64 &#123; buf := make([]float64, m*n*p) x := make([][][]float64, m) for i := range x &#123; x[i] = make([][]float64, n) for j := range x[i] &#123; x[i][j] = buf[:p:p] buf = buf[p:] &#125; &#125; return x&#125; 1[[[0 0 0] [0 0 0]] [[0 0 9] [0 0 0]]] 123456789fn main() &#123; let m = 4; let n = 6; let p = 2; let x = vec![vec![vec![0.0f64; p]; n]; m]; println!(\"&#123;:#?&#125;\", x);&#125; 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107[ [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ],] 123456789fn main() &#123; const M: usize = 4; const N: usize = 6; const P: usize = 2; let x = [[[0.0f64; P]; N]; M]; println!(\"&#123;:#?&#125;\", x);&#125; 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106[ [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ], [ [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], [ 0.0, 0.0, ], ],] 28. Sort by a property Sort elements of array-like collection items in ascending order of x.p, where p is a field of the type Item of the objects in items. 按x-&gt;p的升序对类似数组的集合项的元素进行排序，其中p是项中对象的项类型的字段。 12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"import \"sort\"type Item struct &#123; label string p int lang string&#125;type ItemPSorter []Itemfunc (s ItemPSorter) Len() int &#123; return len(s) &#125;func (s ItemPSorter) Less(i, j int) bool &#123; return s[i].p &lt; s[j].p &#125;func (s ItemPSorter) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125;func sortItems(items []Item) &#123; sorter := ItemPSorter(items) sort.Sort(sorter)&#125;func main() &#123; items := []Item&#123; &#123;\"twelve\", 12, \"english\"&#125;, &#123;\"six\", 6, \"english\"&#125;, &#123;\"eleven\", 11, \"english\"&#125;, &#123;\"zero\", 0, \"english\"&#125;, &#123;\"two\", 2, \"english\"&#125;, &#125; fmt.Println(\"Unsorted: \", items) sortItems(items) fmt.Println(\"Sorted: \", items)&#125; 12Unsorted: [&#123;twelve 12 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;zero 0 english&#125; &#123;two 2 english&#125;]Sorted: [&#123;zero 0 english&#125; &#123;two 2 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;twelve 12 english&#125;] or 12345678910111213141516171819202122232425262728package mainimport \"fmt\"import \"sort\"type Item struct &#123; label string p int lang string&#125;func main() &#123; items := []Item&#123; &#123;\"twelve\", 12, \"english\"&#125;, &#123;\"six\", 6, \"english\"&#125;, &#123;\"eleven\", 11, \"english\"&#125;, &#123;\"zero\", 0, \"english\"&#125;, &#123;\"two\", 2, \"english\"&#125;, &#125; fmt.Println(\"Unsorted: \", items) less := func(i, j int) bool &#123; return items[i].p &lt; items[j].p &#125; sort.Slice(items, less) fmt.Println(\"Sorted: \", items)&#125; 12Unsorted: [&#123;twelve 12 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;zero 0 english&#125; &#123;two 2 english&#125;]Sorted: [&#123;zero 0 english&#125; &#123;two 2 english&#125; &#123;six 6 english&#125; &#123;eleven 11 english&#125; &#123;twelve 12 english&#125;] 123456789101112#[derive(Debug)]struct Foo &#123; p: i32,&#125;fn main() &#123; let mut items = vec![Foo &#123; p: 3 &#125;, Foo &#123; p: 1 &#125;, Foo &#123; p: 2 &#125;, Foo &#123; p: 4 &#125;]; items.sort_by(|a, b| a.p.cmp(&amp;b.p)); println!(\"&#123;:?&#125;\", items);&#125; 输出 1[Foo &#123; p: 1 &#125;, Foo &#123; p: 2 &#125;, Foo &#123; p: 3 &#125;, Foo &#123; p: 4 &#125;] or 123456789101112#[derive(Debug)]struct Foo &#123; p: i32,&#125;fn main() &#123; let mut items = vec![Foo &#123; p: 3 &#125;, Foo &#123; p: 1 &#125;, Foo &#123; p: 2 &#125;, Foo &#123; p: 4 &#125;]; items.sort_by_key(|x| x.p); println!(\"&#123;:?&#125;\", items);&#125; 输出 1[Foo &#123; p: 1 &#125;, Foo &#123; p: 2 &#125;, Foo &#123; p: 3 &#125;, Foo &#123; p: 4 &#125;] 29. Remove item from list, by its index Remove i-th item from list items.This will alter the original list or return a new list, depending on which is more idiomatic.Note that in most languages, the smallest valid value for i is 0. 从列表项中删除第I项。这将改变原来的列表或返回一个新的列表，这取决于哪个更习惯。请注意，在大多数语言中，I的最小有效值是0。 1234567891011121314package mainimport ( \"fmt\")func main() &#123; items := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"&#125; fmt.Println(items) i := 2 items = append(items[:i], items[i+1:]...) fmt.Println(items)&#125; 12[a b c d e f][a b d e f] or 123copy(items[i:], items[i+1:])items[len(items)-1] = nilitems = items[:len(items)-1] 123456fn main() &#123; let mut v = vec![1, 2, 3]; assert_eq!(v.remove(1), 2); assert_eq!(v, [1, 3]); &#125; 30. Parallelize execution of 1000 independent tasks Launch the concurrent execution of procedure f with parameter i from 1 to 1000.Tasks are independent and f(i) doesn’t return any value.Tasks need not run all at the same time, so you may use a pool. 用参数I从1到1000启动程序f的并发执行。任务是独立的，f(i)不返回值。任务不需要同时运行，所以可以使用pools 12345678910import \"sync\"wg := sync.WaitGroup&#123;&#125;wg.Add(1000)for i := 1; i &lt;= 1000; i++ &#123; go func(j int) &#123; f(j) wg.Done() &#125;(i)&#125;wg.Wait() 123456789101112131415161718192021package mainimport ( \"fmt\" \"math/rand\" \"time\")func f(i int) &#123; d := rand.Int() % 10000 time.Sleep(time.Duration(d)) fmt.Printf(\"Hello %v\\n\", i)&#125;func main() &#123; for i := 1; i &lt;= 1000; i++ &#123; go f(i) &#125; time.Sleep(4 * time.Second)&#125; 12345678910111213use std::thread;fn main() &#123; let threads: Vec&lt;_&gt; = (0..1000).map(|i| thread::spawn(move || f(i))).collect(); for thread in threads &#123; thread.join(); &#125;&#125;fn f(i: i32) &#123; println!(\"&#123;&#125;\", i);&#125; or 1234567891011extern crate rayon;use rayon::prelude::*;fn main() &#123; (0..1000).into_par_iter().for_each(f);&#125;fn f(i: i32) &#123; println!(\"&#123;&#125;\", i);&#125; 31. Recursive factorial (simple) Create recursive function f which returns the factorial of non-negative integer i, calculated from f(i-1) 创建递归函数f，该函数返回从f(i-1)计算的非负整数I的阶乘 123456func f(i int) int &#123; if i == 0 &#123; return 1 &#125; return i * f(i-1)&#125; 123456789101112131415161718package mainimport ( \"fmt\")func f(i int) int &#123; if i == 0 &#123; return 1 &#125; return i * f(i-1)&#125;func main() &#123; for i := 0; i &lt;= 10; i++ &#123; fmt.Printf(\"f(%d) = %d\\n\", i, f(i)) &#125;&#125; 输出 1234567891011f(0) = 1f(1) = 1f(2) = 2f(3) = 6f(4) = 24f(5) = 120f(6) = 720f(7) = 5040f(8) = 40320f(9) = 362880f(10) = 3628800 1234567891011fn f(n: u32) -&gt; u32 &#123; if n &lt; 2 &#123; 1 &#125; else &#123; n * f(n - 1) &#125;&#125;fn main() &#123; println!(\"&#123;&#125;\", f(4 as u32));&#125; 输出 24 or 123456789101112131415fn factorial(num: u64) -&gt; u64 &#123; match num &#123; 0 | 1=&gt; 1, _ =&gt; factorial(num - 1) * num, &#125;&#125;fn main ()&#123; println!(\"&#123;&#125;\", factorial(0)); println!(\"&#123;&#125;\", factorial(1)); println!(\"&#123;&#125;\", factorial(2)); println!(\"&#123;&#125;\", factorial(3)); println!(\"&#123;&#125;\", factorial(4)); println!(\"&#123;&#125;\", factorial(5));&#125; 输出 123456112624120 32. Integer exponentiation by squaring Create function exp which calculates (fast) the value x power n.x and n are non-negative integers. 创建函数exp，计算(快速)x次方n的值。x和n是非负整数。 1234567891011121314151617181920package mainimport \"fmt\"func exp(x, n int) int &#123; switch &#123; case n == 0: return 1 case n == 1: return x case n%2 == 0: return exp(x*x, n/2) default: return x * exp(x*x, (n-1)/2) &#125;&#125;func main() &#123; fmt.Println(exp(3, 5))&#125; 输出 243 123456789101112131415fn exp(x: u64, n: u64) -&gt; u64 &#123; match n &#123; 0 =&gt; 1, 1 =&gt; x, i if i % 2 == 0 =&gt; exp(x * x, n / 2), _ =&gt; x * exp(x * x, (n - 1) / 2), &#125;&#125;fn main() &#123; let x = 16; let n = 4; println!(\"&#123;&#125;\", exp(x, n));&#125; 输出 65536 33. Atomically read and update variable Assign variable x the new value f(x), making sure that no other thread may modify x between the read and the write. 为变量x分配新值f(x)，确保在读和写之间没有其他线程可以修改x。 123456789101112131415161718192021package mainimport ( \"fmt\" \"sync\")func main() &#123; var lock sync.RWMutex x := 3 lock.Lock() x = f(x) lock.Unlock() fmt.Println(x)&#125;func f(i int) int &#123; return 2 * i&#125; 6 12345678910111213use std::sync::Mutex;fn f(x: i32) -&gt; i32 &#123; x + 1&#125;fn main() &#123; let x = Mutex::new(0); let mut x = x.lock().unwrap(); *x = f(*x); println!(\"&#123;:?&#125;\", *x);&#125; 输出 1 34. Create a set of objects Declare and initialize a set x containing objects of type T. 声明并初始化一个包含t类型对象的集合x。 1x := make(map[T]bool) 123456789101112131415161718192021222324package mainimport \"fmt\"type T stringfunc main() &#123; // declare a Set (implemented as a map) x := make(map[T]bool) // add some elements x[\"A\"] = true x[\"B\"] = true x[\"B\"] = true x[\"C\"] = true x[\"D\"] = true // remove an element delete(x, \"C\") for t, _ := range x &#123; fmt.Printf(\"x contains element %v \\n\", t) &#125;&#125; 123x contains element D x contains element A x contains element B or 1x := make(map[T]struct&#123;&#125;) 123456789101112131415161718192021222324package mainimport \"fmt\"type T stringfunc main() &#123; // declare a Set (implemented as a map) x := make(map[T]struct&#123;&#125;) // add some elements x[\"A\"] = struct&#123;&#125;&#123;&#125; x[\"B\"] = struct&#123;&#125;&#123;&#125; x[\"B\"] = struct&#123;&#125;&#123;&#125; x[\"C\"] = struct&#123;&#125;&#123;&#125; x[\"D\"] = struct&#123;&#125;&#123;&#125; // remove an element delete(x, \"C\") for t, _ := range x &#123; fmt.Printf(\"x contains element %v \\n\", t) &#125;&#125; 123x contains element B x contains element D x contains element A 123456789use std::collections::HashSet;fn main() &#123; let mut m = HashSet::new(); m.insert(\"a\"); m.insert(\"b\"); println!(\"&#123;:?&#125;\", m);&#125; 输出 1&#123;\"a\", \"b\"&#125; 35. First-class function : compose Implement a function compose (A -&gt; C) with parameters f (A -&gt; B) and g (B -&gt; C), which returns composition function g ∘ f 用参数f (A -&gt; B)和g (B -&gt; C)实现一个函数compose (A -&gt; C)，返回composition函数g ∘ f 12345678910111213141516171819202122232425262728package mainimport \"fmt\"import \"strconv\"func compose(f func(A) B, g func(B) C) func(A) C &#123; return func(x A) C &#123; return g(f(x)) &#125;&#125;func main() &#123; squareFromStr := compose(str2int, square) fmt.Println(squareFromStr(\"12\"))&#125;type A stringtype B inttype C intfunc str2int(a A) B &#123; b, _ := strconv.ParseInt(string(a), 10, 32) return B(b)&#125;func square(b B) C &#123; return C(b * b)&#125; 144 12345fn compose&lt;'a, A, B, C, G, F&gt;(f: F, g: G) -&gt; Box&lt;Fn(A) -&gt; C + 'a&gt; where F: 'a + Fn(A) -&gt; B, G: 'a + Fn(B) -&gt; C&#123; Box::new(move |x| g(f(x)))&#125; or 1234567891011fn compose&lt;A, B, C&gt;(f: impl Fn(A) -&gt; B, g: impl Fn(B) -&gt; C) -&gt; impl Fn(A) -&gt; C &#123; move |x| g(f(x))&#125;fn main() &#123; let f = |x: u32| (x * 2) as i32; let g = |x: i32| (x + 1) as f32; let c = compose(f, g); println!(\"&#123;&#125;\", c(2));&#125; 输出 5 36. First-class function : generic composition Implement a function compose which returns composition function g ∘ f for any functions f and g having exactly 1 parameter. 实现一个函数组合，该函数组合为任何恰好有1个参数的函数f和g返回组合函数g ∘ f。 1234567891011121314151617181920212223package mainimport \"fmt\"func composeIntFuncs(f func(int) int, g func(int) int) func(int) int &#123; return func(x int) int &#123; return g(f(x)) &#125;&#125;func main() &#123; double := func(x int) int &#123; return 2 * x &#125; addTwo := func(x int) int &#123; return x + 2 &#125; h := composeIntFuncs(double, addTwo) for i := 0; i &lt; 10; i++ &#123; fmt.Println(i, h(i), addTwo(double(i))) &#125;&#125; 123456789100 2 21 4 42 6 63 8 84 10 105 12 126 14 147 16 168 18 189 20 20 12345fn compose&lt;'a, A, B, C, G, F&gt;(f: F, g: G) -&gt; Box&lt;Fn(A) -&gt; C + 'a&gt; where F: 'a + Fn(A) -&gt; B, G: 'a + Fn(B) -&gt; C&#123; Box::new(move |x| g(f(x)))&#125; or 1234567891011fn compose&lt;A, B, C&gt;(f: impl Fn(A) -&gt; B, g: impl Fn(B) -&gt; C) -&gt; impl Fn(A) -&gt; C &#123; move |x| g(f(x))&#125;fn main() &#123; let f = |x: u32| (x * 2) as i32; let g = |x: i32| (x + 1) as f32; let c = compose(f, g); println!(\"&#123;&#125;\", c(2));&#125; 输出 5 37. Currying Transform a function that takes multiple arguments into a function for which some of the arguments are preset. 将一个接受多个参数的函数转换为一个预设了某些参数的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"fmt\" \"time\")type Company stringtype Employee struct &#123; FirstName string LastName string&#125;func (e *Employee) String() string &#123; return \"&lt;\" + e.FirstName + \" \" + e.LastName + \"&gt;\"&#125;type Payroll struct &#123; Company Company Boss *Employee Employee *Employee StartDate time.Time EndDate time.Time Amount int&#125;// Creates a blank payroll for a specific employee with specific boss in specific companytype PayFactory func(Company, *Employee, *Employee) Payroll// Creates a blank payroll for a specific employeetype CustomPayFactory func(*Employee) Payrollfunc CurryPayFactory(pf PayFactory, company Company, boss *Employee) CustomPayFactory &#123; return func(e *Employee) Payroll &#123; return pf(company, boss, e) &#125;&#125;func NewPay(company Company, boss *Employee, employee *Employee) Payroll &#123; return Payroll&#123; Company: company, Boss: boss, Employee: employee, &#125;&#125;func main() &#123; me := Employee&#123;\"Jack\", \"Power\"&#125; // I happen to be head of the HR department of Richissim Inc. var myLittlePayFactory CustomPayFactory = CurryPayFactory(NewPay, \"Richissim\", &amp;me) fmt.Println(myLittlePayFactory(&amp;Employee&#123;\"Jean\", \"Dupont\"&#125;)) fmt.Println(myLittlePayFactory(&amp;Employee&#123;\"Antoine\", \"Pol\"&#125;))&#125; 12&#123;Richissim &lt;Jack Power&gt; &lt;Jean Dupont&gt; 0001-01-01 00:00:00 +0000 UTC 0001-01-01 00:00:00 +0000 UTC 0&#125;&#123;Richissim &lt;Jack Power&gt; &lt;Antoine Pol&gt; 0001-01-01 00:00:00 +0000 UTC 0001-01-01 00:00:00 +0000 UTC 0&#125; 12345678910fn add(a: u32, b: u32) -&gt; u32 &#123; a + b&#125;fn main() &#123; let add5 = move |x| add(5, x); let y = add5(12); println!(\"&#123;&#125;\", y);&#125; 输出 17 38. Extract a substring Find substring t consisting in characters i (included) to j (excluded) of string s.Character indices start at 0 unless specified otherwise.Make sure that multibyte characters are properly handled. 查找由字符串s的字符I(包括)到j(不包括)组成的子字符串t。除非另有说明，字符索引从0开始。确保正确处理多字节字符。 123456789101112package mainimport \"fmt\"func main() &#123; s := \"hello, utf-8 문자들\" i, j := 7, 15 t := string([]rune(s)[i:j]) fmt.Println(t)&#125; utf-8 문자 123456789extern crate unicode_segmentation;use unicode_segmentation::UnicodeSegmentation;fn main() &#123; let s = \"Lorem Ipsüm Dolor\"; let (i, j) = (6, 11); let t = s.graphemes(true).skip(i).take(j - i).collect::&lt;String&gt;(); println!(\"&#123;&#125;\", t);&#125; 输出 Ipsüm or 12use substring::Substring;let t = s.substring(i, j); 39. Check if string contains a word Set boolean ok to true if string word is contained in string s as a substring, or to false otherwise. 如果字符串单词作为子字符串包含在字符串s中，则将布尔ok设置为true，否则设置为false。 12345678910111213141516171819202122package mainimport ( \"fmt\" \"strings\")func main() &#123; s := \"Let's dance the macarena\" word := \"dance\" ok := strings.Contains(s, word) fmt.Println(ok) word = \"car\" ok = strings.Contains(s, word) fmt.Println(ok) word = \"duck\" ok = strings.Contains(s, word) fmt.Println(ok)&#125; 123truetruefalse 123456789101112131415fn main() &#123; let s = \"Let's dance the macarena\"; let word = \"dance\"; let ok = s.contains(word); println!(\"&#123;&#125;\", ok); let word = \"car\"; let ok = s.contains(word); println!(\"&#123;&#125;\", ok); let word = \"duck\"; let ok = s.contains(word); println!(\"&#123;&#125;\", ok);&#125; 输出 123truetruefalse","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust vs Go:常用语法对比","date":"2021-09-02T13:02:52.000Z","path":"2021/09/02/Rust-vs-Go-常用语法对比/","text":"这个网站 可以列出某门编程语言的常用语法，也可以对比两种语言的基本语法差别。 在此对比Go和Rust 1. Print Hello World打印Hello World 12345678package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello World\")&#125; 123fn main() &#123; println!(\"Hello World\");&#125; Rust 输出文字的方式主要有两种：println!() 和 print!()。这两个”函数”都是向命令行输出字符串的方法，区别仅在于前者会在输出的最后附加输出一个换行符。当用这两个”函数”输出信息的时候，第一个参数是格式字符串，后面是一串可变参数，对应着格式字符串中的”占位符”，这一点与 C 语言/ Go语言 中的 printf 函数很相似。但是，Rust 中格式字符串中的占位符不是”% + 字母”的形式，而是一对 {}。 2. Print Hello 10 times打印10次Hello World 1234567891011package mainimport ( \"fmt\")func main() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(\"Hello\") &#125;&#125; 12345fn main() &#123; for _ in 0..10 &#123; println!(\"Hello\"); &#125;&#125; or 123fn main() &#123; print!(\"&#123;&#125;\", \"Hello\\n\".repeat(10));&#125; 3. Create a procedure Like a function which doesn’t return any value, thus has only side effects (e.g. Print to standard output) 创建一个方法，没有返回值，打印一些内容 1234567891011package mainimport \"fmt\"func finish(name string) &#123; fmt.Println(\"My job here is done. Good bye \" + name)&#125;func main() &#123; finish(\"Tony\")&#125; 1234567fn main()&#123; finish(\"Buddy\")&#125;fn finish(name : &amp;str) &#123; println!(\"My job here is done. Goodbye &#123;&#125;\", name);&#125; 4. Create a function which returns the square of an integer创建一个函数,返回一个整数的平方 123func square(x int) int &#123; return x*x&#125; 123456789fn square(x: u32) -&gt; u32 &#123; x * x&#125;fn main() &#123; let sq = square(9); println!(\"&#123;&#125;\", sq);&#125; 5. Create a 2D Point data structure Declare a container type for two floating-point numbers x and y 声明一个容器类型,有x、y两个浮点数 12345678910111213141516171819202122232425package mainimport \"fmt\"type Point struct &#123; x, y float64&#125;func main() &#123; p1 := Point&#123;&#125; p2 := Point&#123;2.1, 2.2&#125; p3 := Point&#123; y: 3.1, x: 3.2, &#125; p4 := &amp;Point&#123; x: 4.1, y: 4.2, &#125; fmt.Println(p1) fmt.Println(p2) fmt.Println(p3) fmt.Println(p4)&#125; 输出 1234&#123;0 0&#125;&#123;2.1 2.2&#125;&#123;3.2 3.1&#125;&amp;&#123;4.1 4.2&#125; 123456789101112131415161718use std::fmt;struct Point &#123; x: f64, y: f64,&#125;impl fmt::Display for Point &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result &#123; write!(f, \"(&#123;&#125;, &#123;&#125;)\", self.x, self.y) &#125;&#125;fn main() &#123; let p = Point &#123; x: 2.0, y: -3.5 &#125;; println!(\"&#123;&#125;\", p);&#125; or 123456789101112131415use std::fmt;struct Point(f64, f64);impl fmt::Display for Point &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result &#123; write!(f, \"(&#123;&#125;, &#123;&#125;)\", self.0, self.1) &#125;&#125;fn main() &#123; let p = Point(2.0, -3.5); println!(\"&#123;&#125;\", p);&#125; 6. Iterate over list values Do something with each item x of an array-like collection items, regardless indexes. 遍历列表的值 123for _, x := range items &#123; doSomething(x)&#125; 1234567891011121314151617package mainimport ( \"fmt\")func main() &#123; items := []int&#123;11, 22, 33&#125; for _, x := range items &#123; doSomething(x) &#125;&#125;func doSomething(i int) &#123; fmt.Println(i)&#125; 输出 123112233 1234567891011fn main() &#123; let items = vec![11, 22, 33]; for x in items &#123; do_something(x); &#125;&#125;fn do_something(n: i64) &#123; println!(\"Number &#123;&#125;\", n)&#125; or 123456789fn main() &#123; let items = vec![11, 22, 33]; items.into_iter().for_each(|x| do_something(x));&#125;fn do_something(n: i64) &#123; println!(\"Number &#123;&#125;\", n)&#125; 7. Iterate over list indexes and values遍历列表的索引和值 123456789101112131415package mainimport \"fmt\"func main() &#123; items := []string&#123; \"oranges\", \"apples\", \"bananas\", &#125; for i, x := range items &#123; fmt.Printf(\"Item %d = %v \\n\", i, x) &#125;&#125; 输出 123Item 0 = oranges Item 1 = apples Item 2 = bananas 123456fn main() &#123; let items = [\"a\", \"b\", \"c\"]; for (i, x) in items.iter().enumerate() &#123; println!(\"Item &#123;&#125; = &#123;&#125;\", i, x); &#125;&#125; or 123456fn main() &#123; let items = [\"a\", \"b\", \"c\"]; items.iter().enumerate().for_each(|(i, x)| &#123; println!(\"Item &#123;&#125; = &#123;&#125;\", i, x); &#125;);&#125; 8. Initialize a new map (associative array) Create a new map object x, and provide some (key, value) pairs as initial content. 创建一个新的map,提供一些键值对 作为初始内容 123456789package mainimport \"fmt\"func main() &#123; x := map[string]int&#123;\"one\": 1, \"two\": 2&#125; fmt.Println(x)&#125; 输出 1map[one:1 two:2] 123456789use std::collections::BTreeMap;fn main() &#123; let mut x = BTreeMap::new(); x.insert(\"one\", 1); x.insert(\"two\", 2); println!(\"&#123;:?&#125;\", x);&#125; 输出为： 12(\"one\", 1)(\"two\", 2) or 12345678910use std::collections::HashMap;fn main() &#123; let x: HashMap&lt;&amp;str, i32&gt; = [ (\"one\", 1), (\"two\", 2), ].iter().cloned().collect(); println!(\"&#123;:?&#125;\", x);&#125; 输出为： 12(\"two\", 2)(\"one\", 1) 分 BTreeMap 和 HashMap，且都需要use进来； 前者无序，后者有序 9. Create a Binary Tree data structure The structure must be recursive because left child and right child are binary trees too. A node has access to children nodes, but not to its parent. 创建一个二叉树 12345type BinTree struct &#123; Value valueType Left *BinTree Right *BinTree&#125; 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"type BinTree struct &#123; Value int Left *BinTree Right *BinTree&#125;func inorder(root *BinTree) &#123; if root == nil &#123; return &#125; inorder(root.Left) fmt.Printf(\"%d \", root.Value) inorder(root.Right)&#125;func main() &#123; root := &amp;BinTree&#123;1, nil, nil&#125; root.Left = &amp;BinTree&#123;2, nil, nil&#125; root.Right = &amp;BinTree&#123;3, nil, nil&#125; root.Left.Left = &amp;BinTree&#123;4, nil, nil&#125; root.Left.Right = &amp;BinTree&#123;5, nil, nil&#125; root.Right.Right = &amp;BinTree&#123;6, nil, nil&#125; root.Left.Left.Left = &amp;BinTree&#123;7, nil, nil&#125; inorder(root)&#125; 输出 17 4 2 5 1 3 6 12345struct BinTree&lt;T&gt; &#123; value: T, left: Option&lt;Box&lt;BinTree&lt;T&gt;&gt;&gt;, right: Option&lt;Box&lt;BinTree&lt;T&gt;&gt;&gt;,&#125; 10. Shuffle a list Generate a random permutation of the elements of list x 随机排序一个list 1234567891011121314151617package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"&#125; for i := range x &#123; j := rand.Intn(i + 1) x[i], x[j] = x[j], x[i] &#125; fmt.Println(x)&#125; 输出 [f e c g h a d b] or 123456789101112131415161718package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"&#125; y := make([]string, len(x)) perm := rand.Perm(len(x)) for i, v := range perm &#123; y[v] = x[i] &#125; fmt.Println(y)&#125; 输出 [f h c g b a d e] or 123456789101112131415161718package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"&#125; y := make([]string, len(x)) perm := rand.Perm(len(x)) for i, v := range perm &#123; y[v] = x[i] &#125; fmt.Println(y)&#125; 输出 [f h c g b a d e] rand.Perm(x)挺有意思的一个函数，perm应该是permutation的缩写，即置换，排列。会输出一个从0-(x-1)随机顺序排列的数组，类似洗牌，总数不变，打乱顺序 or 1234567891011121314151617package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"&#125; for i := len(x) - 1; i &gt; 0; i-- &#123; j := rand.Intn(i + 1) x[i], x[j] = x[j], x[i] &#125; fmt.Println(x)&#125; 输出 [g d a h e f c b] 12345extern crate rand;use rand::&#123;Rng, StdRng&#125;;let mut rng = StdRng::new().unwrap();rng.shuffle(&amp;mut x); or 123456789101112use rand::seq::SliceRandom;use rand::thread_rng;fn main() &#123; let mut x = [1, 2, 3, 4, 5]; println!(\"Unshuffled: &#123;:?&#125;\", x); let mut rng = thread_rng(); x.shuffle(&amp;mut rng); println!(\"Shuffled: &#123;:?&#125;\", x);&#125; 11. Pick a random element from a list从列表中选择一个随机元素 123456789101112package mainimport ( \"fmt\" \"math/rand\")var x = []string&#123;\"bleen\", \"fuligin\", \"garrow\", \"grue\", \"hooloovoo\"&#125;func main() &#123; fmt.Println(x[rand.Intn(len(x))])&#125; 输出 fuligin or 1234567891011121314151617package mainimport ( \"fmt\" \"math/rand\")type T stringfunc pickT(x []T) T &#123; return x[rand.Intn(len(x))]&#125;func main() &#123; var list = []T&#123;\"bleen\", \"fuligin\", \"garrow\", \"grue\", \"hooloovoo\"&#125; fmt.Println(pickT(list))&#125; 输出 fuligin 123456789use rand::&#123;self, Rng&#125;;fn main() &#123; let x = vec![11, 22, 33]; let choice = x[rand::thread_rng().gen_range(0..x.len())]; println!(\"I picked &#123;&#125;!\", choice);&#125; or 12345678910use rand::seq::SliceRandom; fn main() &#123; let x = vec![11, 22, 33]; let mut rng = rand::thread_rng(); let choice = x.choose(&amp;mut rng).unwrap(); println!(\"I picked &#123;&#125;!\", choice);&#125; 12. Check if list contains a value Check if list contains a value x.list is an iterable finite container. 检查列表中是否包含一个值 1234567891011121314151617181920package mainimport \"fmt\"func Contains(list []T, x T) bool &#123; for _, item := range list &#123; if item == x &#123; return true &#125; &#125; return false&#125;type T stringfunc main() &#123; list := []T&#123;\"a\", \"b\", \"c\"&#125; fmt.Println(Contains(list, \"b\")) fmt.Println(Contains(list, \"z\"))&#125; 输出 12truefalse 1234567891011121314151617181920212223fn main() &#123; let list = [10, 40, 30]; &#123; let num = 30; if list.contains(&amp;num) &#123; println!(\"&#123;:?&#125; contains &#123;&#125;\", list, num); &#125; else &#123; println!(\"&#123;:?&#125; doesn't contain &#123;&#125;\", list, num); &#125; &#125; &#123; let num = 42; if list.contains(&amp;num) &#123; println!(\"&#123;:?&#125; contains &#123;&#125;\", list, num); &#125; else &#123; println!(\"&#123;:?&#125; doesn't contain &#123;&#125;\", list, num); &#125; &#125;&#125; or 12345678910fn main() &#123; let list = [10, 40, 30]; let x = 30; if list.iter().any(|v| v == &amp;x) &#123; println!(\"&#123;:?&#125; contains &#123;&#125;\", list, x); &#125; else &#123; println!(\"&#123;:?&#125; doesn't contain &#123;&#125;\", list, x); &#125;&#125; or 12345678910fn main() &#123; let list = [10, 40, 30]; let x = 30; if (&amp;list).into_iter().any(|v| v == &amp;x) &#123; println!(\"&#123;:?&#125; contains &#123;&#125;\", list, x); &#125; else &#123; println!(\"&#123;:?&#125; doesn't contain &#123;&#125;\", list, x); &#125;&#125; 13. Iterate over map keys and values Access each key k with its value x from an associative array mymap, and print them 遍历关联数组中的每一对 k-v， 并打印出它们 12345678910111213141516package mainimport \"fmt\"func main() &#123; mymap := map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, &#125; for k, x := range mymap &#123; fmt.Println(\"Key =\", k, \", Value =\", x) &#125;&#125; 输出 1234Key = two , Value = 2Key = three , Value = 3Key = four , Value = 4Key = one , Value = 1 12345678910111213use std::collections::BTreeMap;fn main() &#123; let mut mymap = BTreeMap::new(); mymap.insert(\"one\", 1); mymap.insert(\"two\", 2); mymap.insert(\"three\", 3); mymap.insert(\"four\", 4); for (k, x) in &amp;mymap &#123; println!(\"Key=&#123;key&#125;, Value=&#123;val&#125;\", key = k, val = x); &#125;&#125; 14. Pick uniformly a random floating point number in [a..b) Pick a random number greater than or equals to a, strictly inferior to b. Precondition : a &lt; b. 选出一个随机的浮点数，大于或等于a，严格小于b，且a&lt; b 123456789101112131415package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := pick(-2.0, 6.5) fmt.Println(x)&#125;func pick(a, b float64) float64 &#123; return a + (rand.Float64() * (b - a))&#125; 输出 3.1396124478267664 12345678extern crate rand;use rand::&#123;thread_rng, Rng&#125;;fn main() &#123; let (a, b) = (1.0, 3.0); let c = thread_rng().gen_range(a..b); println!(\"&#123;&#125;\", c);&#125; 15. Pick uniformly a random integer in [a..b] Pick a random integer greater than or equals to a, inferior or equals to b. Precondition : a &lt; b. 选出一个随机的整数，大于或等于a，小于或等于b，且a&lt; b 1234567891011121314151617package mainimport ( \"fmt\" \"math/rand\")func main() &#123; x := pick(3, 7) // Note that in the Go Playground, time and random don't change very often. fmt.Println(x)&#125;func pick(a, b int) int &#123; return a + rand.Intn(b-a+1)&#125; 输出 4 12345fn pick(a: i32, b: i32) -&gt; i32 &#123; let between = Range::new(a, b); let mut rng = rand::thread_rng(); between.ind_sample(&amp;mut rng)&#125; or 12345678910use rand::distributions::Distribution;use rand::distributions::Uniform;fn main() &#123; let (a, b) = (3, 5); let x = Uniform::new_inclusive(a, b).sample(&amp;mut rand::thread_rng()); println!(\"&#123;&#125;\", x);&#125; 17. Create a Tree data structure The structure must be recursive. A node may have zero or more children. A node has access to children nodes, but not to its parent. 创建树数据结构,该结构必须是递归的。一个节点可以有零个或多个子节点,节点可以访问子节点，但不能访问其父节点 12345type Tree struct &#123; Key keyType Deco valueType Children []*Tree&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"type Tree struct &#123; Key key Deco value Children []*Tree&#125;type key stringtype value stringfunc (t *Tree) String() string &#123; str := \"(\" str += string(t.Deco) if len(t.Children) == 0 &#123; return str + \")\" &#125; str += \" (\" for _, child := range t.Children &#123; str += child.String() &#125; str += \"))\" return str&#125;func (this *Tree) AddChild(x key, v value) *Tree &#123; child := &amp;Tree&#123;Key: x, Deco: v&#125; this.Children = append(this.Children, child) return child&#125;func main() &#123; tree := &amp;Tree&#123;Key: \"Granpa\", Deco: \"Abraham\"&#125; subtree := tree.AddChild(\"Dad\", \"Homer\") subtree.AddChild(\"Kid 1\", \"Bart\") subtree.AddChild(\"Kid 2\", \"Lisa\") subtree.AddChild(\"Kid 3\", \"Maggie\") fmt.Println(tree)&#125; 输出 (Abraham ((Homer ((Bart)(Lisa)(Maggie))))) 12345678910111213141516171819202122232425262728293031323334353637383940414243use std::vec;struct Node&lt;T&gt; &#123; value: T, children: Vec&lt;Node&lt;T&gt;&gt;,&#125;impl&lt;T&gt; Node&lt;T&gt; &#123; pub fn dfs&lt;F: Fn(&amp;T)&gt;(&amp;self, f: F) &#123; self.dfs_helper(&amp;f); &#125; fn dfs_helper&lt;F: Fn(&amp;T)&gt;(&amp;self, f: &amp;F) &#123; (f)(&amp;self.value); for child in &amp;self.children &#123; child.dfs_helper(f); &#125; &#125;&#125;fn main() &#123; let t: Node&lt;i32&gt; = Node &#123; children: vec![ Node &#123; children: vec![ Node &#123; children: vec![], value: 14 &#125; ], value: 28 &#125;, Node &#123; children: vec![], value: 80 &#125; ], value: 50 &#125;; t.dfs(|node| &#123; println!(\"&#123;&#125;\", node); &#125;);&#125; 输出： 123450281480 18. Depth-first traversing of a tree Call a function f on every node of a tree, in depth-first prefix order 树的深度优先遍历。按照深度优先的前缀顺序，在树的每个节点上调用函数f 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport . \"fmt\"func (t *Tree) Dfs(f func(*Tree)) &#123; if t == nil &#123; return &#125; f(t) for _, child := range t.Children &#123; child.Dfs(f) &#125;&#125;type key stringtype value stringtype Tree struct &#123; Key key Deco value Children []*Tree&#125;func (this *Tree) AddChild(x key, v value) &#123; child := &amp;Tree&#123;Key: x, Deco: v&#125; this.Children = append(this.Children, child)&#125;func NodePrint(node *Tree) &#123; Printf(\"%v (%v)\\n\", node.Deco, node.Key)&#125;func main() &#123; tree := &amp;Tree&#123;Key: \"Granpa\", Deco: \"Abraham\"&#125; tree.AddChild(\"Dad\", \"Homer\") tree.Children[0].AddChild(\"Kid 1\", \"Bart\") tree.Children[0].AddChild(\"Kid 2\", \"Lisa\") tree.Children[0].AddChild(\"Kid 3\", \"Maggie\") tree.Dfs(NodePrint)&#125; 输出 12345Abraham (Granpa)Homer (Dad)Bart (Kid 1)Lisa (Kid 2)Maggie (Kid 3) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950use std::vec;struct Tree&lt;T&gt; &#123; children: Vec&lt;Tree&lt;T&gt;&gt;, value: T&#125;impl&lt;T&gt; Tree&lt;T&gt; &#123; pub fn new(value: T) -&gt; Self&#123; Tree&#123; children: vec![], value &#125; &#125; pub fn dfs&lt;F: Fn(&amp;T)&gt;(&amp;self, f: F) &#123; self.dfs_helper(&amp;f); &#125; fn dfs_helper&lt;F: Fn(&amp;T)&gt;(&amp;self, f: &amp;F) &#123; (f)(&amp;self.value); for child in &amp;self.children &#123; child.dfs_helper(f); &#125; &#125;&#125;fn main() &#123; let t: Tree&lt;i32&gt; = Tree &#123; children: vec![ Tree &#123; children: vec![ Tree &#123; children: vec![], value: 14 &#125; ], value: 28 &#125;, Tree &#123; children: vec![], value: 80 &#125; ], value: 50 &#125;; t.dfs(|node| &#123; println!(\"&#123;&#125;\", node); &#125;);&#125; 输出： 123450281480 19. Reverse a list Reverse the order of the elements of list x.This may reverse “in-place” and destroy the original ordering. 反转链表 1234567891011121314package mainimport \"fmt\"func main() &#123; s := []int&#123;5, 2, 6, 3, 1, 4&#125; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; fmt.Println(s)&#125; 输出 [4 1 3 6 2 5] 12345fn main() &#123; let x = vec![\"Hello\", \"World\"]; let y: Vec&lt;_&gt; = x.iter().rev().collect(); println!(\"&#123;:?&#125;\", y);&#125; 输出： 1[\"World\", \"Hello\"] or 12345fn main() &#123; let mut x = vec![1,2,3]; x.reverse(); println!(\"&#123;:?&#125;\", x);&#125; 输出: 1[3, 2, 1] 20. Return two values Implement a function search which looks for item x in a 2D matrix m.Return indices i, j of the matching cell.Think of the most idiomatic way in the language to return the two values at the same time. 实现在2D矩阵m中寻找元素x，返回匹配单元格的索引 i，j 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"func search(m [][]int, x int) (bool, int, int) &#123; for i := range m &#123; for j, v := range m[i] &#123; if v == x &#123; return true, i, j &#125; &#125; &#125; return false, 0, 0&#125;func main() &#123; matrix := [][]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;, &#125; for x := 1; x &lt;= 11; x += 2 &#123; found, i, j := search(matrix, x) if found &#123; fmt.Printf(\"matrix[%v][%v] == %v \\n\", i, j, x) &#125; else &#123; fmt.Printf(\"Value %v not found. \\n\", x) &#125; &#125;&#125; 输出 123456matrix[0][0] == 1 matrix[0][2] == 3 matrix[1][1] == 5 matrix[2][0] == 7 matrix[2][2] == 9 Value 11 not found. 1234567891011121314151617181920212223fn search&lt;T: Eq&gt;(m: &amp;Vec&lt;Vec&lt;T&gt;&gt;, x: &amp;T) -&gt; Option&lt;(usize, usize)&gt; &#123; for (i, row) in m.iter().enumerate() &#123; for (j, column) in row.iter().enumerate() &#123; if *column == *x &#123; return Some((i, j)); &#125; &#125; &#125; None&#125;fn main() &#123; let a = vec![ vec![0, 11], vec![22, 33], vec![44, 55], ]; let hit = search(&amp;a, &amp;33); println!(\"&#123;:?&#125;\", hit);&#125; 输出： 1Some((1, 1))","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"字符串匹配之Boyer-Moore算法","date":"2021-08-30T12:08:58.000Z","path":"2021/08/30/字符串匹配之Boyer-Moore算法/","text":"Moore教授自己的例子 https://mp.weixin.qq.com/s/tPElzIbsDURjpwn0r4pgOw https://mp.weixin.qq.com/s/wG2KyDdHMR1Ry0juEWBViQ https://mp.weixin.qq.com/s/ePjPDIFuhyRp9qSOob9n5Q https://mp.weixin.qq.com/s/UG3_czitLcDeGMo3Movpng https://mp.weixin.qq.com/s/S68mm8XicGerimD8zC6b-Q https://mp.weixin.qq.com/s/RSnFzrmitwCCgDuB73I2QA https://mp.weixin.qq.com/s/3tp7TlGyXfVSs7lpG7dKtw https://mp.weixin.qq.com/s/3XF2iVmg51ubY8qFTVCssQ https://mp.weixin.qq.com/s/3gYbmAAFh08BQmT-9quItQ The algorithm behind Ctrl + F. 阮一峰-字符串匹配的Boyer-Moore算法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"字符串匹配的Rabin–Karp算法","date":"2021-08-11T14:51:28.000Z","path":"2021/08/11/字符串匹配的Rabin–Karp算法/","text":"leetcode-28 实现strStr() 更熟悉的字符串匹配算法可能是KMP算法, 但在Golang中,使用的是Rabin–Karp算法 一般中文译作 拉宾-卡普算法,由迈克尔·拉宾与理查德·卡普于1987年提出 要在一段文本中找出单个模式串的一个匹配，此算法具有线性时间的平均复杂度，其运行时间与待匹配文本和模式串的长度成线性关系。虽然平均情况下，此算法表现优异，但最坏情况下，其复杂度为文本长与模式串长的乘积 尽可能多的利用上一步的结果，这是优化时间复杂度的一大核心 对于数字类型的字符串，可有如下匹配方法： 将该方法扩展到非数字类型的字符串： 以上这张图片的LaTex：1234567$$\\begin&#123;gather&#125; 对于长度为n的字符串 x_&#123;0&#125; x_&#123;1&#125; x_&#123;2&#125; ... x_&#123;n-1&#125;,\\\\其对应的“值”val为\\\\val = x_&#123;0&#125; \\times r^&#123;n-1&#125; + x_&#123;1&#125;\\times r^&#123;n-2&#125; + ... + x_&#123;n-1&#125;\\times r^&#123;0&#125; \\\\其中r为进制数\\end&#123;gather&#125;$ ASCII：英语字符与二进制位之间的关系(其他语言？？)Unicode：将世界上所有的符号都纳入其中，每个符号都对应一个独一无二的编码，最多可以容纳1114112个字符(2021年9月公布的14.0.0，已经收录超过14万个字符)(有个问题是浪费空间。。) 也译作统一码/万国码/国际码UTF-8: 使用最广的一种 Unicode 的实现方式(最大特点是 变长的编码方式)字符编码笔记：ASCII，Unicode 和 UTF-8中日韩汉字Unicode编码表 源码注释： 将源码中的16777619进制改为10进制，从字符串31415926中搜索4159： 4159 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"strconv\")func main() &#123; var primeRK uint32 = 10 sep := \"4159\" hash := uint32(0) for i := 0; i &lt; len(sep); i++ &#123; //fmt.Println(sep[i]) //fmt.Println(string(sep[i])) next, _ := strconv.Atoi(string(sep[i])) //hash = hash*primeRK + uint32(sep[i]) hash = hash*primeRK + uint32(next) fmt.Println(hash) &#125; &#125; 输出为： 12344414154159 完整的以10为primeRK，从31415926中搜索4159的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( \"fmt\" \"strconv\")const PrimeRKNew = 10func main() &#123; str := `31415926` substr := \"4159\" fmt.Println(\"最终结果为:\", IndexRabinKarpNew(str, substr))&#125;func HashStrNew(sep string) (uint32, uint32) &#123; hash := uint32(0) for i := 0; i &lt; len(sep); i++ &#123; //fmt.Println(sep[i]) //fmt.Println(string(sep[i])) next, _ := strconv.Atoi(string(sep[i])) //hash = hash*primeRK + uint32(sep[i]) hash = hash*PrimeRKNew + uint32(next) fmt.Println(hash) &#125; var pow, sq uint32 = 1, PrimeRKNew for i := len(sep); i &gt; 0; i &gt;&gt;= 1 &#123; fmt.Println(\"i is:\", i, \"---\", \"i&amp;1 is:\", i&amp;1) if i&amp;1 != 0 &#123; pow *= sq &#125; sq *= sq fmt.Println(\"pow is:\", pow) &#125; return hash, pow&#125;func IndexRabinKarpNew(s, substr string) int &#123; // Rabin-Karp search hashss, pow := HashStrNew(substr) fmt.Println(\"hashss, pow:\", hashss, pow) fmt.Println(\"~~~分割线~~~\") n := len(substr) var h uint32 for i := 0; i &lt; n; i++ &#123; next1, _ := strconv.Atoi(string(s[i])) //h = h*PrimeRKNew + uint32(s[i]) fmt.Println(\"next1 is:\", next1) h = h*PrimeRKNew + uint32(next1) &#125; fmt.Println(\"h即T串初始值为:\", h) if h == hashss &amp;&amp; s[:n] == substr &#123; return 0 &#125; for i := n; i &lt; len(s); &#123; h *= PrimeRKNew fmt.Println(\"h*=:\", h) last, _ := strconv.Atoi(string(s[i])) //当前T串的最后一个元素 fmt.Println(\"last is:\", last) //h += uint32(s[i]) h += uint32(last) fmt.Println(\"h+=:\", h) //h -= pow * uint32(s[i-n]) first, _ := strconv.Atoi(string(s[i-n])) //当前T串的第一个元素 fmt.Println(\"first is:\", first) h -= pow * uint32(first) fmt.Println(\"h-=:\", h) i++ fmt.Println(\"---下次循环的 i为 ---\", i) if h == hashss &amp;&amp; s[i-n:i] == substr &#123; //s[i-n:i]为当前的T串 return i - n &#125; &#125; return -1&#125; 输出为： 1234567891011121314151617181920212223242526272829304414154159i is: 4 --- i&amp;1 is: 0pow is: 1i is: 2 --- i&amp;1 is: 0pow is: 1i is: 1 --- i&amp;1 is: 1pow is: 10000hashss, pow: 4159 10000~~~分割线~~~next1 is: 3next1 is: 1next1 is: 4next1 is: 1h即T串初始值为: 3141h*=: 31410last is: 5h+=: 31415first is: 3h-=: 1415---下次循环的 i为 --- 5h*=: 14150last is: 9h+=: 14159first is: 1h-=: 4159---下次循环的 i为 --- 6最终结果为: 2 strings.Contains()源码阅读暨internal/bytealg初探 书籍推荐 柔性字符串匹配 牛刀小试: 力扣28. 实现strStr() 力扣187. 重复的DNA序列 力扣686. 重复叠加字符串匹配 另： 除去KMP和RK算法，字符串匹配还有 Boyer-Moore算法(简称BM算法)系列算法，其核心思想是： 在字符串匹配过程中，模式串发现不匹配时，跳过尽可能多的字符以进行下一步的匹配，从而提高匹配效率 BM算法的简化版Horspool算法 以及性能更好的Sunday算法 Python用的也不是KMP，而是boyer-moore和horspool, 源码点此 KMP \b算法的实际应用有哪些？ 图解字符串匹配之Horspool算法和Boyer-Moore算法 参考： RABIN-KARP在GOLANG中的实现 编码：KR字符串匹配，一个简单到领导都看得懂的算法 Rabin-Karp（旋转哈希）算法 字符串处理 Rabin-Karp (Rolling Hash)及相关LeetCode题目 Rabin-Karp 算法（字符串快速查找） 字符串查找算法（二） [Golang] 源码探究:strings go/src/internal/bytealg/bytealg.go Go语言源码中的Rabin-Karp算法 Golang 源码阅读笔记/bytes github-IndexByteString 简单易懂的Rabin Karp算法详解！ 字符串匹配算法-Rabin Karp算法 [算法]轻松掌握rabin-karp Rabin–Karp算法 聊一聊字节跳动的面试 Golang源码剖析——字符串查找算法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"strings.Contains()源码阅读暨internal/bytealg初探","date":"2021-08-09T14:42:17.000Z","path":"2021/08/09/strings-Contains-源码阅读暨internal-bytealg初探/","text":"该篇内容去Go夜读做了分享,配合视频食用更佳可能是因为头一次，也可能是准备不算绝对充分，远没有信手即拈来，更激动也忧心此后要被许多同行——包括新手和大牛，数次学习或检验从而压力山大，有些微紧张。几次口齿不清，数度大脑间歇空白，更有片段未顾及听众观感语速不自觉飞快总之也勇敢迈出了这一步，继续加油，继续Explore。感谢杨文大佬的组织，折腾起这样一个社区，个人要付出得太多。 自18年学习go以来便从中获益良多，也希望以后再能返馈涓埃视频中有期期艾艾片段多多包涵，有讲解不清之处欢迎联系 交流探讨2021.09.30补记. 123456789101112131415package mainimport ( \"strings\")func main() &#123; subStr := \"asdadas\" longStr := \"sadsferwasdaasdasaeqasdadasrdgasdaddsaas\" print(strings.Contains(longStr, subStr))&#125; src/strings/strings.go#L611234// Contains reports whether substr is within s.func Contains(s, substr string) bool &#123; return Index(s, substr) &gt;= 0&#125; strings.Contains()底层调的是strings.Index(),前者是判断某个文本串T中是否存在匹配的子串P，后者是返回某个文本串T中匹配的子串P首次出现的位置，若没有则返回-1 原图点此 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"strings\")func main() &#123; str := \"hello world\" substr := \"o\" //str = \"hello world\" //substr = \"or\" // //str = \"hello worldhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\" //100 //substr = \"orldhhh\" //7 // //str = \"ooooooooohello worldhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\" //100 //substr = \"orldhhh\" //7 // //str = \"hello worldhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\" //100 //substr = \"orldhhhxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" //70 // //str = \"ooooooooohello worldhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\" //100 //substr = \"orldhhhxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\" //70 rs := strings.Index(str, substr) fmt.Println(rs)&#125; src/strings/strings.go#L61123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.func Index(s, substr string) int &#123; n := len(substr) switch &#123; case n == 0: return 0 case n == 1: return IndexByte(s, substr[0]) case n == len(s): if substr == s &#123; return 0 &#125; return -1 case n &gt; len(s): return -1 case n &lt;= bytealg.MaxLen: // Use brute force when s and substr both are small if len(s) &lt;= bytealg.MaxBruteForce &#123; return bytealg.IndexString(s, substr) &#125; c0 := substr[0] c1 := substr[1] i := 0 t := len(s) - n + 1 // 滑动窗口，如s长度为100，substr长度为7，那完成整个比较过程，最多仅需要滑动 100-7+1=94 次（此处并不是每次+1比较，所以需要的次数实际会更少） fails := 0 for i &lt; t &#123; if s[i] != c0 &#123; // IndexByte is faster than bytealg.IndexString, so use it as long as // we're not getting lots of false positives. // IndexByte 比 bytealg.IndexString 快，所以只要我们没有收到很多误报，就尽可能去使用IndexByte o := IndexByte(s[i+1:t], c0) if o &lt; 0 &#123; return -1 &#125; i += o + 1 &#125; if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr &#123; return i &#125; fails++ i++ // Switch to bytealg.IndexString when IndexByte produces too many false positives. // 当IndexByte有太多误报时，切回到bytealg.IndexString // 失败次数&gt; 阈值时，余下部分再切换回 「字符比较」; 对于arm64: 阈值为 4 + （到目前为止已处理的元素数/16 向下取整); 对于amd64: 阈值为 （到目前为止已处理的元素数+16/8) 向下取整) if fails &gt; bytealg.Cutover(i) &#123; r := bytealg.IndexString(s[i:], substr) if r &gt;= 0 &#123; return r + i &#125; return -1 &#125; &#125; return -1 &#125; c0 := substr[0] c1 := substr[1] i := 0 t := len(s) - n + 1 fails := 0 for i &lt; t &#123; if s[i] != c0 &#123; o := IndexByte(s[i+1:t], c0) if o &lt; 0 &#123; return -1 &#125; i += o + 1 &#125; if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr &#123; return i &#125; i++ fails++ // 当 失败次数&gt; 阈值时，余下部分执行「Rabin-Karp算法」； 对于arm64和amd64，阈值均为 4 + （到目前为止已处理的元素数/16 向下取整) // 好奇：为何和上面bytealg.Cutover(i)的阈值逻辑不一样？ if fails &gt;= 4+i&gt;&gt;4 &amp;&amp; i &lt; t &#123; // See comment in ../bytes/bytes.go. j := bytealg.IndexRabinKarp(s[i:], substr) if j &lt; 0 &#123; return -1 &#125; return i + j &#125; &#125; return -1&#125;// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.// IndexByte 返回 s 中 c 的第一个实例的索引，如果 c 不存在于 s 中，则返回 -1。// 即给一个字符串和单个”字符“，返回这个字符在字符串中第一次出现的位置。汇编代码，暴力比较func IndexByte(s string, c byte) int &#123; return bytealg.IndexByteString(s, c)&#125; src/internal/bytealg/indexbyte_native.go 12345// +build 386 amd64 s390x arm arm64 ppc64 ppc64le mips mipsle mips64 mips64le riscv64 wasm//go:noescapefunc IndexByteString(s string, c byte) int src/internal/bytealg/indexbyte_arm64.s 123456TEXT ·IndexByteString(SB),NOSPLIT,$0-32 MOVD s_base+0(FP), R0 MOVD s_len+8(FP), R2 MOVBU c+16(FP), R1 MOVD $ret+24(FP), R8 B indexbytebody&lt;&gt;(SB) src/internal/bytealg/index_native.go12345// IndexString returns the index of the first instance of b in a, or -1 if b is not present in a.// Requires 2 &lt;= len(b) &lt;= MaxLen.//IndexString 返回 a 中 b 的第一个实例的索引，如果 b 不存在于 a 中，则返回 -1。 需要 2 &lt;= len(b) &lt;= MaxLen。// 即给两个字符串a和b，返回字符串b在字符串a中第一次出现的位置。汇编代码，暴力比较func IndexString(a, b string) int src/internal/bytealg/index_arm64.go 1234567891011121314151617181920212223242526272829// Copyright 2018 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.package bytealg// Empirical data shows that using Index can get better// performance when len(s) &lt;= 16.const MaxBruteForce = 16func init() &#123; // Optimize cases where the length of the substring is less than 32 bytes MaxLen = 32&#125;// Cutover reports the number of failures of IndexByte we should tolerate// before switching over to Index.// n is the number of bytes processed so far.// See the bytes.Index implementation for details.//Cutover 报告在切换到 Index 之前我们应该容忍的 IndexByte 的失败次数。//n 是到目前为止处理的字节数。//有关详细信息，请参阅 bytes.Index 实现。func Cutover(n int) int &#123; // cutover 切换；转换，和switch一个意思 // 1 error per 16 characters, plus a few slop to start. //每 16 个字符有 1 个错误，加上开始时的一些错误。 // 即 n/16向下取整，再+4 return 4 + n&gt;&gt;4&#125; MaxLen： arm64架构： 32 s390x: 64 amd64: 如果支持HasAVX2指令集，为63；否则为32 MaxBruteForce: arm64: 16 amd64: 64 src/internal/bytealg/bytealg.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// MaxLen is the maximum length of the string to be searched for (argument b) in Index.// If MaxLen is not 0, make sure MaxLen &gt;= 4.var MaxLen int// PrimeRK is the prime base used in Rabin-Karp algorithm.// primeRK相当于进制 (直译为 素数基)const PrimeRK = 16777619// IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of the// first occurrence of substr in s, or -1 if not present.// IndexRabinKarp 使用 Rabin-Karp 搜索算法返回 substr 在 s 中第一次出现的索引，如果不存在则返回 -1。func IndexRabinKarp(s, substr string) int &#123; // Rabin-Karp search // 返回待匹配字符串(模式串)的哈希值(即P串)，以及pow (为PrimeRK的n-1次方，n为模式串的长度) hashss, pow := HashStr(substr) n := len(substr) var h uint32 for i := 0; i &lt; n; i++ &#123; h = h*PrimeRK + uint32(s[i]) &#125; if h == hashss &amp;&amp; s[:n] == substr &#123; return 0 &#125; for i := n; i &lt; len(s); &#123; h *= PrimeRK h += uint32(s[i]) h -= pow * uint32(s[i-n]) i++ if h == hashss &amp;&amp; s[i-n:i] == substr &#123; return i - n &#125; &#125; return -1&#125;// HashStr returns the hash and the appropriate multiplicative// factor for use in Rabin-Karp algorithm.//HashStr的两个返回值，hashss即9图中P模式串的哈希值，pow为PrimeRK的n-1次方(n为模式串P的长度)func HashStr(sep string) (uint32, uint32) &#123; hash := uint32(0) for i := 0; i &lt; len(sep); i++ &#123; // 当某个运算后发生溢出，将结果对uint32的上限即(1&lt;&lt;32 - 1，也就是4294967295)取模；而后再进行后面的运算 // 类似于一个时钟表盘，从现在开始3小时和27小时后，指针都在相同位置 hash = hash*PrimeRK + uint32(sep[i]) &#125; var pow, sq uint32 = 1, PrimeRK for i := len(sep); i &gt; 0; i &gt;&gt;= 1 &#123; // i &gt;&gt;= 1 即 i = i &gt;&gt; 1 if i&amp;1 != 0 &#123; pow *= sq &#125; sq *= sq &#125; return hash, pow&#125; pow即(n-1)个PrimeRK相乘，其中n=len(sep)； 等价于如下 123for i := 0; i &lt; len(sep); i++ &#123; pow *= PrimeRK&#125; 上面这步for循环算P串hash的操作，之所以不累加，应该是为了防止发生加法溢出(根据同余定理，乘法导致的溢出应该没问题)。这样得到的效果与累加一致，如上面计算 Rabin–Karp算法部分的详细内容，可移步 字符串匹配的Rabin–Karp算法查看 另： src/internal/bytealg/index_native.go中的func IndexString(a, b string) int为何只有方法名，而没有实现。 并且也没有发现//go:linkname指令及unsafe包?函数只有签名，没有函数体一般有两种情况,其一便是go:linkname这种方式，另一种则是函数签名使用Go,然后通过该包中的汇编文件来实现它，这两种都广泛存在于Go源码中 （更多参见 为什么 Go 标准库中有些函数只有签名，没有函数体？）故而func IndexString(a, b string) int 实际执行了下面这段汇编代码1234567TEXT ·IndexString(SB),NOSPLIT,$0-40 MOVD a_base+0(FP), R0 MOVD a_len+8(FP), R1 MOVD b_base+16(FP), R2 MOVD b_len+24(FP), R3 MOVD $ret+32(FP), R9 B indexbody&lt;&gt;(SB)Go语言高级编程（柴树杉，曹春晖）NOSPLIT不会生成或包含栈分裂代码，这一般用于没有任何其它函数调用的叶子函数，这样可以适当提高性能","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"16777619与FNV哈希算法","date":"2021-08-09T14:30:47.000Z","path":"2021/08/09/16777619与FNV哈希算法/","text":"概况 FNV哈希算法全名为Fowler-Noll-Vo算法，是以三位发明人 Glenn Fowler，Landon Curt Noll（这位在发现大素数领域成绩卓著），Phong Vo的首字母命名。 最早在1991年提出 (实际比Rabin-Karp算法要晚) FNV能快速hash大量数据并保持较小的冲突率，它的高度分散使它适用于hash一些非常相近的字符串，比如URL，hostname，文件名，text，IP地址等。 (来自 FNV哈希算法) 这个算法的厉害之处在于其可以保存(上一次的)状态。比如对于字符串ab，它的哈希值是aE+b=HashAB，如果计算bc的哈希值，可以利用第一次计算的结果(HashAB-aE)*E+c=HashBC。该例是两个字符效果不明显，但如果当前串是100个字符，后移一位去哈希算法性能，就会比其他哈希方式(如md5)要快很多。(常见的哈希算法和用途) 对于很多算法，和暴力解法相比，优化的重要途径之一，是把每次运算(如比较)产生的结果在下一次尽可能用上，发挥一点价值。。而不是纯粹每次从头开始再去算(和KMP算法如此，Rabin-Karp算法亦然) FNV在Go源码的src/hash/fnv/fnv.go中， 12345678910const ( offset32 = 2166136261 offset64 = 14695981039346656037 offset128Lower = 0x62b821756295c58d offset128Higher = 0x6c62272e07bb0142 prime32 = 16777619 prime64 = 1099511628211 prime128Lower = 0x13b prime128Shift = 24) 16777619 为32 bit FNV的Prime值。 在rust中也内置该算法, 在Linux，OceanBase等项目中有较多使用, 在Go reflect包中也有使用 使用 可将 字符串 哈希为32bit的数字；将字符串 哈希为任意bit的数字，将字符串 哈希为特定范围的数字 更多参考 FNV算法实战 更多阅读： FNV哈希算法【学习】 go/src/internal/bytealg/bytealg.go 字符串查找算法（二） Go语言源码中的Rabin-Karp算法 github-16777619 分布式技术探索——如何判断哈希的好坏","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Rust之测试","date":"2021-07-20T11:59:02.000Z","path":"2021/07/20/Rust之测试/","text":"Rust学习笔记之测试、文档和基准","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust风格的Hello World","date":"2021-07-20T11:56:41.000Z","path":"2021/07/20/Rust风格的Hello-World/","text":"Rust 借鉴了很多语言，比如Cyclone（一种安全的C语言方言）的基于区域的内存管理模型；C++ 的RAII 原理；Haskell 的类型系统、错误处理类型、typeclasses等等。Rust 有非常小的 runtime，不需要垃圾回收，默认情况下是在栈上进行分类内存，而不是堆上。Rust 的编译器 rustc，一开始使用 Ocaml （一种函数式语言）编写，后来在2011年 Rust 实现了自举。 RUST语言的编程范式 配套视频：以 Rust 为例，带你搞懂编程语言本质","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Rust中的Trait和Go中的Interface","date":"2021-07-20T11:49:07.000Z","path":"2021/07/20/Rust中的Trait和Go中的Interface/","text":"通过例子学习 Go 和 Rust —- Interface 和 Trait Rust 学习笔记之类型、泛型和 Trait","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"底层库的一些tricks","date":"2021-07-11T13:31:53.000Z","path":"2021/07/11/底层库的一些tricks/","text":"位运算代替乘法运算 hash = ((hash &lt;&lt; 5) + hash) + (str); //等价hash(i-1) 33 + str[i]。5(2) = 32(10) 还有一个事情很有意思，乘以33是用左移和加法实现的。底层库对性能要求高啊。 https://zhuanlan.zhihu.com/p/37390018 RK算法中计算 旋转hash值 12345678910111213141516171819// primeRK is the prime base used in Rabin-Karp algorithm.const primeRK = 16777619// hashStr returns the hash and the appropriate multiplicative// factor for use in Rabin-Karp algorithm.func hashStr(sep string) (uint32, uint32) &#123; hash := uint32(0) for i := 0; i &lt; len(sep); i++ &#123; hash = hash*primeRK + uint32(sep[i]) &#125; var pow, sq uint32 = 1, primeRK for i := len(sep); i &gt; 0; i &gt;&gt;= 1 &#123; if i&amp;1 != 0 &#123; pow *= sq &#125; sq *= sq &#125; return hash, pow&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"以多位发明者名字命名的技术和工具","date":"2021-07-08T12:22:35.000Z","path":"2021/07/08/以多位发明者名字命名的技术和工具/","text":"awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母 rsafnvFNV哈希算法 kmprabin-carp","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"构建在线小工具","date":"2021-07-07T13:56:59.000Z","path":"2021/07/07/构建在线小工具/","text":"JSON-to-Go Convert JSON to Go struct 右键网页另存为，会将html文件和js文件夹拷贝到本地。 将其上传服务器，改一下资源文件夹的名字，以及html文件里引用的地址。然后添加nginx配置 项目在/home/ubuntu/tools/json2go目录下，nginx配置为tool_json2to.conf 发现没有像预期中的，查看错误日志 122021/07/07 21:16:53 [crit] 18652#0: *45152 stat() \"/home/ubuntu/tools/json2go/static/common.js\" failed (13: Permission denied), client: 120.xxx.xxx.xx, server: json2.dashen.tech, request: \"GET /static/common.js HTTP/1.1\", host: \"json2.dashen.tech\", referrer: \"http://json2.dashen.tech/\"2021/07/07 21:16:53 [crit] 18652#0: *45152 stat() \"/home/ubuntu/tools/json2go/static/common.js\" failed (13: Permission denied), client: 120.xxx.xxx.xx, server: json2.dashen.tech, request: \"GET /static/common.js HTTP/1.1\", host: \"json2.dashen.tech\", referrer: \"http://json2.dashen.tech/\" 资源请求失败 执行 chmod -R 777 static/， 如预期正常显示 在线json解析 路数如上，项目在/home/ubuntu/tools/json目录下，nginx配置为tool_json.conf 并在nginx配置文件里给其添加访问认证(设置后需要输入账号密码才可访问该资源)","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go语言抢占式调度","date":"2021-07-07T00:37:13.000Z","path":"2021/07/07/Go语言抢占式调度/","text":"Go在1.14之前没有真正的实时抢占机制，而是一套协作式抢占(cooperative preemption)。1.14开始使用非协作式抢占(non-cooperative preemption)，通过堆栈和寄存器来保存抢占上下文，避免对抢占不友好的函数导致GC STW延长 Go 调度模型 协作式抢占与非协作式抢占 再谈调度 本篇是对深度探索Go语言：抢占式调度 的记录 Go调度器GPM sysmon–Runtime Monitoring 问题 123456789101112131415package mainimport \"fmt\"func main()&#123; go func(n int)&#123; for&#123; n++ fmt.Println(n) &#125; &#125;(0) for&#123;&#125;&#125; 如果是Go 1.14及以上版本，确实会如预期，一直输出递增的数字； 但对于Go 1.13及以下版本，居然会发生阻塞。 1.13及以前 使用gvm或Goland自带的版本切换功能，切回到Go 1.13.5 执行代码, 数字打印一段时间后，程序就“静止不动“了。 机器是多核CPU，执行top命令，发现程序仍然在运行中。 但却没有继续输出，说明负责输出数字的goroutine阻塞了 通过dlv进行调试： 拿到程序对应的进程id，执行 dlv attach pid 通过grs查看当前所有的协程 *代表当前调试工具绑定到了该协程。 可通过 gr 6 切换到6号协程； 然后可以继续 grs， 通过bt命令查看栈回溯，探究究竟阻塞在哪里 可以看到实际阻塞发生在runtime.futex这里，再往上倒，会找到runtime.gcStart。阻塞发生在gcStart所在文件的第1287行。 定位到这一行，发现是在执行STW时发生了阻塞。 GC开始前需要STW来 进行开启写屏障等准备工作. 所以STW就是要抢占所以的P，让它们暂时放下手中的活儿，让GC得以正常工作。 而我们(继续执行for{})的1号协程没能被抢占，一直在执行。而STW一直在等待它让出，这样就陷入了僵局 为何如此？ STW时，GC需要抢占所有的P，但这不是值日生喊一嗓子就能清场的问题。 所以它会记录下自己要等待多少个P让出(sched.stopwait=gomaxprocs). 当该值减为0，目的就达到了 对于当前P，以及陷入系统调用中的P(_Psyscall)，还有空闲状态的P(_Pidle),直接将它们设置为_Pgcstop状态即可。 对于还有g在运行的p，则会将对应的g.stackguard0设置为一个特殊标识runtime.stackPreempt,告诉它GC在等待你让出呢 此外还会设置一个gcwaiting标识 (sched.gcwaiting=1)。 接下来就通过这两个标识符的配合，来实现运行中的p的抢占。 怎么实现呢？ goroutine在创建之初，栈的大小是固定的，为了防止栈溢出的情况，编译器会在有明显栈消耗的函数头部插入一些检测代码。通过g.stackguard0来判断是否需要进行栈增长 但如果g.stackguard0被设置为特殊标识runtime.stackPreempt, 便不会去执行栈增长，而是去执行一次调度(schedule())。 在调度执行时，会检测gcwaiting标识。若发现GC在等待执行，便会让出当前p，将其置为_Pgcstop状态。 1号协程之所以没有退出，是因为空的for循环并没有调用函数，也就没机会执行栈增长检测代码。所以它并不知道GC在等待它让出 依赖栈增长检测代码的方式，不算是真正的抢占式调度。 Go 1.14中迎来了真正的抢占式调度 1.14: 依赖栈增长检测代码的抢占代码的，遇到没有函数调用的情况就会出现问题。 在Go 1.14中，实现了基于信号的真正的抢占式调度。 因为基于信号实现，所以也称为异步抢占 函数preemptone用来抢占一个p，在1.13中，preemptone主要用来设置g.preempt=true，并将g.tsackguard0设置为特殊标识(stackPreempt)； 而在1.14中，增加了最后的if语句块，第一个判断用来确认当前硬件环境是否支持这种异步抢占，这个常量值(preemptMSupported)是在编译期间就确定的。 第二个判断用来检测用户是否允许开启异步抢占(默认允许)。 可通过GODEBUG环境变量来禁用异步抢占。 这两条验证都通过，则将p.preempt字段设置为true，实际的抢占操作交由preemptM函数来完成。 该函数的主要逻辑是，通过runtime.signalM函数，向指定M发送sigPreempt信号---- 会调用操作系统中信号相关的系统调用，将指定信号发送给目标线程。 信号发出去了，异步抢占的前一半工作就算是完成了 接收到信号的工作线程 会调用对应的信号handler来处理。Go语言中的信号交由runtime.sighandler来处理。 runtime.sighandler在确认信号为sigPreempt以后，会调用doSigPreempt函数。 doSigPreempt函数会首先确认runtime是否要对指定的g进行异步抢占----首先指定的g与其对应p的preempt字段都要为true，且指定的g还要处在_Grunning状态；还要确认在当前位置打断g并执行异步抢占是安全的----1.指定的g可以挂起并安全的扫描它的栈和寄存器，并且当前被打断的位置并没有打断写屏障； 2.指定的g还有足够的栈空间来注入一个异步抢占函数调用(asyncPreempt); 3.这里可以安全的和runtime进行交互，主要是确定当前并没有持有runtime相关的锁，继而不会在后续尝试获得锁时造成死锁 这三点都ok，就可以放心的通过pushCall向g的执行上下文中注入异步抢占函数调用了。 被注入的异步抢占函数(asyncPreempt)是一个汇编函数，它会先把各个寄存器的值保存在栈上，也就是先保存现场到栈上，然后调用runtime.asyncPreempt2函数，这个函数最终会去执行schedule() 使用dlv验证是否如此 深度解密 Go 语言之基于信号的抢占式调度","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"使用FFmpeg将视频转换成音频","date":"2021-07-02T13:32:51.000Z","path":"2021/07/02/使用FFmpeg将视频转换成音频/","text":"整理移动硬盘,发现了一段2017年,在西安回民街青旅,素昧平生的三人闲谈,当时为视频录制,时长近一小时40分钟,超过10G. 听了后感觉很有意思,但没必要使用视频,音频形式空间小,更合适. (三人分别为: 作为合伙人兼旅店日常理事的东北青年A,一表人才, 但其健谈程度远不及另外两位; 在此无偿打工&amp;免费住宿的与我一般大小的青年B,川陕之交的汉中宁强人,在海南读大学; 结束第一份工作, “无房车压力,有过万存款”的C. 游历古都,攀登高岳, 便从汴州到杭州,开启了一段996生涯 后半段适逢在天津大学读研的俄罗斯西西伯利亚留学生问路华山,和其交谈些许) 苦于本地没有视频转音频工具,和同事闲聊时,说”不就是用FFmpeg一行命令的事吗”,豁然开朗. 安装 使用 brew install ffmpeg 时,因为依赖过多,(尤其升级Big Sur后),中途可能会报错: 这时仅需 brew install 安装失败的依赖名称, 而后再 brew install ffmpeg. 如此往复便可安装成功. 将视频转换为音频 ffmpeg -i 视频名.MOV -vn -acodec libmp3lame -ac 2 -qscale:a 4 -ar 48000 想要转成的音频名.mp3 不消几分钟,便可转换成功 将音频切分成多段 需要对音频资源进行裁剪,同样一行命令搞定: ffmpeg -i source.mp3 -vn -acodec copy -ss 00:00:00.00 -t 00:30:00 part1.mp3 -ss 从 小时：分：秒 处开始切割 -t 持续时间 -to 到 小时：分：秒.毫秒 处截止 将音频转为文字 音频内容太长,想要转成文字. 目前有很多 提供在线音频转文字 功能的平台,但大多需要收费,或体验不佳. 多番比选尝试,发现 网易见外 综合下来最佳 那一年,我24岁,相当健谈,天南海北地和人闲聊. 从东北到海南,安康和汉中,天水与兰州,丽江与大理,西西伯利亚和叶尼塞河, 似是都曾去过居住多年. 几天旅途很快结束，我匆匆回归为一名打工人角色。此后几年，也曾在疲乏和劳累间隙,找寻片刻之机踏上旅途,但再未和陌生人,有如此契阔的闲谈. 少年侠气，交结五都雄。肝胆洞，毛发耸。立谈中，死生同。一诺千金重。推翘勇，矜豪纵。轻盖拥，联飞鞚，斗城东。轰饮酒垆，春色浮寒瓮，吸海垂虹。闲呼鹰嗾犬，白羽摘雕弓，狡穴俄空。乐匆匆。似黄粱梦，辞丹凤；明月共，漾孤蓬。官冗从，怀倥偬；落尘笼，簿书丛。鹖弁如云众，供粗用，忽奇功。笳鼓动，渔阳弄，思悲翁。不请长缨，系取天骄种，剑吼西风。恨登山临水，手寄七弦桐，目送归鸿。","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"fmt.Println与println有多少区别","date":"2021-06-20T09:02:22.000Z","path":"2021/06/20/fmt-Println与println有多少区别/","text":"1. 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"golang.org/x/sync/errgroup\")func main() &#123; var midList []int64 for i := 0; i &lt; 100000000; i++ &#123; midList = append(midList, int64(i)) &#125; var g errgroup.Group i := 0 for _, v := range midList &#123; mid := v g.Go(func() error &#123; var err error errG := err fmt.Println(\"mid为:\", mid) if errG != nil &#123; return errG &#125; return nil &#125;) i++ &#125; //println(\"i 为:\", i)&#125; 会报错 panic: too many concurrent operations on a single file or socket (max 1048575) 而将fmt.Println换作println,则不会有这个错误 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"golang.org/x/sync/errgroup\")func main() &#123; var midList []int64 for i := 0; i &lt; 100000000; i++ &#123; midList = append(midList, int64(i)) &#125; var g errgroup.Group i := 0 for _, v := range midList &#123; mid := v g.Go(func() error &#123; var err error errG := err println(\"mid为:\", mid) if errG != nil &#123; return errG &#125; return nil &#125;) i++ &#125; //println(\"i 为:\", i)&#125; 控制协程(goroutine)的并发数量 2. 使用go build -gcflags=-m 文件名.go, 对于fmt.Println,因为其入参是interface,所以会发生逃逸 12345678# command-line-arguments./文件名.go:26:15: inlining call to fmt.Println./文件名.go:17:6: moved to heap: g./文件名.go:22:8: func literal escapes to heap./文件名.go:26:16: \"mid为:\" escapes to heap./文件名.go:26:16: mid escapes to heap./文件名.go:26:15: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape 对于println,其入参是字符串,不会发生逃逸 1234# command-line-arguments./文件名.go:21:8: can inline main.func1./文件名.go:16:6: moved to heap: g./文件名.go:21:8: func literal escapes to heap golang变量逃逸分析小探 3.123456789101112131415package mainimport ( \"fmt\")func main() &#123; print([]byte(\"a\")) fmt.Println() fmt.Println([]byte(\"a\"))&#125; 输出为： ···go[1/1]0xc00006af67[97]···","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"小齐学编程之活学活用","date":"2021-06-15T22:32:56.000Z","path":"2021/06/16/小齐学编程之活学活用/","text":"一直想教女票写代码,但苦于工作就占据她好大部分精力,周末不辞奔波从杭来沪相聚,实在不忍也无心思. 恰好她工作中需要获取地图上的一些数据, 手工找寻复制 费时费力, 逢此契机, 当然要用代码尽可能简化机械重复操作, 力图一劳永逸. 首选简洁易入门的Python. 下文就是对流程的总结, 及简述每步的意义. 并不Hack,重在感受编程的用途和基本工具的使用. 以百度地图为例,需求如下: 想要收集该关键词匹配到的所有公司的名称,地址,和联系方式(没有电话/手机的则忽略), 1. ctrl+shift+i 调出开发者工具 (Mac为Command+Option+i) (1). 点击 Network,选择XHR 这是为了能够获取接口的返回值,即为了能拿到原始的数据 (2). 点击clear,清理掉当前所有接口信息的返回 (3). 点击左侧下方的页码,如第3页. 这时在控制台就发现有新的接口请求 (4). 选中第一个,右键-&gt;Copy-&gt;Copy as Curl(Windows为Copy as Curl Bash) 这时就把这个接口的请求复制了下来 2.借助Postman,生成Python代码 (1). 依次点击 Import-&gt;Raw text,粘贴,点击Continue-&gt;Import (2). 点击右侧&lt;/&gt;图标,选择 Python - Requests 3.添加逻辑并执行 (1). 复制代码到Pycharm, 找到url和headers里面的pn, 将其后面的内容替换为 &#39; + pn + &#39;&amp;nn=&#39; + nn + &#39; （这是为了把页码写活, 多次请求替代人工翻页；） (2). 再在代码中添加对数据的筛选, 如去掉没有联系方式的内容； 及最后将数据写入到csv的逻辑 最终代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import requestsimport jsonimport csvimport urllibdef cui(): a = 1 pnInt = 1 print(111) wd = urllib.parse.quote(\"xxxx\") while a &lt; 30: nnInt = pnInt * 10 - 10 print(pnInt, nnInt) print(\"++++++++++\") fetch(pnInt, nnInt, wd) a = a + 1 pnInt = pnInt + 1def fetch(pnInt, nnInt, wd): pn = str(pnInt) nn = str(nnInt) # ' + pn + '&amp;nn=' + nn + ' url = 'https://map.baidu.com/?newmap=1&amp;reqflag=pcmap&amp;biz=1&amp;from=webmap&amp;da_par=direct&amp;pcevaname=pc4.1&amp;qt=con&amp;from=webmap&amp;c=245&amp;wd=%E8%88%9F%E5%B1%B1%E8%89%BA%E6%9C%AF%E5%9F%B9%E8%AE%AD&amp;wd2=&amp;pn=' + pn + '&amp;nn=' + nn + '&amp;db=0&amp;sug=0&amp;addr=0&amp;&amp;da_src=pcmappg.poi.page&amp;on_gel=1&amp;src=7&amp;gr=3&amp;l=11&amp;auth=xxxxxxxseckey=xxxxxxxxxxxxxxxxxxxxxxxxxxxxcb80e3ae5bb6a5e50a29d1f9face80bde809c0809b62dc348fb8e9375c542f12cea0f3973b2f8374a4ee078076449048d0030069230a67109146098f873a7ecf0d18d2d7cf627c8f2f33584cc3c674ac5c0eff12722764e7da6a3bb0a02054e4801d774ac0cff4ab78f2a83420ea09639fae7c7b6f7e26aac71cc1034e0575aaf147d9f3ec2307548774f52ee4f90bfc50d20871f853d017c39288420493c900287f0ebaf2ab330a523f3fb8401c852c74b01e041925921ca1bbbe2ad4fe58851985119079d972d1d5583a3acc0b0912e&amp;device_ratio=1&amp;tn=B_NORMAL_MAP&amp;u_loc=13526910,3651307&amp;ie=utf-8&amp;b=(13524456.32,3410109.5;13662696.32,3554493.5)&amp;t=1622983893693' payload = &#123;&#125; headers = &#123; 'Connection': 'keep-alive', 'sec-ch-ua': '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"', 'sec-ch-ua-mobile': '?0', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36', 'Accept': '*/*', 'Sec-Fetch-Site': 'same-origin', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Dest': 'empty', 'Referer': 'https://map.baidu.com/search/%E8%88%9F%E5%B1%B1%E8%89%BA%E6%9C%AF%E5%9F%B9%E8%AE%AD/@13593576.32,3482301.5,11z?querytype=s&amp;da_src=shareurl&amp;wd=%E8%88%9F%E5%B1%B1%E8%89%BA%E6%9C%AF%E5%9F%B9%E8%AE%AD&amp;c=29&amp;src=0&amp;pn=' + pn + '&amp;nn=' + nn + '&amp;sug=0&amp;l=10&amp;b=(13259104.722474225,3292542.035257731;13409631.837938145,3449759.244742268)&amp;from=webmap&amp;biz_forward=%7B%22scaler%22:1,%22styles%22:%22pl%22%7D&amp;seckey=xxxxxxxxxxx9c0809b62dc348fb8e9375c542f12cea0f3973b2f8374a4ee078076449048d0030069230a67109146098f873a7ecf0d18d2d7cf627c8f2f33584cc3c674ac5c0eff12722764e7da6a3bb0a02054e4801d774ac0cff4ab78f2a83420ea09639fae7c7b6f7e26aac71cc1034e0575aaf147d9f3ec2307548774f52ee4f90bfc50d20871f853d017c39288420493c900287f0ebaf2ab330a523f3fb8401c852c74b01e041925921ca1bbbe2ad4fe58851985119079d972d1d5583a3acc0b0912e&amp;device_ratio=1', 'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8,ca;q=0.7', 'Cookie': 'BIDUPSID=32E65C20ED3615E7770A464DB8FF18C8; PSTM=1621914601; __yjs_duid=1_7b92c81608ccfdbad0dc7906094e07961621959460314; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BAIDUID=08209514AAE7C66A7FD0952DF04ECBB7:FG=1; validate=18765; H_PS_PSSID=31254; BDRCVFR[PaHiFN6tims]=9xWipS8B-FspA7EnHc1QhPEUf; delPer=0; PSINO=3; BDRCVFR[tox4WRQ4-Km]=mk3SLVN4HKm; BDRCVFR[-pGxjrCMryR]=mk3SLVN4HKm; BDRCVFR[CLK3Lyfkr9D]=mk3SLVN4HKm; MCITY=-289%3A; ab_sr=1.0.0_Y2Q0MjM2MGI0ODU3M2IwNGI3OWNkOWJkNWEyZWU2NDBkMzlhYWQzMDk2MzZkYTUzZmViYmNlNDM4ZjM3MTM5ZWNhNGU1MTc3OTRiMjNiOGYyN2UzNDBmZDE3NDJjZTQ0; BCLID=7585045023682664764; BDSFRCVID=OePOJeC627XmgEOelBU3o48vuPWbG-QTH6aoohZzyJCRtXDnQwcjEG0PSx8g0K4bAOqsogKK0eOTHkDF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF=JbAtoKD-JKvJfJjkM4rHqR_Lqxby26nqLHO9aJ5nJD_BqJ3aQPTqQptJDUPJqn5t523KbMKaQpP-HJ7qMpoMjfk10a-fbbQP0GbxKl0MLUOtbb0xyn_VMM3beMnMBMPj5mOnaPQY3fAKftnOM46JehL3346-35543bRTLnLy5KJYMDF9Dj0hj6Q3eU5H2bbe56uXQ4D8Kb7Vbp7sQxnkbfJBD4JLabolJCTxbK54aK-Wf45VynrM06L7yajK255LWN5W-K3zW4jsJDoG55bpQT8rMlAOK5Oib4ja_KIbab3vOIJNXpO1MU0zBN5thURB2DkO-4bCWJ5TMl5jDh3Mb6ksD-FtqjtDfnkDoC8hfb6HHTrz-tb5-ICShUFshjbTB2Q-5KL-ytbv8-jkbfJWWfFeja7q-lQ7tJ603fbdJJjoOqcuXPr1ett_babhaPvmQgTxoUJvBCnJhhvG-4clb60ebPRiJPQ9QgbWKpQ7tt5W8ncFbT7l5hKpbt-q0x-jLTnhVn0M5DK0hID9jTLaDToMhfQ2etrKK572sJOOaCvbjbvOy4oTj6j-3-c9el3-JnRiLbA2fPQhSDbRjpJG3MvB-fnjb4DDX57MafjaLJ7sffDlQft205kbeMtjBbQaaGTh_n7jWhk2eq72y-RUQlRX5q79atTMfNTJ-qcH0KQpsIJM5-DWbT8EjHCeJT_OJbkJVCvMaP55K43xKITjh6PgbJ39BtQmJJufhn6j3l7qDhoaDPPMebK00bJa0KrIQg-q3R7O2Uc0JqcJ0ROiQ-Cu5UbB0x-jLN7OVn0MWKbDEq7lKPnJyUnQbtnnBPnR3H8HL4nv2JcJbM5m3x6qLTKkQN3T-PKO5bRh_CcJ-J8XMC_xjj3P; BCLID_BFESS=7585045023682664764; BDSFRCVID_BFESS=OePOJeC627XmgEOelBU3o48vuPWbG-QTH6aoohZzyJCRtXDnQwcjEG0PSx8g0K4bAOqsogKK0eOTHkDF_2uxOjjg8UtVJeC6EG0Ptf8g0f5; H_BDCLCKID_SF_BFESS=JbAtoKD-JKvJfJjkM4rHqR_Lqxby26nqLHO9aJ5nJD_BqJ3aQPTqQptJDUPJqn5t523KbMKaQpP-HJ7qMpoMjfk10a-fbbQP0GbxKl0MLUOtbb0xyn_VMM3beMnMBMPj5mOnaPQY3fAKftnOM46JehL3346-35543bRTLnLy5KJYMDF9Dj0hj6Q3eU5H2bbe56uXQ4D8Kb7Vbp7sQxnkbfJBD4JLabolJCTxbK54aK-Wf45VynrM06L7yajK255LWN5W-K3zW4jsJDoG55bpQT8rMlAOK5Oib4ja_KIbab3vOIJNXpO1MU0zBN5thURB2DkO-4bCWJ5TMl5jDh3Mb6ksD-FtqjtDfnkDoC8hfb6HHTrz-tb5-ICShUFshjbTB2Q-5KL-ytbv8-jkbfJWWfFeja7q-lQ7tJ603fbdJJjoOqcuXPr1ett_babhaPvmQgTxoUJvBCnJhhvG-4clb60ebPRiJPQ9QgbWKpQ7tt5W8ncFbT7l5hKpbt-q0x-jLTnhVn0M5DK0hID9jTLaDToMhfQ2etrKK572sJOOaCvbjbvOy4oTj6j-3-c9el3-JnRiLbA2fPQhSDbRjpJG3MvB-fnjb4DDX57MafjaLJ7sffDlQft205kbeMtjBbQaaGTh_n7jWhk2eq72y-RUQlRX5q79atTMfNTJ-qcH0KQpsIJM5-DWbT8EjHCeJT_OJbkJVCvMaP55K43xKITjh6PgbJ39BtQmJJufhn6j3l7qDhoaDPPMebK00bJa0KrIQg-q3R7O2Uc0JqcJ0ROiQ-Cu5UbB0x-jLN7OVn0MWKbDEq7lKPnJyUnQbtnnBPnR3H8HL4nv2JcJbM5m3x6qLTKkQN3T-PKO5bRh_CcJ-J8XMC_xjj3P; BA_HECTOR=8k240g80012g85akjb1gbpdtl0q; BAIDUID_BFESS=EE9C87CC527526D94BAF4BBF7C68C795:FG=1; BAIDUID=119C90F3DD22536C575B00C437176785:FG=1; MCITY=-289%3A' &#125; response = requests.request(\"GET\", url, headers=headers, data=payload) # print(response.text) d = json.loads(response.text) if \"content\" in d.keys(): print(\"have content!\") rs = d[\"content\"] # print(\"json对象d_json: \", d[\"content\"][0][\"addr\"]) for val in rs: address = val[\"addr\"] if \"ext\" in val.keys(): print(\"have ext!\") extInfo = val[\"ext\"] if len(extInfo) &gt; 0: info = extInfo[\"detail_info\"] if \"name\" in info.keys(): print(\"have name!\") name = info[\"name\"] phone = info[\"phone\"] if len(phone) &gt; 0: print(name) print(phone) print(address) print(\"-------\") writeCsv(name, phone, address)def writeCsv(name, phone, address): print(\"name为：\" + name) print(\"手机号为：\" + phone) # 1. 创建文件对象； 以a+的方式打开是追加数据，而不是覆盖数据 f = open('所需信息.csv', 'a+', encoding='utf-8') # 2. 基于文件对象构建 csv写入对象 csv_writer = csv.writer(f) # 3. 构建列表头 # csv_writer.writerow([\"机构名称\", \"联系方式\", \"详细地址\"]) csv_writer.writerow([name, str(phone) + '\\t', address]) f.close()cui() (3). 点击下方的 Terminal（终端），运行 python 文件名.py,这时在同级文件夹里,就出现了生成的csv文件","tags":[{"name":"Python","slug":"Python","permalink":"http://www.dashen.tech/tags/Python/"}]},{"title":"正式成为Go Contributor","date":"2021-06-15T11:39:17.000Z","path":"2021/06/15/正式成为Go-Contributor/","text":"在这篇成为Go贡献者 完成不多时,就如愿以偿,为Golang做出了微小贡献 在研究Rabin–Karp算法时, 翻阅internal/bytealg包,发现了两行重复的 go build 指令,如获至宝, 当晚就提了pull request 之后gopherbot会commented,提供一个 go-review.googlesource.com的链接. 在这里, Reviewers们会对这次CL进行code review,并做出评论. 我这次的Reviewers是鼎鼎大名的Ian Lance Taylor,Go Team核心成员, 至今还身在开源第一线, 乐此不疲. 作为gccgo的作者,大佬在GCC社区也很活跃 过程中有很多不解,如那个REPLY我无法编辑,请教了编译器领域的Ben Shi,大佬给Go提交了数万行代码,commits次数常年居于前50, 不折不扣的当下国内Go语言贡献第一人. 但由于是我第一次提交CL,有很多格式不规范的地方,Ian大佬都不厌其烦耐心指正,令我惊叹其严谨负责, 诧讶这么一位高屋建瓴成名多时的前辈,竟可以事无巨细更不厌其烦,去指正这些看似无关紧要并无技术含量的问题. 任何一个行业中，总有一小批想想就很兴奋的大师级人物，ta们远远走在前面，背景缥缈而伟岸，却让懵懵懂懂的后来者，不乏追随的勇气和梦想。 (感觉浪费了大佬们的时间,愧疚..) 需要按这个格式来提交,如: 12345net/http: frob the quux before blarfing(包名:改动)[longer description here in the body] (更长的描述,也可不填)Fixes #nnnn (只写#数字即可,不用加 golang/go) 解决掉问题后, 使得TryBots are happy., 之后就Change has been successfully cherry-picked. 这样这次改动就合并到了Go项目中, 之前在Github提的PR也会关闭 这无足轻重的一次改动,于golang只是大河浩瀚浪花一点,对我却是里程碑式的一大步. 更希望这是深入理解源码的进军号角,更是引玉之砖再启潘江陆海 Go Go Go！","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"制图工具汇总","date":"2021-06-10T12:41:02.000Z","path":"2021/06/10/制图工具汇总/","text":"Figma 入门及基础使用R： 画矩形 O： 画圆形 L： 画直线 更多快捷键 史上最全 Figma 快捷键 使用Figma制作动画 安装Motion插件 Motion is an animation tool which helps you to bring your design to life. Want to make some interactions in UI, add some stunning effects or animate some character for a mobile game? Try Motion :) https://www.figma.cool/ https://www.uifig.com/1130.html https://www.bilibili.com/video/BV1XK411571d https://www.bilibili.com/video/BV1fb411e7jB?from=search&amp;seid=12320258080689178519 https://www.bilibili.com/video/BV1eg41137Ks?from=search&amp;seid=1860190642853483436 https://www.bilibili.com/video/BV1sf4y197cL?from=search&amp;seid=10428694504513297000 https://qcrao.com/2021/06/10/out-of-tech/ 更多阅读： 我为什么推荐 Figma 曹大带我学 Go（6）—— 技术之外 Excalidraw 其代码开源 快捷键： 按住shift可以画出 正方形和正圆形 按住 option再拖拽某个图形 可以进行复制 按住 A,可以画箭头 一直点击，最后按esc，可以画出曲线或折线 还可以将excel的数据生成图表(目前仅支持两列数据) 1234567公司 市值Apple 23500Microsoft 22000Google 18300Amazon 16500Facebook 9400Tesla 7740 复制，而后在网页上进行粘贴，会自动弹出： 对多个图形的操作： 点击浏览库可查看其他人分享的图像： 点击 ➡️ Add to Excalidraw,可以添加到自己的库里 目前暂不支持中文的手写体 支持中文的手写体的开源实现： 地址: https://excalidraw.mebtte.com/ 参考： 风靡硅谷的白板工具 Excalidraw ｜开源 + 手绘 = 快乐加倍","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"读<一例 Go 编译器代码优化 bug 定位和修复解析>","date":"2021-06-08T13:15:47.000Z","path":"2021/06/08/读-一例-Go-编译器代码优化-bug-定位和修复解析/","text":"看到一例 Go 编译器代码优化 bug 定位和修复解析这样一篇文章,感觉有些意思. 在此复现和记录 在Go 1.16版本下,是没有这个bug的(已修复). 参照gvm:灵活的Go版本管理工具 将Go版本切至有问题的1.13.5(或1.14.6) 12➜ go versiongo version go1.13.5 darwin/amd64 123456789101112131415161718192021222324252627package mainimport \"fmt\"func main() &#123; sli := []int32&#123;1, 2, 3, 4, 5, 6&#125; // 如果是这种方式声明的sli, 依然会出bug //var sli []int32 //sli = []int32&#123;1, 2, 3, 4, 5, 6&#125; // 如果是这种方式声明的sli, 则不会出bug //sli := make([]int32, 0) //sli = append(sli, 1, 2, 3, 4, 5, 6) for k, v := range sli &#123; //如果把sli改为 []int32&#123;1, 2, 3, 4, 5, 6&#125;,也不会出bug if k+1 &lt; 1 &#123; //去掉这个不会被执行进,没啥用的判断,则也不会出bug; 改为if k+2 &lt; 2 &#123;,也不会出bug panic(\"\") &#125; fmt.Println(\"=========\") fmt.Println(k, v) &#125;&#125; 执行结果: 123456789101112131415161718192021222324252627282930313233343536=========0 1=========1 2=========2 3=========3 4=========4 5=========5 6=========6 622680=========7 192=========8 17477952=========9 0=========10 17733712=========11 0=========12 17475456=========13 0=========14 622792=========15 192=========16 17475584... 在线 查看&amp;比对 给定程序编译产出的汇编结果. 该网站好评! 其实 Go 的编译器的实现中规中矩，相比于 GCC/Clang 等老牌编译器甚至有些简陋，许多优化并未实现 “Go 编译器提供了非常方便的功能，可以查看各个优化 pass 前后的 SSA IR，只需要在编译时，增加一个 GOSSAFUNC=xxx 环境变量即可，xxx 即为想要分析的函数的名字，因为 Go 编译器内部的优化都是函数级别的。比如上图的例子，只需要运行 GOSSAFUNC=main go build ssaexample.go，编译器就会将 SSA IR 结果输出到当前目录的 ssa.html 中，用浏览器打开即可。” 用浏览器打开当前目录的 ssa.html: 执行 GOSSAFUNC=main go build 1.go 浏览器打开: prove pass 的功能是对全局中 SSA 值的取值范围做一个推断,这样就可以消除掉许多不必要的分支判断 Go 是内存安全的语言，所以所有的 slice 取元素操作都需要做一个检查，来判断取元素用的下标是否超出了 slice 的范围，这个操作叫做 bound check。但是实际上，很多代码中在编译期就能确定这个下标是否越界，那么我们就可以将原本需要在运行期做 bound check 的检查给消除掉，这步优化叫做 bound check elimination (即 BCE) 如下 这样的写法在Go源码中非常多 可参考 Go 官方标准编译器中所做的优化 之 Bounds Check Elimination 通过日志中的关键字, 能找到只有 findIndVar 和 addLocalInductiveFacts 这两个函数中会打这条日志，结合上下文和相关注释不难看出实际上问题是出在 addLocalInductiveFacts 这个函数上。addLocalInductiveFacts 具体是什么功能呢？从注释中不难看出，这里的功能是匹配到一种特殊的代码 pattern，即类似 repeat until 的逻辑，在循环末尾判断某个条件是否成立 修复 详细","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"使用errors.Wrapf()代替log.Error()","date":"2021-06-07T13:25:31.000Z","path":"2021/06/07/使用errors-Wrapf-代替log-Error/","text":"项目中 main调func1，func1调取func2… 这样就会出现很多的 if err != nil { log.Printf()} , 在Kibana上查看时会搜到多条日志, 需要逐级定位, 确定错误抛出的点 希望只有一条, 能清晰看到整个堆栈调用信息 使用log.xxxx方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( \"fmt\" \"log\" \"strconv\" \"time\")func init() &#123; log.SetFlags(log.Lshortfile | log.LstdFlags)&#125;func main() &#123; str := \"123a\" rs, err := func1(str) if err != nil &#123; log.Printf(\"err is (%+v)\\n\", err) return &#125; fmt.Println(\"最终结果为:\", rs)&#125;func func1(str string) (int, error) &#123; b, err := func2() if err != nil &#123; log.Printf(\"There is func11111, func2 err(%+v)\\n\", err) &#125; if b == false &#123; strInt, err := strconv.Atoi(str) if err != nil &#123; log.Printf(\"There is func11111, err(%+v)\\n\", err) &#125; return strInt, err &#125; return 0, nil&#125;func func2() (bool, error) &#123; now := time.Now().Unix() endTimeStr := \"2021-08-06 20:00:0000\" endtime, err := time.ParseInLocation(\"2006-01-02 15:04:05\", endTimeStr, time.Local) if err != nil &#123; log.Printf(\"There is func22222, err(%+v)\\n\", err) return false, err &#125; if endtime.Unix() &gt; now &#123; return true, nil &#125; return false, nil&#125; 执行结果: 12342021/06/07 21:52:56 vs.go:56: There is func22222, err(parsing time \"2021-08-06 20:00:0000\": extra text: \"00\")2021/06/07 21:52:56 vs.go:33: There is func11111, func2 err(parsing time \"2021-08-06 20:00:0000\": extra text: \"00\")2021/06/07 21:52:56 vs.go:40: There is func11111, err(strconv.Atoi: parsing \"123a\": invalid syntax)2021/06/07 21:52:56 vs.go:20: err is (strconv.Atoi: parsing \"123a\": invalid syntax) 使用errors.Wrapf方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( \"fmt\" \"github.com/pkg/errors\" \"strconv\" \"time\")func main() &#123; str := \"123a\" rs, err := func1(str) if err != nil &#123; fmt.Printf(\"err: %+v\\n\", err) //fmt.Println(\"err:\", lastErr) //必须%+v才会打印完整堆栈信息,否则只打印错误信息 return &#125; fmt.Println(\"最终结果为:\", rs)&#125;func func1(str string) (int, error) &#123; b, err := func2() if err != nil &#123; err = errors.Wrapf(err, \"There is func11111, func2 err, b is(%b) \\n\", b) &#125; if b == false &#123; var strInt int strInt, err = strconv.Atoi(str) if err != nil &#123; err = errors.Wrapf(err, \"There is func11111,str is(%s)\\n\", str) &#125; return strInt, err &#125; return 0, nil&#125;func func2() (bool, error) &#123; now := time.Now().Unix() endTimeStr := \"2021-08-06 20:00:0000\" endtime, err := time.ParseInLocation(\"2006-01-02 15:04:05\", endTimeStr, time.Local) if err != nil &#123; err = errors.Wrapf(err, \"There is func22222,endTimeStr is(%s)\\n\", endTimeStr) return false, err &#125; if endtime.Unix() &gt; now &#123; return true, nil &#125; return false, nil&#125; 执行: 1234567891011err: strconv.Atoi: parsing \"123a\": invalid syntaxThere is func11111,str is(123a)main.func1 /Users/fliter/go/src/shuang/llog/1.go:39main.main /Users/fliter/go/src/shuang/llog/1.go:13runtime.main /usr/local/Cellar/go/1.16.3/libexec/src/runtime/proc.go:225runtime.goexit /usr/local/Cellar/go/1.16.3/libexec/src/runtime/asm_amd64.s:1371 注意赋值这步, 必不可少！ 有一个问题, 即对于f1调f2,f2调f3这种, 如果f3发生error, 可以逐级将error抛出.但如果一个方法里有两个error, 则第二条会覆盖掉第一条,如上 err = errors.Wrapf(err, &quot;There is func11111, func2 err, b is(%b) \\n&quot;, b)这一条就被覆盖了 12345678910111213141516// Wrapf returns an error annotating err with a stack trace// at the point Wrapf is called, and the format specifier.// If err is nil, Wrapf returns nil.func Wrapf(err error, format string, args ...interface&#123;&#125;) error &#123; if err == nil &#123; return nil &#125; err = &amp;withMessage&#123; cause: err, msg: fmt.Sprintf(format, args...), &#125; return &amp;withStack&#123; err, callers(), &#125;&#125; 12345678func callers() *stack &#123; const depth = 32 var pcs [depth]uintptr n := runtime.Callers(3, pcs[:]) var st stack = pcs[0:n] return &amp;st&#125; 12345678910111213141516171819202122// Callers fills the slice pc with the return program counters of function invocations// on the calling goroutine's stack. The argument skip is the number of stack frames// to skip before recording in pc, with 0 identifying the frame for Callers itself and// 1 identifying the caller of Callers.// It returns the number of entries written to pc.//// To translate these PCs into symbolic information such as function// names and line numbers, use CallersFrames. CallersFrames accounts// for inlined functions and adjusts the return program counters into// call program counters. Iterating over the returned slice of PCs// directly is discouraged, as is using FuncForPC on any of the// returned PCs, since these cannot account for inlining or return// program counter adjustment.func Callers(skip int, pc []uintptr) int &#123; // runtime.callers uses pc.array==nil as a signal // to print a stack trace. Pick off 0-length pc here // so that we don't let a nil pc slice get to it. if len(pc) == 0 &#123; return 0 &#125; return callers(skip, pc)&#125; 12345678910func callers(skip int, pcbuf []uintptr) int &#123; sp := getcallersp() pc := getcallerpc() gp := getg() var n int systemstack(func() &#123; n = gentraceback(pc, sp, 0, gp, skip, &amp;pcbuf[0], len(pcbuf), nil, nil, 0) &#125;) return n&#125; 参考: golang 打印error的堆栈信息 Go错误处理最佳实践","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go 官方标准编译器中所做的优化","date":"2021-06-07T12:48:51.000Z","path":"2021/06/07/Go-官方标准编译器中所做的优化/","text":"本文是对#102 Go 官方标准编译器中实现的优化集锦汇总 内容的记录与总结. 优化1-4: 字符串和字节切片之间的转化 1.紧跟range关键字的 从字符串到字节切片的转换； 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"strings\" \"testing\")var cs10086 = strings.Repeat(\"shuang!\", 10086)func main() &#123; fmt.Println(testing.AllocsPerRun(1, f)) //0 fmt.Println(testing.AllocsPerRun(1, g)) //1&#125;func f() &#123; for range []byte(cs10086) &#123; &#125;&#125;func g() &#123; bs := []byte(cs10086) for range bs &#123; &#125;&#125; f没有开辟内存,g开辟了一次内存. 2.映射元素读取索引语法中被用做键值的 从字节切片到字符串的转换； 1234567891011121314151617181920212223242526272829303132package mainimport ( \"bytes\" \"fmt\" \"testing\")var name = bytes.Repeat([]byte&#123;'x'&#125;, 188)var m = make(map[string]string, 10)var s = \"\"func main() &#123; fmt.Println(testing.AllocsPerRun(1, f2)) //0 fmt.Println(testing.AllocsPerRun(1, g2)) //1 fmt.Println(testing.AllocsPerRun(1, h2)) //1&#125;func f2() &#123; s = m[string(name)] // 有效&#125;func g2() &#123; key := string(name) s = m[key] // 无效&#125;func h2() &#123; m[string(name)] = \"Golang\" // 无效&#125; 3.字符串比较表达式中被用做比较值的 从字节切片到字符串的转换 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"testing\")var x = []byte&#123;1023: 'x'&#125;var y = []byte&#123;1023: 'y'&#125;var b boolfunc main() &#123; fmt.Println(testing.AllocsPerRun(1, f3)) //0 fmt.Println(testing.AllocsPerRun(1, g3)) //2&#125;func f3() &#123; b = string(x) != string(y)&#125;func g3() &#123; sx, sy := string(x), string(y) b = sx == sy&#125; 4.含 非空字符串常量 的字符串衔接表达式中的 从字节切片到字符串的转换 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"testing\")var p = []byte&#123;1023: 'p'&#125;var q = []byte&#123;1023: 'q'&#125;var str stringfunc main() &#123; fmt.Println(testing.AllocsPerRun(1, f4)) //1 fmt.Println(testing.AllocsPerRun(1, g4)) //3&#125;func f4() &#123; str = (\"-\" + string(p) + string(q))[1:]&#125;func g4() &#123; str = string(p) + string(q)&#125; 5.[]rune(aString)转换的时间和空间复杂度都是O(n),但len([]rune(aString))中的此转换 不需要开辟内存 Go 1.12引入 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"strings\" \"testing\")var shuang = strings.Repeat(\"shuang!\", 10086)func main() &#123; fmt.Println(testing.AllocsPerRun(1, f5)) //0 fmt.Println(testing.AllocsPerRun(1, g5)) //1&#125;func f5() &#123; _ = len([]rune(shuang))&#125;func g5() &#123; _ = len([]byte(shuang)) //未对len([]byte(aString))做优化&#125; 6.字符串衔接表达式只需开辟一次内存,无论需要衔接多少个字符串 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"testing\")var h, i, j, k = \"Hello\", \"World\", \"Let's\", \"Go\"var str6 stringfunc main() &#123; fmt.Println(testing.AllocsPerRun(1, f6)) //1 fmt.Println(testing.AllocsPerRun(1, g6)) //3&#125;func f6() &#123; str6 = h + i + j + k&#125;func g6() &#123; str6 = h + i str6 += j str6 += k&#125; 7.for i := range anArrayOrSlice{anArrayOrSlice[i]} = zeroElement} 形式 将被优化为一个内部的memclr操作 123456789101112131415161718192021222324package mainconst N = 1024 * 100var arr [N]intfunc clearArray() &#123; for i := range arr &#123; arr[i] = 0 &#125;&#125;func clearSlice() &#123; sli := arr[:] for i := range sli &#123; sli[i] = 0 &#125;&#125;func clearArrayPtr() &#123; for i := range &amp;arr &#123; arr[i] = 0 &#125;&#125; benchmark: 1234567891011121314151617181920212223package mainimport ( \"testing\")func BenchmarkTest1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; clearArray() &#125;&#125;func BenchmarkTest2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; clearSlice() &#125;&#125;func BenchmarkTest3(b *testing.B) &#123; //无效 for i := 0; i &lt; b.N; i++ &#123; clearArrayPtr() &#125;&#125; 执行结果: 123456789goos: darwingoarch: amd64pkg: xxxxcpu: Intel(R) Core(TM) i7-8557U CPU @ 1.70GHzBenchmarkTest1-8 73000 15309 ns/opBenchmarkTest2-8 76464 15167 ns/opBenchmarkTest3-8 40194 30096 ns/opPASSok xxxx 4.213s 8.for k = range m {delete(m,k)}形式 将被优化为一个内部的map清空操作 9.尺寸不大于4个原生字(即int),并且字段数不超过4个的结构体值被视为是小尺寸值 1234567891011121314151617181920212223242526272829package maintype S1 struct &#123; a int&#125;type S2 struct &#123; a, b int&#125;type S3 struct &#123; a, b, c int&#125;type S4 struct &#123; a, b, c, d int&#125;type S5 struct &#123; a, b, c, d, e int&#125;type S6 struct &#123; a, b, c, d, e, f int&#125;var ss1, ss2, ss3, ss4, ss5, ss6 = make([]S1, 1000), make([]S2, 1000), make([]S3, 1000), make([]S4, 1000), make([]S5, 1000), make([]S6, 1000)var x1, x2, x3, x4, x5, x6 int benchmark: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport \"testing\"func Benchmark_Range1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss1 &#123; x1 = v.a &#125; &#125;&#125;func Benchmark_Range2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss2 &#123; x2 = v.a &#125; &#125;&#125;func Benchmark_Range3(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss3 &#123; x3 = v.a &#125; &#125;&#125;func Benchmark_Range4(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss4 &#123; x4 = v.a &#125; &#125;&#125;func Benchmark_Range5(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss5 &#123; x5 = v.a &#125; &#125;&#125;func Benchmark_Range6(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; for _, v := range ss6 &#123; x6 = v.a &#125; &#125;&#125; 执行结果: 123456789101112goos: darwingoarch: amd64pkg: xxxxcpu: Intel(R) Core(TM) i7-8557U CPU @ 1.70GHzBenchmark_Range1-8 4759434 248.4 ns/opBenchmark_Range2-8 3910621 306.0 ns/opBenchmark_Range3-8 3735921 328.9 ns/opBenchmark_Range4-8 3677784 325.9 ns/opBenchmark_Range5-8 814666 1517 ns/opBenchmark_Range6-8 728656 1568 ns/opPASSok xxxx 8.868s 因为很多一等公民,其底层结构体的元素,都没有超过4个 10.接口值包裹 指针值 比 包裹 其他类型的值 要快 12345package mainvar p, p2 = new([100]int), new([100]int)var ip interface&#123;&#125; 1234567891011121314151617181920212223package mainimport \"testing\"func Benchmark_PointerAssign(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; p = p2 &#125;&#125;func Benchmark_BoxPointer(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; ip = p &#125;&#125;func Benchmark_PointerAssert(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; p = ip.(*[100]int) &#125;&#125; 123456789goos: darwingoarch: amd64pkg: xxxxcpu: Intel(R) Core(TM) i7-8557U CPU @ 1.70GHzBenchmark_PointerAssign-8 1000000000 0.5251 ns/op 0 B/op 0 allocs/opBenchmark_BoxPointer-8 1000000000 0.5833 ns/op 0 B/op 0 allocs/opBenchmark_PointerAssert-8 1000000000 0.6418 ns/op 0 B/op 0 allocs/opPASSok xxxx 2.372s 11.接口值包裹 指针值 比 包裹 其他类型的值 要快 Go 1.15新增优化 12345package mainvar x,y = 255,256var ix,iy interface&#123;&#125; 1234567891011121314151617package mainimport \"testing\"func Benchmark_x(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; ix = x &#125;&#125;func Benchmark_y(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; iy = y &#125;&#125; 12345678goos: darwingoarch: amd64pkg: xxxxcpu: Intel(R) Core(TM) i7-8557U CPU @ 1.70GHzBenchmark_x-8 565624285 2.033 ns/op 0 B/op 0 allocs/opBenchmark_y-8 92127024 12.71 ns/op 8 B/op 1 allocs/opPASSok xxxx 2.653s 12.Bounds Check Elimination","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"Go死码消除","date":"2021-06-01T14:27:18.000Z","path":"2021/06/01/Go死码消除/","text":"概念: 死码消除(dead code elimination, DCE) 是一种编译器优化技术, 作用是在编译阶段去掉对程序运行结果没有任何影响的代码 和 逃逸分析,内联优化并称为 Go编译器执行的三个重要优化 效果: 对于 const.go代码如下: 123456789101112131415161718package mainimport \"fmt\"func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;const a, b = 10, 20func main() &#123; if max(a, b) == a &#123; fmt.Println(a) &#125;&#125; 对于var.go代码如下: 123456789101112131415161718package mainimport \"fmt\"func max2(x, y int) int &#123; if x &gt; y &#123; return x &#125; return y&#125;var x, y = 10, 20func main() &#123; if max2(x, y) == x &#123; fmt.Println(x) &#125;&#125; 两个文件的差异,只在于 两个参数 是变量还是常量 分别编译 const.go 和 var.go, 生成的二进制文件大小如下： go build -o 想要生成的二进制名称 想要编译的.go文件 不难发现, const 比 var 体积小了约 10% 为何如此? 首先编译器会对max函数进行内联优化, const.go 优化后如下: 1234567891011121314151617package mainimport \"fmt\"const a, b = 10, 20func main() &#123; var result int if a &gt; b &#123; result = a &#125; else &#123; result = b &#125; if result == a &#123; fmt.Println(a) &#125;&#125; 因为 a和b是常量, 永远有a&lt;b, 编译器可以在编译时证明该分支永远不会为true, 因此编译器可以进一步优化代码为： if a &gt; b {}这个分支被消除了,这称为分支消除 又知道结果总是等于b,因此编译器还将进一步将代码优化为: 12345678package mainconst a, b = 10, 20func main() &#123; const result = b&#125; 最后就是: 1234package mainfunc main() &#123;&#125; 而对于var.go, 参数为 全局变量 不为常量,编译器并不知道运行过程中x、y会不会发生改变, 因此不能进行死代码消除. 这部分代码被编译到最终的二进制程序中, 造成 二进制文件 var 比 const 体积大了约 10% 分支消除是死码消除一种. 使用静态证明来表明一段代码永远不可达,通常会被称为死代码,它不需要在最终的二进制文件中编译和优化. 编译器在编译阶段, 死码消除与内联优化一起工作, 可以减少循环和分支产生的代码数量","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"gvm:灵活的Go版本管理工具","date":"2021-05-30T12:39:05.000Z","path":"2021/05/30/gvm-灵活的Go版本管理工具/","text":"缘起: 编译下面这段代码时,在Mac上没有什么问题,正常运行, 点击查看代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package mainimport ( \"bytes\" \"encoding/binary\" \"encoding/json\" \"fmt\" \"log\" \"math/rand\" \"net/http\" \"time\")func main() &#123; http.HandleFunc(\"/register\", deal) //设置访问的路由 fmt.Println(\"1111:\", 2222) err := http.ListenAndServe(\":8088\", nil) //设置监听的端口 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125;func deal(w http.ResponseWriter, r *http.Request) &#123; // Golang: 接收GET和POST参数 https://www.cnblogs.com/liuhe688/p/11063945.html // 根据请求body创建一个json解析器实例 decoder := json.NewDecoder(r.Body) // 用于存放参数key=value数据 var params map[string]string // 解析参数 存入map decoder.Decode(&amp;params) name := params[\"name\"] rand.Seed(time.Now().UnixNano()) key := crack(name) fmt.Println(\"name:\", name, \" key:\", crack(name)) fmt.Fprintf(w, key) //这个写入到w的是输出到客户端的&#125;const ( rounds = 12 roundKeys = 2 * (rounds + 1))func crack(text string) string &#123; name := []byte(text) length := len(name) + 4 padded := ((-length) &amp; (8 - 1)) + length bs := make([]byte, 4) binary.BigEndian.PutUint32(bs, uint32(len(name))) buff := bytes.Buffer&#123;&#125; buff.Write(bs) buff.Write(name) var ckName int64 = 0x7a21c951691cd470 var ckKey int64 = -5408575981733630035 ck := newCkCipher(ckName) outBuff := bytes.Buffer&#123;&#125; for i := 0; i &lt; padded; i += 8 &#123; bf := buff.Bytes()[i : i+8] buf := bytes.NewBuffer(bf) var nowVar int64 if err := binary.Read(buf, binary.BigEndian, &amp;nowVar); err != nil &#123; panic(err) &#125; dd := ck.encrypt(nowVar) outBuff.WriteByte(byte(dd &gt;&gt; 56)) outBuff.WriteByte(byte(dd &gt;&gt; 48)) outBuff.WriteByte(byte(dd &gt;&gt; 40)) outBuff.WriteByte(byte(dd &gt;&gt; 32)) outBuff.WriteByte(byte(dd &gt;&gt; 24)) outBuff.WriteByte(byte(dd &gt;&gt; 16)) outBuff.WriteByte(byte(dd &gt;&gt; 8)) outBuff.WriteByte(byte(dd)) &#125; var n int32 for _, b := range outBuff.Bytes() &#123; n = rotateLeft(n^int32(int8(b)), 0x3) &#125; prefix := n ^ 0x54882f8a suffix := rand.Int31() in := int64(prefix) &lt;&lt; 32 s := int64(suffix) switch suffix &gt;&gt; 16 &#123; case 0x0401: case 0x0402: case 0x0403: in |= s break default: in |= 0x01000000 | (s &amp; 0xffffff) break &#125; out := newCkCipher(ckKey).decrypt(in) var n2 int64 for i := 56; i &gt;= 0; i -= 8 &#123; n2 ^= int64((uint64(in) &gt;&gt; i) &amp; 0xff) &#125; vv := int32(n2 &amp; 0xff) if vv &lt; 0 &#123; vv = -vv &#125; return fmt.Sprintf(\"%02x%016x\", vv, uint64(out))&#125;type ckCipher struct &#123; rk [roundKeys]int32&#125;func newCkCipher(ckKey int64) ckCipher &#123; ck := ckCipher&#123;&#125; var ld [2]int32 ld[0] = int32(ckKey) ld[1] = int32(uint64(ckKey) &gt;&gt; 32) ck.rk[0] = -1209970333 for i := 1; i &lt; roundKeys; i++ &#123; ck.rk[i] = ck.rk[i-1] + -1640531527 &#125; var a, b int32 var i, j int for k := 0; k &lt; 3*roundKeys; k++ &#123; ck.rk[i] = rotateLeft(ck.rk[i]+(a+b), 3) a = ck.rk[i] ld[j] = rotateLeft(ld[j]+(a+b), a+b) b = ld[j] i = (i + 1) % roundKeys j = (j + 1) % 2 &#125; return ck&#125;func (ck ckCipher) encrypt(in int64) int64 &#123; a := int32(in) + ck.rk[0] b := int32(uint64(in)&gt;&gt;32) + ck.rk[1] for r := 1; r &lt;= rounds; r++ &#123; a = rotateLeft(a^b, b) + ck.rk[2*r] b = rotateLeft(b^a, a) + ck.rk[2*r+1] &#125; return pkLong(a, b)&#125;func (ck ckCipher) decrypt(in int64) int64 &#123; a := int32(in) b := int32(uint64(in) &gt;&gt; 32) for i := rounds; i &gt; 0; i-- &#123; b = rotateRight(b-ck.rk[2*i+1], a) ^ a a = rotateRight(a-ck.rk[2*i], b) ^ b &#125; b -= ck.rk[1] a -= ck.rk[0] return pkLong(a, b)&#125;func rotateLeft(x int32, y int32) int32 &#123; return int32(x&lt;&lt;(y&amp;(32-1))) | int32(uint32(x)&gt;&gt;(32-(y&amp;(32-1))))&#125;func rotateRight(x int32, y int32) int32 &#123; return int32(uint32(x)&gt;&gt;(y&amp;(32-1))) | int32(x&lt;&lt;(32-(y&amp;(32-1))))&#125;func pkLong(a int32, b int32) int64 &#123; return (int64(a) &amp; 0xffffffff) | (int64(b) &lt;&lt; 32)&#125; 但到了Linux上,就会报错: 123456# command-line-arguments./http_register.go:113:15: invalid operation: uint64(in) &gt;&gt; i (shift count type int, must be unsigned integer)./http_register.go:175:16: invalid operation: x &lt;&lt; (y &amp; (32 - 1)) (shift count type int32, must be unsigned integer)./http_register.go:175:47: invalid operation: uint32(x) &gt;&gt; (32 - y &amp; (32 - 1)) (shift count type int32, must be unsigned integer)./http_register.go:179:24: invalid operation: uint32(x) &gt;&gt; (y &amp; (32 - 1)) (shift count type int32, must be unsigned integer)./http_register.go:179:47: invalid operation: x &lt;&lt; (32 - y &amp; (32 - 1)) (shift count type int32, must be unsigned integer) 而在Mac上进行交叉编译: 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build 文件名.go (如果出现GOROOT blabla之类的,执行go env -w GO111MODULE=off ) 也没有什么问题 导致这种情况的原因,可能因Go版本不同而导致 Mac上的Go版本为 1.16, 而Linux上Go版本为 1.11 解决: 最初想看一下有没有在线的不同Go版本执行工具,无果而终. 想到之前用php时,用过brew switch来切换不同的php版本.但搜索之后发现,这个命令被 brew 弃用了. 之前用过node版本工具nvm,于是试图找寻Go有没有类似工具,发现了gvm. 安装gvm 1$ bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) N.B. : 不同操作系统还需要安装所需依赖，如Mac需要执行brew install mercurial安装mercurial。具体见原始项目 另外如果出现“ERROR: Unrecognized command line argument: ‘use’”报错，可参考此文,执行： 12cp -rp .gvm/scripts/env/use .gvm/scripts/usechmod 775 .gvm/scripts/use 安装go 1.11 1gvm install go1.11 选择版本 1gvm use go1.11 果然已经变为 Go 1.11 在 Go 1.11 环境下执行,果然出现了和在Linux上Go 1.11下出现的同样错误 gvm更多命令 查看版本 123456➜ gvm listgvm gos (installed)=&gt; go1.11 system 查看Go的所有版本 (版本来源于源码中的 tag 标签) 点击查看Go所有版本:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220 gvm listallgvm gos (available) go1 go1.0.1 go1.0.2 go1.0.3 go1.1 go1.1rc2 go1.1rc3 go1.1.1 go1.1.2 go1.2 go1.2rc2 go1.2rc3 go1.2rc4 go1.2rc5 go1.2.1 go1.2.2 go1.3 go1.3beta1 go1.3beta2 go1.3rc1 go1.3rc2 go1.3.1 go1.3.2 go1.3.3 go1.4 go1.4beta1 go1.4rc1 go1.4rc2 go1.4.1 go1.4.2 go1.4.3 go1.5 go1.5beta1 go1.5beta2 go1.5beta3 go1.5rc1 go1.5.1 go1.5.2 go1.5.3 go1.5.4 go1.6 go1.6beta1 go1.6beta2 go1.6rc1 go1.6rc2 go1.6.1 go1.6.2 go1.6.3 go1.6.4 go1.7 go1.7beta1 go1.7beta2 go1.7rc1 go1.7rc2 go1.7rc3 go1.7rc4 go1.7rc5 go1.7rc6 go1.7.1 go1.7.2 go1.7.3 go1.7.4 go1.7.5 go1.7.6 go1.8 go1.8beta1 go1.8beta2 go1.8rc1 go1.8rc2 go1.8rc3 go1.8.1 go1.8.2 go1.8.3 go1.8.4 go1.8.5 go1.8.5rc4 go1.8.5rc5 go1.8.6 go1.8.7 go1.9 go1.9beta1 go1.9beta2 go1.9rc1 go1.9rc2 go1.9.1 go1.9.2 go1.9.3 go1.9.4 go1.9.5 go1.9.6 go1.9.7 go1.10 go1.10beta1 go1.10beta2 go1.10rc1 go1.10rc2 go1.10.1 go1.10.2 go1.10.3 go1.10.4 go1.10.5 go1.10.6 go1.10.7 go1.10.8 go1.11 go1.11beta1 go1.11beta2 go1.11beta3 go1.11rc1 go1.11rc2 go1.11.1 go1.11.2 go1.11.3 go1.11.4 go1.11.5 go1.11.6 go1.11.7 go1.11.8 go1.11.9 go1.11.10 go1.11.11 go1.11.12 go1.11.13 go1.12 go1.12beta1 go1.12beta2 go1.12rc1 go1.12.1 go1.12.2 go1.12.3 go1.12.4 go1.12.5 go1.12.6 go1.12.7 go1.12.8 go1.12.9 go1.12.10 go1.12.11 go1.12.12 go1.12.13 go1.12.14 go1.12.15 go1.12.16 go1.12.17 go1.13 go1.13beta1 go1.13rc1 go1.13rc2 go1.13.1 go1.13.2 go1.13.3 go1.13.4 go1.13.5 go1.13.6 go1.13.7 go1.13.8 go1.13.9 go1.13.10 go1.13.11 go1.13.12 go1.13.13 go1.13.14 go1.13.15 go1.14 go1.14beta1 go1.14rc1 go1.14.1 go1.14.2 go1.14.3 go1.14.4 go1.14.5 go1.14.6 go1.14.7 go1.14.8 go1.14.9 go1.14.10 go1.14.11 go1.14.12 go1.14.13 go1.14.14 go1.14.15 go1.15 go1.15beta1 go1.15rc1 go1.15rc2 go1.15.1 go1.15.2 go1.15.3 go1.15.4 go1.15.5 go1.15.6 go1.15.7 go1.15.8 go1.15.9 go1.15.10 go1.15.11 go1.15.12 go1.16 go1.16beta1 go1.16rc1 go1.16.1 go1.16.2 go1.16.3 go1.16.4 release.r56 release.r57 release.r58 release.r59 release.r60 release.r57.1 release.r57.2 release.r58.1 release.r58.2 release.r60.1 release.r60.2 release.r60.3 其他方案–IDE 不管对于Python,还是Golang,面对版本问题时,使用PyCharm或GoLand,始终是极好的选择 但现在只能下载最近几个版本，更久远的无法安装 其他方案–Docker docker pull golang:1.xx docker run -it --name golang-1.xx自定义名称 golang:1.xx 进入到容器中(默认是基于ubuntu的镜像) (如果没有vi/vim)切换源，安装vim 12345678910111213mv /etc/apt/sources.list /etc/apt/sources.list.bakecho \"deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free\" &gt;/etc/apt/sources.listecho \"deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free\" &gt;&gt;/etc/apt/sources.listecho \"deb http://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free\" &gt;&gt;/etc/apt/sources.listecho \"deb http://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free\" &gt;&gt;/etc/apt/sources.listapt-get updateapt-get install -y vim 这种方式是万能的，任何版本都可以得到 (但是都是Linux版本的~) 其他方案–brew 但如果想用Mac的以往版本的Go，用Docker方式做不到~ 还可以用brew 可以在这里找到所有可以安装的Go版本 (从1.16开始支持m1) 问题解决 切换为Go 1.11.5版本后,IDE会自动报错 y为int32,将其强制转为uint32即可, i为int,将其强制转为uint即可. 参考: 如何灵活地进行 Go 版本管理 类似的工具还有g","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"云时代的开发","date":"2021-05-26T13:22:58.000Z","path":"2021/05/26/云时代的开发/","text":"Mac毫无征兆出了问题,最初没有意识到严重性,直到送修后检测告知,数据很可能丢失.. 所幸大多数资料都追了回来,但之前的机器没法用了. 需要快速搭建顺手的新Mac 有选择性参照这几篇 配置一台符合使用习惯的新Mac 配置一台符合使用习惯的新Mac之brew篇 两台Mac之间的资料互传 更换机器后,Hexo博客的迁移 先安装brew,有gitee的脚本,可以非常快速,一行命令搞定(可以搜索“brew gitee”) 接着用brew install git,以及其他实用工具 ssh-keygen -t rsa -C&quot;xxx@xxx.com&quot;生成公钥/私钥,将公钥配置到github/gitlab/gitee上 配置xx软件,下载Chrome,登陆账号后,可以有选择性安装之前的插件 下载Goland按照这篇点睛之笔–JetBrains系列软件中那些好用的插件进行简单配置 使用brew cask安装postman,登陆之前的账号,历史记录和收藏都会同步过来 下载navicat,登陆账号后,cloud里的连接都会同步过来,但密码需要重新输入. 更多可参考 下载vscode, command+shift+p, 输入shell 选第一项 这样就设置 code为在命令行使用vscode打开文件/文件夹的快捷键 在设置中搜索explorer.sortOrder,将排序方式选为按修改时间 安装oh-my-zsh,用一些内容覆盖.zshrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289ZSH_DISABLE_COMPFIX=true# If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH# Path to your oh-my-zsh installation.export ZSH=\"/Users/fliter/.oh-my-zsh\"# Set name of the theme to load --- if set to \"random\", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes#ZSH_THEME=\"agnoster\"#ZSH_THEME=\"ys\"ZSH_THEME=\"robbyrussell\"##ZSH_THEME=\"robbyrussell\"# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in $ZSH/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE=\"true\"# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE=\"true\"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE=\"true\"# Uncomment the following line to automatically update without prompting.# DISABLE_UPDATE_PROMPT=\"true\"# Uncomment the following line to change how often to auto-update (in days).# export UPDATE_ZSH_DAYS=13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS=\"true\"# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS=\"true\"# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE=\"true\"# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION=\"true\"# Uncomment the following line to display red dots whilst waiting for completion.# COMPLETION_WAITING_DOTS=\"true\"# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"# or set a custom format using the strftime function format specifications,# see 'man strftime' for details.# HIST_STAMPS=\"mm/dd/yyyy\"# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in $ZSH/plugins/# Custom plugins may be added to $ZSH_CUSTOM/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.#plugins=(git)plugins=( git zsh-autosuggestions autojump zsh-syntax-highlighting )# autojump[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.shsource $ZSH/oh-my-zsh.shsource $ZSH/oh-my-zsh.sh# User configuration# export MANPATH=\"/usr/local/man:$MANPATH\"# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi# Compilation flags# export ARCHFLAGS=\"-arch x86_64\"# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=\"mate ~/.zshrc\"# alias ohmyzsh=\"mate ~/.oh-my-zsh\"### 爽哥个人配置export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles# golang相关配置# GOROOT#export GOROOT=/usr/local/opt/go\\@1.16export GOROOT=/usr/local/opt/go\\@1.16/libexec# GOPATHexport GOPATH=/Users/fliter/goexport GOBIN=$GOPATH/bin#export PATH=\"/Users/dashen/go/bin:$PATH\"export PATH=$PATH:$GOROOT/binexport PATH=$PATH:$GOPATH/bin# 为chroimum能登陆账号而加export GOOGLE_API_KEY=AIzaSyAJ7Q7oAUumYJ0-xxxxxxexport GOOGLE_DEFAULT_CLIENT_ID=xxxxxx.apps.googleusercontent.comexport GOOGLE_DEFAULT_CLIENT_SECRET=vxxxxxxxxxxxxxxxalias r='go run *.go'alias gr='go run'alias gb='go build'export PATH=$&#123;PATH&#125;:/usr/local/MongoDB/binalias mongostart='mongod --dbpath \"/Users/xxxx/mongo-data/db\"'alias run-rs='run-rs -v 4.0.0 --shell'export PATH=$&#123;PATH&#125;:/usr/local/Cellar/ffmpeg/4.3.1/bin# for mysql by 爽哥#用alias mysql='/usr/local/Cellar/mysql@5.7/5.7.28/bin/mysql'这种方式,5.7.28/bin目录下的mysql.server还是显示为command not find,把这个路径直接加进PATH,而不是用别名alias方式肯定更好~PATH=\"/usr/local/Cellar/mysql@5.7/5.7.28/bin:$&#123;PATH&#125;\"export PATH# rust 2021.03.04export PATH=$&#123;PATH&#125;:/Users/fliter/.cargo/bin#关闭brew每次执行命令时的自动更新export HOMEBREW_NO_AUTO_UPDATE=true# 超级实用alias sn=\"git shortlog -sn\"alias big=\"du -d 1 -h\"alias ll='ls -al'alias c='clear'alias d='docker'alias p='python'alias p3='python3'#alias aws='ssh -i ~/aws/aws_ec2_cuishuang.pem ubuntu@ec2-3-112-xx-xxx.ap-northeast-1.compute.amazonaws.com'alias aws='ssh ubuntu@3.112.xx.xxx'alias cvm='ssh ubuntu@118.126.xx.xx'alias proxy='export GOPROXY=https://goproxy.cn'# git快捷键alias gt=\"git status\"alias ga=\"git add -A\"alias gm=\"git commit -m\"alias gp=\"git push\"alias gba=\"git branch -a\"alias gf=\"git fetch\"alias gc='git clone'alias etcd=\"/usr/local/Cellar/etcd/3.4.3/bin/etcd\"alias etcdctl=\"/usr/local/Cellar/etcd/3.4.3/bin/etcdctl\"alias up=\"echo go get -insecure -u -v git.xxxxxx.com/xxx_xxx/xxx@develop\"alias k6='sudo fuser -k 80/tcp'alias hao='open http://man.linuxde.net/'alias linux='open http://man.linuxde.net/'alias ss='open http://www.dashen.tech/'alias ym='open https://dnspod.cloud.tencent.com/'alias pqstart='pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start '# 配置sublime命令行启动alias subl=\\''/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\\'alias u='ubuntu@118.126.xx.xx:/home/ubuntu/public'alias e='ETCDCTL_API=3 /usr/local/Cellar/etcd/3.3.10/bin/etcdctl'alias k1='kubectl get namespaces'alias sed='gsed'alias nosleep='caffeinate -disu'alias mysql='mysql.server start'alias gut='git'## 工具eval $(thefuck --alias)alias kk='ll'alias bs='brew search'alias bi='brew install'alias bci='brew cask install'alias nginx='sudo /usr/local/Cellar/openresty/1.17.8.2_1/nginx/sbin/nginx'alias cellar='/usr/local/Cellar'alias diff='git icdiff'# bilibiliexport DEPLOY_ENV=uatexport HOSTNAME=creative-devexport APP_ID=main.archive.creative-webalias mid='echo xxxxxxx'# https://juejin.im/post/6844903939121348616# asciinema拍终端大片alias video='asciinema rec first-rec.cast'export NVM_DIR=\"/Users/fliter/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" # This loads nvm#clearDEPLOY_ENV=uat# Created by mirror-config-chinaexport IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojsexport NODIST_IOJS_MIRROR=https://npm.taobao.org/mirrors/iojsexport NVM_IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojsexport NVMW_IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojsexport NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodeexport NODIST_NODE_MIRROR=https://npm.taobao.org/mirrors/nodeexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodeexport NVMW_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodeexport NVMW_NPM_MIRROR=https://npm.taobao.org/mirrors/npm# End of mirror-config-china[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 会报xx插件缺失,按照报错提示,进行相应安装即可~ 如下几个命令可供参考： 1234567chmod 755 /usr/local/share/zshchmod 755 /usr/local/share/zsh/site-functionsgit clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlightingbrew install autojumpbrew install thefuck big,sn,nosleep几个alias超级好用~ 配置一下Mac安装配置rz、sz 通过我的常用资源库,下载安装实用工具. 备用地址 参考逆向工程,下载Charles","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang逃逸技术分析","date":"2021-05-24T12:08:11.000Z","path":"2021/05/24/golang逃逸技术分析/","text":"申请到栈内存好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。申请到堆上面的内存才会引起垃圾回收。 1234567func F() &#123; a := make([]int, 0, 20) b := make([]int, 0, 20000) l := 20 c := make([]int, 0, l)&#125; a和b代码一样，就是申请的空间不一样大，但是它们两个的命运是截然相反的。a前面已经介绍过，会申请到栈上面，而b，由于申请的内存较大，编译器会把这种申请内存较大的变量转移到堆上面。即使是临时变量，申请过大也会在堆上面申请。而c，对我们而言其含义和a是一致的，但是编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。 堆(Heap)和栈(Stack) 参考 此文 &lt;内存模型：Heap&gt;, &lt;内存模型：Stack&gt;部分的内容: Heap: 堆的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 Stack: 栈是由于函数运行而临时占用的内存区域 执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。 一般来说，调用栈有多少层，就有多少帧。 所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 被翻译为栈。 (栈这个字的原始含义,就有栅栏的意思,所谓 栈道,栈桥,都是指比较简陋的用栅栏做的道路/桥梁) 即 在函数中申请一个新的对象： 如果分配 在栈中，则函数执行结束可自动将内存回收；不会引起垃圾回收，对性能没有影响。 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。 C/C++中的new都是分配到堆上,Go则不一定(Java亦然) 何为逃逸分析(Escape analysis) 在堆上分配的内存,需要GC去回收,而在栈上分配,函数执行完就销毁,不存在垃圾回收的问题. 所以应尽可能将内存分配在栈上. 但问题是,对于一个函数或变量,并不能知道还有没有其他地方在引用. 所谓的逃逸分析,就是为了确定这个事儿~ Go编译器会跨越函数和包的边界进行全局的逃逸分析。它会检查是否需要在堆上为一个变量分配内存，还是说可以在栈本身的内存里对其进行管理。 何时发生逃逸分析? Go编译器决定变量应该分配到什么地方时会进行逃逸分析 From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack. Q：如何得知变量是分配在栈（stack）上还是堆（heap）上？A: 准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。但知道变量的存储位置确实对程序的效率有帮助。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。 当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。 可以使用go命令的 -gcflags=&quot;-m&quot;选项，来观察逃逸分析的结果以及GC工具链的内联决策 ([内联是一种手动或编译器优化，用于将简短函数的调用替换为函数体本身。这么做的原因是它可以消除函数调用本身的开销，也使得编译器能更高效地执行其他的优化策略。我们可以显式地在函数定义前面加一行//go:noinline 注释让编译器不对函数进行内联) 实例 对于escape1.go代码如下: 12345678910111213package mainimport \"fmt\"func main() &#123; fmt.Println(\"Called stackAnalysis\", stackAnalysis())&#125;//go:noinlinefunc stackAnalysis() int &#123; data := 100 return data&#125; 通过 go build -gcflags &quot;-m -l&quot; escape1.go go build -gcflags=-m escape1.go 来查看和分析逃逸分析: 12345./escape1.go:6:13: inlining call to fmt.Println./escape1.go:6:14: \"Called stackAnalysis\" escapes to heap./escape1.go:6:51: stackAnalysis() escapes to heap./escape1.go:6:13: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape escapes to heap 即代表该行该处 内存分配发生了逃逸现象. 变量需要在函数栈之间共享(这个例子就是在main和fmt.Println之间在栈上共享) 第6行第13个字符处的字符串标量”Called stackAnalysis”逃逸到堆上 第6行51个字符处的函数调用stackAnalysis()逃逸到了堆上 对于escape2.go代码如下: 12345678910111213package mainimport \"fmt\"func main() &#123; fmt.Println(\"Called heapAnalysis\", heapAnalysis())&#125;//go:noinlinefunc heapAnalysis() *int &#123; data := 100 return &amp;data&#125; 执行go build -gcflags=-m escape2.go: 123456# command-line-arguments./escape2.go:6:13: inlining call to fmt.Println./escape2.go:11:2: moved to heap: data./escape2.go:6:14: \"Called heapAnalysis\" escapes to heap./escape2.go:6:13: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape 函数heapAnalysis返回 int类型的指针,在main函数中会使用该指针变量. 因为是在heapAnalysis函数外部访问,所以data变量必须被移动到堆上 主函数main会从堆中访问该data变量 (可见指针虽能够减少变量在函数间传递时的数据值拷贝,但不该所有类型数据都返回其指针.如果分配到堆上的共享变量太多会增加了GC的压力) 逃逸类型 1. 指针逃逸: 对于 escape_a.go: 12345678910111213141516171819package maintype Student struct &#123; Name string Age int&#125;func StudentRegister(name string, age int) *Student &#123; s := new(Student) //局部变量s逃逸到堆 s.Name = name s.Age = age return s&#125;func main() &#123; StudentRegister(\"dashen\", 18)&#125; 执行 go build -gcflags=-m escape_a.go 1234567# command-line-arguments./escape_a.go:8:6: can inline StudentRegister./escape_a.go:17:6: can inline main./escape_a.go:18:17: inlining call to StudentRegister./escape_a.go:8:22: leaking param: name./escape_a.go:9:10: new(Student) escapes to heap./escape_a.go:18:17: new(Student) does not escape s 虽然为 函数StudentRegister()内的局部变量, 其值通过函数返回值返回. 但s 本身为指针类型. 所以其指向的内存地址不会是栈而是堆. 这是一种典型的变量逃逸案例 2. 栈空间不足而导致的逃逸(空间开辟过大): 对于 escape_b.go: 12345678910111213package mainfunc InitSlice() &#123; s := make([]int, 1000, 1000) for index := range s &#123; s[index] = index &#125;&#125;func main() &#123; InitSlice()&#125; 执行go build -gcflags=-m escape_b.go 123# command-line-arguments./escape_b.go:11:6: can inline main./escape_b.go:4:11: make([]int, 1000, 1000) does not escape 此时并没有发生逃逸 将切片的容量增大10倍,即: 12345678910111213package mainfunc InitSlice() &#123; s := make([]int, 1000, 10000) for index := range s &#123; s[index] = index &#125;&#125;func main() &#123; InitSlice()&#125; 执行go build -gcflags=-m escape_b.go 123# command-line-arguments./escape_b.go:11:6: can inline main./escape_b.go:4:11: make([]int, 1000, 10000) escapes to heap 发生了逃逸 当栈空间不足以存放当前对象,或无法判断当前切片长度时,会将对象分配到堆中 ps: 1234567891011121314package mainfunc InitSlice() &#123; s := make([]int, 1000, 1000) for index := range s &#123; s[index] = index &#125; println(s)&#125;func main() &#123; InitSlice()&#125; 执行go build -gcflags=-m escape_b.go 123# command-line-arguments./escape_b.go:12:6: can inline main./escape_b.go:4:11: make([]int, 1000, 1000) does not escape 没有逃逸. 而改成12345678910111213141516package mainimport \"fmt\"func InitSlice() &#123; s := make([]int, 1000, 1000) for index := range s &#123; s[index] = index &#125; fmt.Println(s)&#125;func main() &#123; InitSlice()&#125; 执行go build -gcflags=-m escape_b.go,则 1234567# command-line-arguments./escape_b.go:11:13: inlining call to fmt.Println./escape_b.go:14:6: can inline main./escape_b.go:6:11: make([]int, 1000, 1000) escapes to heap./escape_b.go:11:13: s escapes to heap./escape_b.go:11:13: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape 发生了逃逸 这是为何? 参见下文! 3. 动态类型逃逸(不确定长度大小): 当函数参数为interface{}类型, 如最常用的fmt.Println(a …interface{}), 编译期间很难确定其参数的具体类型,也会产生逃逸 对于 escape_c1.go: 12345678package mainimport \"fmt\"func main() &#123; s := \"s会发生逃逸\" fmt.Println(s)&#125; 执行go build -gcflags=-m escape_c1.go 12345# command-line-arguments./escape_c1.go:7:13: inlining call to fmt.Println./escape_c1.go:7:13: s escapes to heap./escape_c1.go:7:13: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape 对于 escape_c1.go: 123456789101112131415package mainfunc main() &#123; InitSlice2()&#125;func InitSlice2() &#123; a := make([]int, 0, 20) // 栈 空间小 b := make([]int, 0, 20000) // 堆 空间过大 逃逸 l := 20 c := make([]int, 0, l) // 堆 动态分配不定空间 逃逸 _, _, _ = a, b, c&#125; 执行go build -gcflags=-m escape_c2.go 12345678910# command-line-arguments./escape_c2.go:7:6: can inline InitSlice2./escape_c2.go:3:6: can inline main./escape_c2.go:4:12: inlining call to InitSlice2./escape_c2.go:4:12: make([]int, 0, 20) does not escape./escape_c2.go:4:12: make([]int, 0, 20000) escapes to heap./escape_c2.go:4:12: make([]int, 0, l) escapes to heap./escape_c2.go:8:11: make([]int, 0, 20) does not escape./escape_c2.go:9:11: make([]int, 0, 20000) escapes to heap./escape_c2.go:12:11: make([]int, 0, l) escapes to heap 4. 闭包引用对象逃逸: 对于如下斐波那契数列escape_d.go: 12345678910111213141516171819package mainimport \"fmt\"func Fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125;func main() &#123; f := Fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"Fibonacci: %d\\n\", f()) &#125;&#125; 执行go build -gcflags=-m escape_d.go 123456789# command-line-arguments./escape_d.go:7:9: can inline Fibonacci.func1./escape_d.go:17:13: inlining call to fmt.Printf./escape_d.go:6:2: moved to heap: a./escape_d.go:6:5: moved to heap: b./escape_d.go:7:9: func literal escapes to heap./escape_d.go:17:34: f() escapes to heap./escape_d.go:17:13: []interface &#123;&#125;&#123;...&#125; does not escape&lt;autogenerated&gt;:1: .this does not escape Fibonacci()函数中原本属于局部变量的a和b,由于闭包的引用,不得不将二者放到堆上,从而产生逃逸 总结 逃逸分析在编译阶段完成 逃逸分析目的是决定内分配地址是栈还是堆 栈上分配内存比在堆中分配内存有更高的效率 栈上分配的内存不需要GC处理 堆上分配的内存使用完毕会交给GC处理 通过逃逸分析,不逃逸的对象分配在栈上,当函数返回时就回收了资源,不需gc标记清除,从而减少gc的压力 同时,栈的分配比堆快,性能好(逃逸的局部变量会在堆上分配,而没有发生逃逸的则有编译器在栈上分配) 另外,还可以进行同步消除: 如果定义的对象的方法上有同步锁,但在运行时却只有一个线程在访问,此时逃逸分析后的机器码会去掉同步锁运行 全文参考自: Go内存管理之代码的逃逸分析 Golang内存分配逃逸分析 推荐阅读: golang如何优化编译、逃逸分析、内联优化 java逃逸技术分析 https://zhuanlan.zhihu.com/p/377397367","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"go:linkname","date":"2021-05-23T15:35:14.000Z","path":"2021/05/23/go-linkname/","text":"初入门径 查看一些官方库的源码时,经常发现找不到其具体的实现,以常用的time.Sleep()为例: 12345// Sleep至少在持续时间d内暂停当前goroutine,// 持续时间为负数或零会导致Sleep立即返回// Sleep pauses the current goroutine for at least the duration d.// A negative or zero duration causes Sleep to return immediately.func Sleep(d Duration) 但该方法的实现在哪里? 寻遍time包,也不见Sleep的实现. 其实其实现在 runtime/time.go: 12345678910111213141516171819// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.// timeSleep使当前的goroutine睡眠至少ns纳秒。//go:linkname timeSleep time.Sleepfunc timeSleep(ns int64) &#123; if ns &lt;= 0 &#123; return &#125; gp := getg() t := gp.timer if t == nil &#123; t = new(timer) gp.timer = t &#125; t.f = goroutineReady t.arg = gp t.nextwhen = nanotime() + ns gopark(resetForSleep, unsafe.Pointer(t), waitReasonSleep, traceEvGoSleep, 1)&#125; go:linkname是源码中最常用的Go指令,其官方定义如下: 123//go:linkname localname [importpath.name]This special directive does not apply to the Go code that follows it. Instead, the //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. If the “importpath.name” argument is omitted, the directive uses the symbol's default object file symbol name and only has the effect of making the symbol accessible to other packages. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported \"unsafe\". 这个指令告诉编译器 为当前源文件中的私有函数或者变量在编译时链接到指定的方法或变量。 因为这个指令破坏了类型系统和包的模块化,因此在使用时必须导入unsafe包. 可以看到runtime/time.go文件是有导入unsafe包的 对于//go:linkname localname [importpath.name], 这里localname对应timeSleep, importpath.name 对应time.Sleep 但为什么要这么做？ 这是因为timeSleep在runtime包里,是不可导出的. 使用go:linkname的目的,就是让time包,可以调用runtime包中原本不可导出的方法 Demo实验 新建demo文件夹,结构如下: 12345678910➜ tree.├── linkname│ └── a.go├── main.go└── outer └── world.go2 directories, 3 files a.go: 12345678package linknameimport _ \"unsafe\"//go:linkname hello demo/outer.Worldfunc hello() &#123; println(\"hello,world!\")&#125; world.go:12345package outerimport _\"demo/linkname\"func World() main.go: 12345678package mainimport \"demo/outer\"func main() &#123; outer.World()&#125; 执行 go run main.go,会出现报错: 1main.go:3:8: package note/demo/outer is not in GOROOT (/usr/local/opt/go@1.14/libexec/src/note/demo/outer) 参考报错package xxx is not in GOROOT,将demo文件夹放到GOPATH下: 12345678➜ src echo $GOPATH/Users/dashen/go// 将demo文件夹移动到GOPATH下➜ pwd/Users/dashen/go/src/demo 执行 go run main.go: 报错如下: 12# demo/outerouter/world.go:5:6: missing function body 这是因为go build默认加会加上-complete参数,这个参数检查到World()没有方法,从而抛出如上错误 可以在outer文件夹中增加一个空的.s文件即可绕过这个限制(也可以选择用单独的compile命令进行编译): 12345678910➜ demo tree.├── linkname│ └── a.go├── main.go└── outer ├── i.s └── world.go2 directories, 4 files 执行 go run main.go: hello,world! 总结&amp;注意事项 linkname注解非常广泛地应用于Go的源码中, 其指令的格式如下： //go:linkname hello(具体的实现) demo/outer.World(导出用到哪个地方) //后面不能有空格 //go:linkname xxx xxxxx 必须在具体实现的正上方,之间不能有空行 go:linkname引导编译器将当前(私有)方法或者变量在编译时链接到指定的位置的方法或者变量,第一个参数表示当前方法或变量,第二个参数表示目标方法或变量,因为这关指令会破坏系统和包的模块化,因此在使用时必须导入unsafe 该指令不经常用(最好在业务开发中也不要用),但了解这个指令可以帮助理解核心包的很多代码. 在标准库中,为了可以使用另一个包的unexported的方法或者变量,正常情况这些unexported资源是不可包外访问的,但是运行时用这个命令hack一下,就变得可以访问 参考: 探究golang的linkname用法 注释竟然还有特殊用途？一文解惑 //go:linkname 指令 更多Go指令,可参考 简单围观一下有趣的 //go: 指令 go系列-注释里的黑魔法","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go中的内联优化","date":"2021-05-22T15:38:11.000Z","path":"2021/05/22/Go中的内联优化/","text":"全文参考自 详解 Go 内联优化 概念: 内联(inline),不是一个多么高大上的概念,虽然作用于编译阶段,但不难理解 ---- f1()调用f2(),编译器将f2的代码”拷贝”到f1(),从而避免调用f2(),这就是所谓的内联. 即 将一个被调用f2()在调用处原地展开,替换成这个函数f2()的实现 (在前端html中,也有内联,但意思有所不同) 为了保证程序的执行高效与安全,现代编译器并不会将程序员的代码直接翻译成相应地机器码,它需要做一系列的检查与优化. Go编译器默认做了很多相关工作,例如未使用的引用包检查、未使用的声明变量检查、有效的括号检查、逃逸分析、内联优化、删除无用代码等。 栈分配内存会比堆分配高效得多, 我们自然希望对象能尽可能被分配在栈上. 在Go中,一个goroutine会有一个单独的栈,栈又会包含多个栈帧,栈帧是函数调用时在栈上为函数所分配的区域. 但其实函数调用是存在一些固定开销的, 如维护帧指针寄存器BP、栈溢出检测等. 因此,对于一些代码行比较少的函数,编译器倾向于将它们在编译期展开从而消除函数调用,这种行为就是内联。 内联的优点有二: 第一 是它消除了函数调用本身的开销(函数调用有固定的开销,如栈和抢占检查); 第二是它使得编译器能更高效地执行其他的优化策略。 一般只有 较简短的函数,进行内联优化才会性价比比较高~ (内联只对叶子函数有效,叶子函数指不调用其他func的函数) 想要禁止编译器内联优化很简单, 在函数定义前一行添加//go:noinline即可 效果: 123456➜ tree.├── go.mod└── inlinebench_test.go0 directories, 2 files inlinebench_test.go: 123456789101112131415161718192021222324252627282930313233343536package shuangInlineimport ( \"testing\")func BenchmarkTest1(b *testing.B) &#123; x, y := 1, 2 b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; MaxNoinline(x, y) &#125;&#125;func BenchmarkTest2(b *testing.B) &#123; x, y := 1, 2 b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; MaxInline(x, y) &#125;&#125;//go:noinlinefunc MaxNoinline(a, b int) int &#123; if a &lt; b &#123; return b &#125; return a&#125;func MaxInline(a, b int) int &#123; if a &lt; b &#123; return b &#125; return a&#125; 执行 go test --bench=. -benchmem -count=3, 123456789101112goos: darwingoarch: amd64pkg: 1(go.mod里写的module名)cpu: Intel(R) Core(TM) i7-8557U CPU @ 1.70GHzBenchmarkTest1-8 834522109 1.349 ns/op 0 B/op 0 allocs/opBenchmarkTest1-8 880187982 1.335 ns/op 0 B/op 0 allocs/opBenchmarkTest1-8 881400147 1.339 ns/op 0 B/op 0 allocs/opBenchmarkTest2-8 1000000000 0.2317 ns/op 0 B/op 0 allocs/opBenchmarkTest2-8 1000000000 0.2349 ns/op 0 B/op 0 allocs/opBenchmarkTest2-8 1000000000 0.2316 ns/op 0 B/op 0 allocs/opPASSok 1 4.790s (相关命令可参考 不同写法的性能差异) 函数体内部的执行逻辑非常简单,此时的性能差异主要体现在函数调用的固定开销上,即内联与否. 显而易见, 同样的函数,不许内联用时是允许内联的6倍,差异非常巨大 选择: 内联优化效果显著,但编译器并不会对所以函数调用都进行内联. 因为内联其实就是 将一个被调用函数f2()在调用处原地展开,替换成这个函数f2()的实现. 当该函数f2()被多次调用,就会被多次展开,这显然会增加编译后二进制文件的大小. 而如果不进行内联,则只需要保存一份函数体的代码,正常进行调用即可. 所以, 在空间上,一般来说内联优化会导致生成的可执行文件变大. 具体来说,编译器内联优化的选择策略是什么呢？ 对于 shuang.go: 1234567891011121314151617181920package mainfunc add(a, b int) int &#123; return a + b&#125;func iter(num int) int &#123; res := 1 for i := 1; i &lt; num; i++ &#123; res = add(res, i) &#125; return res&#125;func main() &#123; n := 100 _ = iter(n)&#125; 可通过执行 go build -gcflags=&quot;-m -m&quot; shuang.go 命令 查看编译器的优化策略: 对于 Go 1.11.x版本, 123456# command-line-arguments./shuang.go:3:6: can inline add as: func(int, int) int &#123; return a + b &#125;./shuang.go:8:6: cannot inline iter: unhandled op FOR./shuang.go:12:12: inlining call to add func(int, int) int &#123; return a + b &#125;./shuang.go:17:6: cannot inline main: function too complex: cost 90 exceeds budget 80/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build729909214/b001/_gomod_.go:6:8: can inline init.0 as: func() &#123; __debug_modinfo__ = \"0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tdashen\\nmod\\tdashen\\t(devel)\\t\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\" &#125; 编译器判断add函数可以被内联优化,并将add函数内联 iter函数由于存在循环语句并不能被内联: cannot inline iter: unhandled op FOR 除了for循环,还有一些情况不会被内联, 如闭包/select/defer/go关键字所开启的新goroutine等, 详细可见src/cmd/compile/internal/gc/inl.go: 1234567891011121314case OCLOSURE, OCALLPART, ORANGE, OFOR, OFORUNTIL, OSELECT, OTYPESW, OPROC, ODEFER, ODCLTYPE, // can't print yet OBREAK, ORETJMP: v.reason = \"unhandled op \" + n.Op.String() return true main函数 不能被内联优化,因为 超过了80个节点的代码量,就不再内联 cost 后面的数值代表抽象语法树AST的节点 还可通过 go build -gcflags=”-m -m -m” shuang.go查看更详细信息:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# command-line-arguments./shuang.go:3:6: can inline add as: func(int, int) int &#123; return a + b &#125;./shuang.go:8:6: cannot inline iter: unhandled op FOR./shuang.go:12:12: inlining call to add func(int, int) int &#123; return a + b &#125;./shuang.go:12:12: Before inlining: . CALLFUNC l(12) tc(1) int. . NAME-main.add a(true) l(3) x(0) class(PFUNC) tc(1) used FUNC-func(int, int) int. CALLFUNC-list. . NAME-main.res a(true) g(3) l(10) x(0) class(PAUTO) tc(1) assigned used int. . NAME-main.i a(true) g(4) l(11) x(0) class(PAUTO) tc(1) assigned used intsubstituting name . NAME-main.a a(true) g(2) l(3) x(0) class(PPARAM) tc(1) used int -&gt; . NAME-main.a a(true) l(3) x(0) class(PAUTO) tc(1) assigned used intsubstituting name . NAME-main.b a(true) g(3) l(3) x(8) class(PPARAM) tc(1) used int -&gt; . NAME-main.b a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int./shuang.go:12:12: After inlining . INLCALL-init. . DCL l(12). . . NAME-main.a a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . DCL l(12). . . NAME-main.b a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . DCL l(12). . . NAME-main.~r2 a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . AS2 l(12) tc(1). . AS2-list. . . NAME-main.a a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . . NAME-main.b a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . AS2-rlist. . . NAME-main.res a(true) g(3) l(10) x(0) class(PAUTO) tc(1) assigned used int. . . NAME-main.i a(true) g(4) l(11) x(0) class(PAUTO) tc(1) assigned used int. . AS l(12) tc(1). . . NAME-main.~r2 a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. INLCALL l(12) tc(1) int. INLCALL-rlist. . NAME-main.~r2 a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. INLCALL-body. . GOTO-init. . . AS2 l(12) tc(1). . . AS2-list. . . . NAME-main.~r2 a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . . AS2-rlist. . . . ADD l(5) tc(1) int. . . . . NAME-main.a a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . . . . NAME-main.b a(true) l(3) x(0) class(PAUTO) tc(1) assigned used int. . GOTO l(12) tc(1). . . NAME-main..i0 a(true) l(12) x(0). . LABEL l(12) tc(1). . . NAME-main..i0 a(true) l(12) x(0)./shuang.go:17:6: cannot inline main: function too complex: cost 90 exceeds budget 80/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build416805477/b001/_gomod_.go:6:8: can inline init.0 as: func() &#123; __debug_modinfo__ = \"0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tdashen\\nmod\\tdashen\\t(devel)\\t\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\" &#125;./shuang.go:5:11:[1] add esc: a./shuang.go:5:11:[1] add esc: b./shuang.go:5:11:[1] add esc: a + b./shuang.go:5:2:[1] add esc: return a + b./shuang.go:5:2:[1] add escassign: ~r2( a(true) g(1) l(3) x(16) class(PPARAMOUT))[NAME] = a + b( l(5) tc(1))[+]./shuang.go:5:11:[1] add escassign: ~r2( a(true) g(1) l(3) x(16) class(PPARAMOUT))[NAME] = a( a(true) g(2) l(3) x(0) class(PPARAM) ld(1) tc(1) used)[NAME]./shuang.go:5:11:[1] add escassign: ~r2( a(true) g(1) l(3) x(16) class(PPARAMOUT))[NAME] = b( a(true) g(3) l(3) x(8) class(PPARAM) ld(1) tc(1) used)[NAME]./shuang.go:10:2:[1] iter esc: res./shuang.go:10:2:[1] iter esc: var res int./shuang.go:10:6:[1] iter esc: res./shuang.go:10:9:[1] iter esc: 1./shuang.go:10:6:[1] iter esc: res := 1./shuang.go:10:6:[1] iter escassign: res( a(true) g(3) l(10) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME] = 1( l(10) tc(1))[LITERAL]./shuang.go:11:6:[1] iter esc: i./shuang.go:11:6:[1] iter esc: var i int./shuang.go:11:8:[1] iter esc: i./shuang.go:11:11:[1] iter esc: 1./shuang.go:11:8:[1] iter esc: i := 1./shuang.go:11:8:[1] iter escassign: i( a(true) g(4) l(11) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME] = 1( l(11) tc(1))[LITERAL]./shuang.go:11:16:[2] iter esc: i./shuang.go:11:16:[2] iter esc: num./shuang.go:11:16:[2] iter esc: i &lt; num./shuang.go:11:24:[2] iter esc: i./shuang.go:11:23:[2] iter esc: 1./shuang.go:11:24:[2] iter esc: i++./shuang.go:11:24:[2] iter escassign: i( a(true) g(4) l(11) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME] = 1( l(11) tc(1))[LITERAL]./shuang.go:12:7:[2] iter esc: res./shuang.go:12:12:[2] iter esc: a./shuang.go:12:12:[2] iter esc: var a int./shuang.go:12:12:[2] iter esc: b./shuang.go:12:12:[2] iter esc: var b int./shuang.go:12:12:[2] iter esc: ~r2./shuang.go:12:12:[2] iter esc: var ~r2 int./shuang.go:12:12:[2] iter esc: a./shuang.go:12:12:[2] iter esc: b./shuang.go:12:12:[2] iter esc: res./shuang.go:12:12:[2] iter esc: i./shuang.go:12:12:[2] iter esc: a, b = res, i./shuang.go:12:12:[2] iter escassign: a( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME] = res( a(true) g(3) l(10) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME]./shuang.go:12:12:[2] iter escassign: b( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME] = i( a(true) g(4) l(11) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME]./shuang.go:12:12:[2] iter esc: ~r2./shuang.go:12:12:[2] iter esc: ~r2 = &lt;N&gt;./shuang.go:12:12:[2] iter esc: ~r2./shuang.go:12:12:[2] iter esc: a./shuang.go:12:12:[2] iter esc: b./shuang.go:12:12:[2] iter esc: a + b./shuang.go:12:12:[2] iter esc: ~r2 = a + b./shuang.go:12:12:[2] iter escassign: ~r2( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME] = a + b( l(5) tc(1))[+]./shuang.go:12:12:[2] iter escassign: ~r2( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME] = a( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME]./shuang.go:12:12:[2] iter escassign: ~r2( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME] = b( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME]./shuang.go:12:12:[2] iter esc: .i0./shuang.go:12:12:[2] iter esc: goto .i0./shuang.go:12:12:[2] iter esc: .i0./shuang.go:12:12:[2] iter esc: .i0: ./shuang.go:12:12:.i0: non-looping label./shuang.go:12:7:[2] iter esc: ~r2./shuang.go:12:7:[2] iter esc: int(~r2)./shuang.go:12:7:[2] iter escassign: int(~r2)( l(12) tc(1) hascall)[CONVNOP] = ~r2( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME]./shuang.go:12:7:[2] iter esc: res = int(~r2)./shuang.go:12:7:[2] iter escassign: res( a(true) g(3) l(10) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME] = int(~r2)( l(12) tc(1) hascall)[CONVNOP]./shuang.go:12:7:[2] iter escassign: res( a(true) g(3) l(10) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME] = ~r2( a(true) l(3) x(0) class(PAUTO) ld(2) tc(1) assigned used)[NAME]./shuang.go:11:2:[1] iter esc: for loop./shuang.go:14:2:[1] iter esc: res./shuang.go:14:2:[1] iter esc: return res./shuang.go:14:2:[1] iter escassign: ~r1( a(true) g(1) l(8) x(8) class(PPARAMOUT))[NAME] = res( a(true) g(3) l(10) x(0) class(PAUTO) ld(1) tc(1) assigned used)[NAME]./shuang.go:18:2:[1] main esc: n./shuang.go:18:2:[1] main esc: var n int./shuang.go:18:4:[1] main esc: n./shuang.go:18:7:[1] main esc: 10./shuang.go:18:4:[1] main esc: n := 10./shuang.go:18:4:[1] main escassign: n( a(true) g(1) l(18) x(0) class(PAUTO) ld(1) tc(1) used)[NAME] = 10( l(18) tc(1))[LITERAL]./shuang.go:19:4:[1] main esc: _./shuang.go:19:10:[1] main esc: iter./shuang.go:19:10:[1] main esc: n./shuang.go:19:10:[1] main esc: iter(n)./shuang.go:19:4:[1] main esc: _ = iter(n)/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build416805477/b001/_gomod_.go:7:22:[1] init.0 esc: __debug_modinfo__/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build416805477/b001/_gomod_.go:7:24:[1] init.0 esc: \"0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tdashen\\nmod\\tdashen\\t(devel)\\t\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\"/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build416805477/b001/_gomod_.go:7:22:[1] init.0 esc: __debug_modinfo__ = \"0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tdashen\\nmod\\tdashen\\t(devel)\\t\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\"/var/folders/9z/kzqrt95n3wj9fq3189s2vvh80000gn/T/go-build416805477/b001/_gomod_.go:7:22:[1] init.0 escassign: __debug_modinfo__( a(true) l(5) x(0) class(PEXTERN) tc(1) assigned)[NAME] = \"0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tdashen\\nmod\\tdashen\\t(devel)\\t\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\"( l(7) tc(1))[LITERAL] 对于 Go 1.16.x版本, 情况有所不同 1234567# command-line-arguments./shuang.go:3:6: can inline add with cost 4 as: func(int, int) int &#123; return a + b &#125;./shuang.go:8:6: can inline iter with cost 29 as: func(int) int &#123; res := 1; for loop; return res &#125;./shuang.go:12:12: inlining call to add func(int, int) int &#123; return a + b &#125;./shuang.go:17:6: can inline main with cost 39 as: func() &#123; n := 100; _ = iter(n) &#125;./shuang.go:19:10: inlining call to iter func(int) int &#123; res := 1; for loop; return res &#125;./shuang.go:19:10: inlining call to add func(int, int) int &#123; return a + b &#125; add,iter,main均可内联. 这应该是某次版本升级带来的优化 内联表: 内联会将函数调用的过程抹掉,这会引入一个新的问题：代码的堆栈信息还能否保证? 举个例子,如果上面的add方法发生了panic,内联之后的程序,还能否准确的打印出堆栈信息？ 123456789101112131415161718package mainfunc sub(a, b int) &#123; a = a - b panic(\"panic information\")&#125;func max(a, b int) int &#123; if a &lt; b &#123; sub(a, b) &#125; return a&#125;func main() &#123; x, y := 1, 2 _ = max(x, y)&#125; 在 Go 1.16下,这段代码 go build -gcflags=&quot;-m -m&quot; cui.go 结果为: 1234567# command-line-arguments./cui.go:3:6: can inline sub with cost 8 as: func(int, int) &#123; a = a - b; panic(\"panic information\") &#125;./cui.go:8:6: can inline max with cost 18 as: func(int, int) int &#123; if a &lt; b &#123; sub(a, b) &#125;; return a &#125;./cui.go:10:6: inlining call to sub func(int, int) &#123; a = a - b; panic(\"panic information\") &#125;./cui.go:15:6: can inline main with cost 33 as: func() &#123; x, y := 1, 2; _ = max(x, y) &#125;./cui.go:17:9: inlining call to max func(int, int) int &#123; if a &lt; b &#123; sub(a, b) &#125;; return a &#125;./cui.go:17:9: inlining call to sub func(int, int) &#123; a = a - b; panic(\"panic information\") &#125; 可知 max函数被内联,执行程序 go run cui.go 12345678910panic: panic informationgoroutine 1 [running]:main.sub(...) /Users/fliter/go/src/shuang/lab/cui.go:5main.max(...) /Users/fliter/go/src/shuang/lab/cui.go:10main.main() /Users/fliter/go/src/shuang/lab/cui.go:17 +0x3aexit status 2 panic依然输出了正确的程序堆栈信息,包括源文件位置和行号信息 这是由于Go内部会为每个存在内联优化的goroutine维持一个内联树（inlining tree）, 该树可通过 go build -gcflags=&quot;-d pctab=pctoinline&quot; cui.go 命令查看:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# command-line-argumentsfuncpctab \"\".sub [valfunc=pctoinline] 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:3) TEXT \"\".sub(SB), ABIInternal, $24-16 0 00000 (/Users/fliter/go/src/shuang/lab/cui.go:3) TEXT \"\".sub(SB), ABIInternal, $24-16 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:3) MOVQ (TLS), CX 9 00009 (/Users/fliter/go/src/shuang/lab/cui.go:3) CMPQ SP, 16(CX) d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:3) PCDATA $0, $-2 d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:3) JLS 58 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:3) PCDATA $0, $-1 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:3) SUBQ $24, SP 13 00019 (/Users/fliter/go/src/shuang/lab/cui.go:3) MOVQ BP, 16(SP) 18 00024 (/Users/fliter/go/src/shuang/lab/cui.go:3) LEAQ 16(SP), BP 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:3) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:5) LEAQ type.string(SB), AX 24 00036 (/Users/fliter/go/src/shuang/lab/cui.go:5) MOVQ AX, (SP) 28 00040 (/Users/fliter/go/src/shuang/lab/cui.go:5) LEAQ \"\"..stmp_0(SB), AX 2f 00047 (/Users/fliter/go/src/shuang/lab/cui.go:5) MOVQ AX, 8(SP) 34 00052 (/Users/fliter/go/src/shuang/lab/cui.go:5) PCDATA $1, $0 34 00052 (/Users/fliter/go/src/shuang/lab/cui.go:5) CALL runtime.gopanic(SB) 39 00057 (/Users/fliter/go/src/shuang/lab/cui.go:5) XCHGL AX, AX 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:5) NOP 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:3) PCDATA $1, $-1 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:3) PCDATA $0, $-2 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:3) CALL runtime.morestack_noctxt(SB) 3f 00063 (/Users/fliter/go/src/shuang/lab/cui.go:3) PCDATA $0, $-1 3f 00063 (/Users/fliter/go/src/shuang/lab/cui.go:3) NOP 40 00064 (/Users/fliter/go/src/shuang/lab/cui.go:3) JMP 0 42 donewrote 3 bytes to 0xc00009e500 00 42 00funcpctab \"\".max [valfunc=pctoinline] 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:8) TEXT \"\".max(SB), ABIInternal, $24-24 0 00000 (/Users/fliter/go/src/shuang/lab/cui.go:8) TEXT \"\".max(SB), ABIInternal, $24-24 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:8) MOVQ (TLS), CX 9 00009 (/Users/fliter/go/src/shuang/lab/cui.go:8) CMPQ SP, 16(CX) d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:8) PCDATA $0, $-2 d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:8) JLS 89 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:8) PCDATA $0, $-1 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:8) SUBQ $24, SP 13 00019 (/Users/fliter/go/src/shuang/lab/cui.go:8) MOVQ BP, 16(SP) 18 00024 (/Users/fliter/go/src/shuang/lab/cui.go:8) LEAQ 16(SP), BP 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:8) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:8) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:9) MOVQ \"\".a+32(SP), AX 22 00034 (/Users/fliter/go/src/shuang/lab/cui.go:9) MOVQ \"\".b+40(SP), CX 27 00039 (/Users/fliter/go/src/shuang/lab/cui.go:9) CMPQ AX, CX 2a 00042 (/Users/fliter/go/src/shuang/lab/cui.go:9) JLT 59 2c 00044 (/Users/fliter/go/src/shuang/lab/cui.go:12) MOVQ AX, \"\".~r2+48(SP) 31 00049 (/Users/fliter/go/src/shuang/lab/cui.go:12) MOVQ 16(SP), BP 36 00054 (/Users/fliter/go/src/shuang/lab/cui.go:12) ADDQ $24, SP 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:12) RET 3b 00059 (/Users/fliter/go/src/shuang/lab/cui.go:10) XCHGL AX, AX 3c 0 00060 (/Users/fliter/go/src/shuang/lab/cui.go:10) LEAQ type.string(SB), AX 43 00067 (/Users/fliter/go/src/shuang/lab/cui.go:10) MOVQ AX, (SP) 47 00071 (/Users/fliter/go/src/shuang/lab/cui.go:10) LEAQ \"\"..stmp_1(SB), AX 4e 00078 (/Users/fliter/go/src/shuang/lab/cui.go:10) MOVQ AX, 8(SP) 53 00083 (/Users/fliter/go/src/shuang/lab/cui.go:10) PCDATA $1, $0 53 00083 (/Users/fliter/go/src/shuang/lab/cui.go:10) CALL runtime.gopanic(SB) 58 00088 (/Users/fliter/go/src/shuang/lab/cui.go:10) XCHGL AX, AX 59 00089 (/Users/fliter/go/src/shuang/lab/cui.go:10) NOP 59 00089 (/Users/fliter/go/src/shuang/lab/cui.go:8) PCDATA $1, $-1 59 00089 (/Users/fliter/go/src/shuang/lab/cui.go:8) PCDATA $0, $-2 59 -1 00089 (/Users/fliter/go/src/shuang/lab/cui.go:8) CALL runtime.morestack_noctxt(SB) 5e 00094 (/Users/fliter/go/src/shuang/lab/cui.go:8) PCDATA $0, $-1 5e 00094 (/Users/fliter/go/src/shuang/lab/cui.go:8) NOP 60 00096 (/Users/fliter/go/src/shuang/lab/cui.go:8) JMP 0 62 donewrote 7 bytes to 0xc0006a2270 00 3c 02 1d 01 09 00-- inlining tree for \"\".max:0 | -1 | \"\".sub (/Users/fliter/go/src/shuang/lab/cui.go:10:6) pc=59--funcpctab \"\".main [valfunc=pctoinline] 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:15) TEXT \"\".main(SB), ABIInternal, $24-0 0 00000 (/Users/fliter/go/src/shuang/lab/cui.go:15) TEXT \"\".main(SB), ABIInternal, $24-0 0 -1 00000 (/Users/fliter/go/src/shuang/lab/cui.go:15) MOVQ (TLS), CX 9 00009 (/Users/fliter/go/src/shuang/lab/cui.go:15) CMPQ SP, 16(CX) d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:15) PCDATA $0, $-2 d 00013 (/Users/fliter/go/src/shuang/lab/cui.go:15) JLS 64 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:15) PCDATA $0, $-1 f 00015 (/Users/fliter/go/src/shuang/lab/cui.go:15) SUBQ $24, SP 13 00019 (/Users/fliter/go/src/shuang/lab/cui.go:15) MOVQ BP, 16(SP) 18 00024 (/Users/fliter/go/src/shuang/lab/cui.go:15) LEAQ 16(SP), BP 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:15) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (/Users/fliter/go/src/shuang/lab/cui.go:15) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 1d 00029 (&lt;unknown line number&gt;) NOP 1d 0 00029 (/Users/fliter/go/src/shuang/lab/cui.go:17) XCHGL AX, AX 1e -1 00030 (/Users/fliter/go/src/shuang/lab/cui.go:17) LEAQ type.string(SB), AX 25 1 00037 (/Users/fliter/go/src/shuang/lab/cui.go:17) MOVQ AX, (SP) 29 00041 (/Users/fliter/go/src/shuang/lab/cui.go:17) LEAQ \"\"..stmp_2(SB), AX 30 00048 (/Users/fliter/go/src/shuang/lab/cui.go:17) MOVQ AX, 8(SP) 35 00053 (/Users/fliter/go/src/shuang/lab/cui.go:17) PCDATA $1, $0 35 00053 (/Users/fliter/go/src/shuang/lab/cui.go:17) CALL runtime.gopanic(SB) 3a 00058 (/Users/fliter/go/src/shuang/lab/cui.go:17) XCHGL AX, AX 3b 00059 (/Users/fliter/go/src/shuang/lab/cui.go:17) NOP 3b 00059 (/Users/fliter/go/src/shuang/lab/cui.go:15) PCDATA $1, $-1 3b 00059 (/Users/fliter/go/src/shuang/lab/cui.go:15) PCDATA $0, $-2 3b -1 00059 (/Users/fliter/go/src/shuang/lab/cui.go:15) NOP 40 00064 (/Users/fliter/go/src/shuang/lab/cui.go:15) CALL runtime.morestack_noctxt(SB) 45 00069 (/Users/fliter/go/src/shuang/lab/cui.go:15) PCDATA $0, $-1 45 00069 (/Users/fliter/go/src/shuang/lab/cui.go:15) JMP 0 47 donewrote 11 bytes to 0xc0004a0260 00 1d 02 01 01 07 04 16 03 0c 00-- inlining tree for \"\".main:0 | -1 | \"\".max (/Users/fliter/go/src/shuang/lab/cui.go:17:9) pc=301 | 0 | \"\".sub (/Users/fliter/go/src/shuang/lab/cui.go:10:6) pc=29-- 由此便可以得到一张映射表,这张表被嵌入到了二进制文件中,在运行时可以得到准确的堆栈信息 控制: Go程序编译时,默认将进行内联优化. 可通过-gcflags=&quot;-l&quot; (或 -gcflags=-l)选项全局禁用内联;与一个-l禁用内联相反,如果传递两个或两个以上的-l则会启用内联,并用更为激进的内联策略. -gcflags=-l，禁用内联。什么都不做，常规的内联 -gcflags=’-l -l’ 内联级别2，更积极，可能更快，可能会制作更大的二进制文件。 -gcflags=’-l -l -l’ 内联级别3，再次更加激进，二进制文件肯定更大，也许更快，但也许会有 bug。 -gcflags=-l=4 (4个 -l) 在 Go 1.11 中将支持实验性的 中间栈内联优化。 如果不想全局范围内禁止优化,而只针对某函数,则可以在函数定义上方 添加//go:noinline 编译指令,来阻止编译器内联该函数 推荐阅读: Go 中的内联优化 Go 中对栈中函数进行内联 更多参考: 方法内联 golang [译] Go语言inline内联的策略与限制 java中的内联: JVM代码优化：方法内联(Method inlining)","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go ast库入门","date":"2021-05-20T11:52:54.000Z","path":"2021/05/20/Go-ast库入门/","text":"对于 hello.go代码如下: 12345package mainfunc main() &#123; println(\"Hello, World!\")&#125; 对于hello-ast.go代码如下: 12345678910111213141516171819202122232425262728package mainimport ( \"go/ast\" \"go/parser\" \"go/token\")func main() &#123; // 即hello.go src := `package mainfunc main() &#123; println(\"Hello, World!\")&#125;` // Create the AST by parsing src. fset := token.NewFileSet() // positions are relative to fset f, err := parser.ParseFile(fset, \"\", src, 0) if err != nil &#123; panic(err) &#125; // Print the AST. ast.Print(fset, f)&#125; 执行 go run hello-ast.go,结果如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 0 *ast.File &#123; 1 . Package: 2:1 2 . Name: *ast.Ident &#123; 3 . . NamePos: 2:9 4 . . Name: \"main\" 5 . &#125; 6 . Decls: []ast.Decl (len = 1) &#123; 7 . . 0: *ast.FuncDecl &#123; 8 . . . Name: *ast.Ident &#123; 9 . . . . NamePos: 3:610 . . . . Name: \"main\"11 . . . . Obj: *ast.Object &#123;12 . . . . . Kind: func13 . . . . . Name: \"main\"14 . . . . . Decl: *(obj @ 7)15 . . . . &#125;16 . . . &#125;17 . . . Type: *ast.FuncType &#123;18 . . . . Func: 3:119 . . . . Params: *ast.FieldList &#123;20 . . . . . Opening: 3:1021 . . . . . Closing: 3:1122 . . . . &#125;23 . . . &#125;24 . . . Body: *ast.BlockStmt &#123;25 . . . . Lbrace: 3:1326 . . . . List: []ast.Stmt (len = 1) &#123;27 . . . . . 0: *ast.ExprStmt &#123;28 . . . . . . X: *ast.CallExpr &#123;29 . . . . . . . Fun: *ast.Ident &#123;30 . . . . . . . . NamePos: 4:531 . . . . . . . . Name: \"println\"32 . . . . . . . &#125;33 . . . . . . . Lparen: 4:1234 . . . . . . . Args: []ast.Expr (len = 1) &#123;35 . . . . . . . . 0: *ast.BasicLit &#123;36 . . . . . . . . . ValuePos: 4:1337 . . . . . . . . . Kind: STRING38 . . . . . . . . . Value: \"\\\"Hello, World!\\\"\"39 . . . . . . . . &#125;40 . . . . . . . &#125;41 . . . . . . . Ellipsis: -42 . . . . . . . Rparen: 4:2843 . . . . . . &#125;44 . . . . . &#125;45 . . . . &#125;46 . . . . Rbrace: 5:147 . . . &#125;48 . . &#125;49 . &#125;50 . Scope: *ast.Scope &#123;51 . . Objects: map[string]*ast.Object (len = 1) &#123;52 . . . \"main\": *(obj @ 11)53 . . &#125;54 . &#125;55 . Unresolved: []*ast.Ident (len = 1) &#123;56 . . 0: *(obj @ 29)57 . &#125;58 &#125; 在线AST解析工具 参考: 小窥Go ast库及初步使用 golang快速入门[4]-go语言如何编译为机器码 漫谈Go语言编译器（01） Go 程序是如何编译成目标机器码的","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"Golang实用进阶工具","date":"2021-05-10T12:29:05.000Z","path":"2021/05/10/Golang实用进阶工具/","text":"gotests Generate Go tests from your source code. 1go get -u github.com/cweill/gotests/... gotests -h 1234567891011121314151617181920212223Usage of gotests: -all generate tests for all functions and methods -excl string regexp. generate tests for functions and methods that do not match. Takes precedence over -only, -exported, and -all -exported generate tests for exported functions and methods. Takes precedence over -only and -all -i print test inputs in error messages -nosubtests disable generating tests using the Go 1.7 subtests feature -only string regexp. generate tests for functions and methods that match only. Takes precedence over -all -parallel enable generating parallel subtests -template string optional. Specify custom test code templates, e.g. testify. This can also be set via environment variable GOTESTS_TEMPLATE -template_dir string optional. Path to a directory containing custom test code templates. Takes precedence over -template. This can also be set via environment variable GOTESTS_TEMPLATE_DIR -template_params string read external parameters to template by json with stdin -template_params_file string read external parameters to template by json with file -w write output to (test) files instead of stdout 对 reverse.go: 1234567891011121314151617181920212223242526package mainimport \"fmt\"//func main()&#123; fmt.Println(reverseString(\"dashen\"))&#125;// reverse for string.func reverseString(s string) string &#123; rs := []rune(s) l := len(rs) for f, t := 0, l-1; f &lt; t; f, t = f+1, t-1 &#123; rs[f], rs[t] = rs[t], rs[f] &#125; ns := string(rs) if l &lt; 10 &#123; for i := 0; i &lt; 10-l; i++ &#123; ns = ns + \"0\" &#125; &#125; return ns&#125; 执行 gotests -all ./ 12345678910111213141516171819202122232425262728293031323334353637Generated Test_reverseStringpackage mainimport \"testing\"func Test_main(t *testing.T) &#123; tests := []struct &#123; name string &#125;&#123; // TODO: Add test cases. &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; main() &#125;) &#125;&#125;func Test_reverseString(t *testing.T) &#123; type args struct &#123; s string &#125; tests := []struct &#123; name string args args want string &#125;&#123; // TODO: Add test cases. &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if got := reverseString(tt.args.s); got != tt.want &#123; t.Errorf(\"reverseString() = %v, want %v\", got, tt.want) &#125; &#125;) &#125;&#125; 填充测试用例如下: 12345678910111213141516171819202122232425package mainimport \"testing\"func Test_reverseString(t *testing.T) &#123; type args struct &#123; s string &#125; tests := []struct &#123; name string args args want string &#125;&#123; &#123;\"testcase1\", args&#123;\"cuishuang\"&#125;, \"gnauhsiuc0\"&#125;, &#123;\"testcase2\", args&#123;\"dashen\"&#125;, \"nehsad0000\"&#125;, // TODO: Add test cases. &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if got := reverseString(tt.args.s); got != tt.want &#123; t.Errorf(\"reverseString() = %v, want %v\", got, tt.want) &#125; &#125;) &#125;&#125; 运行单元测试: 123456789=== RUN Test_reverseString=== RUN Test_reverseString/testcase1=== RUN Test_reverseString/testcase2--- PASS: Test_reverseString (0.00s) --- PASS: Test_reverseString/testcase1 (0.00s) --- PASS: Test_reverseString/testcase2 (0.00s)PASS进程完成，并显示退出代码 0 测试通过. 执行代码覆盖率测试如下： go test -cover 123PASScoverage: 90.0% of statementsok dashne 0.880s (更多参见 Go的测试覆盖率) 可见,使用该工具,可以自动生成绝大部分单元测试的代码~ guru a tool for answering questions about Go source code. Using Go Guru:an editor-integrated tool for navigating Go code godepgraph godepgraph is a program for generating a dependency graph of Go packages. 和go-callvis:极其好用的Go程序调用图生成工具类似 godepgraph -h 1go get github.com/kisielk/godepgraph12345678910111213141516171819202122232425262728293031323334Usage of godepgraph: -d (alias for -withgoroot) show dependencies of packages in the Go standard library -horizontal lay out the dependency graph horizontally instead of vertically -i string (alias for -ignorepackages) a comma-separated list of packages to ignore -ignorepackages string a comma-separated list of packages to ignore -ignoreprefixes string a comma-separated list of prefixes to ignore -l int (alias for -maxlevel) maximum level of the go dependency graph (default 256) -maxlevel int max level of go dependency graph (default 256) -nostdlib ignore packages in the Go standard library -novendor ignore packages in the vendor directory -o string (alias for -onlyprefixes) a comma-separated list of prefixes to include -onlyprefixes string a comma-separated list of prefixes to include -p string (alias for -ignoreprefixes) a comma-separated list of prefixes to ignore -s (alias for -nostdlib) ignore packages in the Go standard library -stoponerror stop on package import errors (default true) -t (alias for -withtests) include test packages -tags string a comma-separated list of build tags to consider satisfied during the build -withgoroot show dependencies of packages in the Go standard library -withtests include test packages godepgraph 某个文件或某个github项目 会生成文字版的引用关系 如 如对于b_sql.go, 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" \"time\")func main() &#123; db, err := gorm.Open(\"mysql\", \"root:12345678@/dashen?charset=utf8&amp;parseTime=True&amp;loc=Local\") if err != nil &#123; panic(err) &#125; defer db.Close() books, err := GetBooksInfo(db, 0, 10, \"*\", \"\", \"\", \"id &lt; ? \", 126) spew.Println(\"books are:\", books) books2, err2 := GetBooksInfo(db, 0, 10, \"*\", \"\", \",(select*from(select+sleep(2)union/**/select+1)a)\", \"id &lt; ? \", 126) spew.Println(\"books2, err2\", books2, err2)&#125;type A struct &#123; Id int `gorm:\"column:id;primary_key;AUTO_INCREMENT\" json:\"id\"` Name string `gorm:\"column:name\" json:\"name\"` Book string `gorm:\"column:book\" json:\"book\"` CreateTime time.Time `gorm:\"column:create_time;default:CURRENT_TIMESTAMP\" json:\"create_time\"`&#125;func (A) TableName() string &#123; return \"a\"&#125;func GetBooksInfo(db *gorm.DB, offset, limit int, field, order, sort, where string, params ...interface&#123;&#125;) (res []*A, err error) &#123; db = db.Select(field).Where(where, params...) if order == \"\" &#123; order = \"create_time\" &#125; if sort == \"\" &#123; sort = \"DESC\" &#125; db = db.Order(order + \" \" + sort) if limit &gt; 0 &#123; db = db.Limit(limit) &#125; if offset &gt; 0 &#123; db = db.Offset(offset) &#125; err = db.Find(&amp;res).Error if err != nil &#123; fmt.Printf(\"GetBooksInfo error (%+v): where (%s), params (%+v)\\n\", err, where, params) return &#125; if res == nil &#123; fmt.Printf(\"GetBooksInfo empty: where (%s), params (%+v)\\n\", where, params) res = make([]*A, 0) &#125; return&#125; 执行 godepgraph b_sql.go: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120digraph godep &#123;splines=orthonodesep=0.4ranksep=0.8node [shape=\"box\",style=\"rounded,filled\"]edge [arrowsize=\"0.5\"]\"b_sql.go\" [label=\"b_sql.go\" color=\"paleturquoise\" URL=\"https://godoc.org/b_sql.go\" target=\"_blank\"];\"b_sql.go\" -&gt; \"fmt\";\"b_sql.go\" -&gt; \"github.com/davecgh/go-spew/spew\";\"b_sql.go\" -&gt; \"github.com/jinzhu/gorm\";\"b_sql.go\" -&gt; \"github.com/jinzhu/gorm/dialects/mysql\";\"b_sql.go\" -&gt; \"time\";\"bytes\" [label=\"bytes\" color=\"palegreen\" URL=\"https://godoc.org/bytes\" target=\"_blank\"];\"context\" [label=\"context\" color=\"palegreen\" URL=\"https://godoc.org/context\" target=\"_blank\"];\"crypto/rand\" [label=\"crypto/rand\" color=\"palegreen\" URL=\"https://godoc.org/crypto/rand\" target=\"_blank\"];\"crypto/rsa\" [label=\"crypto/rsa\" color=\"palegreen\" URL=\"https://godoc.org/crypto/rsa\" target=\"_blank\"];\"crypto/sha1\" [label=\"crypto/sha1\" color=\"palegreen\" URL=\"https://godoc.org/crypto/sha1\" target=\"_blank\"];\"crypto/sha256\" [label=\"crypto/sha256\" color=\"palegreen\" URL=\"https://godoc.org/crypto/sha256\" target=\"_blank\"];\"crypto/tls\" [label=\"crypto/tls\" color=\"palegreen\" URL=\"https://godoc.org/crypto/tls\" target=\"_blank\"];\"crypto/x509\" [label=\"crypto/x509\" color=\"palegreen\" URL=\"https://godoc.org/crypto/x509\" target=\"_blank\"];\"database/sql\" [label=\"database/sql\" color=\"palegreen\" URL=\"https://godoc.org/database/sql\" target=\"_blank\"];\"database/sql/driver\" [label=\"database/sql/driver\" color=\"palegreen\" URL=\"https://godoc.org/database/sql/driver\" target=\"_blank\"];\"encoding/binary\" [label=\"encoding/binary\" color=\"palegreen\" URL=\"https://godoc.org/encoding/binary\" target=\"_blank\"];\"encoding/hex\" [label=\"encoding/hex\" color=\"palegreen\" URL=\"https://godoc.org/encoding/hex\" target=\"_blank\"];\"encoding/json\" [label=\"encoding/json\" color=\"palegreen\" URL=\"https://godoc.org/encoding/json\" target=\"_blank\"];\"encoding/pem\" [label=\"encoding/pem\" color=\"palegreen\" URL=\"https://godoc.org/encoding/pem\" target=\"_blank\"];\"errors\" [label=\"errors\" color=\"palegreen\" URL=\"https://godoc.org/errors\" target=\"_blank\"];\"fmt\" [label=\"fmt\" color=\"palegreen\" URL=\"https://godoc.org/fmt\" target=\"_blank\"];\"github.com/davecgh/go-spew/spew\" [label=\"github.com/davecgh/go-spew/spew\" color=\"paleturquoise\" URL=\"https://godoc.org/github.com/davecgh/go-spew/spew\" target=\"_blank\"];\"github.com/davecgh/go-spew/spew\" -&gt; \"bytes\";\"github.com/davecgh/go-spew/spew\" -&gt; \"encoding/hex\";\"github.com/davecgh/go-spew/spew\" -&gt; \"fmt\";\"github.com/davecgh/go-spew/spew\" -&gt; \"io\";\"github.com/davecgh/go-spew/spew\" -&gt; \"os\";\"github.com/davecgh/go-spew/spew\" -&gt; \"reflect\";\"github.com/davecgh/go-spew/spew\" -&gt; \"regexp\";\"github.com/davecgh/go-spew/spew\" -&gt; \"sort\";\"github.com/davecgh/go-spew/spew\" -&gt; \"strconv\";\"github.com/davecgh/go-spew/spew\" -&gt; \"strings\";\"github.com/davecgh/go-spew/spew\" -&gt; \"unsafe\";\"github.com/go-sql-driver/mysql\" [label=\"github.com/go-sql-driver/mysql\" color=\"paleturquoise\" URL=\"https://godoc.org/github.com/go-sql-driver/mysql\" target=\"_blank\"];\"github.com/go-sql-driver/mysql\" -&gt; \"bytes\";\"github.com/go-sql-driver/mysql\" -&gt; \"context\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/rand\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/rsa\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/sha1\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/sha256\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/tls\";\"github.com/go-sql-driver/mysql\" -&gt; \"crypto/x509\";\"github.com/go-sql-driver/mysql\" -&gt; \"database/sql\";\"github.com/go-sql-driver/mysql\" -&gt; \"database/sql/driver\";\"github.com/go-sql-driver/mysql\" -&gt; \"encoding/binary\";\"github.com/go-sql-driver/mysql\" -&gt; \"encoding/pem\";\"github.com/go-sql-driver/mysql\" -&gt; \"errors\";\"github.com/go-sql-driver/mysql\" -&gt; \"fmt\";\"github.com/go-sql-driver/mysql\" -&gt; \"io\";\"github.com/go-sql-driver/mysql\" -&gt; \"log\";\"github.com/go-sql-driver/mysql\" -&gt; \"math\";\"github.com/go-sql-driver/mysql\" -&gt; \"math/big\";\"github.com/go-sql-driver/mysql\" -&gt; \"net\";\"github.com/go-sql-driver/mysql\" -&gt; \"net/url\";\"github.com/go-sql-driver/mysql\" -&gt; \"os\";\"github.com/go-sql-driver/mysql\" -&gt; \"reflect\";\"github.com/go-sql-driver/mysql\" -&gt; \"sort\";\"github.com/go-sql-driver/mysql\" -&gt; \"strconv\";\"github.com/go-sql-driver/mysql\" -&gt; \"strings\";\"github.com/go-sql-driver/mysql\" -&gt; \"sync\";\"github.com/go-sql-driver/mysql\" -&gt; \"sync/atomic\";\"github.com/go-sql-driver/mysql\" -&gt; \"syscall\";\"github.com/go-sql-driver/mysql\" -&gt; \"time\";\"github.com/jinzhu/gorm\" [label=\"github.com/jinzhu/gorm\" color=\"paleturquoise\" URL=\"https://godoc.org/github.com/jinzhu/gorm\" target=\"_blank\"];\"github.com/jinzhu/gorm\" -&gt; \"bytes\";\"github.com/jinzhu/gorm\" -&gt; \"context\";\"github.com/jinzhu/gorm\" -&gt; \"crypto/sha1\";\"github.com/jinzhu/gorm\" -&gt; \"database/sql\";\"github.com/jinzhu/gorm\" -&gt; \"database/sql/driver\";\"github.com/jinzhu/gorm\" -&gt; \"encoding/json\";\"github.com/jinzhu/gorm\" -&gt; \"errors\";\"github.com/jinzhu/gorm\" -&gt; \"fmt\";\"github.com/jinzhu/gorm\" -&gt; \"github.com/jinzhu/inflection\";\"github.com/jinzhu/gorm\" -&gt; \"go/ast\";\"github.com/jinzhu/gorm\" -&gt; \"log\";\"github.com/jinzhu/gorm\" -&gt; \"os\";\"github.com/jinzhu/gorm\" -&gt; \"reflect\";\"github.com/jinzhu/gorm\" -&gt; \"regexp\";\"github.com/jinzhu/gorm\" -&gt; \"runtime\";\"github.com/jinzhu/gorm\" -&gt; \"sort\";\"github.com/jinzhu/gorm\" -&gt; \"strconv\";\"github.com/jinzhu/gorm\" -&gt; \"strings\";\"github.com/jinzhu/gorm\" -&gt; \"sync\";\"github.com/jinzhu/gorm\" -&gt; \"time\";\"github.com/jinzhu/gorm\" -&gt; \"unicode\";\"github.com/jinzhu/gorm\" -&gt; \"unicode/utf8\";\"github.com/jinzhu/gorm/dialects/mysql\" [label=\"github.com/jinzhu/gorm/dialects/mysql\" color=\"paleturquoise\" URL=\"https://godoc.org/github.com/jinzhu/gorm/dialects/mysql\" target=\"_blank\"];\"github.com/jinzhu/gorm/dialects/mysql\" -&gt; \"github.com/go-sql-driver/mysql\";\"github.com/jinzhu/inflection\" [label=\"github.com/jinzhu/inflection\" color=\"paleturquoise\" URL=\"https://godoc.org/github.com/jinzhu/inflection\" target=\"_blank\"];\"github.com/jinzhu/inflection\" -&gt; \"regexp\";\"github.com/jinzhu/inflection\" -&gt; \"strings\";\"go/ast\" [label=\"go/ast\" color=\"palegreen\" URL=\"https://godoc.org/go/ast\" target=\"_blank\"];\"io\" [label=\"io\" color=\"palegreen\" URL=\"https://godoc.org/io\" target=\"_blank\"];\"log\" [label=\"log\" color=\"palegreen\" URL=\"https://godoc.org/log\" target=\"_blank\"];\"math\" [label=\"math\" color=\"palegreen\" URL=\"https://godoc.org/math\" target=\"_blank\"];\"math/big\" [label=\"math/big\" color=\"palegreen\" URL=\"https://godoc.org/math/big\" target=\"_blank\"];\"net\" [label=\"net\" color=\"palegreen\" URL=\"https://godoc.org/net\" target=\"_blank\"];\"net/url\" [label=\"net/url\" color=\"palegreen\" URL=\"https://godoc.org/net/url\" target=\"_blank\"];\"os\" [label=\"os\" color=\"palegreen\" URL=\"https://godoc.org/os\" target=\"_blank\"];\"reflect\" [label=\"reflect\" color=\"palegreen\" URL=\"https://godoc.org/reflect\" target=\"_blank\"];\"regexp\" [label=\"regexp\" color=\"palegreen\" URL=\"https://godoc.org/regexp\" target=\"_blank\"];\"runtime\" [label=\"runtime\" color=\"palegreen\" URL=\"https://godoc.org/runtime\" target=\"_blank\"];\"sort\" [label=\"sort\" color=\"palegreen\" URL=\"https://godoc.org/sort\" target=\"_blank\"];\"strconv\" [label=\"strconv\" color=\"palegreen\" URL=\"https://godoc.org/strconv\" target=\"_blank\"];\"strings\" [label=\"strings\" color=\"palegreen\" URL=\"https://godoc.org/strings\" target=\"_blank\"];\"sync\" [label=\"sync\" color=\"palegreen\" URL=\"https://godoc.org/sync\" target=\"_blank\"];\"sync/atomic\" [label=\"sync/atomic\" color=\"palegreen\" URL=\"https://godoc.org/sync/atomic\" target=\"_blank\"];\"syscall\" [label=\"syscall\" color=\"palegreen\" URL=\"https://godoc.org/syscall\" target=\"_blank\"];\"time\" [label=\"time\" color=\"palegreen\" URL=\"https://godoc.org/time\" target=\"_blank\"];\"unicode\" [label=\"unicode\" color=\"palegreen\" URL=\"https://godoc.org/unicode\" target=\"_blank\"];\"unicode/utf8\" [label=\"unicode/utf8\" color=\"palegreen\" URL=\"https://godoc.org/unicode/utf8\" target=\"_blank\"];\"unsafe\" [label=\"unsafe\" color=\"palegreen\" URL=\"https://godoc.org/unsafe\" target=\"_blank\"];&#125; 配合dot命令生成调用关系图 ➘ dot命令是graphviz的一部分，通过编写一些类似脚本的语言，可以容易地生成流程图,格式：dot -T -o &lt;infile.dot&gt;输入文件是&lt;infile.dot&gt;，生成的格式由指定，生成的文件是。其中-T包括：-Tps (PostScript),-Tsvg -Tsvgz (Structured Vector Graphics),-Tfig (XFIG graphics),-Tmif (FrameMaker graphics),-Thpgl (HP pen plotters),-Tpcl (Laserjet printers),-Tpng -Tgif (bitmap graphics),-Tdia (GTK+ based diagrams),-Timap (imagemap files for httpd servers for each node or edge that has a non-null “href” attribute.),-Tcmapx (client-side imagemap for use in html and xhtml). ➚ godepgraph b_sql.go | dot -Tsvg -o shuang.svg gomodifytags 参考 gomodifytags:好用的struct标签操作工具 goreturns A gofmt/goimports-like tool for Go programmers that fills in Go return statements with zero values to match the func return types 填充方法返回类型的零值 12345package b_demoimport \"errors\"func F() (int, error) &#123; return errors.New(\"foo\") &#125; goreturns 文件名.go 12345package b_demoimport \"errors\"func F() (int, error) &#123; return 0, errors.New(\"foo\") &#125; depth Visualize Go Dependency Trees go get github.com/KyleBanks/depth/cmd/depth depth -h 1234567891011Usage of depth: -explain string If set, show which packages import the specified target -internal If set, resolves dependencies of internal (stdlib) packages. -json If set, outputs the depencies in JSON format. -max int Sets the maximum depth of dependencies to resolve. -test If set, resolves dependencies used for testing. depth 某个第三方库 depth -internal 某个官方标准库 如: depth -internal strings: 123456789101112131415161718192021222324252627282930strings ├ errors └ internal/reflectlite ├ runtime ├ internal/bytealg ├ internal/cpu └ unsafe ├ internal/cpu ├ runtime/internal/atomic └ unsafe ├ runtime/internal/math └ runtime/internal/sys ├ runtime/internal/sys └ unsafe └ unsafe ├ internal/bytealg ├ io ├ errors └ sync ├ internal/race └ unsafe ├ runtime ├ sync/atomic └ unsafe └ unsafe ├ sync ├ unicode ├ unicode/utf8 └ unsafe15 dependencies (15 internal, 0 external, 0 testing). 又如: depth -internal fmt: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889fmt ├ errors └ internal/reflectlite ├ runtime ├ internal/bytealg ├ internal/cpu └ unsafe ├ internal/cpu ├ runtime/internal/atomic └ unsafe ├ runtime/internal/math └ runtime/internal/sys ├ runtime/internal/sys └ unsafe └ unsafe ├ internal/fmtsort ├ reflect ├ math ├ internal/cpu ├ math/bits └ unsafe └ unsafe ├ runtime ├ strconv ├ errors ├ internal/bytealg ├ math ├ math/bits └ unicode/utf8 ├ sync ├ internal/race └ unsafe ├ runtime ├ sync/atomic └ unsafe └ unsafe ├ unicode ├ unicode/utf8 └ unsafe └ sort └ internal/reflectlite ├ io ├ errors └ sync ├ math ├ os ├ errors ├ internal/oserror └ errors ├ internal/poll ├ errors ├ io ├ runtime ├ sync ├ sync/atomic ├ syscall ├ errors ├ internal/bytealg ├ internal/oserror ├ internal/race ├ runtime ├ sync └ unsafe ├ time ├ errors ├ runtime ├ sync ├ syscall └ unsafe └ unsafe ├ internal/syscall/execenv └ syscall ├ internal/syscall/unix ├ syscall └ unsafe ├ internal/testlog └ sync/atomic ├ io ├ runtime ├ sync ├ sync/atomic ├ syscall ├ time └ unsafe ├ reflect ├ strconv ├ sync └ unicode/utf829 dependencies (29 internal, 0 external, 0 testing). interface 实用价值不高~ safesql SafeSQL是Go的静态分析工具，可以防止SQL注入 可用来分析项目中可能存在的sql注入隐患 aligncheck &amp;&amp; structcheck &amp;&amp;varcheck 123go get -u gitlab.com/opennota/check/cmd/aligncheckgo get -u gitlab.com/opennota/check/cmd/structcheckgo get -u gitlab.com/opennota/check/cmd/varcheck 找寻效率低下的结构体 可以是某个官方包,也可以是某个文件 aligncheck net/http 得到: 123456789101112131415161718net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:1507:6: struct http2Framer could have size 200 (currently 216)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:2274:6: struct http2HeadersFrameParam could have size 40 (currently 48)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:4058:6: struct http2serverConn could have size 368 (currently 384)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:4140:6: struct http2stream could have size 152 (currently 168)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:5851:6: struct http2requestBody could have size 32 (currently 40)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:6559:6: struct http2Transport could have size 80 (currently 88)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:6698:6: struct http2ClientConn could have size 368 (currently 384)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:6746:6: struct http2clientStream could have size 312 (currently 328)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:9252:6: struct http2writeData could have size 32 (currently 40)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:9335:6: struct http2writeResHeaders could have size 96 (currently 104)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/h2_bundle.go:9407:6: struct http2writePushPromise could have size 48 (currently 56)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/server.go:3294:6: struct timeoutWriter could have size 88 (currently 96)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/server.go:418:6: struct response could have size 200 (currently 224)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/server.go:653:6: struct connReader could have size 40 (currently 48)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/transfer.go:59:6: struct transferWriter could have size 128 (currently 152)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/transport.go:1103:6: struct wantConn could have size 168 (currently 176)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/transport.go:1768:6: struct persistConn could have size 264 (currently 280)net/http: /usr/local/opt/go@1.14/libexec/src/net/http/transport.go:95:6: struct Transport could have size 288 (currently 304) 找到没有用到的结构体字段 structcheck --help 123456Usage of structcheck: -a Count assignments only -e Report exported fields -t Load test files too -tags string Build tags structcheck fmt 1234567891011121314fmt: /usr/local/opt/go@1.14/libexec/src/fmt/scan.go:169:2: fmt.ssave.nlIsEndfmt: /usr/local/opt/go@1.14/libexec/src/fmt/scan.go:170:2: fmt.ssave.nlIsSpacefmt: /usr/local/opt/go@1.14/libexec/src/fmt/scan.go:171:2: fmt.ssave.argLimitfmt: /usr/local/opt/go@1.14/libexec/src/fmt/scan.go:172:2: fmt.ssave.limitfmt: /usr/local/opt/go@1.14/libexec/src/fmt/scan.go:173:2: fmt.ssave.maxWidfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:25:2: fmt.fmtFlags.precPresentfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:26:2: fmt.fmtFlags.minusfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:27:2: fmt.fmtFlags.plusfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:28:2: fmt.fmtFlags.sharpfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:30:2: fmt.fmtFlags.zerofmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:24:2: fmt.fmtFlags.widPresentfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:35:2: fmt.fmtFlags.plusVfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:36:2: fmt.fmtFlags.sharpVfmt: /usr/local/opt/go@1.14/libexec/src/fmt/format.go:29:2: fmt.fmtFlags.space 找到没有用到的全局变量和常量 varcheck --help 1234Usage of varcheck: -e Report exported variables and constants -tags string Build tags varcheck image/jpeg 12345678image/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/reader.go:74:2: adobeTransformYCbCrimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/reader.go:75:2: adobeTransformYCbCrKimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:54:2: quantIndexLuminanceimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:55:2: quantIndexChrominanceimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:91:2: huffIndexLuminanceDCimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:92:2: huffIndexLuminanceACimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:93:2: huffIndexChrominanceDCimage/jpeg: /usr/local/opt/go@1.14/libexec/src/image/jpeg/writer.go:94:2: huffIndexChrominanceAC eg golang/tools eg -h 1234567891011Usage of eg: -beforeedit string A command to exec before each file is edited (e.g. chmod, checkout). Whitespace delimits argument words. The string '&#123;&#125;' is replaced by the file name. -help show detailed help message -t string template.go file specifying the refactoring -transitive apply refactoring to all dependencies too -v show verbose matcher diagnostics -w rewrite input files in place (by default, the results are printed to standard output) 参考: Go语言不完全工具列表 golang/tools 123456789代码自动完成（使用gocode）快速提示信息（使用godef）跳转到定义（使用godef）搜索参考引用（使用go-find-references）文件大纲（使用go-outline）重命名（使用gorename）保存构建（使用go build和go test）代码格式化（使用goreturns或goimports或gofmt）调试代码（使用delve）","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"读「Linux/UNIX系统编程手册(上)」","date":"2021-05-05T11:37:58.000Z","path":"2021/05/05/读「Linux-UNIX系统编程手册-上-」/","text":"第3章 系统编程概念确定系统的glibc版本 g lib c即GNU C 语言函数库 P37页 腾讯云cvm机器: aws的ec2: 确定GNU C 语言函数库的路径: ldd为列出动态依赖性 第6章 进程size 命令 可显示二进制可执行文件的 文本段,初始化数据段,非初始化数据段(即block started by symbol,bss) 的大小 P94 P97 虚拟内存管理,值得一看. 如搞清楚 页表是怎样联通起进程虚拟地址空间和物理内存(RAM)? PMMU把要访问的每个虚拟内存地址,转换成相应的物理内存地址 printenv,显示当前的环境列表 虚拟内存以页为单位进行分配 更多可参考: 为什么 Linux 需要虚拟内存 为什么 Linux 默认页大小是 4KB 第8章 用户和组P124 执行 vim /etc/passwd MacBook: Ubuntu: 7个字段,用冒号分隔 执行 vim /etc/group Ubuntu: 第10章 时间时区:","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"MySQL的字符转义","date":"2021-04-15T14:30:29.000Z","path":"2021/04/15/MySQL的字符转义/","text":"表象 表结构如下: 其中 content 字段存放json之后的数据,这个json数据里面 extra 字段的内容又是一段json,如下: 123456789INSERT INTO `future`.`test_escape_character`( `id`, `title`, `content`, `is_del` )VALUES ( 2, '我的博客', '&#123;\"web_id\":31415,\"name\":\"清澄秋爽\",\"extra\":\"&#123;\\\"url\\\":\\\"https://dashen.tech\\\",\\\"web_icon\\\":\\\"https://dashen.tech/favicon.ico\\\",\\\"desc\\\":\\\"苹果树下思索者\\\"&#125;\",\"online\":1&#125;', 1 ); 写入之后,复制 content字段,发现extra 无法解析了 而将 content字段{&quot;web_id&quot;:31415,&quot;name&quot;:&quot;清澄秋爽&quot;,&quot;extra&quot;:&quot;{\\&quot;url\\&quot;:\\&quot;https://dashen.tech\\&quot;,\\&quot;web_icon\\&quot;:\\&quot;https://dashen.tech/favicon.ico\\&quot;,\\&quot;desc\\&quot;:\\&quot;苹果树下思索者\\&quot;}&quot;,&quot;online&quot;:1}直接在navicat中写入, 则可成功解析. 对比发现,能成功解析的extra,多了\\.(这是json中的json必须要有的,起转义&quot;的作用) 但为何insert进去的数据,就少了这个\\? 即我们想要保存的是{&quot;web_id&quot;:31415,&quot;name&quot;:&quot;清澄秋爽&quot;,&quot;extra&quot;:&quot;{\\&quot;url\\&quot;:\\&quot;https://dashen.tech\\&quot;,\\&quot;web_icon\\&quot;:\\&quot;https://dashen.tech/favicon.ico\\&quot;,\\&quot;desc\\&quot;:\\&quot;苹果树下思索者\\&quot;}&quot;,&quot;online&quot;:1}, insert写进去之后,却成了 {&quot;web_id&quot;:31415,&quot;name&quot;:&quot;清澄秋爽&quot;,&quot;extra&quot;:&quot;{&quot;url&quot;:&quot;https://dashen.tech&quot;,&quot;web_icon&quot;:&quot;https://dashen.tech/favicon.ico&quot;,&quot;desc&quot;:&quot;苹果树下思索者&quot;}&quot;,&quot;online&quot;:1} 原由 这个问题是因为 MySQL的字符串转义 导致. MySQL中,特殊字符用 反斜线(‘\\’)开始, 从而导致\\”url\\” 被转义为&quot;url&quot;,进而使保存的数据json解析失败. 解决 解决办法也非常简单,将用在转义起始的\\也进行转义即可. MySQL用\\\\来转义 反斜线(‘\\’)字符,即在insert时,将 content 字段改为: 1'&#123;\"web_id\":31415,\"name\":\"清澄秋爽\",\"extra\":\"&#123;\\\\\"url\\\\\":\\\\\"https://dashen.tech\\\\\",\\\\\"web_icon\\\\\":\\\\\"https://dashen.tech/favicon.ico\\\\\",\\\\\"desc\\\\\":\\\\\"苹果树下思索者\\\\\"&#125;\",\"online\":1&#125;' 这样写入的数据,就符合预期了~ 更多MySQL的转义字符,可参考 MySql字符转义 MySQL中执行sql语句反斜杠需要进行转义否则会被吃掉","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"活用 命令行通配符","date":"2021-04-13T15:45:58.000Z","path":"2021/04/13/活用-命令行通配符/","text":"全文参考自 阮一峰-命令行通配符教程 通配符早于正则表达式出现,可以看作是原始的正则表达式. 其功能没有正则那么强大灵活,而胜在简单和方便. - 字符 切回上一个路径/分支 如图: !! 代表上一个命令, 如图: Linux中“!”的神奇用法 在zsh下, !3,表示history中的第3个命令 ? ?字符代表单个字符; 如果想匹配两个字符,就需要?? * *代表任意数量的字符(包括空字符) 想要列出某个文件夹下所有子目录里的.png文件,可使用 ls */*.png […] […]匹配方括号之中的任意一个字符, 如[aeiou]可以匹配五个元音字母 [start-end]表示一个连续的范围 [^…] 和 [!…] [^…]和[!…]表示匹配不在方括号里面的字符（不包括空字符）, 这两种写法等价(对zsh不适用) {…} {…} 表示匹配大括号里面的所有模式,模式之间使用逗号分隔 {start..end} {start..end}会匹配连续范围的字符 可以组合出复杂的匹配模式","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"不同写法的性能差异","date":"2021-04-12T11:48:26.000Z","path":"2021/04/12/不同写法的性能差异/","text":"达到相同目的,可以有多种写法,每种写法有性能、可读性方面的区别,本文旨在探讨不同写法之间的性能差异 如何写单元测试及基准测试(即性能测试),可参考 : go test test &amp; benchmark go test常用介绍 Go测试 len(str) vs str == “” 本部分参考自: 问个 Go 问题，字符串 len == 0 和 字符串== “” ，有啥区别？ gotest.go: 1234567891011121314151617package gotestfunc Test1() bool &#123; var v string if v == \"\" &#123; return true &#125; return false&#125;func Test2() bool &#123; var v string if len(v) == 0 &#123; return true &#125; return false&#125; webbench_test.go: 1234567891011121314151617package gotestimport ( \"testing\")func BenchmarkTest1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; Test1() &#125;&#125;func BenchmarkTest2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; Test2() &#125;&#125; 执行 go test -test.bench=&quot;.*&quot; 1234567goos: darwingoarch: amd64pkg: note/performanceBenchmarkTest1-8 1000000000 0.467 ns/opBenchmarkTest2-8 1000000000 0.464 ns/opPASSok note/performance 1.290s 第4行显示了BenchmarkTest1执行了1000000000次，每次的执行平均时间是0.467纳秒， 第5行显示了BenchmarkTest2也执行了1000000000次，每次的平均执行时间是0.464 纳秒。 最后一行显示总共的执行时间为 1.290s 可使用-count来指定执行多少次 go test -test.bench=&quot;.*&quot; -count=5: 123456789101112131415goos: darwingoarch: amd64pkg: note/performanceBenchmarkTest1-8 1000000000 0.485 ns/opBenchmarkTest1-8 1000000000 0.484 ns/opBenchmarkTest1-8 1000000000 0.464 ns/opBenchmarkTest1-8 1000000000 0.497 ns/opBenchmarkTest1-8 1000000000 0.479 ns/opBenchmarkTest2-8 1000000000 0.490 ns/opBenchmarkTest2-8 1000000000 0.476 ns/opBenchmarkTest2-8 1000000000 0.482 ns/opBenchmarkTest2-8 1000000000 0.469 ns/opBenchmarkTest2-8 1000000000 0.474 ns/opPASSok note/performance 5.791s go test --bench=. -benchmem (添加 -benchmem 参数,可以提供每次操作分配内存的次数，以及每次操作分配的字节数。参考 go benchmark 性能测试) 1234567goos: darwingoarch: amd64pkg: note/performanceBenchmarkTest1-8 1000000000 0.471 ns/op 0 B/op 0 allocs/opBenchmarkTest2-8 1000000000 0.462 ns/op 0 B/op 0 allocs/opPASSok note/performance 1.457s 经过多次测试,可知: . 性能几乎没有差别 . 均不涉及内存申请和操作，均为 0 allocs/op。(也说明变量并不是声明了,就有初始化动作. Go 编译器有做优化) 进一步看两者的汇编代码，以细究具体区别在哪里： go tool compile -S gotest.go: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556\"\".Test1 STEXT nosplit size=6 args=0x8 locals=0x0 0x0000 00000 (gotest.go:3) TEXT \"\".Test1(SB), NOSPLIT|ABIInternal, $0-8 0x0000 00000 (gotest.go:3) PCDATA $0, $-2 0x0000 00000 (gotest.go:3) PCDATA $1, $-2 0x0000 00000 (gotest.go:3) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:3) FUNCDATA $2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:6) PCDATA $0, $0 0x0000 00000 (gotest.go:6) PCDATA $1, $0 0x0000 00000 (gotest.go:6) MOVB $1, \"\".~r0+8(SP) 0x0005 00005 (gotest.go:6) RET 0x0000 c6 44 24 08 01 c3 .D$...\"\".Test2 STEXT nosplit size=6 args=0x8 locals=0x0 0x0000 00000 (gotest.go:11) TEXT \"\".Test2(SB), NOSPLIT|ABIInternal, $0-8 0x0000 00000 (gotest.go:11) PCDATA $0, $-2 0x0000 00000 (gotest.go:11) PCDATA $1, $-2 0x0000 00000 (gotest.go:11) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:11) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:11) FUNCDATA $2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0000 00000 (gotest.go:14) PCDATA $0, $0 0x0000 00000 (gotest.go:14) PCDATA $1, $0 0x0000 00000 (gotest.go:14) MOVB $1, \"\".~r0+8(SP) 0x0005 00005 (gotest.go:14) RET 0x0000 c6 44 24 08 01 c3 .D$...go.cuinfo.packagename. SDWARFINFO dupok size=0 0x0000 67 6f 74 65 73 74 gotestgo.loc.\"\".Test1 SDWARFLOC size=0go.info.\"\".Test1 SDWARFINFO size=46 0x0000 03 22 22 2e 54 65 73 74 31 00 00 00 00 00 00 00 .\"\".Test1....... 0x0010 00 00 00 00 00 00 00 00 00 00 01 9c 00 00 00 00 ................ 0x0020 01 0f 7e 72 30 00 01 03 00 00 00 00 00 00 ..~r0......... rel 0+0 t=24 type.bool+0 rel 10+8 t=1 \"\".Test1+0 rel 18+8 t=1 \"\".Test1+6 rel 28+4 t=30 gofile../Users/dashen/go/src/note/performance/gotest.go+0 rel 40+4 t=29 go.info.bool+0go.range.\"\".Test1 SDWARFRANGE size=0go.debuglines.\"\".Test1 SDWARFMISC size=11 0x0000 04 02 14 06 41 04 01 03 7b 06 01 ....A...&#123;..go.loc.\"\".Test2 SDWARFLOC size=0go.info.\"\".Test2 SDWARFINFO size=46 0x0000 03 22 22 2e 54 65 73 74 32 00 00 00 00 00 00 00 .\"\".Test2....... 0x0010 00 00 00 00 00 00 00 00 00 00 01 9c 00 00 00 00 ................ 0x0020 01 0f 7e 72 30 00 01 0b 00 00 00 00 00 00 ..~r0......... rel 0+0 t=24 type.bool+0 rel 10+8 t=1 \"\".Test2+0 rel 18+8 t=1 \"\".Test2+6 rel 28+4 t=30 gofile../Users/dashen/go/src/note/performance/gotest.go+0 rel 40+4 t=29 go.info.bool+0go.range.\"\".Test2 SDWARFRANGE size=0go.debuglines.\"\".Test2 SDWARFMISC size=13 0x0000 04 02 03 08 14 06 41 04 01 03 73 06 01 ......A...s..gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size=8 0x0000 01 00 00 00 00 00 00 00 ........ 编译出来的汇编代码是完全一致的,可以明确 Go 编译器对此做了优化（应该是直接比对了） —– EOF选看: —– 生成pprof: go test -bench=&quot;.*&quot; -cpuprofile=cpu.profile ../xxx文件夹 此时会在文件夹下,生成一个 xxx.test go tool pprof xxx.test cpu.profile: 1234567891011121314151617181920212223242526272829303132333435File: performance.testType: cpuTime: Apr 12, 2021 at 5:20pm (CST)Duration: 1.23s, Total samples = 970ms (78.99%)Entering interactive mode (type \"help\" for commands, \"o\" for options)(pprof) (pprof) o call_tree = false compact_labels = true cumulative = flat //: [cum | flat] divide_by = 1 drop_negative = false edgefraction = 0.001 focus = \"\" granularity = filefunctions //: [addresses | filefunctions | files | functions | lines] hide = \"\" ignore = \"\" mean = false nodecount = -1 //: default nodefraction = 0.005 noinlines = false normalize = false output = \"\" prune_from = \"\" relative_percentages = false sample_index = cpu //: [samples | cpu] show = \"\" show_from = \"\" tagfocus = \"\" taghide = \"\" tagignore = \"\" tagshow = \"\" trim = true trim_path = \"\" unit = minimum 执行 go tool pprof -web xxx.test cpu.profile —– EOF —– 几种 int转string 方法的性能差异 12345678910111213141516171819202122232425262728293031package shuangimport ( \"fmt\" \"strconv\" \"testing\")func BenchmarkSprintf(b *testing.B) &#123; n := 10 b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; fmt.Sprintf(\"%d\", n) &#125;&#125;func BenchmarkItoa(b *testing.B) &#123; n := 10 b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; strconv.Itoa(n) &#125;&#125;func BenchmarkFormatInt(b *testing.B) &#123; n := int64(10) b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; strconv.FormatInt(n, 10) &#125;&#125; 执行 go test -test.bench=&quot;.*&quot; -benchmem 12345678goos: darwingoarch: amd64pkg: dashenBenchmarkSprintf-8 14417409 75.9 ns/op 16 B/op 2 allocs/opBenchmarkItoa-8 452276205 2.64 ns/op 0 B/op 0 allocs/opBenchmarkFormatInt-8 492620018 2.42 ns/op 0 B/op 0 allocs/opPASSok dashen 4.518s 第4行显示了BenchmarkSprintf-8 执行了14417409次，每次的执行平均时间是75.9纳秒, 每次操作有两次内存分配,每次分配了16Byte大小的内存空间 第5行显示了BenchmarkItoa-8 执行了452276205次，每次的平均执行时间是2.64 纳秒, 无内存分配 第6行显示了BenchmarkFormatInt-8 执行了492620018次，每次的平均执行时间是2.42 纳秒, 无内存分配 。 最后一行显示总共的执行时间为 4.518s 可见, strconv.FormatInt(n, 10) 和 strconv.Itoa(n) 性能差不多, fmt.Sprintf() 性能最差 Golang 中整数转字符串 几种 字符串拼接 写法的性能差异 将两个字符串 “hello”和”world”,拼接为”hello,world” 1234567891011121314151617181920212223242526272829303132333435363738394041424344package shuangimport ( \"bytes\" \"fmt\" \"strings\" \"testing\")func BenchmarkAddStringWithOperator(b *testing.B) &#123; hello := \"hello\" world := \"world\" for i := 0; i &lt; b.N; i++ &#123; _ = hello + \",\" + world &#125;&#125;func BenchmarkAddStringWithSprintf(b *testing.B) &#123; hello := \"hello\" world := \"world\" for i := 0; i &lt; b.N; i++ &#123; _ = fmt.Sprintf(\"%s,%s\", hello, world) &#125;&#125;func BenchmarkAddStringWithJoin(b *testing.B) &#123; hello := \"hello\" world := \"world\" for i := 0; i &lt; b.N; i++ &#123; _ = strings.Join([]string&#123;hello, world&#125;, \",\") &#125;&#125;func BenchmarkAddStringWithBuffer(b *testing.B) &#123; hello := \"hello\" world := \"world\" for i := 0; i &lt; 1000; i++ &#123; var buffer bytes.Buffer buffer.WriteString(hello) buffer.WriteString(\",\") buffer.WriteString(world) _ = buffer.String() &#125;&#125; 执行 go test -test.bench=&quot;.*&quot; -benchmem 123456789goos: darwingoarch: amd64pkg: dashenBenchmarkAddStringWithOperator-8 52448029 21.4 ns/op 0 B/op 0 allocs/opBenchmarkAddStringWithSprintf-8 8755447 136 ns/op 48 B/op 3 allocs/opBenchmarkAddStringWithJoin-8 31878931 37.0 ns/op 16 B/op 1 allocs/opBenchmarkAddStringWithBuffer-8 1000000000 0.000104 ns/op 0 B/op 0 allocs/opPASSok dashen 4.420s 第4行显示了BenchmarkAddStringWithOperator-8 执行了52448029次，每次的执行平均时间是 21.4纳秒, 无内存分配 第5行显示了BenchmarkAddStringWithSprintf-8 执行了8755447次，每次的平均执行时间是 136纳秒, 每次操作有3次内存分配,每次分配了48Byte大小的内存空间 第6行显示了BenchmarkAddStringWithJoin-8 执行了31878931次，每次的平均执行时间是 37.0纳秒, 每次操作有1次内存分配,每次分配了16Byte大小的内存空间 第7行显示了BenchmarkAddStringWithBuffer-8 执行了1000000000次，每次的平均执行时间是 0.000104纳秒, 无内存分配 最后一行显示总共的执行时间为 4.420s 可见, fmt.Sprintf()和strings.Join()均有内存分配,buffer.WriteString()性能最好 通过 go tool compile -S gotest.go: 看四种方法的汇编代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133\"\".BenchmarkAddStringWithOperator STEXT size=164 args=0x8 locals=0x78 0x0000 00000 (join_test.go:10) TEXT \"\".BenchmarkAddStringWithOperator(SB), ABIInternal, $120-8 0x0000 00000 (join_test.go:10) MOVQ (TLS), CX 0x0009 00009 (join_test.go:10) CMPQ SP, 16(CX) 0x000d 00013 (join_test.go:10) PCDATA $0, $-2 0x000d 00013 (join_test.go:10) JLS 154 0x0013 00019 (join_test.go:10) PCDATA $0, $-1 0x0013 00019 (join_test.go:10) SUBQ $120, SP 0x0017 00023 (join_test.go:10) MOVQ BP, 112(SP) 0x001c 00028 (join_test.go:10) LEAQ 112(SP), BP 0x0021 00033 (join_test.go:10) PCDATA $0, $-2 0x0021 00033 (join_test.go:10) PCDATA $1, $-2 0x0021 00033 (join_test.go:10) FUNCDATA $0, gclocals·a36216b97439c93dafebe03e7f0808b5(SB) 0x0021 00033 (join_test.go:10) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0021 00033 (join_test.go:10) FUNCDATA $2, gclocals·96839595c383af6ae8227769d90a999e(SB) 0x0021 00033 (join_test.go:10) PCDATA $0, $0 0x0021 00033 (join_test.go:10) PCDATA $1, $0 0x0021 00033 (join_test.go:10) XORL AX, AX 0x0023 00035 (join_test.go:13) JMP 127 0x0025 00037 (join_test.go:13) MOVQ AX, \"\".i+72(SP) 0x002a 00042 (join_test.go:14) PCDATA $0, $1 0x002a 00042 (join_test.go:14) LEAQ \"\"..autotmp_4+80(SP), AX 0x002f 00047 (join_test.go:14) PCDATA $0, $0 0x002f 00047 (join_test.go:14) MOVQ AX, (SP) 0x0033 00051 (join_test.go:14) PCDATA $0, $1 0x0033 00051 (join_test.go:14) LEAQ go.string.\"hello\"(SB), AX 0x003a 00058 (join_test.go:14) PCDATA $0, $0 0x003a 00058 (join_test.go:14) MOVQ AX, 8(SP) 0x003f 00063 (join_test.go:14) MOVQ $5, 16(SP) 0x0048 00072 (join_test.go:14) PCDATA $0, $2 0x0048 00072 (join_test.go:14) LEAQ go.string.\",\"(SB), CX 0x004f 00079 (join_test.go:14) PCDATA $0, $0 0x004f 00079 (join_test.go:14) MOVQ CX, 24(SP) 0x0054 00084 (join_test.go:14) MOVQ $1, 32(SP) 0x005d 00093 (join_test.go:14) PCDATA $0, $3 0x005d 00093 (join_test.go:14) LEAQ go.string.\"world\"(SB), DX 0x0064 00100 (join_test.go:14) PCDATA $0, $0 0x0064 00100 (join_test.go:14) MOVQ DX, 40(SP) 0x0069 00105 (join_test.go:14) MOVQ $5, 48(SP) 0x0072 00114 (join_test.go:14) CALL runtime.concatstring3(SB) 0x0077 00119 (join_test.go:13) MOVQ \"\".i+72(SP), AX 0x007c 00124 (join_test.go:13) INCQ AX 0x007f 00127 (join_test.go:13) PCDATA $0, $2 0x007f 00127 (join_test.go:13) MOVQ \"\".b+128(SP), CX 0x0087 00135 (join_test.go:13) PCDATA $0, $0 0x0087 00135 (join_test.go:13) CMPQ 272(CX), AX 0x008e 00142 (join_test.go:13) JGT 37 0x0090 00144 (join_test.go:13) PCDATA $0, $-1 0x0090 00144 (join_test.go:13) PCDATA $1, $-1 0x0090 00144 (join_test.go:13) MOVQ 112(SP), BP 0x0095 00149 (join_test.go:13) ADDQ $120, SP 0x0099 00153 (join_test.go:13) RET 0x009a 00154 (join_test.go:13) NOP 0x009a 00154 (join_test.go:10) PCDATA $1, $-1 0x009a 00154 (join_test.go:10) PCDATA $0, $-2 0x009a 00154 (join_test.go:10) CALL runtime.morestack_noctxt(SB) 0x009f 00159 (join_test.go:10) PCDATA $0, $-1 0x009f 00159 (join_test.go:10) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 0f 86 87 eH..%....H;a.... 0x0010 00 00 00 48 83 ec 78 48 89 6c 24 70 48 8d 6c 24 ...H..xH.l$pH.l$ 0x0020 70 31 c0 eb 5a 48 89 44 24 48 48 8d 44 24 50 48 p1..ZH.D$HH.D$PH 0x0030 89 04 24 48 8d 05 00 00 00 00 48 89 44 24 08 48 ..$H......H.D$.H 0x0040 c7 44 24 10 05 00 00 00 48 8d 0d 00 00 00 00 48 .D$.....H......H 0x0050 89 4c 24 18 48 c7 44 24 20 01 00 00 00 48 8d 15 .L$.H.D$ ....H.. 0x0060 00 00 00 00 48 89 54 24 28 48 c7 44 24 30 05 00 ....H.T$(H.D$0.. 0x0070 00 00 e8 00 00 00 00 48 8b 44 24 48 48 ff c0 48 .......H.D$HH..H 0x0080 8b 8c 24 80 00 00 00 48 39 81 10 01 00 00 7f 95 ..$....H9....... 0x0090 48 8b 6c 24 70 48 83 c4 78 c3 e8 00 00 00 00 e9 H.l$pH..x....... 0x00a0 5c ff ff ff \\... rel 5+4 t=17 TLS+0 rel 54+4 t=16 go.string.\"hello\"+0 rel 75+4 t=16 go.string.\",\"+0 rel 96+4 t=16 go.string.\"world\"+0 rel 115+4 t=8 runtime.concatstring3+0 rel 155+4 t=8 runtime.morestack_noctxt+0\"\".BenchmarkAddStringWithSprintf STEXT size=254 args=0x8 locals=0x70 0x0000 00000 (join_test.go:18) TEXT \"\".BenchmarkAddStringWithSprintf(SB), ABIInternal, $112-8 0x0000 00000 (join_test.go:18) MOVQ (TLS), CX 0x0009 00009 (join_test.go:18) CMPQ SP, 16(CX) 0x000d 00013 (join_test.go:18) PCDATA $0, $-2 0x000d 00013 (join_test.go:18) JLS 244 0x0013 00019 (join_test.go:18) PCDATA $0, $-1 0x0013 00019 (join_test.go:18) SUBQ $112, SP 0x0017 00023 (join_test.go:18) MOVQ BP, 104(SP) 0x001c 00028 (join_test.go:18) LEAQ 104(SP), BP 0x0021 00033 (join_test.go:18) PCDATA $0, $-2 0x0021 00033 (join_test.go:18) PCDATA $1, $-2 0x0021 00033 (join_test.go:18) FUNCDATA $0, gclocals·69a9291448fa273f79569cb593f615b2(SB) 0x0021 00033 (join_test.go:18) FUNCDATA $1, gclocals·306ea4dc593c4841cf74b8270a1a332d(SB) 0x0021 00033 (join_test.go:18) FUNCDATA $2, gclocals·a5a3f3e663b1ae9c2739369df7a1eae5(SB) 0x0021 00033 (join_test.go:18) FUNCDATA $3, \"\".BenchmarkAddStringWithSprintf.stkobj(SB) 0x0021 00033 (join_test.go:18) PCDATA $0, $0 0x0021 00033 (join_test.go:18) PCDATA $1, $0 0x0021 00033 (join_test.go:18) XORL AX, AX 0x0023 00035 (join_test.go:21) JMP 216 0x0028 00040 (join_test.go:21) MOVQ AX, \"\".i+56(SP) 0x002d 00045 (join_test.go:22) PCDATA $0, $1 0x002d 00045 (join_test.go:22) LEAQ go.string.\"hello\"(SB), AX 0x0034 00052 (join_test.go:22) PCDATA $0, $0 0x0034 00052 (join_test.go:22) MOVQ AX, (SP) 0x0038 00056 (join_test.go:22) MOVQ $5, 8(SP) 0x0041 00065 (join_test.go:22) CALL runtime.convTstring(SB) 0x0046 00070 (join_test.go:22) PCDATA $0, $1 0x0046 00070 (join_test.go:22) MOVQ 16(SP), AX 0x004b 00075 (join_test.go:22) PCDATA $0, $0 0x004b 00075 (join_test.go:22) PCDATA $1, $1 0x004b 00075 (join_test.go:22) MOVQ AX, \"\"..autotmp_13+64(SP) 0x0050 00080 (join_test.go:22) PCDATA $0, $2 0x0050 00080 (join_test.go:22) LEAQ go.string.\"world\"(SB), CX 0x0057 00087 (join_test.go:22) PCDATA $0, $0 0x0057 00087 (join_test.go:22) MOVQ CX, (SP) 0x005b 00091 (join_test.go:22) MOVQ $5, 8(SP) 0x0064 00100 (join_test.go:22) CALL runtime.convTstring(SB) 0x0069 00105 (join_test.go:22) PCDATA $0, $1 0x0069 00105 (join_test.go:22) MOVQ 16(SP), AX 0x006e 00110 (join_test.go:22) PCDATA $1, $2 0x006e 00110 (join_test.go:22) XORPS X0, X0 0x0071 00113 (join_test.go:22) MOVUPS X0, \"\"..autotmp_4+72(SP) 0x0076 00118 (join_test.go:22) MOVUPS X0, \"\"..autotmp_4+88(SP) 0x007b 00123 (join_test.go:22) PCDATA $0, $3 0x007b 00123 (join_test.go:22) LEAQ type.string(SB), CX 0x0082 00130 (join_test.go:22) MOVQ CX, \"\"..autotmp_4+72(SP) 0x0087 00135 (join_test.go:22) PCDATA $0, $4 0x0087 00135 (join_test.go:22) PCDATA $1, $3 0x0087 00135 (join_test.go:22) MOVQ \"\"..autotmp_13+64(SP), DX 0x008c 00140 (join_test.go:22) PCDATA $0, $3 0x008c 00140 (join_test.go:22) MOVQ DX, \"\"..autotmp_4+80(SP) 0x0091 00145 (join_test.go:22) PCDATA $0, $1 0x0091 00145 (join_test.go:22) MOVQ CX, \"\"..autotmp_4+88(SP) 0x0096 00150 (join_test.go:22) PCDATA $0, $0 0x0096 00150 (join_test.go:22) MOVQ AX, \"\"..autotmp_4+96(SP) 0x009b 00155 (join_test.go:22) PCDATA $0, $1 0x009b 00155 (join_test.go:22) LEAQ go.string.\"%s,%s\"(SB), AX 0x00a2 00162 (join_test.go:22) PCDATA $0, $0 0x00a2 00162 (join_test.go:22) MOVQ AX, (SP) 0x00a6 00166 (join_test.go:22) MOVQ $5, 8(SP) 0x00af 00175 (join_test.go:22) PCDATA $0, $5 0x00af 00175 (join_test.go:22) PCDATA $1, $0 0x00af 00175 (join_test.go:22) LEAQ \"\"..autotmp_4+72(SP), DX 0x00b4 00180 (join_test.go:22) PCDATA $0, $0 0x00b4 00180 (join_test.go:22) MOVQ DX, 16(SP) 0x00b9 00185 (join_test.go:22) MOVQ $2, 24(SP) 0x00c2 00194 (join_test.go:22) MOVQ $2, 32(SP) 0x00cb 00203 (join_test.go:22) CALL fmt.Sprintf(SB) 0x00d0 00208 (join_test.go:21) MOVQ \"\".i+56(SP), AX 0x00d5 00213 (join_test.go:21) INCQ AX 0x00d8 00216 (join_test.go:21) PCDATA $0, $2 0x00d8 00216 (join_test.go:21) MOVQ \"\".b+120(SP), CX 0x00dd 00221 (join_test.go:21) PCDATA $0, $0 0x00dd 00221 (join_test.go:21) CMPQ 272(CX), AX 0x00e4 00228 (join_test.go:21) JGT 40 0x00ea 00234 (join_test.go:21) PCDATA $0, $-1 0x00ea 00234 (join_test.go:21) PCDATA $1, $-1 0x00ea 00234 (join_test.go:21) MOVQ 104(SP), BP 0x00ef 00239 (join_test.go:21) ADDQ $112, SP 0x00f3 00243 (join_test.go:21) RET 0x00f4 00244 (join_test.go:21) NOP 0x00f4 00244 (join_test.go:18) PCDATA $1, $-1 0x00f4 00244 (join_test.go:18) PCDATA $0, $-2 0x00f4 00244 (join_test.go:18) CALL runtime.morestack_noctxt(SB) 0x00f9 00249 (join_test.go:18) PCDATA $0, $-1 0x00f9 00249 (join_test.go:18) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 0f 86 e1 eH..%....H;a.... 0x0010 00 00 00 48 83 ec 70 48 89 6c 24 68 48 8d 6c 24 ...H..pH.l$hH.l$ 0x0020 68 31 c0 e9 b0 00 00 00 48 89 44 24 38 48 8d 05 h1......H.D$8H.. 0x0030 00 00 00 00 48 89 04 24 48 c7 44 24 08 05 00 00 ....H..$H.D$.... 0x0040 00 e8 00 00 00 00 48 8b 44 24 10 48 89 44 24 40 ......H.D$.H.D$@ 0x0050 48 8d 0d 00 00 00 00 48 89 0c 24 48 c7 44 24 08 H......H..$H.D$. 0x0060 05 00 00 00 e8 00 00 00 00 48 8b 44 24 10 0f 57 .........H.D$..W 0x0070 c0 0f 11 44 24 48 0f 11 44 24 58 48 8d 0d 00 00 ...D$H..D$XH.... 0x0080 00 00 48 89 4c 24 48 48 8b 54 24 40 48 89 54 24 ..H.L$HH.T$@H.T$ 0x0090 50 48 89 4c 24 58 48 89 44 24 60 48 8d 05 00 00 PH.L$XH.D$`H.... 0x00a0 00 00 48 89 04 24 48 c7 44 24 08 05 00 00 00 48 ..H..$H.D$.....H 0x00b0 8d 54 24 48 48 89 54 24 10 48 c7 44 24 18 02 00 .T$HH.T$.H.D$... 0x00c0 00 00 48 c7 44 24 20 02 00 00 00 e8 00 00 00 00 ..H.D$ ......... 0x00d0 48 8b 44 24 38 48 ff c0 48 8b 4c 24 78 48 39 81 H.D$8H..H.L$xH9. 0x00e0 10 01 00 00 0f 8f 3e ff ff ff 48 8b 6c 24 68 48 ......&gt;...H.l$hH 0x00f0 83 c4 70 c3 e8 00 00 00 00 e9 02 ff ff ff ..p........... rel 5+4 t=17 TLS+0 rel 48+4 t=16 go.string.\"hello\"+0 rel 66+4 t=8 runtime.convTstring+0 rel 83+4 t=16 go.string.\"world\"+0 rel 101+4 t=8 runtime.convTstring+0 rel 126+4 t=16 type.string+0 rel 158+4 t=16 go.string.\"%s,%s\"+0 rel 204+4 t=8 fmt.Sprintf+0 rel 245+4 t=8 runtime.morestack_noctxt+0type..eq.[2]interface &#123;&#125; STEXT dupok size=179 args=0x18 locals=0x30 0x0000 00000 (&lt;autogenerated&gt;:1) TEXT type..eq.[2]interface &#123;&#125;(SB), DUPOK|ABIInternal, $48-24 0x0000 00000 (&lt;autogenerated&gt;:1) MOVQ (TLS), CX 0x0009 00009 (&lt;autogenerated&gt;:1) CMPQ SP, 16(CX) 0x000d 00013 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x000d 00013 (&lt;autogenerated&gt;:1) JLS 169 0x0013 00019 (&lt;autogenerated&gt;:1) PCDATA $0, $-1 0x0013 00019 (&lt;autogenerated&gt;:1) SUBQ $48, SP 0x0017 00023 (&lt;autogenerated&gt;:1) MOVQ BP, 40(SP) 0x001c 00028 (&lt;autogenerated&gt;:1) LEAQ 40(SP), BP 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $1, $-2 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $0, gclocals·dc9b0298814590ca3ffc3a889546fc8b(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $1, gclocals·69c1753bd5f81501d95132d08af04464(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $2, gclocals·313a5bdbfadc4f007c002a3a3588596d(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $0, $1 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $1, $0 0x0021 00033 (&lt;autogenerated&gt;:1) MOVQ \"\".p+56(SP), AX 0x0026 00038 (&lt;autogenerated&gt;:1) PCDATA $0, $2 0x0026 00038 (&lt;autogenerated&gt;:1) MOVQ \"\".q+64(SP), CX 0x002b 00043 (&lt;autogenerated&gt;:1) XORL DX, DX 0x002d 00045 (&lt;autogenerated&gt;:1) JMP 72 0x002f 00047 (&lt;autogenerated&gt;:1) PCDATA $0, $0 0x002f 00047 (&lt;autogenerated&gt;:1) MOVQ \"\"..autotmp_8+32(SP), BX 0x0034 00052 (&lt;autogenerated&gt;:1) LEAQ 1(BX), DX 0x0038 00056 (&lt;autogenerated&gt;:1) PCDATA $0, $3 0x0038 00056 (&lt;autogenerated&gt;:1) MOVQ \"\".p+56(SP), BX 0x003d 00061 (&lt;autogenerated&gt;:1) PCDATA $0, $4 0x003d 00061 (&lt;autogenerated&gt;:1) MOVQ \"\".q+64(SP), SI 0x0042 00066 (&lt;autogenerated&gt;:1) PCDATA $0, $5 0x0042 00066 (&lt;autogenerated&gt;:1) MOVQ BX, AX 0x0045 00069 (&lt;autogenerated&gt;:1) PCDATA $0, $2 0x0045 00069 (&lt;autogenerated&gt;:1) MOVQ SI, CX 0x0048 00072 (&lt;autogenerated&gt;:1) CMPQ DX, $2 0x004c 00076 (&lt;autogenerated&gt;:1) JGE 154 0x004e 00078 (&lt;autogenerated&gt;:1) MOVQ DX, BX 0x0051 00081 (&lt;autogenerated&gt;:1) SHLQ $4, DX 0x0055 00085 (&lt;autogenerated&gt;:1) PCDATA $0, $6 0x0055 00085 (&lt;autogenerated&gt;:1) MOVQ 8(DX)(AX*1), SI 0x005a 00090 (&lt;autogenerated&gt;:1) PCDATA $0, $7 0x005a 00090 (&lt;autogenerated&gt;:1) MOVQ (DX)(AX*1), DI 0x005e 00094 (&lt;autogenerated&gt;:1) MOVQ (DX)(CX*1), R8 0x0062 00098 (&lt;autogenerated&gt;:1) PCDATA $0, $8 0x0062 00098 (&lt;autogenerated&gt;:1) MOVQ 8(DX)(CX*1), DX 0x0067 00103 (&lt;autogenerated&gt;:1) CMPQ DI, R8 0x006a 00106 (&lt;autogenerated&gt;:1) JNE 139 0x006c 00108 (&lt;autogenerated&gt;:1) MOVQ BX, \"\"..autotmp_8+32(SP) 0x0071 00113 (&lt;autogenerated&gt;:1) MOVQ DI, (SP) 0x0075 00117 (&lt;autogenerated&gt;:1) PCDATA $0, $9 0x0075 00117 (&lt;autogenerated&gt;:1) MOVQ SI, 8(SP) 0x007a 00122 (&lt;autogenerated&gt;:1) PCDATA $0, $0 0x007a 00122 (&lt;autogenerated&gt;:1) MOVQ DX, 16(SP) 0x007f 00127 (&lt;autogenerated&gt;:1) CALL runtime.efaceeq(SB) 0x0084 00132 (&lt;autogenerated&gt;:1) CMPB 24(SP), $0 0x0089 00137 (&lt;autogenerated&gt;:1) JNE 47 0x008b 00139 (&lt;autogenerated&gt;:1) PCDATA $1, $1 0x008b 00139 (&lt;autogenerated&gt;:1) MOVB $0, \"\".~r2+72(SP) 0x0090 00144 (&lt;autogenerated&gt;:1) MOVQ 40(SP), BP 0x0095 00149 (&lt;autogenerated&gt;:1) ADDQ $48, SP 0x0099 00153 (&lt;autogenerated&gt;:1) RET 0x009a 00154 (&lt;autogenerated&gt;:1) MOVB $1, \"\".~r2+72(SP) 0x009f 00159 (&lt;autogenerated&gt;:1) MOVQ 40(SP), BP 0x00a4 00164 (&lt;autogenerated&gt;:1) ADDQ $48, SP 0x00a8 00168 (&lt;autogenerated&gt;:1) RET 0x00a9 00169 (&lt;autogenerated&gt;:1) NOP 0x00a9 00169 (&lt;autogenerated&gt;:1) PCDATA $1, $-1 0x00a9 00169 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x00a9 00169 (&lt;autogenerated&gt;:1) CALL runtime.morestack_noctxt(SB) 0x00ae 00174 (&lt;autogenerated&gt;:1) PCDATA $0, $-1 0x00ae 00174 (&lt;autogenerated&gt;:1) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 0f 86 96 eH..%....H;a.... 0x0010 00 00 00 48 83 ec 30 48 89 6c 24 28 48 8d 6c 24 ...H..0H.l$(H.l$ 0x0020 28 48 8b 44 24 38 48 8b 4c 24 40 31 d2 eb 19 48 (H.D$8H.L$@1...H 0x0030 8b 5c 24 20 48 8d 53 01 48 8b 5c 24 38 48 8b 74 .\\$ H.S.H.\\$8H.t 0x0040 24 40 48 89 d8 48 89 f1 48 83 fa 02 7d 4c 48 89 $@H..H..H...&#125;LH. 0x0050 d3 48 c1 e2 04 48 8b 74 02 08 48 8b 3c 02 4c 8b .H...H.t..H.&lt;.L. 0x0060 04 0a 48 8b 54 0a 08 4c 39 c7 75 1f 48 89 5c 24 ..H.T..L9.u.H.\\$ 0x0070 20 48 89 3c 24 48 89 74 24 08 48 89 54 24 10 e8 H.&lt;$H.t$.H.T$.. 0x0080 00 00 00 00 80 7c 24 18 00 75 a4 c6 44 24 48 00 .....|$..u..D$H. 0x0090 48 8b 6c 24 28 48 83 c4 30 c3 c6 44 24 48 01 48 H.l$(H..0..D$H.H 0x00a0 8b 6c 24 28 48 83 c4 30 c3 e8 00 00 00 00 e9 4d .l$(H..0.......M 0x00b0 ff ff ff ... rel 5+4 t=17 TLS+0 rel 128+4 t=8 runtime.efaceeq+0 rel 170+4 t=8 runtime.morestack_noctxt+0\"\".BenchmarkAddStringWithJoin STEXT size=196 args=0x8 locals=0x68 0x0000 00000 (join_test.go:26) TEXT \"\".BenchmarkAddStringWithJoin(SB), ABIInternal, $104-8 0x0000 00000 (join_test.go:26) MOVQ (TLS), CX 0x0009 00009 (join_test.go:26) CMPQ SP, 16(CX) 0x000d 00013 (join_test.go:26) PCDATA $0, $-2 0x000d 00013 (join_test.go:26) JLS 186 0x0013 00019 (join_test.go:26) PCDATA $0, $-1 0x0013 00019 (join_test.go:26) SUBQ $104, SP 0x0017 00023 (join_test.go:26) MOVQ BP, 96(SP) 0x001c 00028 (join_test.go:26) LEAQ 96(SP), BP 0x0021 00033 (join_test.go:26) PCDATA $0, $-2 0x0021 00033 (join_test.go:26) PCDATA $1, $-2 0x0021 00033 (join_test.go:26) FUNCDATA $0, gclocals·09b80ec389a9e6ac09cfa1cd3c45263d(SB) 0x0021 00033 (join_test.go:26) FUNCDATA $1, gclocals·fb107d7ecaf558140670273b9a8c1e62(SB) 0x0021 00033 (join_test.go:26) FUNCDATA $2, gclocals·96839595c383af6ae8227769d90a999e(SB) 0x0021 00033 (join_test.go:26) FUNCDATA $3, \"\".BenchmarkAddStringWithJoin.stkobj(SB) 0x0021 00033 (join_test.go:26) PCDATA $0, $0 0x0021 00033 (join_test.go:26) PCDATA $1, $0 0x0021 00033 (join_test.go:26) XORL AX, AX 0x0023 00035 (join_test.go:29) JMP 158 0x0025 00037 (join_test.go:29) MOVQ AX, \"\".i+56(SP) 0x002a 00042 (join_test.go:30) PCDATA $1, $1 0x002a 00042 (join_test.go:30) XORPS X0, X0 0x002d 00045 (join_test.go:30) MOVUPS X0, \"\"..autotmp_4+64(SP) 0x0032 00050 (join_test.go:30) MOVUPS X0, \"\"..autotmp_4+80(SP) 0x0037 00055 (join_test.go:30) PCDATA $0, $1 0x0037 00055 (join_test.go:30) LEAQ go.string.\"hello\"(SB), AX 0x003e 00062 (join_test.go:30) PCDATA $0, $0 0x003e 00062 (join_test.go:30) MOVQ AX, \"\"..autotmp_4+64(SP) 0x0043 00067 (join_test.go:30) MOVQ $5, \"\"..autotmp_4+72(SP) 0x004c 00076 (join_test.go:30) PCDATA $0, $2 0x004c 00076 (join_test.go:30) LEAQ go.string.\"world\"(SB), CX 0x0053 00083 (join_test.go:30) PCDATA $0, $0 0x0053 00083 (join_test.go:30) MOVQ CX, \"\"..autotmp_4+80(SP) 0x0058 00088 (join_test.go:30) MOVQ $5, \"\"..autotmp_4+88(SP) 0x0061 00097 (join_test.go:30) PCDATA $0, $3 0x0061 00097 (join_test.go:30) PCDATA $1, $0 0x0061 00097 (join_test.go:30) LEAQ \"\"..autotmp_4+64(SP), DX 0x0066 00102 (join_test.go:30) PCDATA $0, $0 0x0066 00102 (join_test.go:30) MOVQ DX, (SP) 0x006a 00106 (join_test.go:30) MOVQ $2, 8(SP) 0x0073 00115 (join_test.go:30) MOVQ $2, 16(SP) 0x007c 00124 (join_test.go:30) PCDATA $0, $3 0x007c 00124 (join_test.go:30) LEAQ go.string.\",\"(SB), DX 0x0083 00131 (join_test.go:30) PCDATA $0, $0 0x0083 00131 (join_test.go:30) MOVQ DX, 24(SP) 0x0088 00136 (join_test.go:30) MOVQ $1, 32(SP) 0x0091 00145 (join_test.go:30) CALL strings.Join(SB) 0x0096 00150 (join_test.go:29) MOVQ \"\".i+56(SP), AX 0x009b 00155 (join_test.go:29) INCQ AX 0x009e 00158 (join_test.go:29) PCDATA $0, $2 0x009e 00158 (join_test.go:29) MOVQ \"\".b+112(SP), CX 0x00a3 00163 (join_test.go:29) PCDATA $0, $0 0x00a3 00163 (join_test.go:29) CMPQ 272(CX), AX 0x00aa 00170 (join_test.go:29) JGT 37 0x00b0 00176 (join_test.go:29) PCDATA $0, $-1 0x00b0 00176 (join_test.go:29) PCDATA $1, $-1 0x00b0 00176 (join_test.go:29) MOVQ 96(SP), BP 0x00b5 00181 (join_test.go:29) ADDQ $104, SP 0x00b9 00185 (join_test.go:29) RET 0x00ba 00186 (join_test.go:29) NOP 0x00ba 00186 (join_test.go:26) PCDATA $1, $-1 0x00ba 00186 (join_test.go:26) PCDATA $0, $-2 0x00ba 00186 (join_test.go:26) CALL runtime.morestack_noctxt(SB) 0x00bf 00191 (join_test.go:26) PCDATA $0, $-1 0x00bf 00191 (join_test.go:26) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 0f 86 a7 eH..%....H;a.... 0x0010 00 00 00 48 83 ec 68 48 89 6c 24 60 48 8d 6c 24 ...H..hH.l$`H.l$ 0x0020 60 31 c0 eb 79 48 89 44 24 38 0f 57 c0 0f 11 44 `1..yH.D$8.W...D 0x0030 24 40 0f 11 44 24 50 48 8d 05 00 00 00 00 48 89 $@..D$PH......H. 0x0040 44 24 40 48 c7 44 24 48 05 00 00 00 48 8d 0d 00 D$@H.D$H....H... 0x0050 00 00 00 48 89 4c 24 50 48 c7 44 24 58 05 00 00 ...H.L$PH.D$X... 0x0060 00 48 8d 54 24 40 48 89 14 24 48 c7 44 24 08 02 .H.T$@H..$H.D$.. 0x0070 00 00 00 48 c7 44 24 10 02 00 00 00 48 8d 15 00 ...H.D$.....H... 0x0080 00 00 00 48 89 54 24 18 48 c7 44 24 20 01 00 00 ...H.T$.H.D$ ... 0x0090 00 e8 00 00 00 00 48 8b 44 24 38 48 ff c0 48 8b ......H.D$8H..H. 0x00a0 4c 24 70 48 39 81 10 01 00 00 0f 8f 75 ff ff ff L$pH9.......u... 0x00b0 48 8b 6c 24 60 48 83 c4 68 c3 e8 00 00 00 00 e9 H.l$`H..h....... 0x00c0 3c ff ff ff &lt;... rel 5+4 t=17 TLS+0 rel 58+4 t=16 go.string.\"hello\"+0 rel 79+4 t=16 go.string.\"world\"+0 rel 127+4 t=16 go.string.\",\"+0 rel 146+4 t=8 strings.Join+0 rel 187+4 t=8 runtime.morestack_noctxt+0type..eq.[2]string STEXT dupok size=178 args=0x18 locals=0x30 0x0000 00000 (&lt;autogenerated&gt;:1) TEXT type..eq.[2]string(SB), DUPOK|ABIInternal, $48-24 0x0000 00000 (&lt;autogenerated&gt;:1) MOVQ (TLS), CX 0x0009 00009 (&lt;autogenerated&gt;:1) CMPQ SP, 16(CX) 0x000d 00013 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x000d 00013 (&lt;autogenerated&gt;:1) JLS 168 0x0013 00019 (&lt;autogenerated&gt;:1) PCDATA $0, $-1 0x0013 00019 (&lt;autogenerated&gt;:1) SUBQ $48, SP 0x0017 00023 (&lt;autogenerated&gt;:1) MOVQ BP, 40(SP) 0x001c 00028 (&lt;autogenerated&gt;:1) LEAQ 40(SP), BP 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $1, $-2 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $0, gclocals·dc9b0298814590ca3ffc3a889546fc8b(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $1, gclocals·69c1753bd5f81501d95132d08af04464(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) FUNCDATA $2, gclocals·8a866e72a2964e4d3575e01f98e6fe5f(SB) 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $0, $1 0x0021 00033 (&lt;autogenerated&gt;:1) PCDATA $1, $0 0x0021 00033 (&lt;autogenerated&gt;:1) MOVQ \"\".p+56(SP), AX 0x0026 00038 (&lt;autogenerated&gt;:1) PCDATA $0, $2 0x0026 00038 (&lt;autogenerated&gt;:1) MOVQ \"\".q+64(SP), CX 0x002b 00043 (&lt;autogenerated&gt;:1) XORL DX, DX 0x002d 00045 (&lt;autogenerated&gt;:1) JMP 72 0x002f 00047 (&lt;autogenerated&gt;:1) PCDATA $0, $0 0x002f 00047 (&lt;autogenerated&gt;:1) MOVQ \"\"..autotmp_8+32(SP), BX 0x0034 00052 (&lt;autogenerated&gt;:1) LEAQ 1(BX), DX 0x0038 00056 (&lt;autogenerated&gt;:1) PCDATA $0, $3 0x0038 00056 (&lt;autogenerated&gt;:1) MOVQ \"\".p+56(SP), BX 0x003d 00061 (&lt;autogenerated&gt;:1) PCDATA $0, $4 0x003d 00061 (&lt;autogenerated&gt;:1) MOVQ \"\".q+64(SP), SI 0x0042 00066 (&lt;autogenerated&gt;:1) PCDATA $0, $5 0x0042 00066 (&lt;autogenerated&gt;:1) MOVQ BX, AX 0x0045 00069 (&lt;autogenerated&gt;:1) PCDATA $0, $2 0x0045 00069 (&lt;autogenerated&gt;:1) MOVQ SI, CX 0x0048 00072 (&lt;autogenerated&gt;:1) CMPQ DX, $2 0x004c 00076 (&lt;autogenerated&gt;:1) JGE 153 0x004e 00078 (&lt;autogenerated&gt;:1) MOVQ DX, BX 0x0051 00081 (&lt;autogenerated&gt;:1) SHLQ $4, DX 0x0055 00085 (&lt;autogenerated&gt;:1) MOVQ 8(AX)(DX*1), SI 0x005a 00090 (&lt;autogenerated&gt;:1) PCDATA $0, $6 0x005a 00090 (&lt;autogenerated&gt;:1) MOVQ (DX)(CX*1), DI 0x005e 00094 (&lt;autogenerated&gt;:1) PCDATA $0, $7 0x005e 00094 (&lt;autogenerated&gt;:1) MOVQ (DX)(AX*1), R8 0x0062 00098 (&lt;autogenerated&gt;:1) PCDATA $0, $8 0x0062 00098 (&lt;autogenerated&gt;:1) ADDQ CX, DX 0x0065 00101 (&lt;autogenerated&gt;:1) PCDATA $0, $9 0x0065 00101 (&lt;autogenerated&gt;:1) CMPQ 8(DX), SI 0x0069 00105 (&lt;autogenerated&gt;:1) JNE 138 0x006b 00107 (&lt;autogenerated&gt;:1) MOVQ BX, \"\"..autotmp_8+32(SP) 0x0070 00112 (&lt;autogenerated&gt;:1) PCDATA $0, $10 0x0070 00112 (&lt;autogenerated&gt;:1) MOVQ R8, (SP) 0x0074 00116 (&lt;autogenerated&gt;:1) PCDATA $0, $0 0x0074 00116 (&lt;autogenerated&gt;:1) MOVQ DI, 8(SP) 0x0079 00121 (&lt;autogenerated&gt;:1) MOVQ SI, 16(SP) 0x007e 00126 (&lt;autogenerated&gt;:1) CALL runtime.memequal(SB) 0x0083 00131 (&lt;autogenerated&gt;:1) CMPB 24(SP), $0 0x0088 00136 (&lt;autogenerated&gt;:1) JNE 47 0x008a 00138 (&lt;autogenerated&gt;:1) PCDATA $1, $1 0x008a 00138 (&lt;autogenerated&gt;:1) MOVB $0, \"\".~r2+72(SP) 0x008f 00143 (&lt;autogenerated&gt;:1) MOVQ 40(SP), BP 0x0094 00148 (&lt;autogenerated&gt;:1) ADDQ $48, SP 0x0098 00152 (&lt;autogenerated&gt;:1) RET 0x0099 00153 (&lt;autogenerated&gt;:1) MOVB $1, \"\".~r2+72(SP) 0x009e 00158 (&lt;autogenerated&gt;:1) MOVQ 40(SP), BP 0x00a3 00163 (&lt;autogenerated&gt;:1) ADDQ $48, SP 0x00a7 00167 (&lt;autogenerated&gt;:1) RET 0x00a8 00168 (&lt;autogenerated&gt;:1) NOP 0x00a8 00168 (&lt;autogenerated&gt;:1) PCDATA $1, $-1 0x00a8 00168 (&lt;autogenerated&gt;:1) PCDATA $0, $-2 0x00a8 00168 (&lt;autogenerated&gt;:1) CALL runtime.morestack_noctxt(SB) 0x00ad 00173 (&lt;autogenerated&gt;:1) PCDATA $0, $-1 0x00ad 00173 (&lt;autogenerated&gt;:1) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 3b 61 10 0f 86 95 eH..%....H;a.... 0x0010 00 00 00 48 83 ec 30 48 89 6c 24 28 48 8d 6c 24 ...H..0H.l$(H.l$ 0x0020 28 48 8b 44 24 38 48 8b 4c 24 40 31 d2 eb 19 48 (H.D$8H.L$@1...H 0x0030 8b 5c 24 20 48 8d 53 01 48 8b 5c 24 38 48 8b 74 .\\$ H.S.H.\\$8H.t 0x0040 24 40 48 89 d8 48 89 f1 48 83 fa 02 7d 4b 48 89 $@H..H..H...&#125;KH. 0x0050 d3 48 c1 e2 04 48 8b 74 10 08 48 8b 3c 0a 4c 8b .H...H.t..H.&lt;.L. 0x0060 04 02 48 01 ca 48 39 72 08 75 1f 48 89 5c 24 20 ..H..H9r.u.H.\\$ 0x0070 4c 89 04 24 48 89 7c 24 08 48 89 74 24 10 e8 00 L..$H.|$.H.t$... 0x0080 00 00 00 80 7c 24 18 00 75 a5 c6 44 24 48 00 48 ....|$..u..D$H.H 0x0090 8b 6c 24 28 48 83 c4 30 c3 c6 44 24 48 01 48 8b .l$(H..0..D$H.H. 0x00a0 6c 24 28 48 83 c4 30 c3 e8 00 00 00 00 e9 4e ff l$(H..0.......N. 0x00b0 ff ff .. rel 5+4 t=17 TLS+0 rel 127+4 t=8 runtime.memequal+0 rel 169+4 t=8 runtime.morestack_noctxt+0\"\".BenchmarkAddStringWithBuffer STEXT size=321 args=0x8 locals=0x88 0x0000 00000 (join_test.go:34) TEXT \"\".BenchmarkAddStringWithBuffer(SB), ABIInternal, $136-8 0x0000 00000 (join_test.go:34) MOVQ (TLS), CX 0x0009 00009 (join_test.go:34) LEAQ -8(SP), AX 0x000e 00014 (join_test.go:34) CMPQ AX, 16(CX) 0x0012 00018 (join_test.go:34) PCDATA $0, $-2 0x0012 00018 (join_test.go:34) JLS 311 0x0018 00024 (join_test.go:34) PCDATA $0, $-1 0x0018 00024 (join_test.go:34) SUBQ $136, SP 0x001f 00031 (join_test.go:34) MOVQ BP, 128(SP) 0x0027 00039 (join_test.go:34) LEAQ 128(SP), BP 0x002f 00047 (join_test.go:34) PCDATA $0, $-2 0x002f 00047 (join_test.go:34) PCDATA $1, $-2 0x002f 00047 (join_test.go:34) FUNCDATA $0, gclocals·263043c8f03e3241528dfae4e2812ef4(SB) 0x002f 00047 (join_test.go:34) FUNCDATA $1, gclocals·d527b79a98f329c2ba624a68e7df03d6(SB) 0x002f 00047 (join_test.go:34) FUNCDATA $2, gclocals·477643caa859a1fb5c2b872c45af6067(SB) 0x002f 00047 (join_test.go:34) FUNCDATA $3, \"\".BenchmarkAddStringWithBuffer.stkobj(SB) 0x002f 00047 (join_test.go:34) PCDATA $0, $0 0x002f 00047 (join_test.go:34) PCDATA $1, $0 0x002f 00047 (join_test.go:34) XORL AX, AX 0x0031 00049 (join_test.go:37) JMP 110 0x0033 00051 ($GOROOT/src/bytes/buffer.go:65) PCDATA $0, $1 0x0033 00051 ($GOROOT/src/bytes/buffer.go:65) LEAQ \"\"..autotmp_10+56(SP), SI 0x0038 00056 ($GOROOT/src/bytes/buffer.go:65) PCDATA $0, $2 0x0038 00056 ($GOROOT/src/bytes/buffer.go:65) MOVQ SI, (SP) 0x003c 00060 ($GOROOT/src/bytes/buffer.go:65) SUBQ BX, DX 0x003f 00063 ($GOROOT/src/bytes/buffer.go:65) MOVQ DX, SI 0x0042 00066 ($GOROOT/src/bytes/buffer.go:65) NEGQ DX 0x0045 00069 ($GOROOT/src/bytes/buffer.go:65) SARQ $63, DX 0x0049 00073 ($GOROOT/src/bytes/buffer.go:65) ANDQ BX, DX 0x004c 00076 ($GOROOT/src/bytes/buffer.go:65) ADDQ DX, AX 0x004f 00079 ($GOROOT/src/bytes/buffer.go:65) PCDATA $0, $0 0x004f 00079 ($GOROOT/src/bytes/buffer.go:65) MOVQ AX, 8(SP) 0x0054 00084 ($GOROOT/src/bytes/buffer.go:65) SUBQ BX, CX 0x0057 00087 ($GOROOT/src/bytes/buffer.go:65) MOVQ CX, 16(SP) 0x005c 00092 ($GOROOT/src/bytes/buffer.go:65) MOVQ SI, 24(SP) 0x0061 00097 ($GOROOT/src/bytes/buffer.go:65) CALL runtime.slicebytetostring(SB) 0x0066 00102 (join_test.go:37) MOVQ \"\".i+48(SP), AX 0x006b 00107 (join_test.go:37) INCQ AX 0x006e 00110 (join_test.go:37) CMPQ AX, $1000 0x0074 00116 (join_test.go:37) JGE 286 0x007a 00122 (join_test.go:37) MOVQ AX, \"\".i+48(SP) 0x007f 00127 (join_test.go:38) PCDATA $1, $1 0x007f 00127 (join_test.go:38) MOVQ $0, \"\".buffer+88(SP) 0x0088 00136 (join_test.go:38) XORPS X0, X0 0x008b 00139 (join_test.go:38) MOVUPS X0, \"\".buffer+96(SP) 0x0090 00144 (join_test.go:38) MOVUPS X0, \"\".buffer+112(SP) 0x0095 00149 (join_test.go:39) PCDATA $0, $2 0x0095 00149 (join_test.go:39) LEAQ \"\".buffer+88(SP), AX 0x009a 00154 (join_test.go:39) PCDATA $0, $0 0x009a 00154 (join_test.go:39) MOVQ AX, (SP) 0x009e 00158 (join_test.go:39) PCDATA $0, $3 0x009e 00158 (join_test.go:39) LEAQ go.string.\"hello\"(SB), CX 0x00a5 00165 (join_test.go:39) PCDATA $0, $0 0x00a5 00165 (join_test.go:39) MOVQ CX, 8(SP) 0x00aa 00170 (join_test.go:39) MOVQ $5, 16(SP) 0x00b3 00179 (join_test.go:39) CALL bytes.(*Buffer).WriteString(SB) 0x00b8 00184 (join_test.go:40) PCDATA $0, $2 0x00b8 00184 (join_test.go:40) LEAQ \"\".buffer+88(SP), AX 0x00bd 00189 (join_test.go:40) PCDATA $0, $0 0x00bd 00189 (join_test.go:40) MOVQ AX, (SP) 0x00c1 00193 (join_test.go:40) PCDATA $0, $3 0x00c1 00193 (join_test.go:40) LEAQ go.string.\",\"(SB), CX 0x00c8 00200 (join_test.go:40) PCDATA $0, $0 0x00c8 00200 (join_test.go:40) MOVQ CX, 8(SP) 0x00cd 00205 (join_test.go:40) MOVQ $1, 16(SP) 0x00d6 00214 (join_test.go:40) CALL bytes.(*Buffer).WriteString(SB) 0x00db 00219 (join_test.go:41) PCDATA $0, $2 0x00db 00219 (join_test.go:41) LEAQ \"\".buffer+88(SP), AX 0x00e0 00224 (join_test.go:41) PCDATA $0, $0 0x00e0 00224 (join_test.go:41) MOVQ AX, (SP) 0x00e4 00228 (join_test.go:41) PCDATA $0, $2 0x00e4 00228 (join_test.go:41) LEAQ go.string.\"world\"(SB), AX 0x00eb 00235 (join_test.go:41) PCDATA $0, $0 0x00eb 00235 (join_test.go:41) MOVQ AX, 8(SP) 0x00f0 00240 (join_test.go:41) MOVQ $5, 16(SP) 0x00f9 00249 (join_test.go:41) CALL bytes.(*Buffer).WriteString(SB) 0x00fe 00254 (join_test.go:42) XCHGL AX, AX 0x00ff 00255 ($GOROOT/src/bytes/buffer.go:65) PCDATA $0, $2 0x00ff 00255 ($GOROOT/src/bytes/buffer.go:65) MOVQ \"\".buffer+88(SP), AX 0x0104 00260 ($GOROOT/src/bytes/buffer.go:65) MOVQ \"\".buffer+96(SP), CX 0x0109 00265 ($GOROOT/src/bytes/buffer.go:65) MOVQ \"\".buffer+104(SP), DX 0x010e 00270 ($GOROOT/src/bytes/buffer.go:65) PCDATA $1, $0 0x010e 00270 ($GOROOT/src/bytes/buffer.go:65) MOVQ \"\".buffer+112(SP), BX 0x0113 00275 ($GOROOT/src/bytes/buffer.go:65) CMPQ BX, CX 0x0116 00278 ($GOROOT/src/bytes/buffer.go:65) JLS 51 0x011c 00284 ($GOROOT/src/bytes/buffer.go:65) JMP 302 0x011e 00286 (join_test.go:37) PCDATA $0, $-1 0x011e 00286 (join_test.go:37) PCDATA $1, $-1 0x011e 00286 (join_test.go:37) MOVQ 128(SP), BP 0x0126 00294 (join_test.go:37) ADDQ $136, SP 0x012d 00301 (join_test.go:37) RET 0x012e 00302 ($GOROOT/src/bytes/buffer.go:65) PCDATA $0, $0 0x012e 00302 ($GOROOT/src/bytes/buffer.go:65) PCDATA $1, $0 0x012e 00302 ($GOROOT/src/bytes/buffer.go:65) MOVQ BX, AX 0x0131 00305 ($GOROOT/src/bytes/buffer.go:65) CALL runtime.panicSliceB(SB) 0x0136 00310 ($GOROOT/src/bytes/buffer.go:65) XCHGL AX, AX 0x0137 00311 ($GOROOT/src/bytes/buffer.go:65) NOP 0x0137 00311 (join_test.go:34) PCDATA $1, $-1 0x0137 00311 (join_test.go:34) PCDATA $0, $-2 0x0137 00311 (join_test.go:34) CALL runtime.morestack_noctxt(SB) 0x013c 00316 (join_test.go:34) PCDATA $0, $-1 0x013c 00316 (join_test.go:34) JMP 0 0x0000 65 48 8b 0c 25 00 00 00 00 48 8d 44 24 f8 48 3b eH..%....H.D$.H; 0x0010 41 10 0f 86 1f 01 00 00 48 81 ec 88 00 00 00 48 A.......H......H 0x0020 89 ac 24 80 00 00 00 48 8d ac 24 80 00 00 00 31 ..$....H..$....1 0x0030 c0 eb 3b 48 8d 74 24 38 48 89 34 24 48 29 da 48 ..;H.t$8H.4$H).H 0x0040 89 d6 48 f7 da 48 c1 fa 3f 48 21 da 48 01 d0 48 ..H..H..?H!.H..H 0x0050 89 44 24 08 48 29 d9 48 89 4c 24 10 48 89 74 24 .D$.H).H.L$.H.t$ 0x0060 18 e8 00 00 00 00 48 8b 44 24 30 48 ff c0 48 3d ......H.D$0H..H= 0x0070 e8 03 00 00 0f 8d a4 00 00 00 48 89 44 24 30 48 ..........H.D$0H 0x0080 c7 44 24 58 00 00 00 00 0f 57 c0 0f 11 44 24 60 .D$X.....W...D$` 0x0090 0f 11 44 24 70 48 8d 44 24 58 48 89 04 24 48 8d ..D$pH.D$XH..$H. 0x00a0 0d 00 00 00 00 48 89 4c 24 08 48 c7 44 24 10 05 .....H.L$.H.D$.. 0x00b0 00 00 00 e8 00 00 00 00 48 8d 44 24 58 48 89 04 ........H.D$XH.. 0x00c0 24 48 8d 0d 00 00 00 00 48 89 4c 24 08 48 c7 44 $H......H.L$.H.D 0x00d0 24 10 01 00 00 00 e8 00 00 00 00 48 8d 44 24 58 $..........H.D$X 0x00e0 48 89 04 24 48 8d 05 00 00 00 00 48 89 44 24 08 H..$H......H.D$. 0x00f0 48 c7 44 24 10 05 00 00 00 e8 00 00 00 00 90 48 H.D$...........H 0x0100 8b 44 24 58 48 8b 4c 24 60 48 8b 54 24 68 48 8b .D$XH.L$`H.T$hH. 0x0110 5c 24 70 48 39 cb 0f 86 17 ff ff ff eb 10 48 8b \\$pH9.........H. 0x0120 ac 24 80 00 00 00 48 81 c4 88 00 00 00 c3 48 89 .$....H.......H. 0x0130 d8 e8 00 00 00 00 90 e8 00 00 00 00 e9 bf fe ff ................ 0x0140 ff . rel 5+4 t=17 TLS+0 rel 98+4 t=8 runtime.slicebytetostring+0 rel 161+4 t=16 go.string.\"hello\"+0 rel 180+4 t=8 bytes.(*Buffer).WriteString+0 rel 196+4 t=16 go.string.\",\"+0 rel 215+4 t=8 bytes.(*Buffer).WriteString+0 rel 231+4 t=16 go.string.\"world\"+0 rel 250+4 t=8 bytes.(*Buffer).WriteString+0 rel 306+4 t=8 runtime.panicSliceB+0 rel 312+4 t=8 runtime.morestack_noctxt+0go.cuinfo.packagename. SDWARFINFO dupok size=0 0x0000 73 68 75 61 6e 67 shuanggo.info.bytes.(*Buffer).String$abstract SDWARFINFO dupok size=35 0x0000 04 62 79 74 65 73 2e 28 2a 42 75 66 66 65 72 29 .bytes.(*Buffer) 0x0010 2e 53 74 72 69 6e 67 00 01 01 11 62 00 00 00 00 .String....b.... 0x0020 00 00 00 ... rel 0+0 t=24 type.*bytes.Buffer+0 rel 30+4 t=29 go.info.*bytes.Buffer+0go.string.\"hello\" SRODATA dupok size=5 0x0000 68 65 6c 6c 6f hellogo.string.\"world\" SRODATA dupok size=5 0x0000 77 6f 72 6c 64 worldgo.string.\",\" SRODATA dupok size=1 0x0000 2c ,go.loc.\"\".BenchmarkAddStringWithOperator SDWARFLOC size=90 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 01 00 9c 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 02 00 91 48 00 00 00 00 00 00 00 00 00 ......H......... 0x0040 00 00 00 00 00 00 00 01 00 50 00 00 00 00 00 00 .........P...... 0x0050 00 00 00 00 00 00 00 00 00 00 .......... rel 0+8 t=53 \"\".BenchmarkAddStringWithOperator+0 rel 8+8 t=53 \"\".BenchmarkAddStringWithOperator+164 rel 35+8 t=53 \"\".BenchmarkAddStringWithOperator+42 rel 43+8 t=53 \"\".BenchmarkAddStringWithOperator+127 rel 55+8 t=53 \"\".BenchmarkAddStringWithOperator+127 rel 63+8 t=53 \"\".BenchmarkAddStringWithOperator+164go.info.\"\".BenchmarkAddStringWithOperator SDWARFINFO size=128 0x0000 03 22 22 2e 42 65 6e 63 68 6d 61 72 6b 41 64 64 .\"\".BenchmarkAdd 0x0010 53 74 72 69 6e 67 57 69 74 68 4f 70 65 72 61 74 StringWithOperat 0x0020 6f 72 00 00 00 00 00 00 00 00 00 00 00 00 00 00 or.............. 0x0030 00 00 00 01 9c 00 00 00 00 01 0a 68 65 6c 6c 6f ...........hello 0x0040 00 0b 00 00 00 00 00 0a 77 6f 72 6c 64 00 0c 00 ........world... 0x0050 00 00 00 00 10 62 00 00 0a 00 00 00 00 00 00 00 .....b.......... 0x0060 00 15 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0070 00 00 0b 69 00 0d 00 00 00 00 00 00 00 00 00 00 ...i............ rel 0+0 t=24 type.*testing.B+0 rel 0+0 t=24 type.[32]uint8+0 rel 0+0 t=24 type.int+0 rel 35+8 t=1 \"\".BenchmarkAddStringWithOperator+0 rel 43+8 t=1 \"\".BenchmarkAddStringWithOperator+164 rel 53+4 t=30 gofile../Users/dashen/go/src/note/blog/join_test.go+0 rel 66+4 t=29 go.info.string+0 rel 79+4 t=29 go.info.string+0 rel 89+4 t=29 go.info.*testing.B+0 rel 93+4 t=29 go.loc.\"\".BenchmarkAddStringWithOperator+0 rel 98+8 t=1 \"\".BenchmarkAddStringWithOperator+35 rel 106+8 t=1 \"\".BenchmarkAddStringWithOperator+154 rel 118+4 t=29 go.info.int+0 rel 122+4 t=29 go.loc.\"\".BenchmarkAddStringWithOperator+35go.range.\"\".BenchmarkAddStringWithOperator SDWARFRANGE size=0go.debuglines.\"\".BenchmarkAddStringWithOperator SDWARFMISC size=36 0x0000 04 02 03 04 14 0a cd 06 9b 06 26 06 23 06 42 06 ..........&amp;.#.B. 0x0010 41 06 02 2b ff 40 06 41 06 2d 06 5f 06 69 70 04 A..+.@.A.-._.ip. 0x0020 01 03 77 01 ..w.go.string.\"%s,%s\" SRODATA dupok size=5 0x0000 25 73 2c 25 73 %s,%sgo.loc.\"\".BenchmarkAddStringWithSprintf SDWARFLOC size=90 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 01 00 9c 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 02 00 91 40 00 00 00 00 00 00 00 00 00 ......@......... 0x0040 00 00 00 00 00 00 00 01 00 50 00 00 00 00 00 00 .........P...... 0x0050 00 00 00 00 00 00 00 00 00 00 .......... rel 0+8 t=53 \"\".BenchmarkAddStringWithSprintf+0 rel 8+8 t=53 \"\".BenchmarkAddStringWithSprintf+254 rel 35+8 t=53 \"\".BenchmarkAddStringWithSprintf+45 rel 43+8 t=53 \"\".BenchmarkAddStringWithSprintf+216 rel 55+8 t=53 \"\".BenchmarkAddStringWithSprintf+216 rel 63+8 t=53 \"\".BenchmarkAddStringWithSprintf+254go.info.\"\".BenchmarkAddStringWithSprintf SDWARFINFO size=127 0x0000 03 22 22 2e 42 65 6e 63 68 6d 61 72 6b 41 64 64 .\"\".BenchmarkAdd 0x0010 53 74 72 69 6e 67 57 69 74 68 53 70 72 69 6e 74 StringWithSprint 0x0020 66 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f............... 0x0030 00 00 01 9c 00 00 00 00 01 0a 68 65 6c 6c 6f 00 ..........hello. 0x0040 13 00 00 00 00 00 0a 77 6f 72 6c 64 00 14 00 00 .......world.... 0x0050 00 00 00 10 62 00 00 12 00 00 00 00 00 00 00 00 ....b........... 0x0060 15 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0070 00 0b 69 00 15 00 00 00 00 00 00 00 00 00 00 ..i............ rel 0+0 t=24 type.*testing.B+0 rel 0+0 t=24 type.[2]interface &#123;&#125;+0 rel 0+0 t=24 type.int+0 rel 0+0 t=24 type.unsafe.Pointer+0 rel 34+8 t=1 \"\".BenchmarkAddStringWithSprintf+0 rel 42+8 t=1 \"\".BenchmarkAddStringWithSprintf+254 rel 52+4 t=30 gofile../Users/dashen/go/src/note/blog/join_test.go+0 rel 65+4 t=29 go.info.string+0 rel 78+4 t=29 go.info.string+0 rel 88+4 t=29 go.info.*testing.B+0 rel 92+4 t=29 go.loc.\"\".BenchmarkAddStringWithSprintf+0 rel 97+8 t=1 \"\".BenchmarkAddStringWithSprintf+35 rel 105+8 t=1 \"\".BenchmarkAddStringWithSprintf+244 rel 117+4 t=29 go.info.int+0 rel 121+4 t=29 go.loc.\"\".BenchmarkAddStringWithSprintf+35go.range.\"\".BenchmarkAddStringWithSprintf SDWARFRANGE size=0go.debuglines.\"\".BenchmarkAddStringWithSprintf SDWARFMISC size=39 0x0000 04 02 03 0c 14 0a cd 06 9b 06 26 06 41 06 42 06 ..........&amp;.A.B. 0x0010 55 06 91 06 41 06 02 72 fe 06 41 06 2d 06 41 06 U...A..r..A.-.A. 0x0020 91 70 04 01 03 6f 01 .p...o.runtime.nilinterequal·f SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 runtime.nilinterequal+0runtime.memequal64·f SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 runtime.memequal64+0runtime.gcbits.01 SRODATA dupok size=1 0x0000 01 .type..namedata.*interface &#123;&#125;- SRODATA dupok size=16 0x0000 00 00 0d 2a 69 6e 74 65 72 66 61 63 65 20 7b 7d ...*interface &#123;&#125;type.*interface &#123;&#125; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 4f 0f 96 9d 08 08 08 36 00 00 00 00 00 00 00 00 O......6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*interface &#123;&#125;-+0 rel 48+8 t=1 type.interface &#123;&#125;+0runtime.gcbits.02 SRODATA dupok size=1 0x0000 02 .type.interface &#123;&#125; SRODATA dupok size=80 0x0000 10 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 ................ 0x0010 e7 57 a0 18 02 08 08 14 00 00 00 00 00 00 00 00 .W.............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ rel 24+8 t=1 runtime.nilinterequal·f+0 rel 32+8 t=1 runtime.gcbits.02+0 rel 40+4 t=5 type..namedata.*interface &#123;&#125;-+0 rel 44+4 t=6 type.*interface &#123;&#125;+0 rel 56+8 t=1 type.interface &#123;&#125;+80type..namedata.*[]interface &#123;&#125;- SRODATA dupok size=18 0x0000 00 00 0f 2a 5b 5d 69 6e 74 65 72 66 61 63 65 20 ...*[]interface 0x0010 7b 7d &#123;&#125;type.*[]interface &#123;&#125; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 f3 04 9a e7 08 08 08 36 00 00 00 00 00 00 00 00 .......6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]interface &#123;&#125;-+0 rel 48+8 t=1 type.[]interface &#123;&#125;+0type.[]interface &#123;&#125; SRODATA dupok size=56 0x0000 18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 70 93 ea 2f 02 08 08 17 00 00 00 00 00 00 00 00 p../............ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]interface &#123;&#125;-+0 rel 44+4 t=6 type.*[]interface &#123;&#125;+0 rel 48+8 t=1 type.interface &#123;&#125;+0go.loc.type..eq.[2]interface &#123;&#125; SDWARFLOC dupok size=106 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 01 00 51 00 00 00 00 00 00 00 00 00 00 00 00 00 ..Q............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 01 00 9c 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0050 00 00 00 00 00 00 02 00 91 08 00 00 00 00 00 00 ................ 0x0060 00 00 00 00 00 00 00 00 00 00 .......... rel 0+8 t=53 type..eq.[2]interface &#123;&#125;+72 rel 8+8 t=53 type..eq.[2]interface &#123;&#125;+85 rel 35+8 t=53 type..eq.[2]interface &#123;&#125;+0 rel 43+8 t=53 type..eq.[2]interface &#123;&#125;+179 rel 70+8 t=53 type..eq.[2]interface &#123;&#125;+0 rel 78+8 t=53 type..eq.[2]interface &#123;&#125;+179go.info.type..eq.[2]interface &#123;&#125; SDWARFINFO dupok size=100 0x0000 03 74 79 70 65 2e 2e 65 71 2e 5b 32 5d 69 6e 74 .type..eq.[2]int 0x0010 65 72 66 61 63 65 20 7b 7d 00 00 00 00 00 00 00 erface &#123;&#125;....... 0x0020 00 00 00 00 00 00 00 00 00 00 01 9c 00 00 00 00 ................ 0x0030 01 0b 69 00 01 00 00 00 00 00 00 00 00 10 70 00 ..i...........p. 0x0040 00 01 00 00 00 00 00 00 00 00 10 71 00 00 01 00 ...........q.... 0x0050 00 00 00 00 00 00 00 0f 7e 72 32 00 01 01 00 00 ........~r2..... 0x0060 00 00 00 00 .... rel 0+0 t=24 type.*[2]interface &#123;&#125;+0 rel 0+0 t=24 type.bool+0 rel 0+0 t=24 type.int+0 rel 26+8 t=1 type..eq.[2]interface &#123;&#125;+0 rel 34+8 t=1 type..eq.[2]interface &#123;&#125;+179 rel 44+4 t=30 gofile..&lt;autogenerated&gt;+0 rel 53+4 t=29 go.info.int+0 rel 57+4 t=29 go.loc.type..eq.[2]interface &#123;&#125;+0 rel 66+4 t=29 go.info.*[2]interface &#123;&#125;+0 rel 70+4 t=29 go.loc.type..eq.[2]interface &#123;&#125;+35 rel 79+4 t=29 go.info.*[2]interface &#123;&#125;+0 rel 83+4 t=29 go.loc.type..eq.[2]interface &#123;&#125;+70 rel 94+4 t=29 go.info.bool+0go.range.type..eq.[2]interface &#123;&#125; SDWARFRANGE dupok size=0go.debuglines.type..eq.[2]interface &#123;&#125; SDWARFMISC dupok size=29 0x0000 04 01 0f 0a cd 06 cd 06 08 73 06 37 06 02 27 ff .........s.7..'. 0x0010 06 41 06 73 06 41 06 73 04 01 03 00 01 .A.s.A.s.....type..eqfunc.[2]interface &#123;&#125; SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 type..eq.[2]interface &#123;&#125;+0type..namedata.*[2]interface &#123;&#125;- SRODATA dupok size=19 0x0000 00 00 10 2a 5b 32 5d 69 6e 74 65 72 66 61 63 65 ...*[2]interface 0x0010 20 7b 7d &#123;&#125;type.*[2]interface &#123;&#125; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 be 73 2d 71 08 08 08 36 00 00 00 00 00 00 00 00 .s-q...6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[2]interface &#123;&#125;-+0 rel 48+8 t=1 type.[2]interface &#123;&#125;+0runtime.gcbits.0a SRODATA dupok size=1 0x0000 0a .type.[2]interface &#123;&#125; SRODATA dupok size=72 0x0000 20 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 ....... ....... 0x0010 2c 59 a4 f1 02 08 08 11 00 00 00 00 00 00 00 00 ,Y.............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 02 00 00 00 00 00 00 00 ........ rel 24+8 t=1 type..eqfunc.[2]interface &#123;&#125;+0 rel 32+8 t=1 runtime.gcbits.0a+0 rel 40+4 t=5 type..namedata.*[2]interface &#123;&#125;-+0 rel 44+4 t=6 type.*[2]interface &#123;&#125;+0 rel 48+8 t=1 type.interface &#123;&#125;+0 rel 56+8 t=1 type.[]interface &#123;&#125;+0go.loc.\"\".BenchmarkAddStringWithJoin SDWARFLOC size=90 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 01 00 9c 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 02 00 91 48 00 00 00 00 00 00 00 00 00 ......H......... 0x0040 00 00 00 00 00 00 00 01 00 50 00 00 00 00 00 00 .........P...... 0x0050 00 00 00 00 00 00 00 00 00 00 .......... rel 0+8 t=53 \"\".BenchmarkAddStringWithJoin+0 rel 8+8 t=53 \"\".BenchmarkAddStringWithJoin+196 rel 35+8 t=53 \"\".BenchmarkAddStringWithJoin+42 rel 43+8 t=53 \"\".BenchmarkAddStringWithJoin+158 rel 55+8 t=53 \"\".BenchmarkAddStringWithJoin+158 rel 63+8 t=53 \"\".BenchmarkAddStringWithJoin+196go.info.\"\".BenchmarkAddStringWithJoin SDWARFINFO size=124 0x0000 03 22 22 2e 42 65 6e 63 68 6d 61 72 6b 41 64 64 .\"\".BenchmarkAdd 0x0010 53 74 72 69 6e 67 57 69 74 68 4a 6f 69 6e 00 00 StringWithJoin.. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 ................ 0x0030 9c 00 00 00 00 01 0a 68 65 6c 6c 6f 00 1b 00 00 .......hello.... 0x0040 00 00 00 0a 77 6f 72 6c 64 00 1c 00 00 00 00 00 ....world....... 0x0050 10 62 00 00 1a 00 00 00 00 00 00 00 00 15 00 00 .b.............. 0x0060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0b 69 ...............i 0x0070 00 1d 00 00 00 00 00 00 00 00 00 00 ............ rel 0+0 t=24 type.*testing.B+0 rel 0+0 t=24 type.[2]string+0 rel 0+0 t=24 type.int+0 rel 31+8 t=1 \"\".BenchmarkAddStringWithJoin+0 rel 39+8 t=1 \"\".BenchmarkAddStringWithJoin+196 rel 49+4 t=30 gofile../Users/dashen/go/src/note/blog/join_test.go+0 rel 62+4 t=29 go.info.string+0 rel 75+4 t=29 go.info.string+0 rel 85+4 t=29 go.info.*testing.B+0 rel 89+4 t=29 go.loc.\"\".BenchmarkAddStringWithJoin+0 rel 94+8 t=1 \"\".BenchmarkAddStringWithJoin+35 rel 102+8 t=1 \"\".BenchmarkAddStringWithJoin+186 rel 114+4 t=29 go.info.int+0 rel 118+4 t=29 go.loc.\"\".BenchmarkAddStringWithJoin+35go.range.\"\".BenchmarkAddStringWithJoin SDWARFRANGE size=0go.debuglines.\"\".BenchmarkAddStringWithJoin SDWARFMISC size=35 0x0000 04 02 03 14 14 0a cd 06 9b 06 26 06 23 06 42 06 ..........&amp;.#.B. 0x0010 2d 06 02 51 fe 06 41 06 2d 06 41 06 91 70 04 01 -..Q..A.-.A..p.. 0x0020 03 67 01 .g.type..namedata.*[]string- SRODATA dupok size=12 0x0000 00 00 09 2a 5b 5d 73 74 72 69 6e 67 ...*[]stringtype.*[]string SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 92 22 76 84 08 08 08 36 00 00 00 00 00 00 00 00 .\"v....6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]string-+0 rel 48+8 t=1 type.[]string+0type.[]string SRODATA dupok size=56 0x0000 18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 d3 a8 f3 0a 02 08 08 17 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]string-+0 rel 44+4 t=6 type.*[]string+0 rel 48+8 t=1 type.string+0go.loc.type..eq.[2]string SDWARFLOC dupok size=106 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 01 00 51 00 00 00 00 00 00 00 00 00 00 00 00 00 ..Q............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 01 00 9c 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0050 00 00 00 00 00 00 02 00 91 08 00 00 00 00 00 00 ................ 0x0060 00 00 00 00 00 00 00 00 00 00 .......... rel 0+8 t=53 type..eq.[2]string+72 rel 8+8 t=53 type..eq.[2]string+85 rel 35+8 t=53 type..eq.[2]string+0 rel 43+8 t=53 type..eq.[2]string+178 rel 70+8 t=53 type..eq.[2]string+0 rel 78+8 t=53 type..eq.[2]string+178go.info.type..eq.[2]string SDWARFINFO dupok size=94 0x0000 03 74 79 70 65 2e 2e 65 71 2e 5b 32 5d 73 74 72 .type..eq.[2]str 0x0010 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 00 00 ing............. 0x0020 00 00 00 00 01 9c 00 00 00 00 01 0b 69 00 01 00 ............i... 0x0030 00 00 00 00 00 00 00 10 70 00 00 01 00 00 00 00 ........p....... 0x0040 00 00 00 00 10 71 00 00 01 00 00 00 00 00 00 00 .....q.......... 0x0050 00 0f 7e 72 32 00 01 01 00 00 00 00 00 00 ..~r2......... rel 0+0 t=24 type.*[2]string+0 rel 0+0 t=24 type.bool+0 rel 0+0 t=24 type.int+0 rel 20+8 t=1 type..eq.[2]string+0 rel 28+8 t=1 type..eq.[2]string+178 rel 38+4 t=30 gofile..&lt;autogenerated&gt;+0 rel 47+4 t=29 go.info.int+0 rel 51+4 t=29 go.loc.type..eq.[2]string+0 rel 60+4 t=29 go.info.*[2]string+0 rel 64+4 t=29 go.loc.type..eq.[2]string+35 rel 73+4 t=29 go.info.*[2]string+0 rel 77+4 t=29 go.loc.type..eq.[2]string+70 rel 88+4 t=29 go.info.bool+0go.range.type..eq.[2]string SDWARFRANGE dupok size=0go.debuglines.type..eq.[2]string SDWARFMISC dupok size=29 0x0000 04 01 0f 0a cd 06 cd 06 08 73 06 37 06 02 26 ff .........s.7..&amp;. 0x0010 06 41 06 73 06 41 06 73 04 01 03 00 01 .A.s.A.s.....type..eqfunc.[2]string SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 type..eq.[2]string+0type..namedata.*[2]string- SRODATA dupok size=13 0x0000 00 00 0a 2a 5b 32 5d 73 74 72 69 6e 67 ...*[2]stringtype.*[2]string SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 0c 66 1f 3c 08 08 08 36 00 00 00 00 00 00 00 00 .f.&lt;...6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[2]string-+0 rel 48+8 t=1 type.[2]string+0runtime.gcbits.05 SRODATA dupok size=1 0x0000 05 .type.[2]string SRODATA dupok size=72 0x0000 20 00 00 00 00 00 00 00 18 00 00 00 00 00 00 00 ............... 0x0010 50 58 e5 e9 02 08 08 11 00 00 00 00 00 00 00 00 PX.............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 02 00 00 00 00 00 00 00 ........ rel 24+8 t=1 type..eqfunc.[2]string+0 rel 32+8 t=1 runtime.gcbits.05+0 rel 40+4 t=5 type..namedata.*[2]string-+0 rel 44+4 t=6 type.*[2]string+0 rel 48+8 t=1 type.string+0 rel 56+8 t=1 type.[]string+0go.string.\"&lt;nil&gt;\" SRODATA dupok size=5 0x0000 3c 6e 69 6c 3e &lt;nil&gt;go.loc.\"\".BenchmarkAddStringWithBuffer SDWARFLOC size=173 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 03 00 91 a0 7f 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 01 00 50 00 00 00 00 00 00 00 00 .......P........ 0x0030 00 00 00 00 00 00 00 00 03 00 91 a0 7f 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 50 ...............P 0x0050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0060 03 00 91 a0 7f 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0080 00 00 00 00 00 02 00 91 48 00 00 00 00 00 00 00 ........H....... 0x0090 00 00 00 00 00 00 00 00 00 02 00 91 48 00 00 00 ............H... 0x00a0 00 00 00 00 00 00 00 00 00 00 00 00 00 ............. rel 0+8 t=53 \"\".BenchmarkAddStringWithBuffer+107 rel 8+8 t=53 \"\".BenchmarkAddStringWithBuffer+110 rel 21+8 t=53 \"\".BenchmarkAddStringWithBuffer+110 rel 29+8 t=53 \"\".BenchmarkAddStringWithBuffer+154 rel 40+8 t=53 \"\".BenchmarkAddStringWithBuffer+154 rel 48+8 t=53 \"\".BenchmarkAddStringWithBuffer+286 rel 61+8 t=53 \"\".BenchmarkAddStringWithBuffer+286 rel 69+8 t=53 \"\".BenchmarkAddStringWithBuffer+302 rel 80+8 t=53 \"\".BenchmarkAddStringWithBuffer+302 rel 88+8 t=53 \"\".BenchmarkAddStringWithBuffer+321 rel 117+8 t=53 \"\".BenchmarkAddStringWithBuffer+107 rel 125+8 t=53 \"\".BenchmarkAddStringWithBuffer+286 rel 137+8 t=53 \"\".BenchmarkAddStringWithBuffer+302 rel 145+8 t=53 \"\".BenchmarkAddStringWithBuffer+321go.info.\"\".BenchmarkAddStringWithBuffer SDWARFINFO size=164 0x0000 03 22 22 2e 42 65 6e 63 68 6d 61 72 6b 41 64 64 .\"\".BenchmarkAdd 0x0010 53 74 72 69 6e 67 57 69 74 68 42 75 66 66 65 72 StringWithBuffer 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 01 9c 00 00 00 00 01 0a 68 65 6c 6c 6f 00 23 .........hello.# 0x0040 00 00 00 00 00 0a 77 6f 72 6c 64 00 24 00 00 00 ......world.$... 0x0050 00 00 0f 62 00 00 22 00 00 00 00 00 14 00 00 00 ...b..\"......... 0x0060 00 0b 69 00 25 00 00 00 00 00 00 00 00 15 00 00 ..i.%........... 0x0070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0b 62 ...............b 0x0080 75 66 66 65 72 00 26 00 00 00 00 00 00 00 00 00 uffer.&amp;......... 0x0090 00 07 00 00 00 00 00 00 00 00 00 00 00 00 2a 00 ..............*. 0x00a0 00 00 00 00 .... rel 0+0 t=24 type.*testing.B+0 rel 0+0 t=24 type.[32]uint8+0 rel 0+0 t=24 type.bytes.Buffer+0 rel 0+0 t=24 type.int+0 rel 33+8 t=1 \"\".BenchmarkAddStringWithBuffer+0 rel 41+8 t=1 \"\".BenchmarkAddStringWithBuffer+321 rel 51+4 t=30 gofile../Users/dashen/go/src/note/blog/join_test.go+0 rel 64+4 t=29 go.info.string+0 rel 77+4 t=29 go.info.string+0 rel 87+4 t=29 go.info.*testing.B+0 rel 93+4 t=29 go.range.\"\".BenchmarkAddStringWithBuffer+0 rel 101+4 t=29 go.info.int+0 rel 105+4 t=29 go.loc.\"\".BenchmarkAddStringWithBuffer+0 rel 110+8 t=1 \"\".BenchmarkAddStringWithBuffer+127 rel 118+8 t=1 \"\".BenchmarkAddStringWithBuffer+255 rel 135+4 t=29 go.info.bytes.Buffer+0 rel 139+4 t=29 go.loc.\"\".BenchmarkAddStringWithBuffer+117 rel 146+4 t=29 go.info.bytes.(*Buffer).String$abstract+0 rel 150+4 t=29 go.range.\"\".BenchmarkAddStringWithBuffer+64 rel 154+4 t=30 gofile../Users/dashen/go/src/note/blog/join_test.go+0go.range.\"\".BenchmarkAddStringWithBuffer SDWARFRANGE size=128 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0050 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ rel 0+8 t=53 \"\".BenchmarkAddStringWithBuffer+49 rel 8+8 t=53 \"\".BenchmarkAddStringWithBuffer+51 rel 16+8 t=53 \"\".BenchmarkAddStringWithBuffer+102 rel 24+8 t=53 \"\".BenchmarkAddStringWithBuffer+255 rel 32+8 t=53 \"\".BenchmarkAddStringWithBuffer+286 rel 40+8 t=53 \"\".BenchmarkAddStringWithBuffer+302 rel 64+8 t=53 \"\".BenchmarkAddStringWithBuffer+51 rel 72+8 t=53 \"\".BenchmarkAddStringWithBuffer+102 rel 80+8 t=53 \"\".BenchmarkAddStringWithBuffer+255 rel 88+8 t=53 \"\".BenchmarkAddStringWithBuffer+286 rel 96+8 t=53 \"\".BenchmarkAddStringWithBuffer+302 rel 104+8 t=53 \"\".BenchmarkAddStringWithBuffer+311go.debuglines.\"\".BenchmarkAddStringWithBuffer SDWARFMISC size=85 0x0000 04 02 03 1c 14 0a ff 06 f5 26 04 14 03 17 28 04 .........&amp;....(. 0x0010 02 06 02 1b 03 68 fb 06 41 06 2d 06 4b 06 7e 06 .....h..A.-.K.~. 0x0020 69 06 92 06 41 06 08 19 42 06 41 06 08 19 42 06 i...A...B.A...B. 0x0030 41 06 08 19 42 04 14 03 12 1e 06 41 04 02 06 08 A...B......A.... 0x0040 03 68 1f 04 14 06 03 17 b4 06 5f 04 02 03 65 15 .h........_...e. 0x0050 04 01 03 5f 01 ..._.\"\"..inittask SNOPTRDATA size=56 0x0000 00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ................ 0x0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 bytes..inittask+0 rel 32+8 t=1 fmt..inittask+0 rel 40+8 t=1 strings..inittask+0 rel 48+8 t=1 testing..inittask+0type..namedata.*[]uint8- SRODATA dupok size=11 0x0000 00 00 08 2a 5b 5d 75 69 6e 74 38 ...*[]uint8type.*[]uint8 SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 a5 8e d0 69 08 08 08 36 00 00 00 00 00 00 00 00 ...i...6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]uint8-+0 rel 48+8 t=1 type.[]uint8+0type.[]uint8 SRODATA dupok size=56 0x0000 18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 df 7e 2e 38 02 08 08 17 00 00 00 00 00 00 00 00 .~.8............ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[]uint8-+0 rel 44+4 t=6 type.*[]uint8+0 rel 48+8 t=1 type.uint8+0type..eqfunc32 SRODATA dupok size=16 0x0000 00 00 00 00 00 00 00 00 20 00 00 00 00 00 00 00 ........ ....... rel 0+8 t=1 runtime.memequal_varlen+0type..namedata.*[32]uint8- SRODATA dupok size=13 0x0000 00 00 0a 2a 5b 33 32 5d 75 69 6e 74 38 ...*[32]uint8type.*[32]uint8 SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 f4 c7 79 15 08 08 08 36 00 00 00 00 00 00 00 00 ..y....6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f+0 rel 32+8 t=1 runtime.gcbits.01+0 rel 40+4 t=5 type..namedata.*[32]uint8-+0 rel 48+8 t=1 type.[32]uint8+0runtime.gcbits. SRODATA dupok size=0type.[32]uint8 SRODATA dupok size=72 0x0000 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ............... 0x0010 9c 59 ff a8 0a 01 01 11 00 00 00 00 00 00 00 00 .Y.............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 20 00 00 00 00 00 00 00 ....... rel 24+8 t=1 type..eqfunc32+0 rel 32+8 t=1 runtime.gcbits.+0 rel 40+4 t=5 type..namedata.*[32]uint8-+0 rel 44+4 t=6 type.*[32]uint8+0 rel 48+8 t=1 type.uint8+0 rel 56+8 t=1 type.[]uint8+0type..importpath.bytes. SRODATA dupok size=8 0x0000 00 00 05 62 79 74 65 73 ...bytestype..importpath.fmt. SRODATA dupok size=6 0x0000 00 00 03 66 6d 74 ...fmttype..importpath.strings. SRODATA dupok size=10 0x0000 00 00 07 73 74 72 69 6e 67 73 ...stringstype..importpath.testing. SRODATA dupok size=10 0x0000 00 00 07 74 65 73 74 69 6e 67 ...testinggclocals·a36216b97439c93dafebe03e7f0808b5 SRODATA dupok size=9 0x0000 01 00 00 00 01 00 00 00 01 .........gclocals·33cdeccccebe80329f1fdbee7f5874cb SRODATA dupok size=8 0x0000 01 00 00 00 00 00 00 00 ........gclocals·96839595c383af6ae8227769d90a999e SRODATA dupok size=12 0x0000 04 00 00 00 03 00 00 00 00 01 02 04 ............gclocals·69a9291448fa273f79569cb593f615b2 SRODATA dupok size=12 0x0000 04 00 00 00 01 00 00 00 01 01 01 01 ............gclocals·306ea4dc593c4841cf74b8270a1a332d SRODATA dupok size=12 0x0000 04 00 00 00 05 00 00 00 00 01 15 14 ............gclocals·a5a3f3e663b1ae9c2739369df7a1eae5 SRODATA dupok size=14 0x0000 06 00 00 00 03 00 00 00 00 01 02 03 07 04 ..............\"\".BenchmarkAddStringWithSprintf.stkobj SRODATA size=24 0x0000 01 00 00 00 00 00 00 00 e0 ff ff ff ff ff ff ff ................ 0x0010 00 00 00 00 00 00 00 00 ........ rel 16+8 t=1 type.[2]interface &#123;&#125;+0gclocals·dc9b0298814590ca3ffc3a889546fc8b SRODATA dupok size=10 0x0000 02 00 00 00 02 00 00 00 03 00 ..........gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size=8 0x0000 02 00 00 00 00 00 00 00 ........gclocals·313a5bdbfadc4f007c002a3a3588596d SRODATA dupok size=18 0x0000 0a 00 00 00 06 00 00 00 00 01 03 08 28 21 23 22 ............(!#\" 0x0010 24 04 $.gclocals·09b80ec389a9e6ac09cfa1cd3c45263d SRODATA dupok size=10 0x0000 02 00 00 00 01 00 00 00 01 01 ..........gclocals·fb107d7ecaf558140670273b9a8c1e62 SRODATA dupok size=10 0x0000 02 00 00 00 04 00 00 00 00 05 ..........\"\".BenchmarkAddStringWithJoin.stkobj SRODATA size=24 0x0000 01 00 00 00 00 00 00 00 e0 ff ff ff ff ff ff ff ................ 0x0010 00 00 00 00 00 00 00 00 ........ rel 16+8 t=1 type.[2]string+0gclocals·8a866e72a2964e4d3575e01f98e6fe5f SRODATA dupok size=19 0x0000 0b 00 00 00 08 00 00 00 00 01 03 08 28 21 43 c2 ............(!C. 0x0010 c4 c0 40 ..@gclocals·263043c8f03e3241528dfae4e2812ef4 SRODATA dupok size=10 0x0000 02 00 00 00 01 00 00 00 00 00 ..........gclocals·d527b79a98f329c2ba624a68e7df03d6 SRODATA dupok size=10 0x0000 02 00 00 00 05 00 00 00 00 01 ..........gclocals·477643caa859a1fb5c2b872c45af6067 SRODATA dupok size=12 0x0000 04 00 00 00 06 00 00 00 00 21 01 02 .........!..\"\".BenchmarkAddStringWithBuffer.stkobj SRODATA size=24 0x0000 01 00 00 00 00 00 00 00 d8 ff ff ff ff ff ff ff ................ 0x0010 00 00 00 00 00 00 00 00 ........ rel 16+8 t=1 type.bytes.Buffer+0 更多参考: golang 几种字符串的拼接方式 位运算 byte切片转string 1234567891011package mainimport \"fmt\"func main() &#123; str := `&#123;\"default\":&#123;\"common\":&#123;\"pet\":&#123;\"five\":\"斑斑\",\"four\":\"皮瓜瓜\",\"one\":\"弥弥懵\",\"three\":\"呆呆\",\"two\":\"黄橙橙\"&#125;,\"relation\":&#123;\"father\":\"cuixxxxxxx\",\"mother\":\"yinxxxxx\",\"wife\":\"pengxx\"&#125;&#125;&#125;&#125;` fmt.Println([]byte(str))&#125; 先得到 byte类型的切片 输出： 1[123 34 100 101 102 97 117 108 116 34 58 123 34 99 111 109 109 111 110 34 58 123 34 112 101 116 34 58 123 34 102 105 118 101 34 58 34 230 150 145 230 150 145 34 44 34 102 111 117 114 34 58 34 231 154 174 231 147 156 231 147 156 34 44 34 111 110 101 34 58 34 229 188 165 229 188 165 230 135 181 34 44 34 116 104 114 101 101 34 58 34 229 145 134 229 145 134 34 44 34 116 119 111 34 58 34 233 187 132 230 169 153 230 169 153 34 125 44 34 114 101 108 97 116 105 111 110 34 58 123 34 102 97 116 104 101 114 34 58 34 99 117 105 120 120 120 120 120 120 120 34 44 34 109 111 116 104 101 114 34 58 34 121 105 110 120 120 120 120 120 34 44 34 119 105 102 101 34 58 34 112 101 110 103 120 120 34 125 125 125 125] byteSliToStr.go: 123456789101112131415161718192021222324package mainimport ( \"testing\" \"unsafe\")/** 原始字符串`&#123;\"default\":&#123;\"common\":&#123;\"pet\":&#123;\"five\":\"斑斑\",\"four\":\"皮瓜瓜\",\"one\":\"弥弥懵\",\"three\":\"呆呆\",\"two\":\"黄橙橙\"&#125;,\"relation\":&#123;\"father\":\"cuixxxxxxx\",\"mother\":\"yinxxxxx\",\"wife\":\"pengxx\"&#125;&#125;&#125;&#125;`*/func BenchmarkString(b *testing.B) &#123; byteSli := []byte&#123;123, 34, 100, 101, 102, 97, 117, 108, 116, 34, 58, 123, 34, 99, 111, 109, 109, 111, 110, 34, 58, 123, 34, 112, 101, 116, 34, 58, 123, 34, 102, 105, 118, 101, 34, 58, 34, 230, 150, 145, 230, 150, 145, 34, 44, 34, 102, 111, 117, 114, 34, 58, 34, 231, 154, 174, 231, 147, 156, 231, 147, 156, 34, 44, 34, 111, 110, 101, 34, 58, 34, 229, 188, 165, 229, 188, 165, 230, 135, 181, 34, 44, 34, 116, 104, 114, 101, 101, 34, 58, 34, 229, 145, 134, 229, 145, 134, 34, 44, 34, 116, 119, 111, 34, 58, 34, 233, 187, 132, 230, 169, 153, 230, 169, 153, 34, 125, 44, 34, 114, 101, 108, 97, 116, 105, 111, 110, 34, 58, 123, 34, 102, 97, 116, 104, 101, 114, 34, 58, 34, 99, 117, 105, 120, 120, 120, 120, 120, 120, 120, 34, 44, 34, 109, 111, 116, 104, 101, 114, 34, 58, 34, 121, 105, 110, 120, 120, 120, 120, 120, 34, 44, 34, 119, 105, 102, 101, 34, 58, 34, 112, 101, 110, 103, 120, 120, 34, 125, 125, 125, 125&#125; _ = string(byteSli)&#125;func BenchmarkUnsafe(b *testing.B) &#123; byteSli := []byte&#123;123, 34, 100, 101, 102, 97, 117, 108, 116, 34, 58, 123, 34, 99, 111, 109, 109, 111, 110, 34, 58, 123, 34, 112, 101, 116, 34, 58, 123, 34, 102, 105, 118, 101, 34, 58, 34, 230, 150, 145, 230, 150, 145, 34, 44, 34, 102, 111, 117, 114, 34, 58, 34, 231, 154, 174, 231, 147, 156, 231, 147, 156, 34, 44, 34, 111, 110, 101, 34, 58, 34, 229, 188, 165, 229, 188, 165, 230, 135, 181, 34, 44, 34, 116, 104, 114, 101, 101, 34, 58, 34, 229, 145, 134, 229, 145, 134, 34, 44, 34, 116, 119, 111, 34, 58, 34, 233, 187, 132, 230, 169, 153, 230, 169, 153, 34, 125, 44, 34, 114, 101, 108, 97, 116, 105, 111, 110, 34, 58, 123, 34, 102, 97, 116, 104, 101, 114, 34, 58, 34, 99, 117, 105, 120, 120, 120, 120, 120, 120, 120, 34, 44, 34, 109, 111, 116, 104, 101, 114, 34, 58, 34, 121, 105, 110, 120, 120, 120, 120, 120, 34, 44, 34, 119, 105, 102, 101, 34, 58, 34, 112, 101, 110, 103, 120, 120, 34, 125, 125, 125, 125&#125; _ = *(*string)(unsafe.Pointer(&amp;byteSli))&#125; bench_test.go: 1234567891011121314151617package mainimport ( \"testing\")func BenchmarkTest1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; BenchmarkString(b) &#125;&#125;func BenchmarkTest2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; BenchmarkUnsafe(b) &#125;&#125; 执行 go test -test.bench=&quot;.*&quot; -benchmem: 1234567goos: darwingoarch: arm64pkg: xxxxBenchmarkTest1-8 16376076 61.51 ns/op 192 B/op 1 allocs/opBenchmarkTest2-8 34398655 33.49 ns/op 0 B/op 0 allocs/opPASSok xxxx 2.363s 第4行显示了BenchmarkString 执行了16376076次，每次的执行平均时间是61.51纳秒, 每次操作有1次内存分配,每次分配了192Byte大小的内存空间 第5行显示了BenchmarkUnsafe 执行了34398655次，每次的平均执行时间是33.49 纳秒, 无内存分配 可见使用unsafe这种”黑科技”，确实可以少分配一次内存 也可看出，string(byteSli)的方式是深拷贝，为新生成的新字符串新分配了一块内存 string转byte切片 再看一下上面的逆操作 strToByteSli.go: 1234567891011121314151617181920212223242526272829package mainimport ( \"reflect\" \"testing\" \"unsafe\")func BenchmarkByteStyle(b *testing.B) &#123; str := `&#123;\"default\":&#123;\"common\":&#123;\"pet\":&#123;\"five\":\"斑斑\",\"four\":\"皮瓜瓜\",\"one\":\"弥弥懵\",\"three\":\"呆呆\",\"two\":\"黄橙橙\"&#125;,\"relation\":&#123;\"father\":\"cuixxxxxxx\",\"mother\":\"yinxxxxx\",\"wife\":\"pengxx\"&#125;&#125;&#125;&#125;` _ = []byte(str)&#125;func BenchmarkWithUnsafe(b *testing.B) &#123; str := `&#123;\"default\":&#123;\"common\":&#123;\"pet\":&#123;\"five\":\"斑斑\",\"four\":\"皮瓜瓜\",\"one\":\"弥弥懵\",\"three\":\"呆呆\",\"two\":\"黄橙橙\"&#125;,\"relation\":&#123;\"father\":\"cuixxxxxxx\",\"mother\":\"yinxxxxx\",\"wife\":\"pengxx\"&#125;&#125;&#125;&#125;` sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;str)) bh := reflect.SliceHeader&#123; Data: sh.Data, Len: sh.Len, Cap: sh.Len, &#125; _ = *(*[]byte)(unsafe.Pointer(&amp;bh))&#125; bench_test.go: 123456789101112131415161718package mainimport ( \"testing\")func BenchmarkTest3(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; BenchmarkByteStyle(b) &#125;&#125;func BenchmarkTest4(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; BenchmarkWithUnsafe(b) &#125;&#125; 执行 go test -test.bench=&quot;.*&quot; -benchmem: 1234567goos: darwingoarch: arm64pkg: xxxxBenchmarkTest3-8 34892566 34.03 ns/op 192 B/op 1 allocs/opBenchmarkTest4-8 1000000000 0.3148 ns/op 0 B/op 0 allocs/opPASSok xxxx 2.873s 第4行显示了BenchmarkByteStyle 执行了34892566次，每次的执行平均时间是34.03纳秒, 每次操作有1次内存分配,每次分配了192Byte大小的内存空间 第5行显示了BenchmarkWithUnsafe 执行了1000000000次，每次的平均执行时间是0.3148纳秒, 无内存分配 使用unsafe不仅可以少分配一次内存，每次的平均执行时间也差了100倍…(而用unsafe 从[]byte到string，和使用string(byteSli)方式，执行时间只快了一倍)","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"打工人租房记","date":"2021-04-11T12:38:37.000Z","path":"2021/04/11/打工人租房记/","text":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"最多能创建多少个TCP连接？","date":"2021-04-11T12:00:53.000Z","path":"2021/04/11/最多能创建多少个TCP连接？/","text":"https://mp.weixin.qq.com/s/mGkf-9LZhhUgSIRBRqfRDw","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"成为Go贡献者","date":"2021-04-10T12:34:28.000Z","path":"2021/04/10/成为Go贡献者/","text":"Contribution Guide Becoming a contributor Overview The first step is registering as a Go contributor and configuring your environment. Here is a checklist of the required steps to follow: Step 0: Decide on a single Google Account you will be using to contribute to Go. Use that account for all the following steps and make sure that git is configured to create commits with that account’s e-mail address. Step 1: Sign and submit a CLA (Contributor License Agreement). Step 2: Configure authentication credentials for the Go Git repository. Visit go.googlesource.com, click “Generate Password” in the page’s top right menu bar, and follow the instructions. Step 3: Register for Gerrit, the code review tool used by the Go team, by visiting this page. The CLA and the registration need to be done only once for your account. Step 4: Install git-codereview by running go get -u golang.org/x/review/git-codereview If you prefer, there is an automated tool that walks through these steps. Just run: $ go get -u golang.org/x/tools/cmd/go-contrib-init $ cd /code/to/edit $ go-contrib-init The rest of this chapter elaborates on these instructions. If you have completed the steps above (either manually or through the tool), jump to Before contributing code. Step 0: Select a Google Account &amp;&amp; Step 1: Contributor License Agreement Google Individual Contributor License Agreement:12345678910111213141516171819202122232425By signing this contributor license agreement, I understand and agree that this project and contributions to it are public and that a record of the contribution (including all personal information I submit with it, including my full name and email address) is maintained indefinitely and may be redistributed consistent with this project, compliance with the open source license(s) involved, and maintenance of authorship attribution.In order to clarify the intellectual property license granted with Contributions from any person or entity, Google LLC (\"Google\") must have a Contributor License Agreement (\"CLA\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This license is for your protection as a Contributor as well as the protection of Google; it does not change your rights to use your own Contributions for any other purpose.You accept and agree to the following terms and conditions for Your present and future Contributions submitted to Google. Except for the license granted herein to Google and recipients of software distributed by Google, You reserve all right, title, and interest in and to Your Contributions.Definitions.\"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with Google. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to Google for inclusion in, or documentation of, any of the products owned or managed by Google (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to Google or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Google for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\"Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Google and to recipients of software distributed by Google a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works.Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to Google and to recipients of software distributed by Google a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed.You represent that you are legally entitled to grant the above license. If your employer(s) has rights to intellectual property that you create that includes your Contributions, you represent that you have received permission to make Contributions on behalf of that employer, that your employer has waived such rights for your Contributions to Google, or that your employer has executed a separate Corporate CLA with Google.You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions.You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.Should You wish to submit work that is not Your original creation, You may submit it to Google separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here]\".You agree to notify Google of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect. Step 2: Configure git authentication 配置git身份认证 The main Go repository is located at go.googlesource.com, a Git server hosted by Google. Authentication on the web server is made through your Google account, but you also need to configure git on your computer to access it. Follow these steps: Visit go.googlesource.com and click on “Generate Password” in the page’s top right menu bar. You will be redirected to accounts.google.com to sign in. After signing in, you will be taken to a page with the title “Configure Git”. This page contains a personalized script that when run locally will configure Git to hold your unique authentication key. This key is paired with one that is generated and stored on the server, analogous to how SSH keys work. Copy and run this script locally in your terminal to store your secret authentication token in a .gitcookies file. If you are using a Windows computer and running cmd, you should instead follow the instructions in the yellow box to run the command; otherwise run the regular script. 在终端执行这段脚本,身份验证令牌就存储在了.gitcookies文件中 Step 3: Create a Gerrit account Gerrit is an open-source tool used by Go maintainers to discuss and review code submissions. To register your account, visit go-review.googlesource.com/login/ and sign in once using the same Google Account you used above. Step 4: Install the git-codereview command ¶ Changes to Go must be reviewed before they are accepted, no matter who makes the change. A custom git command called git-codereview simplifies sending changes to Gerrit. Install the git-codereview command by running, $ go get -u golang.org/x/review/git-codereview Make sure git-codereview is installed in your shell path, so that the git command can find it. Check that $ git codereview help prints help text, not an error. If it prints an error, make sure that $GOPATH/bin is in your $PATH. On Windows, when using git-bash you must make sure that git-codereview.exe is in your git exec-path. Run git --exec-path to discover the right location then create a symbolic link or just copy the executable from $GOPATH/bin to this directory. Before contributing code The project welcomes code patches, but to make sure things are well coordinated you should discuss any significant change before starting the work. It’s recommended that you signal your intention to contribute in the issue tracker, either by filing a new issue or by claiming an existing one. Where to contribute The Go project consists of the main go repository, which contains the source code for the Go language, as well as many golang.org/x/… repositories. These contain the various tools and infrastructure that support Go. For example, golang.org/x/pkgsite is for pkg.go.dev, golang.org/x/playground is for the Go playground, and golang.org/x/tools contains a variety of Go tools, including the Go language server, gopls. You can see a list of all the golang.org/x/… repositories on go.googlesource.com. Check the issue tracker Whether you already know what contribution to make, or you are searching for an idea, the issue tracker is always the first place to go. Issues are triaged to categorize them and manage the workflow. The majority of the golang.org/x/… repos also use the main Go issue tracker. However, a few of these repositories manage their issues separately, so please be sure to check the right tracker for the repository to which you would like to contribute. Most issues will be marked with one of the following workflow labels: NeedsInvestigation: The issue is not fully understood and requires analysis to understand the root cause. NeedsDecision: the issue is relatively well understood, but the Go team hasn’t yet decided the best way to address it. It would be better to wait for a decision before writing code. If you are interested in working on an issue in this state, feel free to “ping” maintainers in the issue’s comments if some time has passed without a decision. NeedsFix: the issue is fully understood and code can be written to fix it. You can use GitHub’s search functionality to find issues to help out with. Examples: Issues that need investigation: is:issue is:open label:NeedsInvestigation Issues that need a fix: is:issue is:open label:NeedsFix Issues that need a fix and have a CL: is:issue is:open label:NeedsFix &quot;golang.org/cl&quot; Issues that need a fix and do not have a CL: is:issue is:open label:NeedsFix NOT &quot;golang.org/cl&quot; Open an issue for any new problem Excluding very trivial changes, all contributions should be connected to an existing issue. Feel free to open one and discuss your plans. This process gives everyone a chance to validate the design, helps prevent duplication of effort, and ensures that the idea fits inside the goals for the language and tools. It also checks that the design is sound before code is written; the code review tool is not the place for high-level discussions. When planning work, please note that the Go project follows a six-month development cycle for the main Go repository. The latter half of each cycle is a three-month feature freeze during which only bug fixes and documentation updates are accepted. New contributions can be sent during a feature freeze, but they will not be merged until the freeze is over. The freeze applies to the entire main repository as well as to the code in golang.org/x/… repositories that is needed to build the binaries included in the release. See the lists of packages vendored into the standard library and the go command. Significant changes to the language, libraries, or tools must go through the change proposal process before they can be accepted. Sensitive security-related issues (only!) should be reported to security@golang.org. 参考: 成为Go贡献者","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go map转json","date":"2021-04-07T13:01:54.000Z","path":"2021/04/07/Go-map转json/","text":"在Go中如何返回前端 字段名称/数量都不确定的json数据？ 之前用Go写web服务，返回给前端的json格式的接口，有哪些要返回的字段都是明确的。都是预先定义一个结构体，json.Marshal一下即可~ 但当有的场景，要返回哪些字段不确定时，就无法使用struct的方式。 还可以用map 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"encoding/json\" \"fmt\")func main() &#123; Map2Json()&#125;func Map2Json() &#123; mapInstance := make(map[string]interface&#123;&#125;) mapInstance[\"Name\"] = \"cs\" mapInstance[\"Age\"] = 28 mapInstance[\"Address\"] = \"杭州\" relation := make(map[string]interface&#123;&#125;) relation[\"father\"] = \"cuixxxxxxx\" relation[\"mother\"] = \"yinxxxxx\" relation[\"wife\"] = \"pengxx\" mapInstance[\"Relation\"] = relation pet := make(map[string]interface&#123;&#125;) pet[\"one\"] = \"弥弥懵\" pet[\"two\"] = \"黄橙橙\" pet[\"three\"] = \"呆呆\" pet[\"four\"] = \"皮瓜瓜\" pet[\"five\"] = \"斑斑\" mapInstance[\"Cat\"] = pet jsonStr, err := json.Marshal(mapInstance) fmt.Println(\"err is:\", err) fmt.Println(\"jsonStr is:\", string(jsonStr))&#125; 输出为： 12err is: &lt;nil&gt;jsonStr is: &#123;\"Address\":\"杭州\",\"Age\":28,\"Cat\":&#123;\"five\":\"斑斑\",\"four\":\"皮瓜瓜\",\"one\":\"弥弥懵\",\"three\":\"呆呆\",\"two\":\"黄橙橙\"&#125;,\"Name\":\"cs\",\"Relation\":&#123;\"father\":\"cuixxxxxxx\",\"mother\":\"yinxxxxx\",\"wife\":\"pengxx\"&#125;&#125; 在proto中如何定义这样的返回值？ 如果使用proto来定义接口，如何定义不确定字段名称和数量的返回值？ 即上面的 jsonStr，如何定义才能返回给前端？ 尝试使用过Any，发现不行(Any的“风评”很不好，介绍时一般和one of出现在一起) 几经探求，发现这种情况该用Struct(或说Value)类型 Is “google/protobuf/struct.proto” the best way to send dynamic JSON over GRPC? xxxx.proto: 1234567891011121314151617181920212223242526272829syntax = \"proto3\";package demo;import \"validate/validate.proto\";import \"google/api/annotations.proto\";import \"google/protobuf/timestamp.proto\";//import \"google/protobuf/any.proto\";import \"google/protobuf/struct.proto\";rpc Getxxxxx(GetxxxxxReq) returns (GetxxxxxResp) &#123;option (google.api.http) = &#123; get:\"/api/v1/xxxx/xxxx/xxxxxx\"&#125;;&#125;message GetxxxxxResp &#123; google.protobuf.Value data = 1;&#125;message GetxxxxxReq &#123; // 用户名 string user_name = 1 [(validate.rules).string.max_len = 100, (validate.rules).string.min_len = 1]; // 创建时间 google.protobuf.Timestamp create_time = 2;&#125; xxxx.go 大致代码如下: 12345678910111213var rs xxxxxmapInstance[\"default\"] = mapDefaultjsonByteSli, err := json.Marshal(mapInstance)v := &amp;structpb.Value&#123;&#125;err = protojson.Unmarshal(jsonByteSli, v)rs.Data = vreturn &amp;rs, nil struct.proto源码： protobuf/src/google/protobuf/struct.proto [转]Protobuf3 语法指南","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"编译器漫谈","date":"2021-04-05T13:07:53.000Z","path":"2021/04/05/编译器漫谈/","text":"https://pandolia.net/tinyc/ 阮一峰-编译器的工作过程 &lt;br GCC，LLVM，Clang GCC是 RMS 主导的烂尾项目GNU,遗存下来的不多的硕果(glibc算另外一个). GNU全称 Compile Collection(GNU编译器套装) LLVM(Low Level Virtual Machine) 和 Clang作者都是编译器领域大名鼎鼎的 Chris Lattner. LLVM引入IR（Intermediate Representation）概念,兼容性高 这个logo应该是在致敬 龙书 随着后来GCC支持越来越多的语言,GCC架构的问题也逐渐暴露出来 LLVM与GCC在三段式架构上并没有本质区别。LLVM与其它编译器最大的差别是，它不仅仅是Compiler Collection，也是Libraries Collection。 (其实llvm和clang关系比较微妙) 机器只认字节码,至于这个字节码中间是怎么编译成的,机器并不关心 更多参考: GNU、GCC、LLVM和Clang GCC, the GNU Compiler Collection llvm.org LLVM编译原理和使用 Resources for Amateur Compiler Writers Go语言编译器 Go 1.3之前编译器用C实现, 1.3之后用Go实现,即实现了 自举 当前Go的编译器有默认的 GC,以及基于GCC的 GCCGO. 关于这二者区别: 也有基于LLVM的实现,但支持还不够好 go tool compile -w 文件名,展示 抽象语法树 的转换 -l :禁用内联的标志 AST 生成后, 其允许编译器使用 SSA 表示转到较低级别的中间表示 Go 程序是如何编译成目标机器码的 Go编译器——AST到SSA流程分析 编译原理实战课 Go 语言的编译器完全用 Go 语言本身来实现，它完全实现了从前端到后端的所有工作，而不像 Java 要分成多个编译器来实现不同的功能模块，不像 Python 缺少了后端，也不像 Julia 用了太多的语言。所以你研究它所采用的编译技术会更方便。 Go 编译器概述 Go 编译过程 词法分析和语法分析 词法分析器: cmd/compile/internal/syntax.scanner Go 的词法分析器并没有像 V8 那样在不遗余力地压榨性能，它跟你平常编码的方式是很一致的，非常容易阅读。 语法分析器: cmd/compile/internal/syntax.parser 它是一个标准的手写的递归下降算法。在解析二元表达式的时候，Go 的语法分析器也是采用了运算符优先级算法，这个已经是第 N 次见到这个算法了！不过，每个编译器的实现都不大一样，而 Go 的实现方式相当的简洁，可以去自己看一下，或者用调试器来跟踪一下它的执行过程。 在 cmd/compile/internal/syntax 目录下，还有词法分析器和语法分析器的测试程序，可以去运行测试一下 Go语言编译器：把它当作教科书吧 Lexical Scanning in Go - Rob Pike Go 1.5 Bootstrap Plan The Go Programming Language Specification 语义分析 — 包括 类型检查和 AST 变换(即中间代码IR的生成?) 通过词法和语法分析器的解析得到了抽象语法树，然后编译器会继续执行下一阶段 --- 类型检查。 类型检查是 Go 语言编译的第二个阶段，在词法和语法分析之后我们得到了每个文件对应的抽象语法树，随后的类型检查会遍历抽象语法树中的节点，对每个节点的类型进行检验，找出其中存在的语法错误，在这个过程中也可能会对抽象语法树进行改写，这不仅能够去除一些不会被执行的代码、对代码进行优化以提高执行效率，而且也会修改 make、new 等关键字对应节点的操作类型。 词法与语法分析以 及 类型检查 两个部分都属于编译器前端，它们负责对源代码进行分析并检查其中存在的词法和语法错误，经过这两个阶段生成的抽象语法树已经不存在语法错误了，之后就到了编译器的后端工作部分 --- 中间代码生成 中间代码是编译器或者虚拟机使用的语言，它可以来帮助分析计算机程序。在编译过程中，编译器会在将源代码转换到机器码的过程中，先把源代码转换成一种中间的表示形式，即中间代码 从 AST 到 SSA 中间代码的生成过程，有将近 50 个生成中间代码的步骤 Introduction to the Go compiler’s SSA backend 更多参见 编译原理实战课 生成机器码 最后，编译器就可以调用 gc/ssa.go 中的genssa方法，来生成汇编码 至于指令排序，我没看到过在 gc 编译器中的实现。我请教了谷歌的一位研究员，他给我的信息是：像 AMD64 这样的 CPU，已经能够很好地支持乱序执行了，所以指令重排序给 gc 编译器的优化工作，带来的好处很有限。 而 gc 目前没有做指令排序，还有一个原因就是，指令重排序算法的实现代价比较高，而 gc 的一个重要设计目标，就是要求编译速度要快。 扩展：Go 语言的另外两个编译器，gccgo 和 GoLLVM 都具备指令重排序功能。 最开始的计算机使用复杂指令集是因为当时计算机的性能和内存比较有限，业界需要尽可能地减少机器需要执行的指令，所以更倾向于高度编码、长度不等以及多操作数的指令。不过随着计算机性能的提升，出现了精简指令集这种牺牲代码密度换取简单实现的设计；除此之外，硬件的飞速提升还带来了更多的寄存器和更高的时钟频率，软件开发人员也不再直接接触汇编代码，而是通过编译器和汇编器生成指令，复杂的机器指令对于编译器来说很难利用，所以精简指令在这种场景下更适合。 复杂指令集和精简指令集的使用是设计上的权衡，经过这么多年的发展，两种指令集也相互借鉴和学习，与最开始刚被设计出来时已经有了较大的差别，对于软件工程师来讲，复杂的硬件设备对于我们来说已经是领域下三层的知识了，其实不太需要掌握太多，但是对指令集架构感兴趣的读者可以找一些资料开拓眼界 汇编器是将汇编语言翻译为机器语言的程序，Go 语言的汇编器是基于 Plan 9 汇编器的输入类型设计的，Go 语言对于汇编语言 Plan 9 和汇编器的资料十分缺乏，网上能够找到的资料也大多都含糊不清，官方对汇编器在不同处理器架构上的实现细节也没有明确定义 作为软件工程师，如果不是 Go 语言编译器的开发者或者需要经常处理汇编语言和机器指令，掌握这些知识的投资回报率实在太低，我们只需要对这个过程有所了解，补全知识上的盲点，在遇到问题时能够快速定位即可 机器码生成 Go 程序到机器码的编译之旅 go编译器 附加参数 备注 -v 编译时显示包名 -p n 开启并发编译，默认情况下该值为 CPU 逻辑核数 -a 强制重新构建, 强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建,即使它们已是最新的 -n 打印编译时会用到的所有命令，但不真正执行 -x 打印编译时会用到的所有命令 -race 开启竞态检测 -work 打印出编译时生成的临时工作目录的路径,并在编译结束时保留它;在默认情况下,编译结束时会删除该目录","tags":[{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"使用dlv调试Go程序","date":"2021-04-02T13:35:17.000Z","path":"2021/04/02/使用dlv调试Go程序/","text":"有关dlvvi. 钻研；探究；挖vt. 钻研；探究；挖n. 穴；洞n. (Delve)人名；(英)德尔夫delve: 钻研delve into: 深入研究The study delve into: 探讨钻研 之前用过的gdb/lldb,是通用的代码调试器,而delve,则是专门用来调试 Go 程序的工具. delve一般简称为dlv,它和gdb都可以用来调试Go程序,但dlv相比gdb在调试goroutine方面支持更好 安装步骤见github.com/go-delve/delve 使用 以下为dlv的几个常用调试命令: 1、dlv debug main.go #debug一个main.go程序 2、break（b）main.main #在main包里的main函数入口打断点 使用 b 这个命令打断点，有三种方法： b + 地址 b + 代码行数 b + 函数名 3、continue（c） #继续运行，直到断点处停止 4、next（n） #单步运行 5、locals #打印local variables 6、print（p） #打印一个变量或者表达式 7、restart（r） #Restart Process 探究给为nil的map赋值出现的panic: 对于m.go 12345678package mainfunc main() &#123; var m map[int64]string m[1] = \"666\" //panic: assignment to entry in nil map&#125; 编译生成可执行文件, 使用 dlv 进入调试状态: 123go build m.godlv exec ./m 在map赋值的地方,即第6行设置断点: 执行 c 命令,可直接运行到断点处 执行 disass 命令,可以看到汇编指令 使用 si 命令,执行单条指令 多次执行 si,就会执行到 map 赋值函数 mapassign_fast64: 此时再用单步命令 s, 就会进入判断 h 的值为 nil 的分支, 然后执行到 panic 函数: 此时就找到了panic的runtime源码位置,便可以进一步探究 另外,可以使用 bt 命令看到调用栈, 使用 frame x,可以跳转到相应位置. 如frame 2对应图中的 m.go:6, 也即前面打断点的地方 还可以看下frame 3 和 frame 4: (在帧之间跳转) 探究给为nil的sli赋值出现的panic: 对于sli.go: 123456789package mainfunc main() &#123; var sli []int64 sli[0] = 666 // panic: runtime error: index out of range [0] with length 0 //sli = append(sli,1213) //正常操作&#125; 命令手册: 全部: 程序运行 12345678910111213call ：call 函数（注意了，这个会导致整个程序运行的）continue ：往下运行next ：单步调试restart ：重启step ：单步调试，某个函数step-instruction ：单步调试某个汇编指令stepout ：从当前函数跳出 断点相关 12345678910111213break (alias: b) ：设置断点breakpoints (alias: bp) ：打印所有的断点信息clear ：清理断点clearall ：清理所有的断点condition (alias: cond) ：设置条件断点on ：设置一段命令，当断点命中的时候trace (alias: t) ：设置一个跟踪点，这个跟踪点也是一个断点，只不过运行到的时候不会断住程序，只是打印一行信息，这个命令在某些场景是很有用的，比如你断住程序就会影响逻辑（业务有超时），而你仅仅是想打印某个变量而已，那么用这种类型的断点就行 信息打印 123456789101112131415args : 打印程序的传参examinemem (alias: x) ：这个是神器，解析内存用的，和 gdb 的 x 命令一样；locals ：打印本地变量 print (alias: p) ：打印一个表达式，或者变量 regs ：打印寄存器的信息 set ：set 赋值 vars ：打印全局变量（包变量） whatis ：打印类型信息 协程相关 1234567goroutine (alias: gr) ：打印某个特定协程的信息 goroutines (alias: grs) ：列举所有的协程 thread (alias: tr) ：切换到某个线程 threads ：打印所有的线程信息 栈相关 123456789deferred ：在 defer 函数上下文里执行命令 down ：上堆栈 frame ：跳到某个具体的堆栈 stack (alias: bt) ：打印堆栈信息 up ：下堆栈 其他命令 12345678910111213141516171819config ：配置变更 disassemble (alias: disass) ：反汇编 edit (alias: ed) ：略 exit (alias: quit | q) ：略 funcs ：打印所有函数符号 libraries ：打印所有加载的动态库 list (alias: ls | l) ：显示源码 source ：加载命令 sources ：打印源码 types ：打印所有类型信息 example: 打印全局变量: (dlv) vars 设置断点 b = break bp = breakpoint break（b）main.main #在main包里的main函数入口打断点 使用 b 这个命令打断点，有三种方法： b + 地址 b + 文件名:行号 b + 函数名 条件断点 123456789# 先断点(dlv) b # 查看断点信息(dlv) bp# 然后定制条件(dlv) condition 2 i==2 &amp;&amp; j==7 &amp;&amp; z==32 程序继续执行 c = continue next命令来逐行执行程序 step 命令从 main 函数进入 被调用的函数 查看当前的栈信息 &amp; 在帧之间跳转 用 stack 命令查看当前栈的内容 用 frame 命令实现帧之间的跳转 1234# 展示所有堆栈(dlv) goroutines# 所有堆栈展开(dlv) goroutines -t 解析内存 (dlv) x -fmt hex -len 20 0xc00008af38 打印函数参数 args 命令能打印出命令行传给函数的参数 查看反汇编码 由于我们是调试编译出的二进制文件,因此如能查看编译器生成的汇编语言指令将会非常有用, Delve 提供了一个 disassemble命令 disass = disassemble 单步退出函数 stepout命令可以跳回到函数被调用的地方 打印变量信息 可以在 Delve 中用 print 命令通过变量名来展示他们当前的值 还可以用 locals 命令来打印函数内所有的局部变量 如果不知道变量的类型,可以用 whatis 命令来通过变量名来打印它的类型 参考: 曹大带我学 Go（3）—— 如何用汇编打同事的脸 使用 Delve 代替 Println 来调试 Go 程序 全面的整理：golang 调试分析的高阶技巧 Golang程序调试工具介绍(gdb vs dlv) 如何用汇编打同事的脸 gdlv dlv提供了类似gdb的cli调试系统,而这个第三方库提供了dlv的GUI前端(gdlv). 对于习惯使用GUI进行调试的人来说结合gdlv和dlv调试会更加方便","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go 1.12 关于内存释放的一个\"改进\"","date":"2021-03-26T13:28:24.000Z","path":"2021/03/26/Go-1-12-关于内存释放的一个改进/","text":"概述: “改进” 加引号,因为社区反馈问题多多 弊大于利, 于是Go 1.16又改了回去… 问题包括但不仅限于: 引发用户体验的问题：Go issues 上总是出现以为内存泄露，但其实只是未满足条件，内存没有马上释放的案例。 混淆统计信息和监控工具的情况：在 Grafana 等监控上，发现容器进程内存较高，释放很慢，告警了，很慌。 导致与内存使用有关联的个别管理系统集成不良：例如 Kubernetes HPA ，或者自定义了扩缩容策略这类模式，难以评估。 挤压同主机上的其他应用资源：并不是所有的 Go 程序都一定独立跑在单一主机中，自然就会导致同一台主机上的其他应用受到挤压，这是难以评估的。 (参考自 Go1.16 新特性：详解内存管理机制的变更，你需要了解) 出现这个问题 需要同时满足 Go版本在 1.12~1.15之间(都是闭区间)，同时是Linux系统且内核版本&gt;=4.5 通过设置环境变量 GODEBUG:madvdontneed=1即可关闭该功能 Go 1.12~Go 1.15 Go支持两种内存回收方式，即 MADV_DONTNEED与MADV_FREE 其中MADV_FREE是 Go 1.12版本引入，官网上的介绍如下： 12On Linux, the runtime now uses MADV_FREE to release unused memory. This is more efficient but may result in higher reported RSS. The kernel will reclaim the unused data when it is needed. To revert to the Go 1.11 behavior (MADV_DONTNEED), set the environment variable GODEBUG=madvdontneed=1. 大意就是使用MADV_FREE方式，程序内存不会立刻回收，即RSS值不会立刻下降，只有当OS内存紧缺时才会回收Go程序的内存返回给OS； 而Go 1.11以及之前的版本默认采用的是 MADV_DONTNEED方式，程序RSS值下降很快。因此如果需要使程序内存占用下降很快的话，可设置环境变量GODEBUG=madvdontneed=1。 注：Go 1.12~1.15版本的这项功能, 仅限于 Linux平台; 且需要内核在 4.5及之后的版本，才默认使用MADV_FREE方式。 如果不支持会退用之前默认的MADV_DONTNEED runtime/mem_linux.go源码里注释如下： 123456789101112var advise uint32if debug.madvdontneed != 0 &#123; advise = _MADV_DONTNEED&#125; else &#123; advise = atomic.Load(&amp;adviseUnused)&#125;if errno := madvise(v, n, int32(advise)); advise == _MADV_FREE &amp;&amp; errno != 0 &#123; // MADV_FREE was added in Linux 4.5. Fall back to MADV_DONTNEED if it is // not supported. atomic.Store(&amp;adviseUnused, _MADV_DONTNEED) madvise(v, n, _MADV_DONTNEED)&#125; 参考: Go 1.12中出现的top命令RES参数异常增高的问题 Go进程的HeapReleased上升，但是RSS不下降造成内存泄漏？—- 并不是内存泄露 Go 1.12 关于内存释放的一个改进—并不是内存泄露 Go 1.16又改了回去 在 Go 1.16 中,对这个问题又做了优化, 在 Linux 上，runtime 现在默认会迅速地（使用 MADV_DONTNEED）向操作系统释放内存，而不是在操作系统面临内存压力时（使用 MADV_FREE）惰性地释放内存。这意味着像 RSS 这样的进程级内存统计信息将更准确地反映 Go 进程所使用的物理内存数量。因此 Go1.16 中，不再需要配置 GODEBUG=madvdontneed=1 来改善内存监控行为。 通过 123456789func parsedebugvars() &#123; // defaults debug.cgocheck = 1 debug.invalidptr = 1 if GOOS == \"linux\" &#123; debug.madvdontneed = 1 &#125; ...&#125; 又 直接指定回了 debug.madvdontneed = 1 也算是Go Team走的一段弯路 参考&amp;值得阅读: 列举一些 Go1.16 中可能对大家有影响的变化 Go1.16 新特性：详解内存管理机制的变更，你需要了解 Go 1.16中值得关注的几个变化 一个 Go 程序不释放内存的问题 runtime: smarter scavenging #30333","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Wireshark网络分析的艺术","date":"2021-03-23T15:22:45.000Z","path":"2021/03/23/Wireshark网络分析的艺术/","text":"答读者问 Linux为什么卡住了? 解决SSH登录过慢——取消ssh的DNS反解 cat sshd_config | grep -i dns 发现没有结果,说明这台服务器没有这项配置 (貌似仅 debian 服务器才会出现这现象) 像福尔摩斯一样思考 用 Wireshark 排查问题,和侦探破案的思路是一致的 一篇关于VMware的文章 灵感不是天生的,它来自长期的训练 ESX/ESXi hosts might experience read or write performance issues with certain storage arrays (1002598) 来点有深度的 SACK: 即 Selective ACK. 使得接收方能告诉发送方哪些报文段丢失，哪些报文段重传了，哪些报文段已经提前收到等信息。根据这些信息TCP就可以只重传哪些真正丢失的报文段。 TCP选项之SACK选项概述 MSS: 最大分段大小 (Maximum segment size) 三次握手的小知识 DDoS 的形式有很多种,其中最流行的就是基于三次握手的 SYN flood,其原理是从大量主机发送SYN请求给服务器,假装要建立TCP连接. 这些SYN请求可能含有假的源地址,所以服务器响应后永远收不到Ack,就会留下half-open状态的TCP连接. 由于每个TCP连接都会消耗一定的系统资源,如果攻击足够猛烈,此类连接越建越多,服务器的资源就会被耗光,真正的用户访问也会被拒绝. 可以把 SYN flood 看作TCP协议的设计缺陷,有办法可以防御,却无法根除 被误解的TCP 就像我们不用每天都跟公司算一次工钱,而是攒到月底结算一样,数据接收方也可以累积一些包 才对发送方ACK一次/ 至于ACK的频率,不同的操作系统有不同的偏好. 最经典的网络问题 AIX（Advanced Interactive eXecutive）: IBM基于AT&amp;T Unix System V开发的一套类UNIX操作系统 愚笨窗口综合症(Silly window syndrome), 也叫 “小包问题”(small packet problem) 纳格(Nagle)算法 TCP Performance problems caused by interaction between Nagle’s Algorithm and Delayed ACK 为什么丢了单子? 1234567891011121314Appendix A: System Authentication The client may wish to identify itself, for example, as it is identified on a UNIX(tm) system. The flavor of the client credential is \"AUTH_SYS\". The opaque data constituting the credential encodes the following structure: struct authsys_parms &#123; unsigned int stamp; string machinename&lt;255&gt;; unsigned int uid; unsigned int gid; unsigned int gids&lt;16&gt;; &#125;; rfc 5531 受损的帧 帧检验序列(FCS) 一般使用 循环冗余算法（CRC）检测算法来进行检错和纠错 虚惊一场 延迟确认: 可以省掉四次挥手中的第二个包 Linux下TCP延迟确认(Delayed Ack)机制导致的时延问题分析 TCP/IP还有三次挥手 作为 Wireshark 熟练工,必须能从一端抓到的网络包中推测出另一端的概况,才能分析出那些最复杂的问题. NTLM协议分析 NTLM: NT LAN Manager, Windows NT时代就出现的身份验证协议 已经不够安全,不推荐使用. 推荐 Kerberos 域控: 域控制器是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC） Wireshark的提示 Packet size limited during capture TCP Previous segment not captured TCP ACKed unseen segment TCP Out-of-Order TCP Dup ACK TCP Fast Retransmission TCP Retransmission TCP zerowindow TCP window Full TCP segment of a reassembled PDU Continuation to # Time-to-live exceeded (Fragment reassembly time exceeded) 工作中的Wireshark 书上错了吗? 建议初学者两边(数据接收方,数据发送方)同时抓包,对照着看 网络延迟 会导致同样的网络包,在两端体现出不同的顺序. 计算’在途字节数’ 承载量 就是处于运输工具中的货物量，即已经从源仓库发货，但还没有到达目的地的包裹数量。 和运输机类似，网络承载量也可以用已经发送出去，但尚未被确认的字节数来表示。在英文技术文档中，形象地用“bytes in fight”来描述它，我觉得用“在途字节数”来翻译最好。 飞机如果超载了，是会发生严重事故的。而在途字节数如果超过网络的承载能力，也会丢包重传，这就是我们需要计算它的原因。 估算网络拥塞点 假如把网络路径想象成一条河流。发送方是水源、接收方是入海口，那 在途字节数 就是河里的水量。 当水源的流速超过了入海口的流速，河里的水量就会越来越多，直至溢出。所以大致可以认为，发生拥塞时的在途字节数即是该时刻的网络拥塞点。明白了这一点，估算拥塞点就可以简化成找出拥塞时刻的在途字节数了。 每一次拥塞带来的性能影响都很大，即使千分之一的概率都足以导致性能大滑坡 顺便说说LSO LSO: Large Segment Offload LSO是什么呢？它是为了拯救CPU而出现的一个创意。随着网络进入千兆和万兆时代， CPU的工作负担明显加重了。625MB/s的网络流量大约需要耗费5GHz的CPU，这已经需要一个双核2.5 GHz CPU的全部处理能力了。为了缓解CPU的压力，最好把它的一些工作 外包（offload） 给网卡，比如TCP的分段工作。 传统的网络工作方式是这样的：应用层把产生的数据交给TCP层， TCP层再根据MSS大小进行分段（由CPU负责），然后再交给网卡。 而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段工作了. 熟读RFC 决定客户端发送窗口的因素有两个，分别为网络上的拥塞窗口（Congestion Window，缩写为cwnd）和服务器上的接收窗口。 本案例中的客户端采用了一种不太科学的cwnd算法,服务器上又启用了LRO. 两者分开工作的时候都没有问题,但是配合起来就会导致cwnd上升过慢,从而极大地影响了性能. CWnd 如何理性的调整「rwnd」和「cwnd」的大小 LRO: Large Receive Offload, 通过将接收到的多个TCP数据聚合成一个大的数据包，然后传递给网络协议栈处理，以减少上层协议栈处理 开销，提高系统接收TCP数据包的能力。(积累多个TCP包再集中处理) 关于网卡特性TSO、UFO、GSO、LRO、GRO 一个你本该解决的问题 争论TCP和UDP哪个更好,就像每天在吵狮子和老虎谁更厉害一样无聊. 它们俩都是其领域之王,只不过一个适合在草原,另一个适合在森林而已 几个关于分片的问题 为什么要分片? 20世纪60年代以前，数据通信是依靠电路交换技术的，根本没有分片一说，比如传统电话。由于电路交换的双方要独占链路，所以利用率很低，直到 Paul Baran(被称为交换机之父,于2011年去世)和Donald Davies(于2000年去世)发明了分组交换的概念，把数据分割成小包后才实现了链路共享。 既然要分割，就得先确定一个包的大小， 有趣的是当时这两位独立发明人都在实验室中选择了128字节作为一个传输单位。不过到了20世纪80年代的以太网中，就发展到以1500字节作为最大传输单位了，即MTU（Maximum TransmissionUnit）为1500. 刨去20字节的头部，一个IP包最多可以携带 $1500—20—1480$字节的数据。当要传输的数据块超过1480字节时，网络层 就不得不把它分片，封装成多个网络包。 MTU:最大传输单元（Maximum Transmission Unit，MTU） 网络相关 发送方是怎样确定分片大小的？ 如果经常分析各种环境中的包，会发现有些分片并不是携带1480字节，而是更大或者更小。这是因为有些网络是Jumbo Frame （巨帧）或PPPOE类的，它们的MTU并不是1500。 于是问题来了， MTU不一致的两个网络之间要通信怎么办？比如启用巨帧之后的MTU是9000字节，那从发送方出来的包就有9000 字节，万一经过一个MTU只有1500字节的网络设备，还是可能被重新分片甚至丢弃。这种情况下发送方要怎样决定分片大小，才能避免因为MTU不一致而出问题呢？ 比较理想的办法是先通过Path MTU Discovery协议来探测路径上的最小MTU，从而调节分片的大小。可惜该协议是依靠ICMP来探测的，会被很多网络设备禁用，所以不太可靠。 总而言之，目前发送方没有一个很好的机制来确定最佳分片大小，所以实施和运维人员配置MTU时必须慎之又慎，尽量使网络中每个设备的MTU保持一致。 下一个章节就是一些由于MTU配置出错而导致的问题。 接收方又是靠什么重组分片的？ 每个分片都包含off=xxx,ID=XXX的信息，接收方就是依据这两个值，把ID相同的分片按照off值（偏移量）进行重组的. 原理非常简单，唯一的问题是接收方如何判断最后一个分片已经到达，应该开始重组了。 当某个包 包含了一个“More fragments =0”的Flag，表示它是最后一个分片.接收方可以开始重组了。 (有一种网络攻击方式就是持续发送“More fragments”为1的包，导致接收方一直缓存分片，从而耗尽内存。) TCP是如何避免被发送方分片的？ TCP可以避免被发送方分片，是因为它主动把数据分成小段再交给网络层。 最大的分段大小称为MSS （Maximum Segment Size），它相当于把MTU刨去IP头和TCP头之后的大小，所以一个MSS恰好能装进一个MTU中。 MSS: 最大分段大小 (Maximum segment size) 那TCP又是怎样适配接收方的MTU的呢? TCP建立连接时,必须先进行三次握手,在前两个握手包中,双方互相声明了自己的MSS 为什么UDP比TCP更适合语音通话？ 如果把UDP和TCP想象成两位搬运工，前者的风格就是盲目苦干，搬运过程中丢了东西也不管；而后者却是小心翼翼，丢了多小的东西都要回去捡。假如某个应用环境允许忽视质量，只追求速度，那UDP就是一个更好的选择。语音传输正符合这种情况，因为它最在乎的不是音质，而是延迟 采用UDP传输时，如果有些包丢失，应用层可以选择忽略并继续传输其他包. 由于一个发音会被采样到很多个包中，所以丢掉其中一些包只是影响到了音质，却能保障流畅性。 而采用TCP传输时，出现丢包就一定要重传，重传就会带来延迟。这是TCP与生俱来的特点，即使应用层想忽略丢包都没办法。前文说过TCP的优点是可靠，有丢包重传机制，这个优点在语音传输时就变成了缺点。通话延迟的后果很严重. MTU导致的悲剧 MTU带来的问题实在太多了 如两个子网的MTU大小不一样. 当客户端发送给服务器的巨帧经过路由器时,或者被丢包,或者被分片. 这取决于该巨帧是否在网络层携带了DF(Don’t fragment)标志. 如果带了就被丢弃,如果没带就被分片. 当路径中的某个”关卡”的MTU较小时,可能出现这些问题 迎刃而解 NIC Teaming TLB: Transmit Load Balancing, 传输负载平衡 Linux下多网卡绑定模式详解 七种网卡绑定模式详解 如果说有什么工具能彻底改善工作体验,我的回答毫无疑问是Wireshark 昙花一现的协议 Fibre Channel:光纤信道 另一种流控 比特时间: 发送1比特需要的时间，这种时间单位与数据率密切相关。 quanta:512比特时间 用 暂停帧 (Pause Frame) 来缓解 拥塞 过犹不及 (TCP)连接数并非越多越好.当连接数多到足以占满整个链路时,再增加连接就没有意义了,甚至可能带来负面效果: 多个连接需要更高的资源成本. 比如连接的建立和断开,以及维护每个连接需要分配的内存,都会消耗服务器的资源, 太多连接抢占同一个链路,有可能会增加丢包率.就像用多辆车来运输货物可以加快速度一样,当车辆多到足以引发交通事故时就适得其反了. 治疗强迫症 人们处理焦虑的方式各有不同,有些人喝喝咖啡晒晒太阳就觉得岁月静好了.可惜我就做不到这一点,一定要把细节都理清楚了才能治愈,多年下来竟然也’被迫’学了不少知识. 技术与工龄 工龄的确可以累积经验,但不一定能提高多少技能. 专业知识容易补,钻研精神却很难养成 如何科学地推卸责任 TTL: Time To Live，生存时间值. 该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4报头的一个8 bit字段 一个面试建议 屋漏偏逢连夜雨,吹牛碰到老熟人 能用自己语言表达出来才算真正理解并且记住了. 写作能强迫思考,对于真正有技术含量的东西,你会在写作过程中加深理解,从此就忘不掉了;而技术含量不高的东西,你写个开头自然会停笔. 生活中的Wireshark 假宽带真相 中国的宽带服务是以下载速度为计算标准的,其实上传速度慢很多,上下行带宽严重不对等. Iperf 是一个网络性能测试工具。Iperf可以测试最大TCP和UDP带宽性能，具有多种参数和UDP特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。 网络性能测试工具iperf详细使用图文教程 手机抓包 安卓抓包测试-之tPacketcapture Network Time Protocol（NTP）: NTP服务器【Network Time Protocol（NTP）】是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。 微博为什么会卡 寻找HttpDNS 全局负载均衡（GSLB）的实现方案 谁动了我的网络 一个协议的进化 HTTP协议所导致的网络延迟才是影响上网体验的主要因素,而不是带宽. SPDY QUIC: Quick UDP Internet Connections 我为这篇文章的长度而抱歉,如果我有足够多的时间,一定会把它写得短一点. 假装产品经理 自学的窍门 在这个信息爆炸的时代,很多行业的门槛已经被网络填平了,有志者皆可跨界入门,经过努力甚至能达到专业水平 从浏览权威的百科网站开始 善用搜索引擎 2.1. 用Google2.2. 把关键词换成英文再搜: 不要怕英语不够用,开头也许是有点难,但是慢慢就能适应了.2.3. 不要忽视图片搜索的价值. 啃一本大部头: 大部头的买一本足矣,关键是要真的去读. 动手操作: 即学即用 不要收藏了文章而不去读它,那样是在浪费时间 多给新人培训: 能把一个技术讲到新手能听懂,比起自己懂就高了一层境界 兴趣主导 多参加技术圈的交流 两个项目 打造自己的分析工具 网络文件系统（Network File System，缩写作 NFS）是一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样.由Sun微系统开发，于1984年发布 NFS各个版本之间的比较 传输层是性能问题的高发区 tshark 是 Wireshark的命令行形式 创业的点子 高延迟为什么会影响性呢？因为它会造成长时间的空等：发完一个窗口的数据量后，发送方就不得不停下来等待接收方的确认。延迟越高，发送方需要等待的时间就越长 丢包对性能影响极大,可以说是网络传输的第一大忌 TCP协议拥塞控制算法（Reno、HSTCP、BIC、Vegas、Westwood）","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"Wireshark网络分析就这么简单","date":"2021-03-16T15:03:21.000Z","path":"2021/03/16/Wireshark网络分析就这么简单/","text":"初试锋芒 从一道面试题开始说起 小试牛刀: 一个简单的应用案例 Execl文件的保存过程 你一定会喜欢的技巧 . 抓包: 只抓包头 只抓必要的包 . 个性化设置: 调整时间格式 不同类型的网络包可以自定义颜色 Edit-Preferences更多设置 可设置时区与服务器一致 . 过滤: 用协议名称过滤 IP地址+Port号 用鼠标帮助过滤 可以把过滤后得到的网络包存在一个新的文件里,小文件更方便操作 . 让Wireshark自动分析 Analyze-&gt;Export Info Composite Statistics-&gt;Service Response Time Statistics-&gt;TCP Stream Graph Statistics-&gt;Summary . Ctrl + F Patrick的故事 从此我就喜欢上了Wireshark,因为它实在很有用,就像学武之人得到了一把趁手好剑 Wireshark的故事 当你透过它看到网络时，不再是没有意义的0和1，而是可以理解的简洁文字。有了它的专业解说，我们几乎能直接看懂网络上发生的一切。以前难以排查的问题，在它介入后便显露无遗。它还提供了权威的分析报告，比如重传率统计、响应时间和对话列表等，这解放了原本负担繁重的网络管理员，使他们有更多时间专注其他事务。 Gerald把这个软件命名为Ethereal，正对应了它的功能---还原以太网的真相 1234567ethereal 英[iˈθɪəriəl]美[iˈθɪriəl]adj. 优雅的; 轻飘的; 缥缈的; 超凡的;[例句]She&apos;s the prettiest, most ethereal romantic heroine in the movies.她是所有电影中最美丽、最飘逸的爱情女主角。 庖丁解牛 NFS协议的解析 20世纪80年代初，一家神奇的公司在硅谷诞生了，它就是Sun Microsystems。这个名字与太阳无关，而是源自互联网的伊甸园----Stanford University Network的首字母。在不到30年的时间里， SUN公司创造了无数传世作品。其中， Java.Solaris和基于SPARC的服务器至今还闻名遐迩。后来，人们总结SUN公司衰落的原因时，有一条竟然是技术过剩。 Network File System （NFS）协议也是SUN公司设计的。顾名思义， NFS就是网络上的文件系统。 portmap的功能是维护一张进程与端口号的对应关系表,而它自己的端口号11是众所周知的 rpcinfo命令 telnet命令 从Wireshark看网络分层 传输层: 虽然名曰”传输层”,但它并不是把网络包从一个设备传到另一个,而只是对传输行为进行控制. 真正负责设备间传输的是下面两层(即网络层和数据链路层) 分工(分层)会带来很多好处,因为每个人都可以专注自己擅长的领域,更好的服务他人. 网络对包的大小是有限制的,其最大值称为MTU,即”最大传输单元”. 知道自己的MTU容易,但对方的MTU如何获得? 在TCP建立连接(三次握手)时,双方都会把自己的MSS(Maxinum Segment Size)告诉对方. MSS加上TCP头和IP头的长度,就得到MTU了. 如MSS是8960,那MTU就是 $$8960+20(TCP头)+20(IP头)=9000$$. 如果MSS是1460,那MTU就是 $$1460+20(TCP头)+20(IP头)=1500$$. 发包的大小是由MTU较小的一方决定的 TCP的连接启蒙 nslookup命令 为什么要用三个包来建立连接呢，用两个不可以吗？其实也是可以的，但不够可靠。我们可以设想一个情况来说明这个问题：某个网络有多条路径，客户端请求建立连接的第一个包跑到一条延迟严重的路径上了，所以迟迟没有到达服务器。因此，客户端只能当作这个请求丢失了,不得不再请求一次。由于第二个请求走了正确的路径，所以很快完成工作并关闭了连接。对于客户端来说，事情似乎已经结束了。没想到它的第一个请求经过跋山涉水，还是到达了服务器。 服务器并不知道这是一个旧的无效请求，所以按照惯例回复了。假如TCP只要求两次握手，服务器上就这样建立了一个无效连接。而在三次握手的机制下，客户端收到服务器的回复时，知道这个连接不是它想要的，所以就发了一个拒绝包.服务器收到这个包后,也放弃这个连接. 其实用四次挥手来断开连接也不完全可靠,但世界上不存在100%可靠的通信机制. 两军问题与拜占庭将军问题 快递员的工作策略 ---- TCP窗口 TCP显然不用电瓶车送包，但它也有“往返”的需要。因为发包之后并不知道对方能否收到，要一直等到确认包到达，这样就花费了一个往返时间。假如每发一个包就停下来等确认，一个往返时间里就只能传一个包，这样的传输效率太低了。最快的方式应该是一口气把所有包发出去，然后一起确认。但现实中也存在一些限制：接收方的缓存（接收窗口）可能一下子接受不了这么多数据；网络的带宽也不一定足够大，一口气发太多会导致丢包事故。所以，发送方要知道接收方的接收窗口和网络这两个限制因素中哪一个更严格，然后在其限制范围内尽可能多发包。这个一口气能发送的数据量就是传说中的TCP发送窗口。 发送窗口对性能的影响有多大？在相同的往返时间里，右边比左边多发了两倍的数据量。而在真实环境中，发送窗口常常可以达到数十个MSS. . (如图)每个包的TCP层都含有”windows size:”(也就是win=)的信息. 这个值表示发送窗口的大小吗? 很多人会把接收窗口误认为发送窗口. Windows Size其实不是发送窗口,而是在向对方声明自己的接收窗口. 滑动窗口机制,说的就是这两个窗口的关系 . 我如何在包里看出发送窗口的大小呢? 很遗憾,没有简单办法,有时候甚至完全没有办法. . 发送窗口和MSS有什么关系? .发送方在一个窗口里发出n个包,是不是就能收到n个确认包? . 经常听说”TCP Window Scale”这个概念,它究竟和接收窗口有和关系? 重传的讲究 前文说到,发送方的发送窗口是受接收方的接收窗口和网络影响的,其中限制得更严的因素就起决定作用. 接收窗口的影响方式非常简单,只要在包里用”Win=”告知发送方就可以了. 而网络的影响方式非常复杂,这篇来专门介绍. 能导致网络拥塞的数据量称为拥塞点 慢启动过程 拥塞避免 超时重传 RTO 重复确认(Dup Ack) 快速重传 快速恢复 NewReno “本文的信息量有点大，你也许需要一些时间来消化它。有些部分一时理解不了也无妨，即便只记住本文导出的几个结论，在工作中也是很有用的:” 没有拥塞时，发送窗口越大，性能越好。所以在带宽没有限制的条件下，应该尽量增大接收窗口，比如启用Scale Option （Windows上可参考KB224829）. 如果经常发生拥塞，那限制发送窗口反而能提高性能，因为即便万分之一的重传对性能的影响都很大。在很多操作系统上可以通过限制接收窗口的方法来减小发送窗口， Windows上同样可以参考KB 224829 超时重传对性能影响最大，因为它有一段时间（RTO）没有传输任何数据,而且拥塞窗口会被设成1个MSS，所以要尽量避免超时重传。 快速重传对性能影响小一些，因为它没有等待时间，而且拥塞窗口减小的幅度没那么大。 SACK和NewReno有利于提高重传效率，提高传输性能。 丢包对极小文件的影响比大文件严重。因为读写一个小文件需要的包数很少，所以丢包时往往凑不满3个Dup Ack，只能等待超时重传了。而大文件有较大可能触发快速重传。下面的实验显示了同样的丢包率对大小文件的不同影响：图11中的test是包含很多小文件的目录，而图12的hi是一个大文件。发生丢包时前者耗时增加了7倍多，而后者只增加了不到4倍。 延迟确认与Nagle算法 这种方式其实是很低效的,因为一个包的TCP头和IP头至少就40字节,而携带的数据却只有一个字符.这就像快递员开着大货车去送一个小包裹一样浪费. 延迟确认并没有直接提高性能,它只是减少了部分确认包,减轻了网络负担. 和延迟确认一样,Nagle也没有直接提高性能,启用它的作用只是提高传输效率,减轻网络负担. 百家争鸣 慢启动算法 拥塞避免算法 Westwood: 在经常发生非拥塞性丢包的环境中(比如无线网络),Westwood最能体现出气优势 Vegas: 独辟蹊径,通过监控网络状态来调整发包速度,从而实现真正的”拥塞避免” 与别的算法相比， Vegas就像一位敏感、稳重、谦让的君子。我们可以想象当环境中所有发送方都使用Vegas时，总体传输情况是更稳定、更高效的，因为几乎没有丢包会发生。而当环境中存在Vegas和其他算法时，使用Vegas的发送方可能是性能最差的，因为它最早探测到网络繁忙，然后主动降低了自己的传输速度。这一让步可能就释放了网络的压力，从而避免其他发送方遭遇丢包。这个情况有点像开车，如果路上每位司机的车品都很好，谦让守规矩，则整体交通状况良好；而如果一位车品很好的司机跟一群车品很差的司机一起开车，则可能被频繁加塞，最后成了开得最慢的一个。 简单的代价 ---- UDP . UDP不像TCP一样在乎双方MTU的大小。 它拿到应用层的数据之后，直接打上UDP头就交给下一层了。那么超过MTU的时候怎么办？在这种情况下，发送方的网络层负责分片，接收方收到分片后再组装起来，这个过程会消耗资源，降低性能。一个32 KB的写操作，可能会根据发送方的MTU被切成23个分片。 . UDP没有重传机制，所以丢包由应用层来处理。如某个写操作需要6个包完成。当基于UDP的写操作中有一个包丢失时，客户端不得不重传整个写操作（6个包）。相比之下，基于TCP的写操作就好很多，只要重传丢失的那1个包即可。 . 分片机制存在弱点，会成为黑客的攻击目标。 接收方之所以知道什么时候该把分片组装起来，是因为每个包里都有“More fragments”的flag. 1表示后续还有分片， 0则表示这是最后一个分片，可以组装了。如果黑客持续快速地发送flag为1的UDP包，接收方一直无法把这些包组装起来，就有可能耗尽内存。 剖析CIFS协议 “前文介绍过一个文件共享协议，即Sun设计的NFS。理论上NFS可以应用在任何操作系统上，但因为历史原因，现实中只在Linux/UNIX上流行。那Windows上一般使用什么共享协议呢？它就是微软维护的SMB协议，也叫Common InternetFile System （CIFS）. CIFS协议有三版本： SMB， SMB2和SMB3， 目前SMB和SMB2比较普遍。” 网络江湖 Linux和Windows上的共享协议之争 NFS vs CIFS DNS小科普 A (Address）记录: 从域名解析到IP地址。 PTR记录：与A记录的功能相反，它能从IP地址解析到域名。PTR有什么作用呢？比如IT部门发现最近公司里的机器10.32.106.47和YouTube 之间数据流量很大，用nslookup一查PTR记录就知道原来是阿满在上班时间偷看视频了 SRV记录：Windows的域管理员要特别关心SRV记录，因为它指向域里的资源。比如我想知道我们公司的域nas.com里有哪些DC，只要随便在一台电脑上查询＿ldap._tcp.dc._msdcs.nas.com这个SRV记录就可以了。如果你也想查贵司的DC，请把nas.com改成正确域名即可。 CNAME记录：又称为Alias记录，就是别名的意思。比如我的服务器 10.32.106.73同时提供网页（www）、邮件（mail）和地图（map）服务。那直接把10.32.106.73配给mail和map可以吗？当然是可以的，但如果某天 要改变这个IP地址，就不得不在DNS上修改www、mail和map这3项记录了。 而在使用别名的情况下，只要修改www一项的IP就行了，mail和map都没有必要改动。别名的使用节省了管理时间，站长们应该会喜欢这个功能。 递归查询 迭代查询 DNS的缺点: 就像雕牌洗衣粉被周佳牌模仿一样，DNS上也存在山寨域名。比如招商银行 的域名是www.cmbchina.com，但是www.cmbchina.com.cn和www.cmbchina.cn 却不一定属于招行。如果这两个域名被指向外表和招行一样的钓鱼网站，就可能会骗到部分用户的银行账号和密码。 如果DNS服务器被恶意修改也是很危险的事情。比如登录招行网站时虽然 用了正确域名www.cmbchina.com，但由于DNS服务器是黑客控制的，很可能解析到一个钓鱼网站的IP 即便是配了正规的DNS服务器，也是有可能中招的。比如正规的DNS服务器遭遇缓冲投毒- 之后，也会变得不可信。 NS除了能用来欺骗，还能当做攻击性武器。著名的DNS放大攻击就很让人头疼。利用这个放大效应,黑客只要控制少量电脑就能把一个大网站拖垮了. 一个古老的协议 ---- FTP FTP是用明文传输的,如果对安全要求非常高,就不能采用这种方式 主动模式与被动模式 上网的学问 —- HTTP This is for everyone #london2012 #oneweb #openingceremony @webfoundation @w3c&mdash; Tim Berners-Lee (@timberners_lee) July 27, 2012 This is for everyone 英国人不但借此传播了开放和分享的互联网精神，也展示了其在IT历史上的地位----从奠定现代计算机基础的 Alan Turing，到发明分组交换的 Donald Davies，再到万维网之父 Tim Berners—Lee，每一个重大环节都有英国人的参与。 Tim所实现的HTTP便是我们今天浏览网页所用的网络协议。他当年建立的网站至今还能访问，域名为http：/info.crm.ch，虽然这个页面已经更新过，但我们还可以在http//www3.org/Histor/1992110—ypertexthypertext/wwW/News/9201.html看到当年的内容。 解密https的包: Edit-&gt;Preferences-&gt;Protocol-&gt;SSL-&gt;RSA key list. 解密所用的密钥只能在服务器端导出 无懈可击的Kerberos ‘在古希腊神话中，冥界的大门由一头烈犬看守。此犬长有三个头，兢兢业业地守在冥河边，从没有灵魂能在它醒着的时候逃离。这头烈犬就是Kerberos，安全守卫的象征。古希腊人下葬时要放好蜜饼，就是为了讨好它。现代游戏里也有它的英姿，比如《英雄无敌》里以一敌多的地狱烈犬。 这篇要介绍的身份认证协议也叫Kerberos，它有着非常广泛的应用，比如Windows域环境的身份认证就会用到它。我们用域账号登录电脑，就在不知不觉间完成了一次Kerberos认证过程。 Kerberos的认证结果是双向的----当账号A访问资源B时，不但B要确保A并非冒充，而且A也要查明B不是假货。我们一般只知道前者，比如前文提到的CIFS服务器就要在Session Setup中对造访者验明正身。后者则很少被提及，因为人们一般不会怀疑自己要访问的资源是假的。其实后者还是很有必要的，举一个例子：如果你老板伪造了一台网络打印机，但是你没法确认它的真假，就可能把求职信打到他办公室里去，然后就真的得出去求职了。西游记中其实也出现需要相互认证的场景，比如如来佛祖要认出假冒的访问者六耳猕猴，唐僧师徒也要识别山寨的“资源”小雷音寺。 双向认证的方式不止一种，最简单的做法是互报密码。这个过程就像电影中用暗号接头。A说： “江南风光好”， B说： “遍地红花开”。如果双方都核对无误，就可以激动地握手“同志，我可找到你了！”假如其中一方报错暗号，则接头失败。这种方式的弊端很多，最大的问题是不方便管理。比如在一个数百名员工共享几百台机器的环境中，当新加入一名员工时，就得在几百台机器上更新账号信息。相信没有管理员能忍受这样的环境。’ TCP/IP的故事 一开始这两个协议并没有分层,而是合在一起 TCP/IP的设计非常成功。30年来，底层的带宽、延时，还有介质都发生了翻天覆地的变化，顶层也多了不少应用，但TCP/IP却安如泰山。它不但战胜了国际标准化组织的OSI七层模型，而且目前还看不到被其他方案取代的可能。第一代从事TCP/IP工作的工程师，到了退休年龄也在做着朝阳产业。令人费解的是，现在的大学课程还在介绍OSI七层模型。因为OSI模型的层数太多，很多学生根本理解不了，甚至连顺序都记不住。于是老师们就用“All People Seem To Need Data Processing”来帮助记忆，因为这7个单词的首字母和OSI模型每一层的首字母是一样的。大学的应试教育由此可见一斑。 ‘到今天,OSI模型几乎名存实亡了,它对我们的影响只停留在还没来得及更新的教科书上’ 可能是唯一篇无关技术的RFC: rfc2468 -I REMEMBER IANA 举重若轻 “一小时内给你答复” NAT(Network Address Translation) Life is tough,but Wireshark makes it easy. 午夜铃声 乱序导致了重传,从而影响了性能 真的和探案一样… 深藏功与名 一般存储设备都是读比写快 一般存储端的带宽大，客户端的带宽小。读文件时数据从大带宽进入小带宽，就如同大河水流入小河，有可能会溢出（表现在网络上就是拥塞）而导致性能问题。写文件时方向相反，所以拥塞概率低，性能就会好一些 棋逢对手 NFS网络锁管理器（NLM） 学无止境 ➜ ~ tshark -h: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106TShark (Wireshark) 2.4.3 (v2.4.3-0-g368ba1e)Dump and analyze network traffic.See https://www.wireshark.org for more information.Usage: tshark [options] ...Capture interface: -i &lt;interface&gt; name or idx of interface (def: first non-loopback) -f &lt;capture filter&gt; packet filter in libpcap filter syntax -s &lt;snaplen&gt; packet snapshot length (def: appropriate maximum) -p don't capture in promiscuous mode -I capture in monitor mode, if available -B &lt;buffer size&gt; size of kernel buffer (def: 2MB) -y &lt;link type&gt; link layer type (def: first appropriate) -D print list of interfaces and exit -L print list of link-layer types of iface and exitCapture stop conditions: -c &lt;packet count&gt; stop after n packets (def: infinite) -a &lt;autostop cond.&gt; ... duration:NUM - stop after NUM seconds filesize:NUM - stop this file after NUM KB files:NUM - stop after NUM filesCapture output: -b &lt;ringbuffer opt.&gt; ... duration:NUM - switch to next file after NUM secs filesize:NUM - switch to next file after NUM KB files:NUM - ringbuffer: replace after NUM filesInput file: -r &lt;infile&gt; set the filename to read from (- to read from stdin)Processing: -2 perform a two-pass analysis -M &lt;packet count&gt; perform session auto reset -R &lt;read filter&gt; packet Read filter in Wireshark display filter syntax (requires -2) -Y &lt;display filter&gt; packet displaY filter in Wireshark display filter syntax -n disable all name resolutions (def: all enabled) -N &lt;name resolve flags&gt; enable specific name resolution(s): \"mnNtCd\" -d &lt;layer_type&gt;==&lt;selector&gt;,&lt;decode_as_protocol&gt; ... \"Decode As\", see the man page for details Example: tcp.port==8888,http -H &lt;hosts file&gt; read a list of entries from a hosts file, which will then be written to a capture file. (Implies -W n) --enable-protocol &lt;proto_name&gt; enable dissection of proto_name --disable-protocol &lt;proto_name&gt; disable dissection of proto_name --enable-heuristic &lt;short_name&gt; enable dissection of heuristic protocol --disable-heuristic &lt;short_name&gt; disable dissection of heuristic protocolOutput: -w &lt;outfile|-&gt; write packets to a pcap-format file named \"outfile\" (or to the standard output for \"-\") -C &lt;config profile&gt; start with specified configuration profile -F &lt;output file type&gt; set the output file type, default is pcapng an empty \"-F\" option will list the file types -V add output of packet tree (Packet Details) -O &lt;protocols&gt; Only show packet details of these protocols, comma separated -P print packet summary even when writing to a file -S &lt;separator&gt; the line separator to print between packets -x add output of hex and ASCII dump (Packet Bytes) -T pdml|ps|psml|json|jsonraw|ek|tabs|text|fields|? format of text output (def: text) -j &lt;protocolfilter&gt; protocols layers filter if -T ek|pdml|json selected (e.g. \"ip ip.flags text\", filter does not expand child nodes, unless child is specified also in the filter) -J &lt;protocolfilter&gt; top level protocol filter if -T ek|pdml|json selected (e.g. \"http tcp\", filter which expands all child nodes) -e &lt;field&gt; field to print if -Tfields selected (e.g. tcp.port, _ws.col.Info) this option can be repeated to print multiple fields -E&lt;fieldsoption&gt;=&lt;value&gt; set options for output when -Tfields selected: bom=y|n print a UTF-8 BOM header=y|n switch headers on and off separator=/t|/s|&lt;char&gt; select tab, space, printable character as separator occurrence=f|l|a print first, last or all occurrences of each field aggregator=,|/s|&lt;char&gt; select comma, space, printable character as aggregator quote=d|s|n select double, single, no quotes for values -t a|ad|d|dd|e|r|u|ud|? output format of time stamps (def: r: rel. to first) -u s|hms output format of seconds (def: s: seconds) -l flush standard output after each packet -q be more quiet on stdout (e.g. when using statistics) -Q only log true errors to stderr (quieter than -q) -g enable group read access on the output file(s) -W n Save extra information in the file, if supported. n = write network address resolution information -X &lt;key&gt;:&lt;value&gt; eXtension options, see the man page for details -U tap_name PDUs export mode, see the man page for details -z &lt;statistics&gt; various statistics, see the man page for details --capture-comment &lt;comment&gt; add a capture comment to the newly created output file (only for pcapng) --export-objects &lt;protocol&gt;,&lt;destdir&gt; save exported objects for a protocol to a directory named \"destdir\"Miscellaneous: -h display this help and exit -v display version info and exit -o &lt;name&gt;:&lt;value&gt; ... override preference setting -K &lt;keytab&gt; keytab file to use for kerberos decryption -G [report] dump one of several available reports and exit default report=\"fields\" use \"-G help\" for more help 一个技术男的自白 关于技术,当下的热点是Full Stack Engineer,翻译过来就是全栈工程师.我的理解就是从前端到后端,从软件到硬件都懂的通才.其实在全栈的概念出现之前,关于技术广度和深度的讨论就从来没有停止过. 在时间有限的情况下,究竟是应该扩展广度,各种技术都去涉猎,还是把所有精力都投入在一门技术上呢? 我个人更倾向于后者,因为当某项技术学到了较深的程度后,眼界就不样了, 再学其他的技术也容易达到类似境界. .. 假如一个人连最擅长的技术都浅尝辄止,那学习其他技术也会停留在表面上. .. 技术深度和广度的关系,就像登山时的高度和视野．假如你爬到半山腰就停下来眺望,就只能看到一半的视野；但如果埋头爬到山顶,一抬头便是无边的风风景 私有笔记","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"实用工具汇总","date":"2021-03-11T11:43:58.000Z","path":"2021/03/11/实用工具汇总/","text":"Cockpit: Linux 服务器的 Web 控制台 对于Ubuntu系统: sudo apt-get install cockpit 其他Linux发行版的安装方法 使用: 机器的ip:9090 需先配置一下服务器的安全组 还可能会出现浏览器安全级别过高,而出现警告,以FireFox为例:(也可直接点击接受风险并继续) 可参考此修改方法 -2 用户名和密码与服务器用户名和密码相同 Linux管理工具Cockpit安装及使用 gping， 带图形界面的ping命令 Install 💿 Usage 🎷 cargo install gping lazykube, k8s 终端可视化管理器 brew install tnk-studio/tools/lazykube duf, 磁盘空间占用统计工具 Broot, 比ls更强大的命令行目录树浏览工具 brew install broot broot vs, Google搜索词关联关系图谱 cloc, 代码行数统计工具 可以用于压缩文件（如zip tar等），包括空行和特殊字符的处理与统计，生成多种格式的结果。安装简单且轻量，对于阅读源码，分析项目代码的场景非常实用。 brew install cloc Git quick statistics, 针对Git 仓库的命令行统计工具 brew install git-quick-stats git quick-stats 我还曾配置过两个alias 12gcount='git shortlog -sn'sn='git shortlog -sn' 在某个Git仓库下,执行sn,就可以得到该仓库的提交者及提交记录数 EnvPane - 图形终端形式查看环境变量 Cocoa Rest Client, 类似 Postman 但更简洁 Sloth, lsof 命令的图形界面 Mac 系统的桌面应用，显示当前所有正在运行的进程、打开的文件和系统连接（socket），基本上就是 lsof 命令的图形界面。 brew install --cask sloth Marp, 将 Markdown 文档转成幻灯片 RCT 一个通过解析 rdb 文件对 redis 内存结构分析的一站式平台 Pock 把 Mac 电脑的 Dock 放到 TouchBar 的工具 Toch Bar废物利用系列 Convert images to LaTeX 将 数学公式 OCR 转为 LaTex 代码的桌面软件 Motrix 一款桌面端下载工具，支持下载 HTTP、FTP、BT、磁力链、百度网盘等资源。 git_curate 当项目 Git 仓库有很多分支，忘记了哪些分支有用哪些没有，而不敢贸然删除，这个工具可以显示每个分支的详细情况，以及是否已经合并了，帮助判断是否应该删除这个分支 ModHeader Chrome插件,可以自定义HTTP请求头或者是重写响应头 Rooster for Chrome Chrome插件,可以实时展示访问时间统计图表,类似 Web Timer git icdiff 更好用的 git diff brew install icdiff 可以配置下别名 vim ~/.zshrc 1alias diff='git icdiff' source ~/.zshrc diff gum 一个命令行的 Git 用户管理器，适合需要不同身份，向不同仓库提交代码的情况。 Git 多用户配置 BookmarkHub 一个浏览器插件，可以跨浏览器进行书签同步，数据存储在 GitHub Gist ojoy 一个网页图像工具，可以放大图片的同时，还保持同样的清晰度。","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"一不留神就掉坑","date":"2021-03-01T12:18:38.000Z","path":"2021/03/01/一不留神就掉坑/","text":"乘除顺序问题 在据卡特兰数公式,解决leetcode-96 不同的二叉搜索树时,遇到一个非常诡异的问题, 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; for i := 0; i &lt;= 40; i++ &#123; fmt.Printf(\"第%d个卡特兰数为:%d\\n\", i, numTrees(i)) &#125;&#125;func numTrees(n int) int &#123; rs := 1 for i := 0; i &lt; n; i++ &#123; rs = rs * 2 * (2*i + 1) / (i + 2) //rs *= 2 * (2*i + 1) / (i + 2) &#125; return rs&#125; 即 注释掉的这一行,居然和上一行得出了完全不同的结果. 虽然马上解决,但对固有认知影响巨大---难道对一直以来习以为常的乘法语法糖理解有误??? *= 为乘法和赋值运算符，它将右操作数与左操作数相乘，并将结果赋给左操作数. C *= A 相当于 C = C * A 读了一遍感觉没问题,那原因出在哪里呢? 构建demo, 12345678910111213141516package mainimport \"fmt\"func main() &#123; rs1 := 2 rs2 := 2 i := 3 fmt.Println(\"当前的rs1,rs2为:\", rs1, rs2) fmt.Println(\"2 * (2*i + 1) / (i + 2)为:\", 2*(2*i+1)/(i+2)) rs1 = rs1 * 2 * (2*i + 1) / (i + 2) rs2 *= 2 * (2*i + 1) / (i + 2) fmt.Println(\"最后rs1 is,rs2 is:\", rs1, rs2)&#125; 结果为 123当前的rs1,rs2为: 2 22 * (2*i + 1) / (i + 2)为: 2最后rs1 is,rs2 is: 5 4 初步判断,问题出在除法这里. 去掉除法部分后,确实得到的结果都一样. 在数学中 乘除运算不分先后. 但因为可能无法整除，对计算机来说，除不尽的部分会一律向下取整。所以乘除的先后顺序，实际是对最终结果有影响的 对于 rs1,其等于 2 * 2 * 7 / 5,即28/5,向下取整,即为5 对于rs2, 会先计算后面部分2 * (2*3 + 1) / (3 + 2) = 14/5 = 2, 而后计算 2*2 = 4 crontab配置问题 Linux自带的crontab只能精确到分钟,而某些语言的工具包,可以提供精确到秒的crontab. 但在使用时,务必注意,如0 */10 * * * *,是从下一个 xx:x0:00 开始,每10分钟执行一次. 如写成 * */10 * * * *, 就成了每秒钟执行一次,如有对数据库的读写操作,会造成巨大压力. 上线前可以用这个工具, 选Java(Spring)项,来校验一下 map和slice变量的赋值作用范围问题 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; m := make(map[string]string) m[\"gender\"] = \"女\" fmt.Println(\"map is:\", m) f1(&amp;m) fmt.Println(\"map is:\", m)&#125;func f1(m1 *map[string]string) *map[string]string &#123; (*m1)[\"name\"] = \"dashen\" (*m1)[\"gender\"] = \"男\" return m1&#125; 运行结果: 12map is: map[gender:女]map is: map[gender:男 name:dashen] 但这种写法,非常不Golang! 在函数A中定义一个map记为m,想要在函数B,函数C中对其进行赋值或修改,是没有必要传指针的 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; m := make(map[string]string) m[\"gender\"] = \"女\" fmt.Println(\"map is:\", m) f1(m) fmt.Println(\"map is:\", m)&#125;func f1(m1 map[string]string) map[string]string &#123; m1[\"name\"] = \"dashen\" m1[\"gender\"] = \"男\" return m1&#125; 运行结果: 12map is: map[gender:女]map is: map[gender:男 name:dashen] 对于slice,情况有所不同 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; sli := make([]string, 1) sli[0] = \"宋江\" fmt.Println(\"slice is:\", sli) f1(sli) fmt.Println(\"slice is:\", sli)&#125;func f1(sli1 []string) []string &#123; sli1[0] = \"晁盖\" return sli1&#125; 运行结果: 12slice is: [宋江]slice is: [晁盖] 与map的”全部引用”不同,slice只是底层数组是指针类型,长度和容量不是. 对于上面这样只修改原有值,而没有append操作的行为,是没有问题的. 但如果有append操作,引发了扩容,底层数组的地址变了,则将会得不到预期结果 sql的update问题 update一条不存在的记录,Affected rows为0,但并不会报错 UPDATE a SETname=&quot;卡拉马佐夫兄弟&quot; WHERE id=12345 update一条存在的记录,但实际并没有对现有内容进行更新,Affected rows也会是0 Golang 58个坑","tags":[{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"性能分析工具","date":"2021-03-01T11:45:56.000Z","path":"2021/03/01/性能分析工具/","text":"关于profiling(性能分析，或特征分析与实践追踪) go性能分析工具–profiling 123456789profiling英[ˈprəʊfaɪlɪŋ]美[ˈproʊfaɪlɪŋ]n. (有关人或事物的)资料搜集;v. 扼要介绍; 概述; 写简介;[词典] profile的现在分词;[例句]You need to provide only two special profiling functions.您只需要提供两个特殊的分析函数即可。 profiling这词比较难翻译,有译成画像,我将其译为资料收集、剖析研究, 用于对程序指标或特征的分析，很多软件中都内置或有第三方的profiling工具，如Linux(比较知名的如Perf)，MySQL，JAVA，Go等。 如 以MySQL为例：1. 开启profiling参数set profiling=1;2. 执行Query语句select * from products where id &lt; 1003. 获取系统中保存的所有Query的profile概要信息show profiles;4. 针对单个Query获取详细的profile信息SELECT * FROM information_schema.profiling WHERE query_id = 3 ORDER BY seq;MySQL之profiling性能分析（在5.6.14版本被丢弃） 在Go中，最常使用pprof(及其内置的火焰图)进行特征分析，使用trace进行事件追踪 pprof 更擅长去查看程序效率，比如查看谁占用内存时间长，谁的协程阻塞了等等trace 则是程序在运行期间的信息追踪，通过可视化的方式来查看这期间程序到底做了什么，以及了解 GC 对程序的影响等等这两套工具配合起来，更快发现问题，解决问题 推荐 Golang 性能分析工具简要介绍 pprof pprof是Google推出的分析工具，该工具在Go安装时已存在。并且Go 1.10之后的版本，pprof工具直接支持火焰图 Go 1.10 的pprof的工具将直接支持火焰图 其使用方式有两种，一种是通过net/http/pprof，在http中收集样本，另一种是和、用runtime/pprof，直接在代码需要分析的位置嵌入分析函数 详细使用方式可参考 煎鱼-Golang 大杀器之性能剖析 PProf 获取程序在30s内占用CPU的情况：curl http://IP:port/debug/pprof/profile?seconds=30 -o profile_cui.out 获取所有协程堆栈信息：curl http://IP:port/debug/pprof/groutine -o groutine_cui.out 获取堆内存使用情况： curl -o heap_cui.out http://IP:port/debug/pprof/heap 堆内存分析 命令行交互形式 curl http://IP:port/debug/pprof/heap -o heap_cui.out 而后 go tool pprof heap_cui.out (或直接两条命令合二为一 go tool pprof http://IP:port/debug/pprof/heap) 默认类型为inuse_space,代表去分析正在使用的内存 heap.out可以显示4种不同类型： alloc_objects, alloc_space, inuse_objects, inuse_space其中alloc_objects和inuse_objects分别代表已被分配的对象和正在使用的对象的数量，前者是累计值，不考虑对象释放的情况。默认分析inuse_space类型，但要切换分析的类型也很简单, 如想分析alloc_objects情况，只需要输入alloc_objects并回车即可 交互命令有很多，可通过help查看:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(pprof) help Commands: callgrind Outputs a graph in callgrind format comments Output all profile comments disasm Output assembly listings annotated with samples dot Outputs a graph in DOT format eog Visualize graph through eog evince Visualize graph through evince gif Outputs a graph image in GIF format gv Visualize graph through gv kcachegrind Visualize report in KCachegrind list Output annotated source for functions matching regexp pdf Outputs a graph in PDF format peek Output callers/callees of functions matching regexp png Outputs a graph image in PNG format proto Outputs the profile in compressed protobuf format ps Outputs a graph in PS format raw Outputs a text representation of the raw profile svg Outputs a graph in SVG format tags Outputs all tags in the profile text Outputs top entries in text form top Outputs top entries in text form topproto Outputs top entries in compressed protobuf format traces Outputs all profile samples in text form tree Outputs a text rendering of call graph web Visualize graph through web browser weblist Display annotated source in a web browser o/options List options and their current values q/quit/exit/^D Exit pprof Options: call_tree Create a context-sensitive call tree compact_labels Show minimal headers divide_by Ratio to divide all samples before visualization drop_negative Ignore negative differences edgefraction Hide edges below &lt;f&gt;*total focus Restricts to samples going through a node matching regexp hide Skips nodes matching regexp ignore Skips paths going through any nodes matching regexp intel_syntax Show assembly in Intel syntax mean Average sample value over first value (count) nodecount Max number of nodes to show nodefraction Hide nodes below &lt;f&gt;*total noinlines Ignore inlines. normalize Scales profile based on the base profile. output Output filename for file-based outputs prune_from Drops any functions below the matched frame. relative_percentages Show percentages relative to focused subgraph sample_index Sample value to report (0-based index or name) show Only show nodes matching regexp show_from Drops functions above the highest matched frame. source_path Search path for source files tagfocus Restricts to samples with tags in range or matched by regexp taghide Skip tags matching this regexp tagignore Discard samples with tags in range or matched by regexp tagshow Only consider tags matching this regexp trim Honor nodefraction/edgefraction/nodecount defaults trim_path Path to trim from source paths before search unit Measurement units to display Option groups (only set one per group): granularity functions Aggregate at the function level. filefunctions Aggregate at the function level. files Aggregate at the file level. lines Aggregate at the source code line level. addresses Aggregate at the address level. sort cum Sort entries based on cumulative weight flat Sort entries based on own weight : Clear focus/ignore/hide/tagfocus/tagignore type \"help &lt;cmd|option&gt;\" for more information 比较常用的有以下命令： top： 会以flat列从大到小的顺序排序。flat代表当前函数统计的值。inuse_space模式下，就是当前函数分配的堆区正在使用的内存大小； cum则是一个累积的概念，指当前函数及其调用的一系列函数flat的和。flat只包含当前函数的栈帧信息，不包括其调用函数的。cum字段正好可以弥补这一点。 flat%和cum%分别表示flat和cum字段占总字段的百分比。 可以使用 top -cum，根据cum进行排序； 可使用list 函数名称列出函数信息; 可使用tree打印出函数的调用链 可视化形式 在安装graphviz的前提下，可以的命令行中输出web，即可在浏览器中展示 或直接通过 go tool pprof --http :9091 heap_cui.out 选择 Top，则如上命令行 可以点击Cum或Flat进行排序 点击 Graph，则即默认的调用图 其中： 节点颜色： 红色代表累计值cum为正，且很大 绿色代表累计值cum为负，且很大 灰色代表累计值cum可忽略不计 节点字体大小： 较大的字体表示较大的当前值 较小的字体表示较小的当前值 边框颜色： 当前值较大并且为正数时为红色 当前值较小并且为负数时为绿色 当前值接近0时为灰色 箭头大小： 箭头越粗代表当前的路径消耗了越多的资源 箭头越细代表当前的路径消耗了越少的资源 箭头线型： 虚线箭头表示两个节点之间的某些节点已被忽略，为间接调用 实线箭头表示两个节点之间为直接调用 点击 Flame Graph，则为火焰图 可点击进行放大 最上方的root框代表整个程序的开始，其他框都代表一个函数 火焰图每一层的函数都是平级的，下层函数是其对应的上层函数的子函数 函数调用栈越长，火焰就越高 框越长，颜色越深，代表当前函数占用CPU时间越久 可单击任何框，查看该函数更详细的信息 点击 Peek，则为函数调用关系 点击 Source，则为对应的源码文件 点击 Disassemble，则为总的内存数 可点击SAMPLE切换要分析的类型 协程栈分析 除 堆内存分析，协程栈分析也使用较多。 分析协程栈有两方面作用： 查看协程数量，看协程是否泄露 查看当前大量的协程在执行哪些函数，判断当前协程是否健康 引入net/http/pprof，然后启一个goroutine来监听端口 123456789101112131415161718192021222324package mainimport ( \"log\" \"net/http\" _ \"net/http/pprof\" \"time\")func main() &#123; go func() &#123; log.Println(http.ListenAndServe(\":6060\", nil)) &#125;() a := make(chan int) for &#123; time.Sleep(time.Second) go func() &#123; &lt;-a &#125;() &#125;&#125; 运行以上代码，同时 go tool pprof http://localhost:6060/debug/pprof/goroutine 当前协程有33个，大部分都在runtime.gopark函数中(gopark是协程休眠函数) 通过tree查看函数调用链，发现协程阻塞，是调用runtime.chanrecv函数以表明通道正在等待接收导致 同样可以使用web命令，在浏览器查看调用关系： 也可以使用 go tool pprof --http :9091 pprof.goroutine.001.pb.gz,可视化查看各种信息 base基准分析 除了查看协程栈帧数据，goroutine profile 还可用来排查协程泄露。 通过对比协程的总数，可以大概评估出程序是否陷入泄露状态。 pprof提供了强大的工具，用来对比前后特征文件的区别。 下面使用-base标志，后面跟两个基准特征文件: 同样支持web指令 mutex堵塞分析 和block类似，mutex主要用于查看锁争用导致的休眠时间。有助于排查锁争用导致的CPU利用率不足问题(不经常使用) 12345678910111213141516171819202122232425262728package mainimport ( \"log\" \"net/http\" _ \"net/http/pprof\" \"runtime\" \"sync\")func main() &#123; go func() &#123; log.Println(http.ListenAndServe(\":6060\", nil)) &#125;() var mu sync.Mutex var items = make(map[int]struct&#123;&#125;) runtime.SetMutexProfileFraction(5) for i := 0; i &lt; 1000000*1000000; i++ &#123; go func(i int) &#123; mu.Lock() defer mu.Unlock() items[i] = struct&#123;&#125;&#123;&#125; &#125;(i) &#125;&#125; 运行以上代码，同时 go tool pprof http://localhost:6060/debug/pprof/mutex 同样支持web指令 CPU分析 获取程序在30s内占用CPU的情况：curl http://IP:port/debug/pprof/profile?seconds=30 -o profile_cui.out 或 go tool pprof http://localhost:6060/debug/pprof/profile?second=30 火焰图分析 参见上面内容 trace 在pprof分析中，可以知道一段时间CPU占用、内存分配、协程堆栈信息。这些消息都是一段时间内数据的汇总，但并没有提供整个周期内发生的事件，如 指定的goroutine何时执行、执行了多长时间、什么时刻陷入了阻塞、什么时刻解除了阻塞、GC如何影响单个goroutine的执行、STW中断花费的时间是否太长等。 Go 1.5之后推出了trace工具，提供了指定时间内程序发生的事件的完整信息，包括： 协程的创建、开始和结束 协程的阻塞---系统调用、通道、锁 网络I/O相关事件 系统调用事件 垃圾回收相关事件 (源码在runtime/trace.go) 收集trace文件的方式和收集pprof特征文件差不多，都有两种方式 详细使用方式可参考 煎鱼-Golang 大杀器之跟踪剖析 trace 收集： curl http://IP:port/debug/pprof/trace?seconds=30 -o trace_cui.out 分析： go tool trace trace_cui.out 之后会自动打开浏览器： View trace 其中最复杂，信息最丰富的是第一个 View trace 选项，显示整个执行周期的完整事件 时间线：可使用如下快捷键浏览时间轴 w快捷键可以放大图像 s快捷键可以缩小图像 a快捷键可以左移图像 d快捷键可以右移图像 Goroutines：显示每个时间点正在运行的goroutine数量，及可运行(等待调度)的goroutine数量。存在大量可运行的goroutine，可能表明调度器繁忙。 堆: 显示执行期间的内存分配情况，对于查找内存泄露及检查每次runtime GC释放的内存很有用处。 操作系统线程： 显示正在使用的操作系统线程及被系统调用阻塞的线程数 显示每个逻辑处理器 显示协程和事件，表明协程何时开始，何时结束，以及结束的原因 w放大，选中某一位置： Title: 协程的名字 Start: 协程开始的事件 Wall Duration: 协程持续时间 Start Stack Trace: 协程开始时的栈追踪 End Stack Trace: 协程结束时的栈追踪 Event(s): 协程产生的事件信息 Goroutine analysis选项 点击一处进入详情，可看到每个goroutine的id，以及执行时间，网络等待时间，因同步而锁定的时间，因系统调用锁定的时间，调度等待时间，GC清扫时间，GC暂停时间 之后的四处profile选项 都是一个调用关系及时间图 Network blocking profile选项: 用调用关系图展示网络阻塞的情况 Synchronization blocking profile 选项: 同步阻塞耗时情况，使用调用关系图来展示 Syscall blocking profile选项: 系统调用阻塞耗时情况，使用调用关系图来展示 Scheduler latency profile 选项: 调度器延迟耗时情况，使用调用关系图来展示 User-defined tasks、User-defined regions 用户自定义 trace 的 tasks/用户自定义 trace 的 region Go 1.11 版本中引入的特性，trace 可以添加我们自定义的内容，用来快速跟踪想要看到的代码块的耗时点 Minimum mutator utilization 用一个曲线图来展示 GC 对程序的影响情况，可以用来分析和判断是否要对 GC 做优化 大约1.2ms后,程序才获得到 cpu 使用(在这之前GC 做了 STW) 。 如果曲线随着时间增加依然不高，说明 GC 负担比较重，占用更多系统资源，这个时候需对 GC 做优化 曲线图右侧的几个选项： System：整个系统的利用率 Per-goroutine：每一个协程的利用率 STW：Stop the word，表示所有协程同时暂停，在做 GC 的时，是会 STW Background workers：GC 的协程，会消耗 25% 的利用率，在 GC 的时候，会以后台方式执行 Mark assist：GC 要减慢内存分配速度时，会分配 goroutine 来做标记 Sweep：回收在 GC 之间未使用的内存 Show percentiles：除了最基本数据外，还显示 mutator 利用率的百分比 trace 使用场景 分析延迟问题 如某个接口预期200ms执行完，但却用了2s。 当程序中重要的协程长时间无法运行，可能带来延迟问题。协程长时间无法得到执行，可能因为系统调用被阻塞，通道/互斥锁上被阻塞，协程运行时代码(如GC)阻塞。这些都可以通过trace来查看。 诊断不良并行性 如预期使用全部CPU，使用trace后发现，只有一个CPU在跑~ 关于trace，还可参考 go trace 剖析 go1.14 异步抢占式调度 更多参考： Go调优神器trace介绍 Tony Bai - 通过实例理解Go Execution Tracer 性能调优 - trace 其他第三方profiling工具： 鸟窝-[译]使用 bcc/BPF 分析 go 程序 鸟窝-[译] Go 可视化性能分析工具 鸟窝-调试利器：dump goroutine 的 stacktrace 文中部分工具已经out… Go官方博客: Diagnostics (这里认为Profiling和Tracing是同级。我这里把Profiling看成是Tracing的上一级） Profiling Go Programs Go pprof官方文档 部分译文： 译文 Go 高性能系列教程之二：性能评估和分析 译文 Go 性能工具小抄 原创分享 Go 高性能系列教程：读懂 pprof 生成的报告 更多可参考： 奇伢-全面的整理：golang 调试分析的高阶技巧 曹大-Go 应用优化指北 曹大-pprof 和火焰图 鸟窝-[译]Go性能分析工具工具和手段 性能分析方法论 李文周的博客 使用 pprof 和火焰图调试 golang 应用 Golang -CPU 性能、内存分析调试方法汇总 golang pprof 的使用调试 cpu，heap，gc,逃逸 go tool 可选的那些参数","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"卡特兰数","date":"2021-02-28T08:27:10.000Z","path":"2021/02/28/卡特兰数/","text":"可以记住 概念 卡特兰数 的通项公式为 $$f \\left( n \\right) = \\frac{1}{n+1} C_{2n}^{n}$$ 又根据 组合数的计算公式: 可得: $$f \\left(n \\right) = \\frac{1}{n+1} \\frac{(2n)!}{n!\\cdot n!} = \\frac{(2n)!}{(n+1)!\\cdot n!} $$ 同时满足递推关系式: $$f \\left(0 \\right) = 1, f \\left(n+1 \\right) = \\frac{2(2n+1)}{n+2} \\cdot f \\left(n \\right) $$ 应用 1.括号化问题（或者01的个数问题） 矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种) 2.出栈次序问题 一个栈(无穷大)的进栈序列为1,2,3,…n,有多少个不同的出栈序列? 与 问题1解法相同, 进栈相当于左括号,出栈相当于右括号 另两个类似例子: (1)有2n个人排成一行进入剧场（或者商店买东西）。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈) 还是与1类似,5块钱相当于左括号,10块钱相当于右括号 (2)在圆上选择2n个点,将这些点成对连接起来，使得所得到的n条线段不相交的方法数。 3.凸多边形问题 （1）一个凸的n边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案。 (2)类似：一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那 么有多少条可能的道路？ (3)类似：在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数?例如n+2个点的凸多边形，这里n=4，通过卡特兰数的推导可以得出h(4)=14。 4.给定节点组成二叉树的问题 给定N个节点，能构成多少种形状不同的二叉树？ 先取一个点作为顶点,然后左边依次可以取0至N-1个,相对应的,右边是N-1到0个,两两配对相乘,就是h(0)*h(n-1) + h(2)*h(n-2) +…+ h(n-1)h(0)=h(n)（能构成h(N)个） leetcode-96 不同的二叉搜索树 5.n*n棋盘从左下角走到右上角而不穿过主对角线的走法 a.在 nn的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？其实向右走相当于进栈， 向左走相当于出栈，本质就是n个数出栈次序的问题，所以答案就是卡特兰数。（利用这个模型，可以解决这个卡特兰问题的变形问题，并顺便给进出栈问题的解法一个几何解释） b.有n+1个叶子的满二叉树的个数？事实上，向左记为+1，向右记为−1，按照向左优先的原则，从根节点开始遍历．例如第一个图记为+1,+1,+1,−1,−1,−1,于是由卡特兰数的含义可得满二叉树的个数为Cn。 参考: 卡特兰(Catalan)数概念的简要介绍 史上最详细的卡特兰数浅谈 卡特兰数的证明 LeetCode 96之卡特兰数 卡特兰数/概率/蓄水池抽样","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"汇编语言入门","date":"2021-02-26T09:02:53.000Z","path":"2021/02/26/汇编语言入门/","text":"我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。 Intel的指令：汇编 is so easy 12345678910111213141516171819mov rax, 0x1 // rax = 1 (把一个16进制的1值赋给rax)add rax, 11 // rax = rax + 11 （将rax寄存器中的值+11）sub rax,1 // rax = rax - 1(带0x的是16进制，像11是十进制)// 在寄存器之间搬数据mov rax, rbx // rax = rbx （用rbx的值，去覆盖rax的值）// 在寄存器和内存之间搬数据mov rax, [rbx] // 把 rbx 寄存器的值看作一个地址，把该物理地址的值取出，然后赋值给 rax，即 rax = *rbx// 在内存之间搬数据- 你想多了，不可以的push rax =&gt; 将 rax 的值存储到栈顶，并将 rsp 上移 8 个字节pop rax =&gt; 将 rsp 指向的内存位置的 8 个字节移动到 rax，并将 rsp 从栈顶下移 8 个字节jmp addr =&gt; 跳转到指定地址 函数 or 过程 函数调用在汇编上的本质： 12jmp 跳进去jmp 跳回来 cpu 很傻，跳回来的时候我必须到当前过程的下一条指令位置，难道我还需要在被调用过程里知道调用者的过程下一条指令位置？ 12call =&gt; push pc; jmp to callee addr;ret =&gt; pop pc; 所以高级编程语言函数调用的基础 要点，在栈上记录下一条指令位置，即我们常说的 return address，理解成路标就行。在执行完被调用函数的时候，顺着路标回去继续向下走。 Intel CPU上栈是从高地址向低地址增长的 rbp：函数栈的栈底 rsp：栈的栈顶 16个通用寄存器 1234567891011121314151617rax = 0x0000000001053940 rbx = 0x0000000000000000 rcx = 0x000000c000000300 rdx = 0x00000000010750c0 rdi = 0x0000000000000000 rsi = 0x0000000000000001 rbp = 0x000000c0000427d0 rsp = 0x000000c000042790 r8 = 0x7fffffffffffffff r9 = 0xffffffffffffffff r10 = 0x00000000010c0478 r11 = 0x0000000000000202 r12 = 0x0000000000203000 r13 = 0x0000000000000000 r14 = 0x0000000000000178 r15 = 0x0000000000000004 rip = 0x000000000105394f 前6个主要用于参数传递 rip存指令地址 对于Plan9 汇编，寄存器有如下差别： 123rax -&gt; AXrbx -&gt; BXr8 -&gt; R8 使用汇编知识 在plan9中，常数要用$开头，表示数字 可以使用objdump查看intel指令的反汇编结果 但是如果有 NOSPLIT 这个 flag，则可以忽略参数和返回值占用的空间，就像上述这个例子，只有一个$8 。表示 frame size 只有 8 字节大小。这从汇编中也能看出来 MOVQ CX, 0(SP) ,因为 MOVQ 表示这个操作的操作对象是 8 字节的 MOV 指令有有好几种后缀 MOVB MOVW MOVL MOVQ 分别对应的是 1 字节 、2 字节 、4 字节、8 字节 Plan 9 汇编语言 伪寄存器伪寄存器不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针。 FP, Frame Pointer：帧指针，参数和本地 PC, Program Counter: 程序计数器，跳转和分支 SB, Static Base: 静态基指针, 全局符号 SP, Stack Pointer: 当前栈帧开始的地方 所有用户定义的符号都作为偏移量写入伪寄存器 FP 和 SB。 汇编代码中需要表示用户定义的符号(变量)时，可以通过 SP 与偏移还有变量名的组合，比如x-8(SP) ，因为 SP 指向的是栈顶，所以偏移值都是负的，x则表示变量名 SB, Static Base: 静态基地址寄存器 NOSPLIT和go://nosplit一样，确信栈空间够用，不用再检查是否需要栈扩充了~ 汇编文件.s与 .go在一个文件夹下即可，不用名称相同. 使用go build就能构建出来 如 例1： 实现一个简单的 a+ba.go 123456789package mainimport \"fmt\"func add(a, b int) int // 汇编函数声明func main() &#123; fmt.Println(add(10, 11))&#125; 123456789#include \"textflag.h\"// func add(a, b int) intTEXT ·add(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX // 参数 a MOVQ b+8(FP), BX // 参数 b ADDQ BX, AX // AX += BX MOVQ AX, ret+16(FP) // 返回 RET “你能解释这里为什么是 $0-24 吗？” 12345678TEXT ·IndexString(SB),NOSPLIT,$0-40 MOVQ a_base+0(FP), DI MOVQ a_len+8(FP), DX MOVQ b_base+16(FP), R8 MOVQ b_len+24(FP), AX MOVQ DI, R10 LEAQ ret+32(FP), R11 JMP indexbody&lt;&gt;(SB) // 无条件跳转 之 跳转到标签，可以跳转到同一函数内的标签位置，https://segmentfault.com/a/1190000039978109， https://github.com/golang/arch/blob/master/x86/x86.csv 挨个拆解： 函数的声明以TEXT标识开头，以${package}·${function}为函数名。 如果函数属于本package，通常可以不写${package}，只留·${function}即可。 (为什么要叫 TEXT ？如果对程序数据在文件中和内存中的分段稍有了解的同学应该知道，我们的代码在二进制文件中，是存储在 .text 段中的，这里也就是一种约定俗成的起名方式) $0表示该函数栈大小为0byte，计算栈大小时，需要考虑局部变量和本函数内调用其他函数时，需要传参的空间，不含函数返回地址和CALLER BP。 $40表示该函数入参和返回值一共有40byte。当有NOSPLIT标识时，可以不写输入参数、返回值占用的大小。 func IndexString(a, b string) int入参为两个string，返回值为int。 因为string占16个byte，int占8个字节(int占8个，int32占4个，int64占8个)，可参考 利用反射,探究Go语言中的数据类型,故而是$40 全局变量声明 &lt;&gt;表示该变量只在该文件内全局可见 地址运算也是用 lea 指令，英文原意为Load Effective Address，amd64 平台地址都是8个字节，所以直接就用LEAQ就好： index_amd64.s 12345678910111213AX: length of string, that we are searching forDX: length of string, in which we are searchingDI: pointer to string, in which we are searchingR8: pointer to string, that we are searching forR11: address, where to put return valueNote: We want len in DX and AX, because PCMPESTRI implicitly consumes themAX：我们要搜索的字符串长度DX：字符串的长度，我们在其中搜索DI：指向字符串的指针，我们在其中搜索R8：指向字符串的指针，我们正在搜索R11：地址，返回值放在哪里注意：我们需要 DX 和 AX 中的 len，因为 PCMPESTRI 隐式消耗它们 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249// AX: length of string, that we are searching for// DX: length of string, in which we are searching// DI: pointer to string, in which we are searching// R8: pointer to string, that we are searching for// R11: address, where to put return value// Note: We want len in DX and AX, because PCMPESTRI implicitly consumes themTEXT indexbody&lt;&gt;(SB),NOSPLIT,$0 CMPQ AX, DX JA fail CMPQ DX, $16 JAE sse42no_sse42: //SSE 4.2为Intel指令集，https://zh.wikipedia.org/wiki/SSE4， https://baike.baidu.com/item/SSE%204.2/138412 CMPQ AX, $2 JA _3_or_more MOVW (R8), R8 LEAQ -1(DI)(DX*1), DXloop2: MOVW (DI), SI CMPW SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop2 JMP fail_3_or_more: CMPQ AX, $3 JA _4_or_more MOVW 1(R8), BX MOVW (R8), R8 LEAQ -2(DI)(DX*1), DXloop3: MOVW (DI), SI CMPW SI,R8 JZ partial_success3 ADDQ $1,DI CMPQ DI,DX JB loop3 JMP failpartial_success3: MOVW 1(DI), SI CMPW SI,BX JZ success // 有条件跳转 JZ target, 如果 zero flag 被 set 过，则跳转 ADDQ $1,DI CMPQ DI,DX JB loop3 JMP fail_4_or_more: CMPQ AX, $4 JA _5_or_more MOVL (R8), R8 LEAQ -3(DI)(DX*1), DXloop4: MOVL (DI), SI CMPL SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop4 JMP fail_5_or_more: CMPQ AX, $7 JA _8_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVL -4(R8)(AX*1), BX MOVL (R8), R8loop5to7: MOVL (DI), SI CMPL SI,R8 JZ partial_success5to7 ADDQ $1,DI CMPQ DI,DX JB loop5to7 JMP failpartial_success5to7: MOVL -4(AX)(DI*1), SI CMPL SI,BX JZ success ADDQ $1,DI CMPQ DI,DX JB loop5to7 JMP fail_8_or_more: CMPQ AX, $8 JA _9_or_more MOVQ (R8), R8 LEAQ -7(DI)(DX*1), DXloop8: MOVQ (DI), SI CMPQ SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop8 JMP fail_9_or_more: CMPQ AX, $15 JA _16_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVQ -8(R8)(AX*1), BX MOVQ (R8), R8loop9to15: MOVQ (DI), SI CMPQ SI,R8 JZ partial_success9to15 ADDQ $1,DI CMPQ DI,DX JB loop9to15 JMP failpartial_success9to15: MOVQ -8(AX)(DI*1), SI CMPQ SI,BX JZ success ADDQ $1,DI CMPQ DI,DX JB loop9to15 JMP fail_16_or_more: CMPQ AX, $16 JA _17_or_more MOVOU (R8), X1 LEAQ -15(DI)(DX*1), DXloop16: MOVOU (DI), X2 PCMPEQB X1, X2 PMOVMSKB X2, SI CMPQ SI, $0xffff JE success ADDQ $1,DI CMPQ DI,DX JB loop16 JMP fail_17_or_more: CMPQ AX, $31 JA _32_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVOU -16(R8)(AX*1), X0 MOVOU (R8), X1loop17to31: MOVOU (DI), X2 PCMPEQB X1,X2 PMOVMSKB X2, SI CMPQ SI, $0xffff JE partial_success17to31 ADDQ $1,DI CMPQ DI,DX JB loop17to31 JMP failpartial_success17to31: MOVOU -16(AX)(DI*1), X3 PCMPEQB X0, X3 PMOVMSKB X3, SI CMPQ SI, $0xffff JE success ADDQ $1,DI CMPQ DI,DX JB loop17to31 JMP fail// We can get here only when AVX2 is enabled and cutoff for indexShortStr is set to 63// So no need to check cpuid_32_or_more: CMPQ AX, $32 JA _33_to_63 VMOVDQU (R8), Y1 LEAQ -31(DI)(DX*1), DXloop32: VMOVDQU (DI), Y2 VPCMPEQB Y1, Y2, Y3 VPMOVMSKB Y3, SI CMPL SI, $0xffffffff JE success_avx2 ADDQ $1,DI CMPQ DI,DX JB loop32 JMP fail_avx2_33_to_63: LEAQ 1(DI)(DX*1), DX SUBQ AX, DX VMOVDQU -32(R8)(AX*1), Y0 VMOVDQU (R8), Y1loop33to63: VMOVDQU (DI), Y2 VPCMPEQB Y1, Y2, Y3 VPMOVMSKB Y3, SI CMPL SI, $0xffffffff JE partial_success33to63 ADDQ $1,DI CMPQ DI,DX JB loop33to63 JMP fail_avx2partial_success33to63: VMOVDQU -32(AX)(DI*1), Y3 VPCMPEQB Y0, Y3, Y4 VPMOVMSKB Y4, SI CMPL SI, $0xffffffff JE success_avx2 ADDQ $1,DI CMPQ DI,DX JB loop33to63fail_avx2: VZEROUPPERfail: MOVQ $-1, (R11) RETsuccess_avx2: VZEROUPPER JMP successsse42: CMPB internal∕cpu·X86+const_offsetX86HasSSE42(SB), $1 JNE no_sse42 CMPQ AX, $12 // PCMPESTRI is slower than normal compare, // so using it makes sense only if we advance 4+ bytes per compare // This value was determined experimentally and is the ~same // on Nehalem (first with SSE42) and Haswell. JAE _9_or_more LEAQ 16(R8), SI TESTW $0xff0, SI JEQ no_sse42 MOVOU (R8), X1 LEAQ -15(DI)(DX*1), SI MOVQ $16, R9 SUBQ AX, R9 // We advance by 16-len(sep) each iteration, so precalculate it into R9loop_sse42: // 0x0c means: unsigned byte compare (bits 0,1 are 00) // for equality (bits 2,3 are 11) // result is not masked or inverted (bits 4,5 are 00) // and corresponds to first matching byte (bit 6 is 0) PCMPESTRI $0x0c, (DI), X1 // CX == 16 means no match, // CX &gt; R9 means partial match at the end of the string, // otherwise sep is at offset CX from X1 start CMPQ CX, R9 JBE sse42_success ADDQ R9, DI CMPQ DI, SI JB loop_sse42 PCMPESTRI $0x0c, -1(SI), X1 CMPQ CX, R9 JA fail LEAQ -1(SI), DIsse42_success: ADDQ CX, DIsuccess: SUBQ R10, DI MOVQ DI, (R11) RET 12345678// 无条件跳转JMP addr // 跳转到地址，地址可为代码中的地址，不过实际上手写不会出现这种东西JMP label // 跳转到标签，可以跳转到同一函数内的标签位置JMP 2(PC) // 以当前指令为基础，向前/后跳转 x 行JMP -2(PC) // 同上// 有条件跳转JZ target // 如果 zero flag 被 set 过，则跳转 肝了一上午的Golang之Plan9入门golang 汇编A Quick Guide to Go’s Assemblergo/build学习 Golang 的 Plan 9 汇编plan9 assembly 完全解析golang/arch 相关图片,NOSPLIT,$0+CMPQ+AX,+DX+JA+f&amp;sa=X&amp;ved=2ahUKEwjWztmLx4DzAhWhwjgGHRIZAc0QjJkEegQIIhAC&amp;biw=1775&amp;bih=1218) golang内核系列–深入理解plan9汇编&amp;实践 cch123/asmshare Go语言高级编程 GO汇编-函数 golang内核系列–深入理解plan9汇编&amp;实践 汇编语言入门教程 图文讲解：Go 中的循环是如何转为汇编的？ 曹春晖：谈一谈 Go 和 Syscall [译]go 和 plan9 汇编 指示叶子函数不进行栈分裂","tags":[{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"hexo中插入数学公式","date":"2021-02-21T13:54:09.000Z","path":"2021/02/21/hexo中插入数学公式/","text":"在 海明校验码 这篇博文中,涉及到许多数学公式的插入.原生的Markdown对此支持不够好,但可借助插件,实现 LaTex 那样的效果. 一般常用的是 mathjax 和 katex 安装 步骤如下: yarn add hexo-math (注: 此时node_module会重新初始化,原来对里面文件做的改动会丢失,如我对图片的魔改) 在全局的 _config.yml 文件中,添加 123456math: engine: 'mathjax' # or 'katex' mathjax: # src: custom_mathjax_source config: # MathJax config 在主题文件夹的 _config.yml中,添加(或覆盖为)如下内容 12345# MathJax Supportmathjax: enable: true #true/false. per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 另外,将 node_modules/hexo-math/index.js文件中, 与katex相关的两行注释掉(因为使用了mathjax,没有用katex) 否则,在构建时,会出现如下报错 使用 当公式不独占一行时: $数学公式$ 独占一行时: $$数学公式$$ 常用语法可参考 Latex/MathJax/Katex数学公式手册 如在 海明校验码 中, $D_7$ 用 $D_7$来表示,即_表示下标 $2^{i-1}$ 用 $2^{i-1}$来表示, 即^表示指数, 指数位置的加减写在{}内 几个不错的在线公式编辑器: LaTeX公式编辑器 在线LaTeX 公式编辑器 参考: hexo中插入数学公式 结合MathType和MathJax在Hexo博客中插入数学公式 MathJax 数学符号以及公式在 Markdown 中的运用 KaTeX数学公式整理 修复Hexo写Mathjax公式多个下标失效的问题","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"CRC算法原理","date":"2021-02-17T06:17:46.000Z","path":"2021/02/17/CRC算法原理/","text":"循环冗余校验码 (Cyclic Redundancy Check, CRC) ，简称循环码，是一种常用的、具有检错、纠错能力的校验码，在早期的通信中运用广泛。循环冗余校验码常用于外存储器和计算机同步通信的数据校验。 奇偶校验码(Parity Check, PC) 和 海明校验码(Hamming Check, HC) 都是采用奇偶检测为手段检错和纠错的(奇偶校验码不具有纠错能力)，而循环冗余校验则是通过某种数学运算来建立数据位和校验位的约定关系的。 12345678910111213141516Cyclicadj. 环的；循环的；周期的cyclic: 循环的cyclic voltammetry: 循环伏安法cyclic loading: 循环荷载Redundancyn. [计][数] 冗余（等于redundance）；裁员；人浮于事Redundancy: 冗余redundancy payment: 裁员支出redundancy package: 遣散超额员工计划 循环冗余校验码（CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生r个校验位来进行编码，其编码长度为k+r。 循环冗余校验码是由两部分组成的，左边为信息码（数据），右边为校验码。若信息码占k位，则校验码就占n-k位。其中，n为CRC码的字长，所以又称为 (n，k)码 。校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。在求CRC编码时，采用的是模2运算。 CRC码的生成步骤 精简版如下: 1、将x的最高幂次为R的生成多项式G(x)转换成对应的R+1位二进制数。 2、将信息码左移R位，相当于对应的信息多项式C(x)*2R 3、用生成多项式（二进制数）对信息码做模2除，得到R位的余数。 4、拼接，将余数拼到信息码左移后空出的位置，得到完整的CRC码。 左移: 如xxxxxx&lt;&lt;2即左移2位,右边空出的位用0填补，高位左移溢出则舍弃该高位 这里正体现了“循环” 实例 参考: [CRC校验]手算与直观演示 原码、反码、补码与位运算 循环冗余校验码例题 软考-CRC检验码计算 计算机组成与体系结构考点总结","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"海明校验码","date":"2021-02-15T08:30:11.000Z","path":"2021/02/15/海明校验码/","text":"二进制数据在 传送、存取等环节，可能会发生 误码(1变成0或0变成1). 如何发现并纠正 误码? 解决此类问题的思路是在原始数据(数码位)基础上增加几位校验位。常使用的检验码有三种. 分别是 奇偶校验码、海明校验码和循环冗余校验码(CRC) 其中 奇偶校验码 只能查是否有错误而无法纠错，且要求只能有一位出现错误。 为了能找到发生错误的位置，而有了 海明校验码 实际上本质来说, 海明码是升级款的奇偶校验码,其采用了一种非常巧妙的方式,把这串数字(即要传输的内容)分了组,通过分组校验来确定哪一位出现了错误类似KMP算法,描述起来很麻烦,实际上使用起来却很简单“海明”也被译为”汉明” 实例 数据位为8的数据$D_7D_6D_5D_4D_3D_2D_1D_0=01101001$,求海明码 1.计算校验位的个数 设数据位为n位，校验位P为k位，则n和k必须满足以下关系： $$2^k - 1 ≥ n + k$$ 此例中有 $2^k - 1 ≥ 8 + k$，可得k最小应为4，即 16 - 1 ≥ 8 + 4。 (奇偶校验称为 Parity Check,Parity Bit即奇偶校验位,故用P表示校验位) 2.计算校验位的位置 2.1 海明码的总位数 设校验位为P,数据位为D,海明码为H,则海明码H的位数为数据的位数和校验码的位数相加, 在此即为 8+4 = 12 位 2.2 校验码的位置 校验位P 在海明码的第$2^{i-1}$位，即$H_j = P_i，j=2^{i-1}$，i从1开始计数。 无论是海明码、校验位还是数据位，均从右向左排列，即从低位向高位排列。 可先填入校验码的位置，再将数据位依次从低位到高位填入 如此例,i即为 1,2,3,4, 故有: 3.确定每个数据位 都由哪些校验码进行校验 根据 $2^{i-1}$ 的公式,可知$P_4、P_3、P_2、P_1$的下标分别为8、4、2、1 确定$D_0-D_7$每个数据位都是由哪些校验码(P)进行校验的 数据位D的下标,等于其校验位的下标之和 4.计算校验码的值 校验码的值 为有参与校验的数据依次从低到高异或的值。 (异或:相同为0,相异为1) 因为 $D_7D_6D_5D_4D_3D_2D_1D_0=01101001$ $P_1$参与了$D_0、D_1、D_3、D_4、D_6$等数据位的校验。$P_2$参与了$D_0、D_2、D_3、D_5、D_6$等数据位的校验。$P_3$参与了$D_1、D_2、D_3、D_7$等数据位的校验。$P_4$参与了$D_4、D_5、D_6、D_7$等数据位的校验。所以：（$D_7D_6D_5D_4D_3D_2D_1D_0=01101001$）$$P_1 = D_0⊕D_1⊕D_3⊕D_4⊕D_6 = 1⊕0⊕1⊕0⊕1 = 1$$$$P_2 = D_0⊕D_2⊕D_3⊕D_5⊕D_6 = 1⊕0⊕1⊕1⊕1 = 0$$$$P_3 = D_1⊕D_2⊕D_3⊕D_7 = 0⊕0⊕1⊕0 = 1$$$$P_4 = D_4⊕D_5⊕D_6⊕D_7 = 0⊕1⊕1⊕0 = 0$$ 5.错误校验 确定错误校验$G_4G_3G_2G_1$，校验码有几位，错误校验就有几位。如果采用偶校验则结果全为0时没有错误，如果采用奇校验则结果全为1时没有错误$$G_1 = P_1D_0⊕D_1⊕D_3⊕D_4⊕D_6 = 1⊕1⊕0⊕1⊕0⊕1 = 0$$$$G_2 = P_2D_0、D_2、D_3、D_5、D_6 = 0⊕1⊕0⊕1⊕1⊕1 = 0$$$$G_3 = P_3D_1、D_2、D_3、D_7 = 1⊕0⊕0⊕1⊕0 = 0$$$$G_4 = P_4D_4、D_5、D_6、D_7 = 0⊕0⊕1⊕1⊕0 = 0$$ 则$G_4G_3G_2G_1 = 00004$，表示没有异常。假如结果为0100则转为十进制为8，表示第八位存在异常。 海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定于某些被校位的数据，当被校数据出错时，可根据校验位的值的变化找到出错位，从而纠正错误。对于32位的数据，至少需要增加（ ）个校验位才能构成海明码。 以10位数据为例，其海明码表示为 D（0≤i≤9）表示数据位，P（1 ≤j≤4）表示校验位，数据位D由（ ）进行校验。 参考: 软考笔记–海明码 简单理解海明校验码 hamming code通俗易懂的解释 软考-计算机系统知识之海明码 白话——海明校验码及编码过程 理解海明校验法 【软考】校验码之详细总结 软考-海明码-单位错-冗余位数","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"git:一些撤销操作","date":"2021-02-07T11:43:43.000Z","path":"2021/02/07/git-一些撤销操作/","text":"如何撤销 Git 操作？ 一、撤销提交 git revert HEAD 撤销上次提交. (会在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化,所有记录都会保留) 二、撤销某次merge git merge --abort 三、替换上一次提交 git commit --amend -m &quot;新的提交信息&quot; 可以修改上一次的提交信息 四、从暂存区撤销文件 如果不小心使用了git add命令, 把一个文件本不想添加到暂存区的文件加到了暂存区，可用下面的命令撤销 git rm --cached [filename] 更多: Git的撤销和回滚命令总结 恢复GIT不同区域的修改","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"故乡，只在审美中","date":"2021-02-06T12:18:24.000Z","path":"2021/02/06/故乡，只在审美中/","text":"作者: 石扉客 “母亲织布的机子和父亲坐着的老椅子，奶奶拧麻绳的的拨架和那一棵撂粗瓷黄碗，老屋木梁上吊着的蜘蛛残网以及这老宅古屋所散发的气息，都使他潜藏心底的那种悠远的记忆重新复活。尤其是中午那顿臊子面的味道，那是任何高师名厨都做不出来的。只有架着麦秸棉征柴禾的大铁锅才能煮烹出这种味道。” 这是陈忠实描述的一次回乡感受，主角是已晋升为保安团长的白孝文。白团长带着新婚媳妇，骑着高头大马，回到白鹿原故乡祭祖。 这是文学与传统里的故乡。 张季鹰在洛，见秋风起，思吴中莼菜羹、鲈鱼脍，曰：“人生贵得适意尔，何能羁宦数千里以要名爵!”，于是辞官回江南。 余杰访问瑞典，城堡上俯瞰北欧大地绿茵如画，忍不住感叹：“此地风景大好，叹无回锅肉！”于是回国。 去年10月，我在这里写下一篇《昨夜寒蛩不住鸣》，思念故乡的霉豆腐、剁辣椒，于是埋头继续码字。 这是长在胃上的故乡。 1980年代的流行歌曲《我的故乡并不美》，旋律铿锵，节奏古怪，借冒犯传统中那个美丽的故乡意象，将那个时代既盛极一时又远不够彻底的反思气氛推到极致。 互联网初起时的BBS时代里，70后才子王怡引领，天涯社区那一波网友们竞相同题撰文《每一个人的故乡都在沦陷》。 这是在传统社会的农业文明和现代文明之间痛苦反省，三步一徘徊的故乡。 我总在想第二代甚至第三代农民工孩子眼里的故乡是什么样？他们生长于都市，其中的大部分不得不回到从无印象的故乡，以准备迎接高中生活和高考。 我还在想东莞性服务行业里的姑娘们眼里的故乡是什么样？都市丛林里，她们也许是最不喜欢谈论故乡的人。常人回乡，是近乡情怯。她们总是要努力将故乡和熟人彻底赶出日常生活图景。 这是在现实煎熬中的故乡。 社交工具陌陌在文宣中预言“中国在进步，个体信任必将要过渡到社会信任，社会信任包含了对城市文明和陌生人的信任，相信与陌生人的互动是平和与无害的。” 我认同这种判断。问题是我们所处的这个时代，既未挣脱农业文明的襁褓，工业化还在进程中，现代化又远未完成。我们就是这个前不着村后不着店时代里的一群尴尬人。既留恋故乡的温情与乡情，又无法远离城市的资源与文明。 在这里，故乡，只是一种纯粹的审美，是一种精神存在，一个文化符号。 白孝文确实也只呆了三天。祭祖完毕准备打道回府的白团长清醒地发现，他的故乡也回不去了： “这些复活的情愫仅仅只能引发怀旧的兴致，却根本不想重新再去领受，恰如一只红冠如血尾翎如帜的公鸡发现了曾经哺育自己的那只蛋壳，却再也无法重新蜷卧其中体验那蛋壳里头的全部美妙了，它还是更喜欢跳上墙头跃上柴禾垛顶引颈鸣唱。”","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"实用插件汇总","date":"2021-02-06T07:01:24.000Z","path":"2021/02/06/实用插件汇总/","text":"https://github.com/zhaoolee/ChromeAppHeroes","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"操作系统中的算法/策略","date":"2021-02-04T13:30:02.000Z","path":"2021/02/04/操作系统中的算法-策略/","text":"OS中的几种进程调度算法 大厂面试爱问的“调度算法”，20 张图一举拿下 页面置换算法 页面置换算法 磁盘调度算法 四种常用的磁盘调度算法 Linux的I/O调度算法","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"Legends of the Condor Heroes","date":"2021-01-31T03:11:25.000Z","path":"2021/01/31/Legends-of-the-Condor-Heroes/","text":"07 比武招亲 1234He stopped before an inn,hunger gnawing at hist stomach.(郭靖)来到一家大酒店之前，腹中饥饿 gnawing adj. (长时间)折磨人的，令人痛苦的，使人苦恼的;v. 咬; 啃; 啮; gnaw的现在分词; [例句]The dog was gnawing a bone.那狗在啃骨头。 123flatbread n. 大饼，扁面包; 123456steppes 英[stɛps]美[stɛps]n. (尤指东南欧及西伯利亚树少的)大草原，干草原;[词典] steppe的复数;[例句]She was hardened by the rigours of the Siberian steppes西伯利亚大草原的艰苦环境使她变得坚强起来。 12345678taunt 英[tɔːnt]美[tɔːnt]v. 辱骂; 嘲笑; 讽刺; 奚落;n. 嘲笑(或讽刺、奚落等)的言辞;[例句]He was thick-skinned enough to cope with her taunts.他脸皮厚，不怕她嘲弄。[其他] 第三人称单数：taunts 现在分词：taunting 过去式：taunted 过去分词：taunted 123456gaunt 英[ɡɔːnt]美[ɡɔːnt]adj. (常因疾病、饥饿或忧虑而)瘦削憔悴的; 寒碜的; 破败的;[例句]Above on the hillside was a large, gaunt, grey house.山坡上有幢难看的灰色大房子。 123456789blemished 英[ˈblemɪʃt]美[ˈblemɪʃt]adj. 有污点的; 有瑕疵的; 有疤痕的;v. 破坏…的完美; 玷污;[词典] blemish的过去分词和过去式;[例句]The pianist&apos;s performance was blemished by several wrong notes.钢琴家的演奏由于弹错了几个音符而使人感到美中不足。 12345678fist 英[fɪst]美[fɪst]n. 拳; 拳头;vt. 紧握; 握成拳; 用拳打;[例句]He put his fist through a glass door.他把拳头伸进了玻璃门。 12345678disgusting英[dɪsˈɡʌstɪŋ]美[dɪsˈɡʌstɪŋ]adj. 极糟的; 令人不快的; 令人厌恶的; 令人气愤的;v. 使作呕; 使厌恶; 使反感;[词典] disgust的现在分词;[例句]The kitchen was in a disgusting state when she left.她离开时厨房里一片狼藉。 123mutt 英[mʌt]美[mʌt]n. 狗; 杂种狗; 1234567proceed 英[prəˈsiːd]美[proʊˈsiːd]v. 继续做(或从事、进行); 接着做; 继而做; 行进; 前往;[例句]She sold her car and bought a piano with the proceeds.她卖掉了汽车，然后用这笔收入买了一架钢琴。[其他] 第三人称单数：proceeds 现在分词：proceeding 过去式：proceeded 过去分词：proceeded 12345678filthy 英[ˈfɪlθi]美[ˈfɪlθi]adj. 肮脏的; 污秽的; 下流的; 淫秽的; 猥亵的; 气愤的;adv. 极其肮脏的; 富得流油的;[例句]He looked around the filthy room in distaste.他厌恶地环顾着这肮脏的房间。[其他] 比较级：filthier 最高级：filthiest 123456tableware 英[ˈteɪblweə(r)]美[ˈteɪblwer]n. (商店用语)餐具;[例句]Their range of tableware is decorated with a blackberry design他们的整套餐具上都饰有黑莓图案。 123456palate 英[ˈpælət]美[ˈpælət]n. 腭; 上腭; 味觉; 品尝力;[例句]It was a meal to tempt even the most jaded palate.这顿饭能使最没胃口的人产生食欲。 123456perfumed 英[ˈpɜːfjuːmd]美[ˈpɜːrfjuːmd]adj. (水果、酒等)芬芳的; 芳香的; 有香味的;v. 使香气弥漫; 在…上撒香水; 抹香水;[词典] perfume的过去分词和过去式; 123456moist 英[mɔɪst]美[mɔɪst]adj. 微湿的; 湿润的;[例句]Strawberries grow best in a cool, moist climate.草莓最适于在凉爽、潮湿的气候条件下生长。 周伯通 1234567hostage 英[ˈhɒstɪdʒ]美[ˈhɑːstɪdʒ]n. 人质;[例句]Three children were taken hostage during the bank robbery.在银行抢劫案中有三名儿童被扣为人质。[其他] 复数：hostages 12345678tame 英[teɪm]美[teɪm]adj. 养驯的; 驯服的; 平淡无奇的; 枯燥乏味的; 听使唤的; 温顺的;v. 驯化; 驯服; 使易于控制;[例句]The deer never became tame; they would run away if you approached them.那些鹿一直没有被驯服：你一靠近，它们就跑开。[其他] 比较级：tamer 最高级：tamest 第三人称单数：tames 现在分词：taming 过去式：tamed 过去分词：tamed 12345678encounter 英[ɪnˈkaʊntə(r)]美[ɪnˈkaʊntər]v. 遭遇，遇到(尤指令人不快或困难的事); 偶然碰到; 意外地遇见; 与…邂逅;n. (意外、突然或暴力的)相遇，邂逅，遭遇，冲突; (体育)比赛，交锋;[例句]You&apos;ll have little patience with the hypocrisy and double standards you encounter.你将会无法忍受所遭遇的伪善和双重标准。[其他] 第三人称单数：encounters 复数：encounters 现在分词：encountering 过去式：encountered 过去分词：encountered 123456789intrigued 英[ɪnˈtriːɡd]美[ɪnˈtriːɡd]adj. 着迷; 很感兴趣; 好奇;v. 激起…的兴趣; 引发…的好奇心; 秘密策划(加害他人); 密谋;[词典] intrigue的过去分词和过去式;[例句]I&apos;m intrigued to know what you thought of the movie.我很想知道你对这部电影的看法。 12345678teasing 英[ˈtiːzɪŋ]美[ˈtiːzɪŋ]adj. (表情、神态)调侃的，戏谑的，开玩笑的;v. 取笑; 戏弄; 揶揄; 寻开心; 招惹，逗弄(动物); 挑逗，撩拨(异性);[词典] tease的现在分词;[例句]Don&apos;t get upset ─ I was only teasing.别不高兴，我只是在逗你玩。 123456789foul 英[faʊl]美[faʊl]adj. 肮脏恶臭的; 难闻的; 很令人不快的; 很坏的; 充满脏话的; 辱骂性的; 下流的;v. 对(对手)犯规; 击(球)出界; (通常用废物)弄脏，污染;n. 犯规;[例句]The house was filled with foul odor.房间里充满了难闻的气味。[其他] 比较级：fouler 最高级：foulest 第三人称单数：fouls 复数：fouls 现在分词：fouling 过去式：fouled 过去分词：fouled 12345678rein 英[reɪn]美[reɪn]n. 缰绳; (幼儿佩戴以防走失的)保护带; 控制; 主宰; 掌管;v. 控制; 驾驭; 勒住;[例句]The government would try to rein back inflation.政府将努力控制通货膨胀。[其他] 第三人称单数：reins 复数：reins 现在分词：reining 过去式：reined 过去分词：reined 08 各显神通 12345extent 英[ɪkˈstent]美[ɪkˈstent]n. 程度; 限度; 大小; 面积; 范围; 1234567duel 英[ˈdjuːəl]美[ˈduːəl]n. 决斗; (双方的)竞争，斗争;v. 使（另一人）参加决斗; 反对; 参加正式决斗;[其他] 第三人称单数：duels 复数：duels 现在分词：duelling 过去式：duelled 过去分词：duelled 123456undeterred英[ˌʌndɪˈtɜːd]美[ˌʌndɪˈtɜːrd]adj. 顽强的; 坚毅的; 不屈不挠的;[例句]Yet the government and people of Pakistan are undeterred.巴基斯坦政府和人民没有退却。 1234567slippery 英[ˈslɪpəri]美[ˈslɪpəri]adj. 滑的; 滑得抓不住(或站不稳、难以行走)的; 油滑的; 滑头滑脑的; 靠不住的; 难以应对的; 棘手的;[例句]These tyres give the bus better grip in slippery conditions.这些轮胎可使公共汽车在路滑时行驶得平稳一些。 12345678steeper 英[ˈstiːpə]美[ˈstipər]adj. 陡的; 陡峭的; 突然的; 急剧的; 大起大落的; 过高的; 过分的; 不合理的;[词典] steep的比较级;[例句]The path was steeper and less travelled than the previous one.这条小路比刚才那条陡，走的人少。 123456789steady 英[ˈstedi]美[ˈstedi]adj. (发展、增长等)稳步的，持续的，匀速的; 稳定的; 恒定的; 稳的; 平稳的; 稳固的;v. 使稳; 使平稳; 稳住; 恢复平稳; 稳定下来; 使平静; 使冷静; 使镇定;adv. 稳定地; 持续地; 稳固地;[例句]She&apos;s never had a steady job.她从未有过稳定的工作。 12345678considerable英[kənˈsɪdərəbl]美[kənˈsɪdərəbl]adj. 相当多(或大、重要等)的;[例句]Considerable modification of the existing system is needed.需要对现有的系统进行相当大的改进。 123456taoist 美[ˈdaʊɪst]网络 道士; 道家; 道人; 道教; 道教徒;[例句]The Basic Features of Taoist Outlook of Life and Their Ecological Significance生命本位与自然关怀&amp;道家生命观的基本特征及其生态学意义 123456scarlet 英[ˈskɑːlət]美[ˈskɑːrlət]adj. 猩红的; 鲜红的;n. 猩红色; 红衣; 象征罪恶的深红色; 绯红色;[例句]The scarlet of the wings shades into pink at the tips.猩红的翅膀到了翼端渐变成浅红。 12345678delighted 英[dɪˈlaɪtɪd]美[dɪˈlaɪtɪd]adj. 高兴的; 愉快的; 快乐的;v. 使高兴; 使愉快; 使快乐;[词典] delight的过去分词和过去式;[例句]I am delighted to make your acquaintance, Mrs Baker.贝克太太，我很高兴与您相识。 1234567widened 英[ˈwaɪdnd]美[ˈwaɪdnd]v. (使)变宽; 加宽; 拓宽; 放宽; (使)扩展，程度加深，范围扩大;[词典] widen的过去分词和过去式;[例句]The legislation will be widened to include all firearms.这项法规的范围将扩大到包括所有的枪支。 123456disciple 英[dɪˈsaɪpl]美[dɪˈsaɪpl]n. 信徒; 门徒; 追随者; (耶稣的)门徒，十二门徒之一;[其他] 复数：disciples 123456combat 英[ˈkɒmbæt]美[ˈkɑːmbæt]n. 搏斗; 打仗; 战斗;v. 防止; 减轻; 战斗; 与…搏斗; 1234reminiscent 英[ˌremɪˈnɪsnt]美[ˌremɪˈnɪsnt]adj. 使回忆起(人或事); 回忆过去的; 怀旧的; 缅怀往事的; 123456unaware 英[ˌʌnəˈweə(r)]美[ˌʌnəˈwer]adj. 不知道; 没意识到; 未察觉;[例句]There may be unrecognised cases of manifest injustice of which we are unaware.也许还有一些我们不知道的明显不公平现象被忽视了。 12345courteous 英[ˈkɜːtiəs]美[ˈkɜːrtiəs]adj. 有礼貌的; 客气的; (尤指)恭敬的，谦恭的;[例句]The hotel staff are friendly and courteous.旅馆服务人员友好而有礼貌。 这人轻狂妄为，我要会同丘师兄好好罚他。”郭靖道：“他要是肯同那位穆姑娘结亲，道长就饶了他罢。” 123456arrogant 英[ˈærəɡənt]美[ˈærəɡənt]adj. 傲慢的; 自大的;[例句]He&apos;s an arrogant little swine!他是个傲慢的小讨厌鬼！ 而这人武功之中另有旁门左道的诡异手法，定是另外尚有师承，那更教人猜想不透了 1234567unorthodox英[ʌnˈɔːθədɒks]美[ʌnˈɔːrθədɑːks]adj. 非正统的; 非传统的; 不正规的;[例句]But Brooks has structured his book in an unorthodox, and perhaps unfortunate, way.但是布鲁克斯用一种非正统的、或许不恰当的方式来撰写他的书。 123456pernicious 英[pəˈnɪʃəs]美[pərˈnɪʃəs]adj. 有害的，恶性的(尤指潜移默化地);[例句]I did what I could, but her mother&apos;s influence was pernicious我已尽力了，但是她母亲贻害颇深。 1234567explanation英[ˌekspləˈneɪʃn]美[ˌekspləˈneɪʃn]n. 解释; 说明; 阐述; 解释性说法; 说明性文字;[例句]It should be emphasized that this is only one possible explanation.应该强调的是，这只是一种可能的解释。 123456789sophisticated英[səˈfɪstɪkeɪtɪd]美[səˈfɪstɪkeɪtɪd]adj. 见多识广的; 老练的; 见过世面的; 复杂巧妙的; 先进的; 精密的; 水平高的; 在行的;[例句]Some sign languages are very sophisticated means of communication.有些手语可以表达非常复杂的内容。[其他] 比较级：more sophisticated 最高级：most sophisticated 123456789101112农历节日农历正月初一春节(the Spring Festival)农历正月十五元宵节(Lantern Festival)农历五月初五端午节(the Dragon-Boat Festival)农历七月初七乞巧dao节(中国情人节）(Double-Seventh Day)农历八月十五中秋节(the Mid-Autumn Festival)农历九月初九重阳节(the Double Ninth Festival)农历腊月初八腊八节(the laba Rice Porridge Festival)the Lunar 代表农历然后后面加节日....比如: It is August 15th, the Mid-Autumn Festival, according to the lllunar calender.今天农历八月十五,中秋节。 1234567barest 英[ˈbeərɪst]美[ˈbɛrəst]adj. 裸体的; 裸露的; (树木)光秃秃的; (土地)荒芜的; 无遮盖的; 没有保护的;[词典] bare的最高级;[例句]It was the barest hint of a smile.那是一个几乎不露一丝痕迹的笑。 王处一道：“你六位师父既然尚未明言，我也不便代说。”他曾听丘处机说起过前后的原委，对江南六怪的义举心下好生相敬。他和马钰是一般的心思，也盼江南六怪获胜，不过他是师弟，却不便明劝丘师哥相让，今日见了郭靖的为人，暗自思量如何助他一臂之力，却又不能挫折丘师哥的威名，决意届时赶到嘉兴，相机行事，从中调处。 1234567prevail 英[prɪˈveɪl]美[prɪˈveɪl]v. 普遍存在; 盛行; 流行; 被接受; 战胜; 压倒; (尤指长时间斗争后)战胜，挫败;[例句]I hope this book is not yet another restatement of the prevailing wisdom我希望这本书不会又是重复一些流行的至理名言。[其他] 第三人称单数：prevails 现在分词：prevailing 过去式：prevailed 过去分词：prevailed 1234567concede 英[kənˈsiːd]美[kənˈsiːd]v. 承认(某事属实、合乎逻辑等); (尤指勉强地)让与，让步; 允许; 承认(比赛、选举等失败);[例句]After losing this decisive battle, the general was forced to concede.输掉了这场决定性的战役后，那位将军不得不承认失败。[其他] 第三人称单数：concedes 现在分词：conceding 过去式：conceded 过去分词：conceded 1234567startled 英[ˈstɑːtld]美[ˈstɑːrtld]v. 使惊吓; 使吓一跳; 使大吃一惊;[词典] startle的过去分词和过去式;[例句]She was startled when Lisa popped up at the door all smiles莉萨突然笑容满面地出现在门口时，她吓了一跳。 1234567esquire 英[ɪsˈkwaɪə]美[ˈɛˌskwaɪr]n. 先生(用于男子姓名后表尊敬，尤用于信封上);[例句]With the very powerful publishing group Trends ESQUIRE is the most leading brand in Chinese market.依靠中国最具实力的期刊出版集团《时尚》，成为国内本土期刊市场上名副其实的领导品牌； 123456residence 英[ˈrezɪdəns]美[ˈrezɪdəns]n. 住所; 住房; (尤指)宅第，豪宅; 居住; 定居; (在他国的)居住权，居留许可;[例句]The house was terribly small and cramped, but the agent described it as a bijou residence.房子十分狭小拥挤，但经纪人却把它说成是小巧别致的住宅。 123456banquet 英[ˈbæŋkwɪt]美[ˈbæŋkwɪt]n. 宴会; 盛宴; 筵席;[例句]The banquet was full of cordial and friendly atmosphere from beginning to end.宴会始终充满亲切友好的气氛。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"常见缩写的不同含义","date":"2021-01-27T14:26:07.000Z","path":"2021/01/27/常见缩写的不同含义/","text":"缘起 起因是看一位其他行业的好友微博,把阈值精准得打了出来,不禁慨叹难得 --- 因为在工作中,作为高频接触到的词,还是会经常听到阀值,阀值… 但对方颇有不忿---“我在你那儿的形象这么没文化啊”. 一番探究,发现其行业同样使用该词. 在这样一个相互渗透,相融共生的年代,并没有想象中那样隔行隔山. 但也有一些相同缩写,在不同行业不同场景下,含义大相径庭,在此总结,持续更新. CPI Consumer Price Index 消费者价格指数/居民消费价格指数 Cycles Per Instruction执行每条指令所需要的时钟周期数 SRC Securities Regulatory Commission证券监督管理委员会 Security Response Center安全应急响应中心 1234567security 英[sɪˈkjʊərəti]美[sɪˈkjʊrəti]n. 保护措施; 安全工作; 保卫部门; 保安部门; 担保; 保证;[例句]The group was considered to be a risk to national security.这伙人被认为是威胁国家安全的危险分子。 为什么证券的英文是securities?security是安全的意思，为什么securities却是证券的意思？证券的意思是如何从安全引申过来的呢？ OTC Over-the-counter场外交易市场(也称 柜台交易市场) Over the counter drug非处方药 红底白字的是甲类，绿底白字的是乙类。甲乙两类OTC虽然都可以在药店购买，但乙类非处方药安全性更高。乙类非处方药除了可以在药店出售外，还可以在超市、宾馆、百货商店等处销售 MIPS Microprocessor without interlocked piped stages architecture一种采取精简指令集（RISC）的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。最早的MIPS架构是32位，最新的版本已经变成64位。 MIPS架构20多年前由斯坦福大学开发，是一种简洁、优化、具有高度扩展性的RISC架构。它的基本特点是：包含大量的寄存器、指令数和字符、可视的管道延时时隙，这些特性使MIPS架构能够提供最高的每平方毫米性能和当今SoC设计中最低的能耗 Millions of Instructions Per Second每秒处理的百万级的机器语言指令数。 是衡量CPU速度的一个指标。如一台 Intel80386 电脑可以每秒处理3百万到5百万机器语言指令，即可以说80386是3到5MIPS的CPU。MIPS只是衡量CPU性能的指标。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"十个漂亮的数学定理赏析","date":"2021-01-24T03:24:24.000Z","path":"2021/01/24/十个漂亮的数学定理赏析/","text":"原地址 十个漂亮的数学定理赏析 Beauty is the first test: there is no permanent place in the world for ugly mathematics --- G.H.Hardy 科学家研究自然并不是因为它有用，而是因为他喜爱它，他喜爱它是因为它美。如果它不美，它就不值得被人知道，而如果自然不值得知道，人也就不值得活下去。当然，我这里说的并不是那种激动感官的美——那种品质上和外观上的美；并不是我低估那种美，远远不是如此，但那种美跟科学不相干；我说的是各部分之间和谐有序的更深刻的美，是一个纯洁的心灵所能掌握的美。 --- 庞加莱 数学家的智慧——胡和生文集 1.欧拉公式 把指数函数和三角函数联系起来 2.多面体中的欧拉公式 柯西在20岁时给出的证明: 3.素数有无穷多个 反证法: 高斯 素数分布猜想: 素数定理: 作为素数规律的孜孜以求者,看到感觉非常亲切 ^_^ 4.在三维空间中存在5种正多面体 毕达哥拉斯学派很早就提出 至少有5种 利用 2.多面体中的欧拉公式,可证明正好有5种 5.n的平方分之一的级数=π²/6 (n为自然数) 也可以用 傅里叶级数来证明 6.不动点定理 布劳威尔不动点定理是拓扑学里一个非常重要的不动点定理，它可应用到有限维空间并构成了一般不动点定理的基石。布劳威尔不动点定理得名于荷兰数学家鲁伊兹·布劳威尔（英语：L. E. J. Brouwer）。 布劳威尔不动点定理说明：对于一个拓扑空间中满足一定条件的连续函数f，存在一个点x0，使得f(x0) = x0。布劳威尔不动点定理最简单的形式是对一个从某个圆盘D射到它自身的函数f。而更为广义的定理则对于所有的从某个欧几里得空间的凸紧子集射到它自身的函数都成立。 7.根号2是无理数 8.π是超越数 超越数，数学概念，指不是代数的数、无限不循环数。超越数的存在是由法国数学家刘维尔（Joseph Liouville，1809—1882）在1844年最早证明的。关于超越数的存在，刘维尔写出了下面这样一个无限小数：a=0.110001000000000000000001000…（a=1/10^1!+1/10^2!+1/10^3!+…），并且证明取这个a不可能满足任何整系数代数方程，由此证明了它不是一个代数数，而是一个超越数。后来人们为了纪念他首次证明了超越数，所以把数a称为刘维尔数。 transcendental number 9.四色猜想 这种说法正确吗? 10.费马大定理","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"Plan9汇编入门","date":"2021-01-10T14:05:16.000Z","path":"2021/01/10/Plan9汇编入门/","text":"Go 系列文章3 ：plan9 汇编入门 Go 语言的实现为何使用Plan 9的汇编器? 贝尔实验室九号项目 Golang中的Plan9汇编器 为什么 Plan9 在生产环境没有实际的应用，是因为应用程序匮乏的原因么？ https://codereview.appspot.com/133740043/ A Manual for the Plan 9 assembler Plan9 汇编入门讲解 plan9汇编手册 汇编和PLAN9汇编 1.4 Plan 9 汇编语言 转: 汇编是深入理解 Go 的基础 src/internal/bytealg/index_amd64.s 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274// Copyright 2018 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.#include \"go_asm.h\"#include \"textflag.h\"TEXT ·Index(SB),NOSPLIT,$0-56 MOVQ a_base+0(FP), DI MOVQ a_len+8(FP), DX MOVQ b_base+24(FP), R8 MOVQ b_len+32(FP), AX MOVQ DI, R10 LEAQ ret+48(FP), R11 JMP indexbody&lt;&gt;(SB)TEXT ·IndexString(SB),NOSPLIT,$0-40 MOVQ a_base+0(FP), DI MOVQ a_len+8(FP), DX MOVQ b_base+16(FP), R8 MOVQ b_len+24(FP), AX MOVQ DI, R10 LEAQ ret+32(FP), R11 JMP indexbody&lt;&gt;(SB)// AX: length of string, that we are searching for// DX: length of string, in which we are searching// DI: pointer to string, in which we are searching// R8: pointer to string, that we are searching for// R11: address, where to put return value// Note: We want len in DX and AX, because PCMPESTRI implicitly consumes themTEXT indexbody&lt;&gt;(SB),NOSPLIT,$0 CMPQ AX, DX JA fail CMPQ DX, $16 JAE sse42no_sse42: CMPQ AX, $2 JA _3_or_more MOVW (R8), R8 LEAQ -1(DI)(DX*1), DXloop2: MOVW (DI), SI CMPW SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop2 JMP fail_3_or_more: CMPQ AX, $3 JA _4_or_more MOVW 1(R8), BX MOVW (R8), R8 LEAQ -2(DI)(DX*1), DXloop3: MOVW (DI), SI CMPW SI,R8 JZ partial_success3 ADDQ $1,DI CMPQ DI,DX JB loop3 JMP failpartial_success3: MOVW 1(DI), SI CMPW SI,BX JZ success ADDQ $1,DI CMPQ DI,DX JB loop3 JMP fail_4_or_more: CMPQ AX, $4 JA _5_or_more MOVL (R8), R8 LEAQ -3(DI)(DX*1), DXloop4: MOVL (DI), SI CMPL SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop4 JMP fail_5_or_more: CMPQ AX, $7 JA _8_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVL -4(R8)(AX*1), BX MOVL (R8), R8loop5to7: MOVL (DI), SI CMPL SI,R8 JZ partial_success5to7 ADDQ $1,DI CMPQ DI,DX JB loop5to7 JMP failpartial_success5to7: MOVL -4(AX)(DI*1), SI CMPL SI,BX JZ success ADDQ $1,DI CMPQ DI,DX JB loop5to7 JMP fail_8_or_more: CMPQ AX, $8 JA _9_or_more MOVQ (R8), R8 LEAQ -7(DI)(DX*1), DXloop8: MOVQ (DI), SI CMPQ SI,R8 JZ success ADDQ $1,DI CMPQ DI,DX JB loop8 JMP fail_9_or_more: CMPQ AX, $15 JA _16_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVQ -8(R8)(AX*1), BX MOVQ (R8), R8loop9to15: MOVQ (DI), SI CMPQ SI,R8 JZ partial_success9to15 ADDQ $1,DI CMPQ DI,DX JB loop9to15 JMP failpartial_success9to15: MOVQ -8(AX)(DI*1), SI CMPQ SI,BX JZ success ADDQ $1,DI CMPQ DI,DX JB loop9to15 JMP fail_16_or_more: CMPQ AX, $16 JA _17_or_more MOVOU (R8), X1 LEAQ -15(DI)(DX*1), DXloop16: MOVOU (DI), X2 PCMPEQB X1, X2 PMOVMSKB X2, SI CMPQ SI, $0xffff JE success ADDQ $1,DI CMPQ DI,DX JB loop16 JMP fail_17_or_more: CMPQ AX, $31 JA _32_or_more LEAQ 1(DI)(DX*1), DX SUBQ AX, DX MOVOU -16(R8)(AX*1), X0 MOVOU (R8), X1loop17to31: MOVOU (DI), X2 PCMPEQB X1,X2 PMOVMSKB X2, SI CMPQ SI, $0xffff JE partial_success17to31 ADDQ $1,DI CMPQ DI,DX JB loop17to31 JMP failpartial_success17to31: MOVOU -16(AX)(DI*1), X3 PCMPEQB X0, X3 PMOVMSKB X3, SI CMPQ SI, $0xffff JE success ADDQ $1,DI CMPQ DI,DX JB loop17to31 JMP fail// We can get here only when AVX2 is enabled and cutoff for indexShortStr is set to 63// So no need to check cpuid_32_or_more: CMPQ AX, $32 JA _33_to_63 VMOVDQU (R8), Y1 LEAQ -31(DI)(DX*1), DXloop32: VMOVDQU (DI), Y2 VPCMPEQB Y1, Y2, Y3 VPMOVMSKB Y3, SI CMPL SI, $0xffffffff JE success_avx2 ADDQ $1,DI CMPQ DI,DX JB loop32 JMP fail_avx2_33_to_63: LEAQ 1(DI)(DX*1), DX SUBQ AX, DX VMOVDQU -32(R8)(AX*1), Y0 VMOVDQU (R8), Y1loop33to63: VMOVDQU (DI), Y2 VPCMPEQB Y1, Y2, Y3 VPMOVMSKB Y3, SI CMPL SI, $0xffffffff JE partial_success33to63 ADDQ $1,DI CMPQ DI,DX JB loop33to63 JMP fail_avx2partial_success33to63: VMOVDQU -32(AX)(DI*1), Y3 VPCMPEQB Y0, Y3, Y4 VPMOVMSKB Y4, SI CMPL SI, $0xffffffff JE success_avx2 ADDQ $1,DI CMPQ DI,DX JB loop33to63fail_avx2: VZEROUPPERfail: MOVQ $-1, (R11) RETsuccess_avx2: VZEROUPPER JMP successsse42: CMPB internal∕cpu·X86+const_offsetX86HasSSE42(SB), $1 JNE no_sse42 CMPQ AX, $12 // PCMPESTRI is slower than normal compare, // so using it makes sense only if we advance 4+ bytes per compare // This value was determined experimentally and is the ~same // on Nehalem (first with SSE42) and Haswell. JAE _9_or_more LEAQ 16(R8), SI TESTW $0xff0, SI JEQ no_sse42 MOVOU (R8), X1 LEAQ -15(DI)(DX*1), SI MOVQ $16, R9 SUBQ AX, R9 // We advance by 16-len(sep) each iteration, so precalculate it into R9loop_sse42: // 0x0c means: unsigned byte compare (bits 0,1 are 00) // for equality (bits 2,3 are 11) // result is not masked or inverted (bits 4,5 are 00) // and corresponds to first matching byte (bit 6 is 0) PCMPESTRI $0x0c, (DI), X1 // CX == 16 means no match, // CX &gt; R9 means partial match at the end of the string, // otherwise sep is at offset CX from X1 start CMPQ CX, R9 JBE sse42_success ADDQ R9, DI CMPQ DI, SI JB loop_sse42 PCMPESTRI $0x0c, -1(SI), X1 CMPQ CX, R9 JA fail LEAQ -1(SI), DIsse42_success: ADDQ CX, DIsuccess: SUBQ R10, DI MOVQ DI, (R11) RET","tags":[{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"统计命令汇总","date":"2021-01-10T13:00:00.000Z","path":"2021/01/10/统计命令汇总/","text":"适用于Unix体系 关于wc命令 Word Count 用于统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 wc [-lcw] c 统计字节数 l 统计行数 m 统计字符数，此标志不能与-c标志一起使用 w 统计字数。一个字定义为由空白、跳格或换行字符分隔的字符串 统计某文件夹下的文件数量 ls -l | grep &quot;^-&quot; | wc -l grep “^-“: 将ls -l长列表输出信息过滤一部分,只保留一般文件;如果只保留目录就是 ^dwc -l: 统计输出信息的行数, 因为已经过滤得只剩一般文件了,又由于一行信息对应一个文件, 所以结果也就是文件的个数 统计某文件夹下的目录的数量(即文件夹的数量) ls -l | grep &quot;^d&quot; | wc -l 统计文件夹下文件的个数,包括子文件 ls -lR | grep &quot;^-&quot; | wc -l -R为 递归子文件夹wc -l: 统计输出信息的行数, 因为已经过滤得只剩一般文件了,又由于一行信息对应一个文件, 所以结果也就是文件的个数 统计文件夹下目录个数，包括子目录 ls -lR | grep &quot;^d&quot; | wc -l 使用脚本 统计文件夹下所有文件的总字符数 123456789101112131415#!/bin/bashfiles=$(ls)all=0for i in $files; do #忽略该脚本本身包含的字符 if [ $i != 'wc.sh' ]; then head -n1 $i t=$(wc -m $i | cut -d ' ' -f5) all=$(($all+$t)) echo ' 统计字数: '$t fidoneecho '共计字数'$all 该脚本其实有问题,因为cut -d &#39; &#39; -f5并不一定恰好能拿到wc统计出的字符数量 用wc命令怎么做到只打印统计数字不打印文件名 可以使用cat test.txt |wc -l 替代wc -l test.txt,这样就解决了这个问题~ 修正后的脚本如下: 123456789101112131415#!/bin/bashfiles=$(ls)all=0for i in $files; do #忽略该脚本本身包含的字符 if [ $i != 'wc.sh' ]; then head -n1 $i t=$(cat $i | wc -m ) all=$(($all+$t)) echo ' 统计字数: '$t fidoneecho '共计字数'$all 再为其添加判断,忽略掉当前文件夹下的目录,只统计纯文件 1234567891011121314151617#!/bin/bashfiles=$(ls)all=0for i in $files; do #忽略该脚本本身包含的字符 if [[ $i != 'wc.sh' ]] &amp;&amp; ! [[ -d $i ]]; then head -n1 $i t=$(cat $i | wc -m ) all=$(($all+$t)) echo $i ' 统计字数: '$t fidoneecho \"\"echo \"\"echo '共计字数'$all 共601篇博客,字数共计 1655265","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"夜雨对床","date":"2021-01-03T13:50:16.000Z","path":"2021/01/03/夜雨对床/","text":"夜宿xx。一年多前，重回xx前夜，亦曾于此借宿。谈这一年来变化，各有收获，各留失落。 讲到一位共同的前同事，不及而立便撒手西去。逝者长我一岁，因是哈工大焊接专业转行做设计，跨度之大，5年前在司内“名闻遐迩”。 于是探讨起最近几年各自的眼观耳闻，如当年我遇到的脑瘤女孩，曾滴水相助的同龄人，六度空间内的各种不想看到 又难忍打开的轻松筹/水滴筹链接，心有戚戚。 我们还是太卑微无力，自保尚可，却无力顾及ta人。每当想起前人“每一块土壤都是大陆的一部分，这形形色色的人，都和我有关”，自惭而形秽----这很可能是最近一两年，明明进步巨大，却还常觉失望。早几年困顿于一城一房，是没有太多心思考虑这些的。 我这位相熟数年引为知己的前同事，直言不讳我想的太多。我们都是普通人，不是英雄天神，这些责任归属gov，有的甚至连“联合国，连安南都解决不了”，你操哪门子心呢。 我忖度，可能正是喜欢诗词，最是尊崇膜拜老杜。那种高山景行甚至死板的忧怀民瘼 恫瘝在抱 情操，多多少少给了本是俗人的我，以无声之感染。 安得广厦千万间？早些年我想是通过商业通过市场经济解决匮乏，成一方巨贾施恩援助。却才发觉，杯水车薪。又觉得被我鄙夷的政事，操行得当，恰是最有影响力的改变方式。再又发觉，好些不以人意志为转移，归根结底还是提高生产力，提升科学技术。而谙熟科技史，又清晰实在太多科学家高风亮节的举止，招来非议甚至巨大灾难。 可能年岁增长，愈发不再会有这种天下己任，解民倒悬的胸怀抱负。承认自己和时代的普通，是一件困难却必须去做的事。人一生需要三次和解，我已经真诚谅解并感谢父母，现在，也许是原谅自己的时候了。 承认那些不可捉摸的特质和背景我不具备，承认没有逆天的运气加持，承认平凡转而走向庸常，现在，我耳根松动，跟风或听劝去做一些事，去从众考研考证的概率，去开拓副业去经营圈子，比任何时候都大----在过去几年，这些相对简单,中规中矩而低风险的事务，对自命不凡不甘从俗的我，如天方夜谭绝无可能。 “我相信这不是我一个人的经历：傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。” “什么是似水流年？就如一个人中了邪躺在河底，眼看潺潺流水，波光粼粼，落叶，浮木,空玻璃瓶,一样一样从身上流过去。”","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"实用网站汇总","date":"2021-01-02T13:09:30.000Z","path":"2021/01/02/实用网站汇总/","text":"codelf,变量命名神器 在线版 可以键入一个中文,看在其他开源项目中,怎样命名 github地址 中文wiki 支持多款编辑器, 可以在Jetbrains系列IDE中,插件市场搜索OnlineSearch Programming-Idioms,对比两个语言的语法 在线地址 会把这两门语言在非常典型的应用场景的使用方法和区别罗列出来,可以很容易的基于已经掌握的一门语言去学习另外一门新语言 libhunt,库对比功能 包括不同语言之间,和同一语言之间 在线地址 更多可参见 选择困难?试试libhunt 一些不错的技术站点 thoughtworks的技术雷达 美团技术团队 淘宝数据库内核月报 参考: 五个对程序员来说极具价值的小众网站 编程语言都有中央包存储库吗？ Does every programming language have a central package repository? Bash 命令的可视化解释工具 ExplainShell.com 遇到复杂的 Bash 命令，可以输入到这个网站，查看该命令的解释 数据结构可视化 收集各种数据结构，并将它们用可视化的形式表现出来。 How old is it 可以查询各种技术存在了多久，用来供 HR 招聘时了解，有些技术岗位要求N年经验是不现实的。 Visu Algo 各种算法的动态演示网站,很赞 Paste to Markdown 粘贴到该窗口的任何文本内容，都会自动转为 Markdown 格式 ScreenDump 在线截屏工具。只要输入网址，就会显示各种设备的网页截屏。 I love IMG 提供各种在线的图像编辑工具，比如图像缩放、压缩、裁剪、水印等 Benchmarks Game 27种 常用编程语言的两两性能对比 curl-to-Go 将 cURL 转为Golang代码 (Postman有相同功能) goquery 网页解析利器,可用于爬取网页","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"开源人物志","date":"2021-01-01T12:59:26.000Z","path":"2021/01/01/开源人物志/","text":"Richard Matthew Stallman 贡献领域: Emacs, GCC, GDB 中文一般译作”理查德·斯托曼”,Geek圈内一般简称”RMS” 1953年生于美国,自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者、著名黑客 所写作的 GNU通用公共许可证（GPL） 是世上最广为采用的自由软件许可证 别出心裁,创造了著佐权(Copyleft) 这一概念, 即可以拷贝,可以修改,可以出售, 只是有一条:源代码所有的改进和修改必须向每个用户公开,所有用户都可以获得改动后的源码. Copyleft保证了自由软件传播的延续性 有和RMS用同款键盘 ( =•ω•= ) 理查德·斯托曼一直是对的 Fabrice Bellard 贡献领域: 贝拉公式(最快圆周率算法),TCCBOOT,TCC（微型C编译器）,FFMPEG 中文一般译作”法布里斯·贝拉” 1972年生于法国 Fabrice Bellard 是个什么水平的程序员？ Chris Lattner 贡献领域: LLVM项目主要作者之一,Clang编译器作者,Swift之父 中文一般译作”克里斯·拉特纳” 1978年生于美国 Chris Lattner’s Homepage github.com/lattner 开源人物 http://www.iis7.com/a/lm/bk/","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"南方周末新年致辞","date":"2020-12-31T16:00:00.000Z","path":"2021/01/01/南方周末新年致辞/","text":"参考: 南方周末新年献词合集 1997年新年献辞：1997年主编寄语 岁末，有一种特别的牵挂，缠绕着我们的心。让我们牵挂的人，就是千万个陌生的“你”。 回望一道走过的1997，我们共同经历了多少大事：“万众送小平”的啜泣犹在耳边低回；“香港回归夜”的焰火还在眼前闪耀；党的十五大响鼓重捶声震寰宇；三峡“世纪梦”牵动亿人的心…… 日子在交织着泪水和欢笑中匆匆流逝，日子也在交织着担忧和希望中匆匆走来。 无论这日子曾经多么地不平常，走进寻常百姓家，它就变成了实实在在的柴米油盐酱醋茶。而平平常常的日子，也具有打动人心的力量，哪怕是弱小者的生存，也和“强”字分不开。活着，就意味着“生”之顽强。 读者也许还记得，“芳草地”曾经登过一篇《深秋的北风》：在北京的大风天里，一个下岗男人坚守街头卖他的梨，妻儿来了，苦劝不回，他说，他要为这个家担负起一种责任。 我们自以为饱经沧桑，阅透了人生，心早已磨出厚茧，可是，一篇朴素的文章，一段质朴的对话，一个感人的细节，仍足以令我们鼻子发酸，心头发烫。我想起了一位女作家十多年前说过的一句话：“你的心并不是粗砺荒漠的一片，那光明的一隅，会永远充满了温情地留给世上无助的弱者。” 当弱者努力摆脱无助让自己站得更直时，我们的心又何止充满温情。我们把永远的尊敬留给他们。 走过1997，我们有梦圆的欢欣，也有梦碎的痛苦，而执著于梦想的追求，使我们天涯咫尺，息息相通。 就在几天前，一位读者给编辑部写来了他亲历的一件事：在湛江开往海口的轮船上，百无聊赖的他买下一份《南方周末》，尚未读完，就已经泪流满面。他把报纸递给了正在甲板上追逐嬉闹的一群素不识的少年，少年们看完报纸，也如塑像一般陷入了沉思。深深地打动了这一群人的，是老榕的文章，那篇取自网络、感动过无数人的《大连金州没有眼泪》。当轮船靠岸，各自东西，少年们也许很快就淡忘了这不期然而至的邂逅，但是，在甲板上触动他们沉思的东西不会湮没。中国足球梦碎金洲的夜晚，也许是老榕儿子10岁的生命历程中最寒冷的一夜，但就在那寒冷之夜的第二天早晨，孩子幼小的心灵已经开始照耀着一种特殊的阳光，那就是理想和希望。 我们无法想象没有理想没有希望的日子，就如同我们无法想象没有阳光的日子一样。正因为有了阳光赋予生命的作用，地球才没有变成石头。 莎士比亚告诉过我们：“草木是靠着上天的雨露滋长的，但是它们也敢仰望穹苍。”而在穹苍之上，“同一个太阳照着他的宫殿，也不曾避过我们的草屋。”迎着新年初升的太阳，陌生的朋友，我们同行。 希望从来也不抛弃弱者。 希望就是我们自己。 1998年新年献辞：让无力者有力，让悲观者前行 迎着新年初升的太阳，让我们轻轻地作个道别，说一声：“再见，一九九八。” 回望逝去的365个日夜，我们所有的努力，都是为了证明“我是一个记者”。 透过记者的眼睛，我们现场目击了朔州假酒荼毒生灵的惨祸；透过记者的眼睛，我们奋力传递了昆明“铲除恶霸”的呼喊；透过记者的眼睛，我们仔细观察了中国电信反垄断的艰难进程；透过记者的眼睛，我们忠实记录了亿万军民战胜世纪洪水的巨大勇气和抗争精神……有人说，人在履行职责中得到幸福；也有人说，履行一项职责时总会感到是在还债，因为它决不会令我们自己非常满意。 记者所履行的职责，何尝不是对公众的一种“还债”——他要告诉人们世界上发生的新闻，他还要告诉人们新闻背后的真相。 对于这样一项职责，我们当然时时力有不逮，但我们愿意为此而竭尽全力。 植物的生命要靠它的绿叶显示，新闻的生命要用它的真实担保。 面对世俗的力量，尽管生命有时也会显得脆弱，尽管我们也不都总是那么坚强，但是，我们决不苟且于虚伪和庸俗，决不。因为我们深深懂得，尊严是人类灵魂中不可糟踏的东西。 读者也许还记得伐木工人的最后一个劳模吧。为了寻找他，以便寻找长江上游水土流失的真相，我们的记者排除了“报喜不报忧”的地方干扰，翻山越岭，穿过一个又一个伐木点，终于找到了生病住院的主人公，这位老伐木工发自内心的忏悔，为“寻找长江的伤口”留下了最真实的言说和最切肤的痛。 我们的许多报道，就是不断发现和不断寻找的结果。 记者的眼睛不仅仅为发现事实寻找真相而睁开，记者的眼睛也常常被真情打动，而轻轻闭上。 在东北灾区，滔滔洪水已退，漫漫严冬将临，迎着刺骨的寒风，一位大嫂对我们的记者悠悠地说了一句：“我们需要什么？太多了，国家哪帮得过来，今年灾情这么普遍，自己苦点都没啥……”言者毫不经意的话语，却令闻者心头一热，久久为之发烫。 面对如此重灾巨创，柔弱之躯内蕴藏的宽厚与善良，谁说不是一种坚强？也正是人民所固有的善良和坚强，唤起我们一种不可摧毁的希望。也只有那些曾抱住几块脆弱的木板，在狂风暴雨的急流中颠簸过的人，才能体会到一个晴朗的天空是多么的可贵。 告别一九九八，回访我们报道过的新闻，作恶多端的孙小果终于被一审判处死刑，身心俱疲的改革者董阳终于在他乡找到知音，而中国电信也终于开始降低消费者们抱怨已久的不合理收费……这就是世道人心。 是的，希望从来也不抛弃弱者。希望就是我们自己 1999年新年致辞：总有一种力量让我们泪流满面 这是新年的第一天。这是我们与你见面的第777次。祝愿阳光打在你的脸上。 阳光打在你的脸上，温暖留在我们心里。这是冬天里平常的一天。北方的树叶已经落尽，南方的树叶还留在枝上，人们在大街上懒洋洋地走着，或者急匆匆地跑着，每个人都怀着自己的希望，每个人都握紧自己的心事。 本世纪最后的日历正在一页页减去，没有什么可以把人轻易打动。除了真实。人们有理想但也有幻象，人们得到过安慰也蒙受过羞辱，人们曾经不再相信别人也不再相信自己。好在岁月让我们深知“真”的宝贵——真实、真情、真理，它让我们离开凌空蹈虚的乌托邦险境，认清了虚伪和欺骗。尽管，“真实”有时让人难堪，但直面真实的民族是成熟的民族，直面真实的人群是坚强的人群。 没有什么可以轻易把人打动，除了正义的号角。当你面对蒙冤无助的弱者，当你面对专横跋扈的恶人，当你面对足以影响人们一生的社会不公，你就明白正义需要多少代价，正义需要多少勇气。 没有什么可以轻易把人打动，除了内心的爱。没有什么可以轻易把人打动，除了前进的脚步…… 这是新年的第一天，就像平常一样，我们与你再次见面，为逝去的一年而感怀，为新来的一年作准备。祝愿阳光打在你的脸上。 阳光打在你的脸上，温暖留在我们心里。有一种力量，正从你的指尖悄悄袭来，有一种关怀，正从你的眼中轻轻放出。在这个时刻，我们无言以对，惟有祝福：让无力者有力，让悲观者前行，让往前走的继续走，让幸福的人儿更幸福；而我们，则不停为你加油。 我们不停为你加油。因为你的希望就是我们的希望，因为你的苦难就是我们的苦难。我们看着你举起锄头，我们看着你舞动镰刀，我们看着你挥汗如雨，我们看着你谷满粮仓。我们看着你流离失所，我们看着你痛哭流涕，我们看着你中流击水，我们看着你重建家园。我们看着你无奈下岗，我们看着你咬紧牙关，我们看着你风雨度过，我们看着你笑逐颜开……我们看着你，我们不停为你加油，因为我们就是你们的一部分。 总有一种力量它让我们泪流满面，总有一种力量它让我们抖擞精神，总有一种力量它驱使我们不断寻求“正义、爱心、良知”。这种力量来自于你，来自于你们中间的每一个人。 所以，在这样的时候，在这新年的第一天，我们要向你、向你身边的每一个人，说一声，“新年好”！祝愿阳光打在你的脸上。 因为有你，才有我们。 阳光打在你的脸上，温暖留在我们心里。为什么我们总是眼含着泪水，因为我们爱得深沉；为什么我们总是精神抖擞，因为我们爱得深沉；为什么我们总在不断寻求，因为我们爱得深沉。爱这个国家，还有她的人民，他们善良，他们正直，他们懂得互相关怀。 2000年新年致辞：我们从来没有放弃，因为我们爱得深沉 这是千载一遇的时刻，百年的更迭，千年的交替，都将汇于同一个瞬间。为了欢呼新世纪的太阳照临地球，全世界的人们都在翘首以待…… 这又是岁末平常的一天。这是我们第８２９次和你见面。面对着即将远去的一个世纪，面对着就要开启的新千年之门，也许，我们真的该来一次”世纪之旅”，就像聪明的同行已经去做的那样———派记者去新西兰，去那个２０００年第一缕阳光照射到的地方？或者去五大洲，去感受不同肤色的人们异域狂欢的情状？ “世纪之旅”？千年等一回呵，为什么不呢？ 15名记者受命出发了。他们脚步匆匆，他们意绪绵绵。他们要去的地方其实都不陌生，每个人却又分明都有一点惴惴然。是呵，”近乡情更怯”，处在百年之交、千年之交的故乡，你别来无恙否？ 这就是我们献给读者的一次世纪末特别的旅行————“记者回家乡”。 一群难得在故乡转悠的人，有人甚至对那片土地已睽违多时。他们终年的奔波行走，总是在寻找他乡的故事；他们的爱和恨，也更多地倾注在别的地方。家乡，成了每个人心灵深处秘不示人的珍藏。 现在，就让他们小心翼翼地把珍藏打开吧——— 那些版图上无甚出奇的所在；那些所在处平平常常的故人；那些故人里被岁月模糊了的面容；那些面容中被风霜蚀刻下的皱纹……这一切一切，都因为百年之交、千年之交的踏访和叩问，在我们的记者的笔下，变得异常生动、鲜明、隽永，历历在目，触手可及。 为什么我们总是眼里含着泪水？读完了这一组“记者回家乡”，也许，你会找到答案。而我们必须表达的，是我们对那片土地的敬意。 我们要向乡间的母亲致敬。她用一双小脚走过春夏秋冬，走到了人生的尽头，才算丈量完所有的苦难。母亲，我们祝福你，因为你知道怎样把你的儿子培养成一个真正的人。他将在人生的战斗中获得胜利。 我们要向天国的父亲致敬，他的在天之灵，冥冥之中依然向儿子散发出最质朴的光辉。即使刚刚承受了失去父亲的巨大创痛，在接到采访特大海难的任务时，儿子首先记起的，还是父亲常说的那句话：别为了自个的事耽误了公家的活。 我们要向一位新婚的妻子致敬。就在新婚之夜，她的丈夫却匆匆登上颠簸的长途公共汽车，去采访令人撕心裂肺的海难事故现场，他这样做只有一个理由：“我是一个记者！”而她的理解和支持，正好成为他义无反顾的另外一个理由…… 2001年新年献词：愿新年的阳光照亮你的梦想 这是本报本年度最后一次和你见面。恭贺你的新年，祝福你的梦想。 时光匆匆，回望一年，是谁最长久地驻留在你的心中？是什么最深切地打动过你的心灵？从今年开始，我们将每年进行年度人物评选。每一次评选都是一次岁月的盘点，每一张选票都是一粒点燃梦想的燧石。 每一群人中都有英雄，每一个人都有梦想。人们总是被那些风云际会的弄潮儿激励着，总是在对他们的指点评说中倾诉着自己的梦想与希望。 今年我们推出的十位候选人，涵盖了经济、文化、科技、体育等社会生活的方方面面。许多读者在投票中指出，他们各有建树，难分高下。然而，也许正是在这样的评选中，我们更知道了什么是最重要的，什么是最基本的，什么是宽容，什么是多元，什么是尽职守责，什么是同舟共济。 李昌平，一个并不为很多人所知的新闻人物，凭着一个乡党委书记的良知与责任感打动了千千万万个读者的心。因为他直面百姓疾苦，求索改革之路；因为他行使了一名共产党员和基层官员的权利，向国务院领导坦荡陈言，从而引起高度重视，引发了大刀阔斧的改革。人民对自己根本利益的代表者表达了深深的敬意，人民对改革寄予焦灼的期待。这是希望。有些读者投票时称“李昌平是国家民族的希望”。其实，这些投向良知与责任感的欢呼，何尝不是国家民族的希望？ 同样以直面现实赢得人心的山西作家张平，多年来百折不回，秉笔直书，鞭挞司法腐败、吏治腐败和文化腐败。在这个寒冬，那个最初打动张平的身患肝癌却无钱买药，痛得将床边的墙砖抠掉三分之二的下岗工人是否还好？那些被他拜访过的付出太多而得到太少的工人是否已感到温暖？那些被他揭露的腐败官员是否已受到惩罚？人们赞扬张平不畏挫折的恒心和毅力，而支撑张平的信念是：反腐败只能靠体制的改革与进步。 对外经济贸易部首席谈判代表龙永图和他的同事们则正在为打开一条改革与进步的通道，也是实现大多数人的梦想的通道而努力，那就是让中国加入WTO，那就是让中国融入世界，进一步开放市场。“必须通过体制改革走向市场经济，实行计划经济的国家永远不可能成为经济大国。”几天前，龙永图在香港的一次演讲中说。 不仅是经济，许许多多的梦想，民主与法制，公平与效率，都将在改革、开放中去实现。 这是一条经过历史选择的正确通道，但是并非坦途。十多年的谈判让多少志士呕心沥血，“没什么精彩，很艰苦。”龙永图说，“我们必须忍辱负重，以中华民族的耐心和坚韧精神面对未来。” 改革越到深水区越艰难，它需要我们每一个人的锲而不舍。孙雯是一名成功者，也是一名失败者。众多读者把选票投给孙雯，或许更因为她的挫折她的艰辛，她在逆境中的风范。站在世界足球最光彩夺目的领奖台上，孙雯说，中国女子足球队成为世界强队的秘诀就是信心。这支球队带给我们的是一种精神，那种紧紧握住梦想，永不言败的精神。 紧紧握住你的梦想：也许你是一位企业家，你的梦想是柳传志的梦想；也许你是一位艺术家，你的梦想是王家卫的梦想；也许你是一位科学家，你的梦想是杨焕明的梦想。甚至，也许你的手中只有一柄锄头，你的肩上只有一条纤绳，你也有追求幸福和尊严的崇高权利，你的梦想、你的勇气、你的贡献也和他们同等重要。 我们下一次和你见面时，新年的阳光已打在你的脸上，它将照亮你的梦想。 新年的阳光将照亮你的梦想，将照亮每一个和你一样善良、正直、互相关怀、默默奋斗的人的梦想，将照亮这个正在走向开放的国家、正在谋求发展的民族的梦想。 2002年新年献词：走在中国的大地上 阳光打在你的脸上，温暖留在我们心间；雨露滴在你的胸膛，我们走在中国的大地上。我们与你在一起，我们的爱一如既往。 我们上路了，新闻在远方。你见到我们的时候，我们和新闻在纸上；你见不到我们的时候，我们和新闻在路上。我们是观察者，我们是记录者，我们是报道者，我们执著地寻找真相。当年，有些同行追逐新千年的第一缕阳光，我们却回到了自己的家乡；我们是农民的儿子，我们是工人的儿子，那里是我们的根，我们从我们的根部汲取力量。 在新世纪第一年的岁末，我们又兵分九路，走在中国的大地上。顺德、厚街、温州、利辛、武汉、宣汉、喀什、大同、沈阳，祖国的四面八方，各不同的内涵和外表，我们走近你，我们走进你，我们想看清你的模样，我们想叩问你的心房。 我们倾听，我们观察，我们张开浑身的每一个毛孔，我们打开自己的每一个器官，我们感受，我们思考，我们记录，我们报道。你的笑脸，你的眼泪，你的焦虑，你的方言表达的你的梦想，对于我们，这一切是多么珍贵！ 福建的成功路、四川的白鹿镇、河南的小常庄，这儿与那儿，久违了，一年一度，我们是第四次涉足。音容笑貌，多么熟悉，生老病死，几多沧桑。如此累积的记录，或者就是一部特殊的编年史。 年度人物寄托人们的理想。龙永图做了一个中国官员应该做的事，冯锦华显示了一个中国人应有的血性。他们做得多么漂亮！什么可贵？做应该做的事可贵！ 我们走在中国的大地上，追逐着新闻应有的理想。我们不敢说凡有新闻发生的地方，我们就在场————我们有太多的遗漏————但我们敢说，新闻总是牵动着我们的走向。南丹矿难的兄弟，我们钻到你哭泣的家乡，让事件剥去伪装，显露真相。千里追踪沙尘暴，戈壁滩里渗进了我们的鲜血，但我们习以为常，身上留下了风的形状 我们走在中国的大地上，我们捉摸着大地的脉搏，我们关注着中国的动向。莫斯科的悬念，申奥，北京；五里河的欢腾，中国足球首次入围世界杯；多哈，中国入世，15年的长征，中国从此进入新天地，中国的未来可预期！ 土地流转，宪法司法化第一案，户籍改革，收容，中国当代社会阶层……你还记得这些词句吗？还有这些词句背后的事实？我们关注效率，也关注公平；我们赞美机遇，赞美可能；我们关注世事的变迁，我们赞美新的萌芽，那是中国未来的无限生机！ 我们走在中国的大地上，我们与红豆杉一起流泪，我们看不见藏羚羊绝望的眼神（它总是奔逃得那么张皇），我们随着野马撒野，我们看见塔里木河重新轻波荡漾…… 我们走在中国的大地上，为你鼓劲，为你欢喜，为你分忧。 我们走在中国的大地上，我们走过乡土，走过城镇，走过大都会。我们喝过你的家酿酒，我们吃过你的糌粑，我们坐过你的三轮（在被迫离开艾滋病村时，你甚至不收车钱），我们经过金茂大厦前修剪陈枝的你的身旁…… 我们与你在一起，我们的爱一如既往。 我们走在中国的大地上，这片土地曾经悲伤，这片土地曾经辉煌；我们走在中国的大地上，这片土地沐浴阳光，这片土地充满希望。 我们走在中国的大地上…… 2003年新年致辞：“全面小康”与“公正社会” 在剧变的时代追寻最大的正义 当我们的目光从注视了一年的黄土地、黑土地、红土地上抬起时，新年的阳光已经第十九次炫目地照在中国这份平凡的报纸上。 19年来，我们一次次、一年年，艰难而执著地贴近大地，贴近人民，记录时代的进程，在希望与梦想中汲取力量。 而新的一年，是中共十六大确定全面建设小康社会目标后的第一年。我们没有回避“全面小康”与“公正社会”这么严肃的话题，哪怕是在本该轻松的新年第一天，因为我们知道，“解决问题”与“发展”是一个概念的两面，我们正视问题，因为有一个值得冀望的明天摆在所有中国人面前。 ［一］ 这片土地正在发生着令人目眩的变化：珠三角蓬勃的加工企业，构成了全球化工业链条中不可或缺的一环；大上海重现“海上繁华梦”，离国际大都市仅一步之遥；首都北京还有5年就要举办奥运会了，正在以上千亿的投入打造一个“新北京”，迎接来自远方的客人。 毫无疑问，我们身处一个空前繁荣的时代。物质的极大丰富、国力的极大增强，都表明这个国家正呈现出一种蓬勃向上的发展态势。 但是，仍然有一些信息不能被我们忽视，那是上千万刚刚进入都市的民工惘然的脸庞，是都市里失业人员的艰难谋生，是都市边缘的不能称为学校的“民工子弟学校”；是上海、北京和广州等特大城市之外的更为广袤的土地，是那些土地上祖祖辈辈顽强生存着的人们…… 其实，江泽民在中共十六大报告中已经对当前形势作了深刻的阐述：“经过全党和全国各族人民的共同努力，我们胜利实现了现代化建设‘三步走’战略的第一步、第二步目标，人民生活总体上达到小康水平。这是社会主义制度的伟大胜利，是中华民族发展史上一个新的里程碑。”他同时指出，“现在达到的小康还是低水平的、不全面的、发展很不平衡的小康”，“城乡二元经济结构还没有改变，地区差距扩大的趋势尚未扭转，贫困人口还为数不少；……就业和社会保障压力增大……”。 如果不能清醒地认清形势，盲目的乐观可能会干扰我们前进的方向。 所以，我们又一次选择了行动。十多名记者以沈阳、北京、上海、江苏宜兴、广州5个地域为原点，出发。方向是既定的：向西；距离是特定的：在50里左右。方向和距离并不代表什么，恰恰表明了选择的随意。我们只想为急速变化中的中国划出5个横切面，作一次社会学意义上的观察。目的只有一个：我们力图展现一个真实的中国。 ［二］ 这是一个剧变的时代。如同有专家所说，自晚清以降，经过多少仁人志士的热血奋争，中国人一百多年来的最大命题———“从传统社会向现代社会的转变”，现已进入“总结期”。正因为如此，变化之剧烈、转型之迅猛、牵涉面之广，可想而知。 如何看待正在发生的剧变，便成为这个时代的一个重大命题。 我们认为，只有把这些变化放在历史的大背景之下来审视，我们才不至于在纷繁的表象面前变得迷惘而再次失去方向。那便是：一百多年来，虽然历经曲折，但中国社会从传统到现代、从封闭到开放、从封建王朝的专制统治到人民共和国的民主自由，这一“历史之河”无疑是朝着正确的方向流淌，而且不可逆转。 但历史又不只是几页冰冷的纸张。只有把变化同时放在现实中、放在每个社会个体的日常悲欢中来考察，我们才能在认清方向的同时更加清醒，而不至于走向虚妄。那便是：即使在一个变动的时代，每个个体的幸福和上升通道仍应该尽可能地获得很好的制度保证。 具体而言，在健康的力量正在生长和发育、社会总体走向繁荣的同时，我们更应该正视更广大社会群体的基本诉求，对生存保障、对幸福生活和美好未来、对社会公正的诉求。 没有人能忽视、也没有人会忽视他们的诉求。尤其在一个变动的时代，正义往往会成为变动的代价而被轻易支付，但成为悖论的另一面是：越是变动的时代，人们也越呼唤正义，呼唤公平。 自从18世纪欧洲启蒙思潮发端以来，“人人生而平等”的理想便从根本上改变了这个世界，成为影响全人类的最基本信仰。有历史学家甚至曾经精辟地对刚刚逝去的20世纪这样进行总结：整个世纪，人类都是在对“发展”和“平等”这两大主题的追逐和摇摆中度过的。所有关于社会治理的理论和思潮，都力图在这两者之间寻找适当的平衡点。 在这个辞旧迎新的时刻，不论是我们记者的行动，还是众多知名专家的访谈，我们都想为这一问题寻找答案：当下的中国，是否已经到了把重心逐渐倾向“公平”的时刻？ ［三］ 事实上，十六大报告已经给出了答案。 这次极为重要的会议，为21世纪头20年中国的发展规划了一个美好的蓝图，那便是：全面建设小康社会。本报记者采访的几乎所有专家，均不约而同地向记者提及了这一规划，并指出，它表明党和政府已经把让更多的公民享受到改革的成果、建设一个更为公正的社会，作为今后20年的重中之重。 其实，这一政策取向早在5年前即已经开始显现。在改革步伐迅猛向前、而旧有的保障制度已经无力保障的时刻，1998年，朱镕基总理就明确提出将建立一个世界上最为庞大的社会保障体系，作为本届政府的几个最重要的目标之一。而旨在缩小东西部差距的西部大开发，也正在付诸实施。 就在刚刚逝去的2002年里，从年初试图采取“国有股减持”来充实社会保障基金、从不惜排除重重阻力将农村税费改革推行到20个省，都显示出高层关怀困难群体、确保社会公正的良苦用心。 这也是我们认为，2002年将成为中国社会进程中一个有标志意义的年度的重要原因。 与此同时，实现社会公正的根本路径也已相当清晰地在我们面前展现开来。规则公平是最起码的公平，如果没有透明和公正的规则，权钱交易可以获取巨额利润，这对公平将是釜底抽薪。 即使在规则平等的前提下，天生禀赋的差异，加上成功者对利润最大化的追逐，仍然会导致结果的巨大差异。此时，便需要政府在教育、就业、保障等公共政策上进行有效的调节，更多地倾向困难群体，以维持社会的总体和谐。这被称为“矫正的正义”。 而在公共政策的选择受到各种利益集团相互博弈、相互影响的情况下，保障各个群体的政治权利便成为能够实现“矫正的正义”的当务之急。也只有在政治权利得到充分的尊重与保障的情况下，制定公正的规则这一更为重要的前提才成为可能。于是，尊重宪法、依法治国、建设社会主义民主政治和政治文明的道路便成为根本的选择。 按他国的经验，在一个特定的历史阶段，往往会在这三个层面的选择中偏向一个。然而，对于剧变中的中国而言，这三个层面的选择似乎正显得同样重要而迫切。 正因为如此，这才是需要决策层和全体国民的大智慧的时候。 所以，我们寄望于2003年，寄望于今后20年。 2004年新年致辞：这梦想，不休不止 谁说这是平常的一天？候鸟掠出线影，年轮添了新纹；我们大声地问候亲友，也默默地思念远人。 365天，两鬓多了白发，或许连心事也疲倦了几分，但你依然，依然轻轻地叹着，却终究微微地笑了——这是一个收获祝福的日子，要赶紧抹去浮尘，擦亮梦想。但这其实是很平常的一天：北方的飘雪，南国的暖阳，还有来来往往人海茫茫。历史并不常常在某个特定的时刻让一切发生改变，只是在我们的心里，习惯找一个开始。 一开始，就有梦想。 那么在这新年的开始，我们祝福你，朋友，愿你的梦想一路远行！ 我们乐观地回首，2003是放飞梦想的一年：小康社会，“立党为公、执政为民”，“神舟五号”，“振兴东北”…… 有了开始，即便梦想千年，也新意盎然。 我们现实地记录，2003也背负恐惧、泪水和愤怒。当SARS疫潮席卷，渭河洪水滔滔，公民惨死收容所……不，我们不仅仅记录，而且感同身受，所以眼里有泪，心里有痛…… 但在谎言中，有勇士挺身而出；在暴力后，有对恶行汹涌的讨伐……这无畏的直言与血的印痕，又何尝不是一个开始？ 所有这些或悲或喜的开始，在不同的层面指向同一个终点：人之尊严与福祉的增进。2003年的奋力与求索，在这路途中为中国大写了两个关键的名词：“公民”与“权利”——它们，原本就相辅相成。 这，也正是我们不休不止关注与祝福的梦想。 携着梦想与祝福，今天与你见面的这张报纸已走过20个年头。 这20年，中国持续激变；我们为变革而生，但关注持续未变：为我们国家每一个进步喝彩加油，为确立市场经济添注加解，为关注社会积弊呐喊张目…… 今天的中国，“政治文明”与“全球规则”成为新时代的关键词，那我们也毫不讳言对“政治”的兴趣，因为这关乎众人之事的政治，关乎国家之进步，关乎民生之改善，关乎民族之复兴；我们关注政治的方式，一如媒体的天职，忠实地记录，公开地陈述，理性地评说。 对于时代的进步，尤其是对于所处的这个民族在所处这个时代的进步，我们欣然落笔，化为墨痕；虽然前路或许多艰，但对这朝着阳光方向的生长，我们努力地鼓与呼。 但记录不是记录的理由，关注也非关注的终点。我们对于这时代变革的每一次喜和忧，最终都只有沉潜于人的层面才有价值。生活要多样化，经济要市场化，政治要民主化，这是一个古老文明要重焕青春的步伐和必然诉求。 所以20年来，当你在会场陈言，在书斋握笔，在农田挥汗，在工厂劳作，在校园诵念……我们将你的故事告诉他，将他的故事告诉你，将中国的故事说给中国人，也说给世界听；要让书斋知晓江湖事，也求民间参知庙堂言。 这个国家不正是大家的国家吗？我们用真实架一座桥，让言说者不空谈，让主事者不麻木，让刚烈者不偏激，让脆弱者不沉沦，让大家知道大家的心事，也知道自己的方向。 在这一年的开始，我们也祝福自己的梦想，它萌自20年前的那个早春，从此便如春藤一般爬满了我们的心间眉宇。 然则这梦想其实来得更深远，甚至早在100年以前，我们的先辈们面对积弱积贫的中国，他们的梦想就是民族的复兴、国家的富强和人民的解放。 所梦所想，何止20年，其实百年一脉。 但对于中国这个老大的后发国家来讲，每向梦想逼近一步，都要有巨大的付出。 但梦想没有流产，因为正如此，历史每数十年给出一个阶段主题的规律似乎清晰可见：开天眼（西风东渐、启蒙运动）、反帝制（推翻清政府）、求统一（北伐、结束军阀混战）、争主权（抗日、废除不平等条约、建立新中国）、平均地权（土地改革）、改善民生（经济改革），而贯穿其中的就是增强国力和复兴我们这个有着悠久历史的伟大民族。 在中国，这些主题环环相扣，它们赋予今日中国以独特的魅力：每一天都能感知这变革中每一步前进的喜悦。我们愿意相信，这个时代能够成为中国最好的时代，因为它给我们未来以最新的期许。 这个国家对于未来的期许，从理想叙事的乌托邦，到国家叙事的现代化，再到传统叙事的小康社会，共性与个性、出发与归宿间，今日中国也充满着独特的张力与快速节奏。 这种状况将继续于新的时代主题破题启程后。 2003年当被铭记：政府因“乙肝歧视”遭遇行政诉讼、四川自贡3万农民“民告官”，公民依法维权的意识在这里觉醒；前河北省委书记与卫生部长被处理、收容制度被埋葬，公民对公权的监督在这里呈现；北京、深圳甚至内地小城潜江自荐竞选人活跃涌现、“违宪审查”的话题被广泛讨论，公民的政治权利在这里伸张…… 这不仅表明公民意识的成长，更说明在深化与推进经济改革的同时，党的十六大概括的“以人为本”、“政治文明”的新主题正在破题。 今天，这新年的第一天，我们回看一年，回看20年，回看100年———看到我们的兄弟姐妹与前辈，在不同时间留下的眼泪和微笑。就让时间如光，串起这晶莹剔透的液滴，折射出一如灿烂微笑的七彩虹谱，照亮你的前路和梦想，中国！ 2005年新年献词：站在民意的泥土上 这是你的光荣之路 我们又一次向你祝贺新年。在这个时刻，我们祝贺你新年快乐，祝福你有好的运气，也祝福你得到鼓舞，相信自己的似锦前程。 我们还有两天时间，作别2004年。我们也有时间，纪念那些在中国的建设之路上辛劳走过的人们。 站在民意的泥土上，我们向那些身居庙堂深处却不忘民瘼的人鼓掌。当他们掀起审计风暴，促进吏治清明时，人们还只是谨慎地表达自己的敬意；可是当他们不为成规所囿，在改革的进程中破冰前进时，我们却要朗声说出心中激赏。我们要为我们的国家在过去的一年所取得的成就大声喝彩。同时，我们也纪念一些小人物，宝马彩票案中的不服输的刘亮，以及嘉禾拆迁事件中那些愤怒的市民。纪念这些不愿放弃自己的利益的普通人，尽管他们取得的只是或然性的成功，却促进了这个时代的文明进程。 我们期待着有更多的普通人，把其个人的生涯与历史的嬗变、时代的进步融汇到一起。这是个人的幸运，更是公众的福祉。 纪念每一个援助了贫苦阶层的富人，也纪念每一个敢于维护法律尊严的平民。纪念那些在价值观多元的年代里保持了学术品格的知识分子，他们的光彩不在于提出洞见，而在于留恋真理。纪念那些为公共利益而奔忙的组织和个人，每当在夜色中默默奔走，他们的光荣之路就是中国的大街小巷。 只要你致力于参与推动中国的文明进程，这一年就是你的光荣之路。 辉煌的殿宇与低矮的茅屋，都迈着同样的匆匆脚步，在这个变化迅速的年代，我们大家都珍视最朴素的良心。 我们纪念这一年的荣耀，也纪念这一年的甘苦。纪念中国在雅典奥运会上取得的巨大成功，也纪念人们为了这成功而付出的巨大代价。我们难忘经济发展给人们带来的欢乐，体会广袤大地上农民增收后的喜悦，也难忘这一年里发生的各种悲剧。我们纪念密云惨剧、大平矿难、铜川矿难、包头空难等等事故，尤其是那些本可避免发生的灾难。 没有哪一年的安全事故，像今年这样引人注目。而临近岁末发生在印度洋的地震海啸，更让人对自然灾害保持警惕。在这新年时候，我们祈祷逝者的灵魂永得安宁，祈祷他们的家庭走出阴影。 只有建设一个更安全的环境，才能抚慰这些家庭的伤痕。人们早已清楚独自一人不能温暖，独自一人不能欢乐，更早已明了没有人是汪洋中的孤岛。纪念那些罹难的矿工，他们的悲剧也是我们的悲剧；他们的离去，也正是我们的社会的损失。 不要让任何人无辜而死，无论是为了国家能源还是个人金钱。 我们的国家与人类的其他地方没有什么不同，它也在走向文明；这里人们的生命与全世界人的生命也没有什么不同，它们同样珍贵。凡在阳光照耀下的，都是蒙恩的国度，都是蒙恩的生命。我们纪念这一年的灾难，只是为了人们不再承受本可避免的戕害。 我们要再一次感谢生息在这国家里的建设者，他们在祖先居留过的土地上创造奇迹，又勇敢地品尝着祖先从未品尝过的欢喜哀愁。 这是2004年的年终时节，这是美好的一天，我们纪念每一个在这一年里承担了自己的责任的普通公民。 纪念那些不知其名的普通百姓。当他们年老力衰，只能依靠低保金生活，依然能够相互扶持；当他们遭逢灾祸，贫病交加，依旧笑对人生；他们依然辛勤抚育了自己的儿女，默默地寄寓着微小的希望。 我们纪念所有这些人。祝福这些人，也祝福我们自己。祝福每一个为自己奋斗的人，祝福每一个为他人的利益而努力的人，你们会让后人说：为了文明，为了公义，为了幸福，在那一年里他们曾经竭尽所能。 我们祝福你的未来，因为你也是他人的前途所系，我们祝福你平安喜悦。我们还要祝福我们的国家，因为她是你我全体中国人的命运所系，我们祝福她高歌猛进，顺利前行。 2006年新年致辞：一句真话能比整个世界的分量还重 今天我们又一次向你祝贺新年。这一天我们洗掉过去一年的征尘，和你一起敞开心灵，重温往日的憧憬。这一天我们在广州大道中289号的高楼上，打望着南国天空，怀想着一年来我们这个国家走过的历程。这一天我们擦拭信仰，心灵安宁，如在世界开创的第一个早上。 在此之时，我们想起了一句难于忘怀的话语。它是36年前一位作家说的：“一句真话能比整个世界的分量还重。”新闻会过时，纸张会变旧，油墨会模糊，甚至信任也会偶尔消弭，只有真实、真诚才把我们的心灵与你的心灵联系到一起。 我们默诵这个宝贵的句子，因为它就是我们的情感，我们的伦理，我们理应担当之事。它温暖过你的心，也一直种植在我们的灵魂里。不是每一天，每一个人，都可以闪出光亮。不是每一天，每一个人，都可以热烈燃烧。但是很多人在发展着纯正的品格，让它无声地生长，直到更多的人闪出光亮，更多的人热烈燃烧。 一句真话能比整个世界的分量还重。在这岁末年初，我们要和你一起说，让我们更有力，让我们再前行。这是因为，我们愿中国更有力，正像在过去一年中实践科学发展观——这一凝聚了无数成功与失败的经验教训的结晶——推动社会进步与发展，所取得各种可贵的成就；我们愿中国再前行，消除在过去一年中仍未完全消除的积弊。 过去这一年，我们的国家迈向了自鸦片战争以来最接近实现民族伟大复兴梦想的历史关口。这一年，经济高速发展，人权保障切实进步，政府推出各项举措，大利民生，疏通价格体系，完善社会保障制度，打破城乡壁垒等等，这些都使我们为之自豪。而这一年，对改革路径的反思空前醒目，在效率与福利公平之间，如医疗体制改革和教育体制改革，政府和公众都在审视何为合适的平衡。更加社会主义，更加市场经济，我们的改革有望更加到位。 我们愿中国更有力，再前行，进一步加强和改善政府公共管理——完善民主法治、规范利益博弈、精简机构转变职能、消除腐败、提高行政效率、促进教育、文化、科研体制的合理化…… 我们愿中国更有力，再前行。我们梦想着这样一个国民集体的出现：他们既拥抱物质生活，又体认精神世界；他们现实，但有梦想；他们精明，但有坚持；他们富有激情，又尊重规则和秩序；他们以幸福为生活的首要目标，又不摒弃远见；他们仁爱，但不软弱；他们勇敢，但深知尊重法治、和谐宽容、和平和解的可贵。他们是尽责的公民，共同构造一个日渐和谐的社会。这是因为，我们没有其它家园，这个国家就是我们的家园；我们没有其它梦想，这个民族的梦想就是我们每一个人的梦想。 一句真话能比整个世界的分量还重，每一个人的幸福比整个世界的分量还重。我们可以永远没有新的梦想，如果这个梦想你已经达到；我们可以永远没有新的成就，如果这个成就在你的手中完成。我们祝你新年快乐，相信你的明天会更好。 2007年新年致辞：从今天起，我们更要彼此珍惜 这是2006年12月28日，时光的渡船穿越三百多个日子，穿越大江南北，又回到岁末终点，将开始新的轮回。 这是2006年的渡轮，这一年的中国潮起潮落，令人感慨万千。 这一年，中国经济继续一骑绝尘快速向前，国家实力明显提升。东盟十国聚首广西，中日突破多年坚冰，中非论坛“所有通往非洲的路都要经过中国”，中美战略对话驱使白宫三分之一的首长齐聚北京……世界，终于看到一个在和谐中崛起的中国。 这一年，房价续涨，股市翻身。欲望浮现，热度升腾。有人欣喜，有人踌躇，有人叹息。纸业出身的张茵成了中国女首富，自由市场的活力造就了一个个财富传奇；楼宇预售处前排起了久违的长队，不甘做房奴者，却一个个被迫做了房奴；毒多宝鱼、红心鸭蛋、欣弗事件，局部领域的失范频频示警，规则重建迫在眉睫…… 这是2006年的渡轮，坐在船上的人们，冷暖自知。她承载的是人民，穿越的是时代，经历的是中国。面对人民，我们常常觉得有千万种方式来表达，有时却沉默得无话可说。 这一年，最高层关注民生，我们看到了对百姓的珍惜。这一年，千年农业税成为历史，中西部农村中小学学杂费全免，以公平为指向的新医改制度正在紧锣密鼓地设计。熊彼特说，一个国家的财政支出就是她的意识形态。诚哉斯言。 这一年，虽然历经波折饱受争议，物权法毕竟已进行史无前例的第七次审议，对私产的保护早已深入人心。入世初人们颇含忐忑，但在入世第五年，全面开放与融入世界早已成为不可逆转的潮流。 这一年，我们不停地问自己，我们拥有一个怎么样的中国？ 经过百年激荡，三十年变革，这是一个越来越融入世界大潮、却又相伴着许多难题的中国。 这是一个背负着沉重的历史包袱，但又始终顽强地向上生长的中国。 这是个全社会深深地被各种欲望搅动，但同时又发自内心地渴望和谐、正义与真实幸福的中国…… 这是2006年的渡船，一条阔达九百六十万平方公里的渡船，因此，我们不得不彼此珍惜，因为我们彼此相连。 我们不得不问自己，是否忘记对那些无助者表示善意与怜悯。 我们不得不问自己，是否因为恐惧和冷漠，而不敢对不平事发出一声呐喊。 我们不得不问自己，是否忘记怎样去对朋友表达爱，甚至也不习惯对我们的妻子、儿女、父母去表达…… 这是2006年的渡船，载着梦想和期待，将要重新上路。这时候，请让我们祝福你，朋友。我们彼此有情，互道珍重。 让我们再次上路，愿你我、愿这个国家一路平安，路都通畅，桥都坚固，隧道都很光明。从今天起，我们更要彼此珍惜。 2008年年终寄语：常人的悲欢，常识的力量 岁暮天寒，你不得不惊讶，我们刚刚度过了多么传奇性的一年，而这一年的喧哗、幽默与彷徨都还余澜未了。在一个简单至极的问题上，因为不想被愚弄，“打虎网民”们在网络上持续地质疑着、嘲弄着。这场行动看上去似乎浩大而无聊，似乎消耗社会的精力，似乎遮蔽了真问题，却有着高度的中国式合理性，最终达成了庄重的效果，促使权力放下架子正视事实。 这也是属于正剧的一年，真正值得为之举杯庆祝的一年。年终时节，海沧PX项目宣布迁建，厦门市民的绝地反击终获成功。一场儿童节的散步，持续6个月的坚持，配合厦门市政府充满智慧的回应与利导，成就了2007年最不可思议的民主童话。 正是这些最平常的人们，在这一年，用他们的智慧证明了民意终究不可违背。正是这些最平常的人坚持说：等一下，你忽略了我们的立场。正是他们促使这个匆忙逐利的时代为民主、为常识而驻足沉思。 像以往一样，中国这艘巨轮穿行在全球化的劲风之中。这一年最可喜悦之事，在于中国民众的行为已经证明，他们在开放进程中收获的思想更多于利益，民主与民权等普世价值不仅被中央高层强调，还越来越被各阶层的人们视为理所当然。这一年，中国的任何涓滴进步都基于权力对平常人的敬畏，基于国家对常识的回归。 岁暮天寒，你不得不惊讶，在重庆，一幢因锱铢必较而产生的孤独矗立的危楼，竟然成为了一个经典的象征、一个奇迹和一座民权的堡垒。在“最牛钉子户”得到了广泛支持的背后，正是人们在捍卫着自己对私有财产交易价格的谈判权。当强迁已成往事，姗姗来迟的常识正是文明的真义，民权的背后更是民利。 重庆市政府在事后收获的诸多好评，又证明了民众愿意慷慨地嘉许开明的执政者这一素来不变的常理。 在北京，医改八套方案的博弈，农村义务教育真正成为国家义务，是基于现代政府的自我回归；最高人民法院收回死刑复核权，是基于一个文明社会必须尊重生命与慎杀的常识。在中央政府层面，官员的任命更为多元而不局限于执政党内部，亦可显变化之微，知公共管理常识之著。 同时你也不得不感到遗憾，这一年不是每个平常人都受到平常的对待，不是每个常识都受到了尊重。 岁暮天寒，你不得不回忆，在7月，豪雨袭击中的济南银座商场有市民死难，而参与灾情讨论的女网友“红钻帝国”竟然因言获罪。如果这个社会每做对一道现代文明给出的题目，就要由多次的错误作为陪伴，那么它的进步就还不够快，还不足以温暖普通民众们的心怀。 进步，一定要快些，再快些。今天，当我们说起中国是一个伟大的国家的时候，并不只是说它有着深邃的历史和文化，更是说这里生活着一些最平常的人，他们有着一个质朴的中国梦：不要让任何一个纳税人享受不到应得的公务服务，也不要让任何一个辛苦工作的人受到不公正的待遇。 2007年，比照一些不幸的先辈，即便在最贫瘠的乡野，中国民众的自尊也已经不再麻木。他们知道自己面临着纷繁复杂的问题，他们期待着社会的进步。 岁暮天寒，你不得不想起，这一年，当一位英国记者驱车中国西部遇到一位中国农民并问他最需要什么时，农民回答说：“尊重。” 对于平常人来说，这是辛苦的一年，对于赢家们来说却是金碧辉煌的一年。从来没有哪一年，福布斯中国富豪榜上的财富数字获得了如此惊人的爆炸性增长，也从没有哪一年房地产商们的集体上榜如此令人目眩。对于经济社交生活来说，这也是觥筹交错的一年，与权力愈接近者愈强大，普通人的利益则在某种程度受损，这意味着资源和机会的垄断者阻断了更多人的幸福之路。 当中央财政收入预计达到惊人的5万亿元时，人们期望着分享国家发展的成果，期望着服务型政府的建成。 人们期望着经济改革路径的调整，政治改革路径的延展。人们期望着效率，也期望着公平，期望着民主，也期望着法治。人们期望着常人的悲欢成为国家的悲欢，常识的力量成为国家的力量。 他们也期望着，物价飞涨之时，有公平的机会让人们去应对。“跑赢CPI”成了2007年的时代最强音，可是在城市中间阶层当中，个个跑得累，谁人跑得赢？没有什么比这更让人丧失希望——当一个双手劳动的人鼓足勇气站到售楼处前，却发现房价数月的涨幅就已经把他多年的辛苦化为泡影。 岁暮天寒，你不得不注意到，失望会造成精神的迷茫。你不得不期待，社会精神的实利主义化不再加深。 一个国家必须有价值洼地，便于人们走入获利；一个国家也必须有精神高地，便于人们登高眺望。洼地与高地的形成，都有赖于机会平等的体制建设。如果相应的机会被垄断，不曾寻求与权力对接的平常人，就只能望价值高地而兴叹，见精神洼地而沉溺，他就既不会拥有财富，也不能享有精神生活。岁暮天寒，人们在期望，这个国家的一切制度都以普惠于民为依归。 我们刚刚度过了多么传奇性的一年。常人的悲欢日益成为国家的悲欢，常识的力量日益成为国家的力量。我们要回望这一年。这漫长而又不容易的一年。 2008年新年献辞：愿自由开放的旗帜高高飘扬 帷幕徐启，灯火璀璨，在二00八年的世界舞台上，中国已然站在中央。闸门洞开，浪涛汹涌，在历史洪流的席卷之下，你在哪里？这是一个大时代的派对年，一个大中国的狂欢夜。抬眼可见，奥运倒计时牌上的数目飞速递减。耳边隐约传来那个老人的声音：“你们要冲出一条血路来！” 蓦然惊觉，改革开放三十年了。 这两件事情，看似各不相干，其间却丝缕相连。 这丝丝缕缕中的一条，曾异常清晰，最近又被大声呼唤，那就是：思想解放。 三十年前的月亮，照着一个国运彷徨、民生凋敝的中国。 一个大钟停摆了，另一个闹钟响起来。铃声急促而动听，饥肠辘辘的人民，突然都红光满面。在一场真理标准的大讨论中，两只猫杀出重围。一只是白的，另一只是黑的，它们吃掉了“两个凡是”。人民跟着两只猫，走进了家庭联产承包的土地，走进了个体户的摊位，走进了民营企业家的办公室，走进了股票交易所，走进了互联网空间。 这时候人民已不再是一个空洞的符号，而是一个个具体的人，一个个第一人称，我和我们。我们能感知温饱，还能开动脑筋，发出各种不同的声音。我们鼓足干劲，力争上游，多快好省地建设自己的家园。 我们还去了一些别的地方，比如政府大楼、法院、报社、电视台、学校、电影院等等。有时被请上座，有时被赶出门，有时被赶出门以后又被请上座。 反反复复之间，我们在成长，社会在进步。 成长的方向是独立人格，进步的标志是自由宽容。 整齐划一的运动越来越少了，参差百态成为幸福的本源。 五千年的古文明，三十年的大变局。变局之中，泥沙俱下。有些目标甚至越来越远了，有些方向越来越模糊。 如果要问究根由，乃个体之还不够解放，思想之还不够自由。 三十年间，我们逐渐学会了正眼看世界，发现天下之大，无奇不有；更发现千奇百怪，不离其宗，那就是和平与发展，民主与自由，还有人的权利。 人类共有的精神遗产，不该由他国独享。 何况我们遇到了全球化。它把普世同一的游戏规则摆在我面前，希望我们珍惜。我们签署了人权公约，加入了WTO，出席了八国峰会，也申办了奥运会。那照亮古希腊奥林匹亚村的阳光，也将同样照亮北京紫禁城。 那些来自西方的运动规则、和平理念和欢乐精神，也将同样进驻我们的内心。 如果我们为五星红旗感到骄傲，那么也可以为五环旗感到自豪。 毫无疑问，没有三十年来的思想解放、观念嬗变，就没有二○○八年北京奥运会。 而人们又希望奥运会的火炬，能为中国传递更多的文明梦想。 从来没有像今天这样，中国和世界的距离如此之近。从来没有像今天这样，中国和世界的对话如此之多。 越来越多的人将会知道，奥运会是全民的动员，集体的狂欢，更是个体的奋斗，是灵魂的舞蹈。 奥运会带给我们的，将不仅是比赛成绩，还有更好的空气；将不仅是更多的商机，还有更多的欢乐和自由。 我们也该同时记得，二○○八年是戊戌变法一百一十周年、“大跃进”五十周年。 这两场历史悲剧，是思想解放的别样版本。 那场由一个开明皇帝发动的、自上而下诏书纷飞的改良运动，以上层官僚的倾轧和宫廷政变而告终。 一百一十年后，“戊戌六君子”的鲜血仿佛还在当空喷涌，它仍然是一本浓缩的政治教材，上面写的并不仅仅是权力斗争，还有关于民众思想和社会结构对于改革的影响。 而五十年前，高层领导也曾号令解放思想，大胆想象，结果浮夸风起，资源耗尽，饿殍遍地。那是一种没有灵魂的思想，没有个体的解放，民众被绑架成为政治荒诞剧的道具。 三十年前，思想解放释放了个体能量，渐得温饱；十六年前，胆子再大一次，民间沸腾，创造了世界经济的奇迹；如今继续呼吁思想解放，当深察历史，反思改革，激活社会，科学发展。 二○○八年已经开始，中国闪亮登场。 你在其间，独一无二，不可或缺。 无论你是何种角色，都不要被历史的大潮淹没，或者冲刷去你的独立存在。 至少你要在大时代中做个坚强的小人物，在狂欢夜中做个自由的舞者。 2009年新年献词：没有一个冬天不可逾越 当经济危机带来的一丝隐忧弥漫在心头，当寒风吹动落叶而雪的消息从北方传来，在这新年的第一天，请让我们倾听一个久远的声音。十年前的今天，本报发表了1999年新年献词《让无力者有力，让悲观者前行》。今天，当南方周末致力于新闻专业主义之路时，这句标题仍是我们精神的圭臬，我们勉力继承其志，并视之为伟大的传统。中国已经度过了激流般的十年，多少繁华事，已付笑谈中，可是这句箴言仍然在每一个新年来临之时嗡然回响。 因此，在今天，让我们在这最单纯和美好的精神传统中相逢，让我们在自己的内心中汲取力量，寻找最热诚的信念。让我们继续前行，因为这是我们的责任，因为我们是社会的中坚。 这就是为什么在汶川地震发生之时，无论我们身在现场，还是在千里之外，都曾感受到举国一致的悲伤；在北京奥运会举办之时，无论我们是中产阶层，还是贫寒之家，都曾体会过壮美场景带来的欣喜；在三聚氰胺奶粉事件发生之时，无论我们为人父母，还是尚无子嗣，都曾拍案而起，怒不可遏。这是因为中国是一个整体，我们休戚与共，须臾不曾分离。这是因为我们是社会的中坚，因为扪心自问之时，我们发现自己对人的爱无可置疑，对国家的爱无可置疑。 当我们扪心自问之时，我们心中对这个国家深挚的爱已经给了该如何行事的答案。 这就是为什么我们不只赞美国家的进步，也批评它的不尽完美；为什么像捧着烛火一样捧着“真相”，在群论汹汹之际也坚持独立的立场；为什么若我们只能发出荧荧之光，也有崇高之意。 这也就是为什么你会在今天买下这份报纸，而它没有提供可供获利的消息甚至也不提供什么消遣。 这是因为我们是理性的爱国者。经历了地震的悲痛，经历了奥运的盛况，经历了30年改革开放之后，我们已经成年。当我们在这新年的这份新闻纸上相逢，我们已是社会的中坚。 在这个时候，让我们回想，30年前，在改革开放之初的羊肠小道上，我们的父辈荜路蓝缕，何其艰辛。他们经历了多么复杂的年代，走过了多么长的路。今天，他们结束了对国家的使命，头发斑白，回想着自己与同辈如何开创了这个世界。我们的孩子生活在一个比过去更好的世界，我们可曾想过他们有权利生活在一个更好的世界？是否有一天当他们追问我们的故事，我们可以说，我们没有推卸责任，不负历史的托付？ 这就是为什么我们不能犬儒，不能抱怨“那是不可改变的”。这就是为什么我们要寻找最热诚的信念。这就是为什么我们望向历史深处，回忆这个国家在一百多年来的兜兜转转。因为我们是社会的中坚。 越是望向历史深处，我们就越是坚定。是的，我们要毫不游移地支持那些人类共同的价值。我们支持进步、民主、自由、人权，支持中国走向现代文明。我们可曾忆起，一百多年前，先贤们发现故步自封于本国文化已不足以救亡图存，因此埋藏了心中痛苦，远渡重洋，以寻求国家振兴之道？因此西风东渐，建兵工厂以御外侮，建学校以期未来，建报馆以开民智，因此德先生、赛先生给这个古老的国家带来了复兴之光。在这漫长历史的此端，我们可曾想过这个国家的希望从何而来？我们可曾想过，如何延续这希望，以不误国家和人民的前程？ 这就是为什么我们坚持让各种社会力量进行公正博弈。这就是为什么我们呼吁中国的改革开放之路超越集团利益。这就是为什么我们支持继续深化改革。这就是为什么公正、公平是我们必须达到的目标，无论发生什么；为什么国富民穷的趋势需要彻底扭转，无论要做多么繁复的工作。 一切都因为，历史的接力棒已经在我们手中。我们是社会的中坚，不是因为我们身在高位，不是因为我们资金丰足，不是因为我们聪明绝顶，不，我们甚至并不比任何一代中国人优秀，只是我们有此机会。我们有一个机会把中国变得更好，我们有一个责任把中国变得更好。我们不能彼此耳语，而要朗声合唱，这歌声要求着国家与人的共同幸福，从一百多年前而来，回荡今时今日。 这就是为什么我们要相信自己的使命，让无力者有力，让悲观者前行。这就是为什么我们必须了解真相，不能坠入一个失真的世界。这就是为什么当我们讲述自己对国家的爱时，可以平静、深邃和坚定。 这就是为什么我们既不随波逐流，也不凌空虚蹈；这就是为什么我们要做现实主义者，求应然之事。 因为在这个大陆上，太平洋以西，当新年的熹微曙光笼罩大地之时，我们要对这个国家负责。当我们看到它辽阔的天空，看到天空下一条条曾被地震折断的令人难以置信的巨大的山岭和阡陌纵横的土地，繁华都市和出产古老谷物的土地，以及在这个国家中来来往往的沉浸在梦幻中的人们；当我们的孩子将出生，在夜色中发出柔弱却嘹亮的哭泣声；我们会知道，没有任何东西比一个信念更为珍贵，也从没有任何一个时代有如此之多的困难，有如此之多的希望。 2010献词：这是你所拥有的时间，这是你能决定的生活 新世纪已经过去十年了，我们并不想神话什么数字，我们要说的是，时间里包含着一些东西。 我们也不想神话某一个时间节点，正如十年前全世界的媒体都去追逐新千年的第一缕晨曦，仿佛不知道太阳每天都会升起、日子每天都是新的一样。但是我们总是要找一个机会向你表达问候，所以因袭十年来的传统，在新年来临之际，祝愿阳光打在你的脸上。 我们也没有必要神话阳光。阳光下有美丽的春暖花开，也有罪恶的杀人越货。我们借助阳光和鲜花来给自己打气。我们是那么脆弱，但是我们必须坚强。 我们也不要神话坚强。英雄固然令人敬仰，但是芸芸众生大多是普通人。物价降了我们就高兴，工作丢了我们就犯愁。遇到坏人我们会害怕，警察来了又怕他不守法。就像花朵依赖春天一样，我们依赖这个社会。有时候我们的眼睛是雪亮的，但大多数时候我们不明真相。给点阳光我们就会灿烂，房子拆了只有极个别会去自焚。我们生活在一个平凡的世界里，期待最平庸的人也能得到幸福。 我们还是来说说十年吧。十年时间足可以诞生一代人。他们被称为00后，会被贴上一些标签。不要神话这些标签，他们和父辈一样会生老病死，一样面对社会的善恶美丑，一样需要勇气和担当，也一样会徘徊于软弱和坚强。他们不是拯救我们的天使，我们也没有理由扮演魔鬼。 这十年来经济腾飞，国力日盛。国内生产总值当年不到十万亿，如今已经超过三十万亿。我们是第三贸易大国，但是我们占第三十以后的选项也还不少。十年来建了那么多房子，也拆了那么多房子。当然，有人提醒说要看到建设是社会主流，那是千真万确的事实。但是每一条支流都不能抛弃，每一个个体更值得关注。每一个人的快乐都不可替代，每一个人的痛苦都渴望理解。 十年前我们正在争取加入世贸组织，还不知道可以举办奥运会和世博会，如今我们已经在G8会上一言九鼎，在哥本哈根出演主角，在东亚地盘上一枝独秀。但是不要神话大国崛起，我们小时候就听说周总理在国际舞台上叱咤风云。按照过去的思路，崛起意味着担当，我们能否引领人类文明？想想未来的变化，民族国家一定会有新的发展，我们总会明白一些基本的道理：大舅二舅都是他的舅，大国小国都是我的国。 十年前互联网的泡沫还没有吹起，一些今日忙碌奔波的大人物还闲得发慌，整天往模样单薄的BBS上灌水。今天我们已经可以手机上网，博客遍地开花，twitter一往无前，网络购物前景无量，网民反腐也所向披靡。但是不要神话互联网，没有网络的时代仍然建立了新中国，世界上的民主与自由大都要比网络出生更早。网络是我们生活不可分割的一部分，它可以是黄色的，也可以是红色的，还可以是绿色的，也可以是多姿多彩的，想要什么样的生活取决于我们自己。 十年来我们经历了太多的灾难。从SARS到汶川地震，从松花江水污染到三鹿奶粉掺毒，从拉萨和乌鲁木齐的暴力事件，到全国各地的矿难，一次又一次地，总有一种力量让我们泪流满面。不要神话灾难，它们就是灾难。有人说真高兴我们总算挺过来了，但是不要忘记那些没有挺过来的人，还有那些正在挺着甚至永远都只能挺着的人。 亲爱的读者朋友，下一个十年又要开始了……没错，这个说法没有意义。我们只是想要告诉你，这是你所拥有的时间，是你生命中无可逃避的又一段历程，假如你愿意的话，你可以用它来做很多事情，你可以找到你想要的生活。 2011年主编寄语：让每个中国人都金贵起来 这是2010年的最后一个星期四，也是《南方周末》这张报纸今年最后一期与你相约的日子。再有一天，我们就将迎来新的一年。这个世界有一个和星期四绑在一起的节日叫感恩节。最接近新年元旦的这个星期四是属于我们的“感恩节”。我们仅以此文奉上新年的问候。 我们向你感恩。过去的一年，亦如曾经的二十六个春秋，我们早已习惯了从你那里积聚再次出发的动力，习惯了从每一次的倾听、观察、交流中感悟个人的命运、社会的脉动、国家的方向。所以，“感恩”不只是纸面上的一句话，更是我们的一份承诺：我们会尽责地体会你的快乐，分担你的伤悲；我们承诺，新的一年你依然能从这张纸的字里行间发现我们的热血、眼泪和汗水。 我们也感恩这个国家带给国民的荣耀。2010年，当全世界大多数国家都在经济危机的阴影下如履薄冰般地复苏之时，中国则继续着她史诗般的高歌猛进：GDP跃上世界第二，半世纪前那句“超英”的口号终于不再只是望梅止渴；中国在一年内举办了世博、亚运两项盛会，并将它们推上了各自的历史新高；中国政府对抗经济寒流的大气魄，还有它的大手笔让世界上众多的政府感到艳羡……“中国模式”、“G2”这些高帽飞来了一顶又一顶。更重要的是，在发生争议、冲突的国际场合，比如钓鱼岛，这个国家越来越知道，国民的生命与安全应该排在第一位。 我们更加感恩于我们的国民。在玉树，在舟曲，在上海，他们的不屈、坚持、互助与爱心，让曾经疏离的人心贴得更近。宜黄拆迁、渭南书案、跨省追捕、度身招聘……是一个一个的普通人迸发出最大的力量，尽可能突破一切公开的、隐性的束缚，刷新着这个国家的公共议程，改变了一个个遭受不公的小人物的命运。关注就是力量，围观改变中国，最大的意义在于，它让我们更加清醒地认识到，我们所向往的公平、正义、尊严、幸福和世界上其他民族并没有什么不同，我们国民的生命也同样金贵。 2010年或许是一个重要的历史进程之中的关键一年。这一年里，伟大的国家与渺小的个人正在向着它们之间的一个和谐点迅速靠拢。它消减了国家层面的宏大叙事的魅力，那些令人目眩的统计数据，那些彰显国威的盛事，远不如带给国民最切实的福祉更能得到发自内心的认同。个人的权利意识正在加速生长，越来越多的人愿意参与跟他们切身利益相关的国是讨论；乐意对所有的社会热点发表看法，并被人关注；敢于对一切的社会不公表示不满，进行抗争…… 我们对此感到由衷的喜悦，这是一个自然发展的过程。在成功地解决了人们的最初级的生存需要之后，我们的社会、国民已经在向着更高的需求，即对权利和尊严的需求迈进。这意味着已经持续了三十多年的改革，再次站在了一个重要的历史选择关口。这一次，它需要把大写的人放到压倒一切的高度。强拆、截访、官员贪腐、官富二代的骄横对平等、对权利、对人心的践踏必须遏制，社会分配不公所累积的社会紧张必须得到有序释放，让每一个中国人都金贵起来。要达到这样的高度，仅靠经济领域的发展与改革是不够的，这需要包括政治、社会、文化在内的整体性改革，如同中共中央在“十二五”规划所表达的那种急迫性——“必须以更大的决心和勇气全面推进各领域改革”。 2010年年末，“涨”四年内第二次获评年度汉字。我们真心希望国家能越来越强盛，更希望每一个中国人越来越金贵。至于物价，还是涨得尽可能慢一点吧。毕竟，免于恐惧，先要免于匮乏。 2012年新年献辞：像一束光簇拥另一束光 我们再次赋予时间以壮丽感，这是我们和你在这个崭新年头的第一次见面。太阳照常在黎明升起，从辽阔幅员的霜雪和晨露间升起，从每一桩生老病死和柴米油盐间升起，从远方潮湿的枕木和卧室窗玻璃上的冰花上升起。无论身在何地，愿你在这个清晨，分享这份光亮。 没有哪个黎明能阻止阳光。在又一个新年，我们迎接正义与真相的光芒。你看到动车调查报告宣告出炉，看到商业系统红十字会终被撤销，看到乌坎村即将迎来属于自己的村民代表……这是这个国家向前的步伐，这更是属于你我的荣光，因为每一个渴求进步的个体都为之贡献了力量。平凡真实的生活中，能动的个体执拗地站立于每一寸坚实的土地之上。 你看着他们愚公移山，将旧规则改变，让新价值诞生。希望从人心的地平线升起，一寸寸照亮大江南北。这平凡的生活，因为他们而不再平凡。能被他们感动，每个人的心也终能散发光芒。伸出双手，你不仅点亮自己，也温暖周围。 这是一个亟需正义的时代，而你对权利的坚守就是正义之源。从年初的乐清，到年终的乌坎，公民为土地和自治的权利奏出了时代的最强音。“任何人都无权剥夺”——2011年，庙堂之上的诸多言说体现出为政者应有的光彩，切中斯土斯民的肯綮。我们乐见政府诚意回应，打开良性互动的空间。我们希望宪法声如洪钟一言九鼎，正义公正照耀每一个人。 大转型的中国，已然走到这里。一切都奠基于权利。权利摇晃的国度，决不可能固若磐石。哪些不容侵犯？什么不可剥夺？何处是光？哪里是影？光线被遮蔽之处，理性就难以生长。这便是为什么我们不辞辛劳追寻真相，这便是为什么我们不遗余力追问究竟。而真相的呈现、权利的稳固，有赖于每一束光，有赖于每一个人——不管体制内外，无分男女老少。 我们不再一己呢喃，也不满足于窃窃私语。我们要让声音在阳光下汇聚。越来越多的人不惮于我口说我心，才是希望之民族，才是强大之国度。 如此，才能智者蜂起，百家争鸣，让思想的光芒肆意照射。 如此，才能勇者辈出，齐头并进，让实践的理性改变现实。 思想的光芒正在重生。从曾经的枯竭僵化走向人性复苏，从新左派与自由派之争到2011年的宪政辩论。从哪里来？到哪里去？应该且能够做什么？一百七十年来，中国社会从未像现在这样，认清自己的路向。 行动的理性正在重生。我们反省内心，从不可遏制的良知出发。我们埋头向下，从自己开始。我们正在建设一个生机勃勃的公民社会，以张扬人性微光。 这光微而不弱，足以充塞天地，烛照人间。 这光不在远处，就在当下。你体认内心光芒，权利已在其中，责任已在其中。你活出尊严来，那些想为你做主的人就脚脚踩空。光明前进一寸，黑暗便后退一分，这道理简易明白。而你，至少可以点亮自己，一切只要无愧于心。 点亮自己，便不会妄自菲薄。此处点亮一束光，上天总会在某处打开一扇窗。我们只用求应然之理，做分内之事；虽千万人吾往矣，知其不可而为之。 点亮自己，权利便能着床，能动的个体由之生焉，公民由之成焉；点亮自己，权利便会团结于权利，公民社会由之生焉，制衡权力的力量由之成焉。 公民强大，社会才会强大。社会强大，公民的尊严才得以保障，每一个个体才能够主动参与国家的制度运转。人们深爱自己的国家，只因她能保障正义与安全，只因她不断由公民们亲手“重建”。国家与公民之间血脉贯通，于是公民的悲伤，成为国家的悲伤，于是国家的荣光，成为公民的荣光。 所以我们不能止步于抱怨，尽管抱怨本身无可厚非；我们也不能沉溺于低俗，尽管低俗是最起码的权利。我们理应成就一个更好的自己——为了成就更好的中国。 我们在一起，就像一滴水融入另一滴水，就像一束光簇拥着另一束光。因为我们知道，惟有点亮自己，才有个体的美好前程；惟有簇拥在一起，才能照亮国家的未来。 2013年新年献词：“我们比任何时候都更接近梦想” 梦想是我们对自己的期许，梦想是我们对应然之事的承诺。 这是我们第一千零五十七次和你相见，也是2013年的第一次。过去、现在以及将来，你守护你的生活，我们守护这张报纸。让我们彼此祝福，愿你我都能够在新的一年离梦想更近一步。 梦想是我们对自己的期许，而这期许常新。我们曾创造灿烂古国延续千年，但1840年的炮火惊醒天朝旧梦，我们始觉昨日之弊。开眼看世界，鼓民力、开民智、新民德肇始于此；变法维新肇始于此；革命共和肇始于此；五四呐喊肇始于此；而南湖游船上的畅想、天安门上的宣告、改革开放的号角，亦肇始于此。 我们对自己的期许从来不能脱离时代的进程；“苟日新，日日新”，唯有融入文明进步的潮流，期许才不会退化为桎梏。 梦想是我们对应然之事的承诺，而我们必须对自己一诺千金。农民从种子里收获一个好年景是应然之事，孩子从学校平安归来也是应然之事；先贤所谓“老有所终，壮有所用，鳏寡孤独皆有所养”是应然之事。 在2012年年末，梦想的火焰又一次被点燃。新任中共中央总书记习近平说：“实现中华民族的伟大复兴，就是中华民族近代以来最伟大的梦想。”这个梦想，凝聚着近代以来无数仁人志士的探索奋斗，蕴藏着中华民族固有的“家国天下”情怀，更包含着中国走向未来的道路自信、理论自信和制度自信，体现了中华民族和中国人民的整体利益，是每一个中华儿女的共同期盼。 站在新年的起点，我们比任何时候都更接近这个梦想。 我们比任何时候都更接近这个梦想，是因为“宪法的生命在于实施，宪法的权威也在于实施”这样的时代强音，因为宪法正是国家对万千生民的梦想所签署的契约。 我们比任何时候都更接近这个梦想，是因为“每个人的前途命运都与国家和民族的前途命运紧密相连”这样的民生承诺。“国家好，民族好，大家才会好”。民族复兴之梦必须将广大人民个人小梦串联汇聚，把国家与人民真正连为一体的承诺正是汇聚的闸门。 我们比任何时候都更接近这个梦想，是因为今天的我们已处于能够兑现梦想的时代。我们梦想权利一一落地，公义自在流淌；我们梦想国家的强大成为人民福祉的保障，让每一个人都从国家的发展中收获自己应得的成果。 兑现这一千一万个梦想，才能祭奠那无数舍身成仁的亡灵；兑现这一万一亿个梦想，才能抚平这一百多年的刻骨痛楚。令人欣慰的是，从新中国“站起来”，到改革开放“富起来”，再到新世纪“强起来”，我们的梦想正在一步步变为现实。 万物速朽，但梦想永在。我们倾听你的梦想，我们期待你敢于做梦：不是杰出者才做梦，而是善做梦者才杰出。我们别无所倚，惟有对期许的追求；我们别无所长，惟有对承诺的执著。 2014年新年献词：从未如此需要浴火重生 今天是2014年的第二天，今年是我们创办这份报纸的三十周年。 每当新年，我们都在这里为你祝福，也在这里向你剖白。剖白是为了沟通，沟通是为了理解，理解是为了共识，共识是为了同行。 我们希望有你同行，但更尊重你选择的权利。而我们能做的，就是努力告诉你“我是谁”。我们认为，在这个众声喧哗而又面目模糊的年代里，这也应成为每一个人、每一种身份、每一个行业的共同努力。这正是我们策划本期特刊的初衷。 我们是南方周末，我们三十而立。 理解以真实为本，但真实不总是会自动呈现。这是国家复兴的伟大时代，也是发展转型的复杂时期；这是信息奔腾的狂欢时刻，也是资讯泛滥的迷离时间；这是英雄辈出的繁华时光，也是以假乱真的可乘时机。社会在进步、社会在变幻，生活在当下、生活在别处，理想在彰显、理想在解构，利益在表达、利益在分化，一切尽在掌握、一切指向未知，人们想展翅高飞、人们要倦鸟归巢。 真实总是那样难以甄别，真实又是那样弥足珍贵。作为一份以真实为生命的新闻纸，我们有时有力，有时乏力，但别无选择，除了努力、专业、有担当地去逼近、追问、表达真实。这是我们与你相依出发的原点，也是南方周末三十年不悔的初心。 但我们绝不仅仅是冷冰冰的记录者，我们内心有爱，眼中有泪。我们的报道一直有立场、有原则、有温度，因为我们对国家与人民饱含深情，对历史充满敬畏。 我们时而宏大叙事，时而犀利评析，但视线从未远离那些在大时代中悲欢沉浮的个体命运。我们从来无意去做先知、导师、法官、卫道士……无意去做其他任何角色，除了一份讲述真实故事、传递人文情怀的报纸，除了一名理性的社会守望与监督者。我们一直努力让自己跟上时代的脉动，但始终铭记“正义、爱心、良知、理性”——它照亮了我们的文字，照亮了我们的脸庞，照亮了我们的前路，也照亮了无数的故事——这些故事组成了我们的故事，我们的故事也是中国的故事。 其实我们很幸运，诞生于上世纪八十年代那个激情燃烧的岁月，见证了当代中国的一次精彩跨越，也使改革开放的精神从一开始就融入了我们的血脉筋骨。 今天，时间再一次开始，国家与民族正在出发。三十年未有的改革宏图正在徐徐展开，庙堂江湖、塞北江南正在摩拳擦掌，有一种似曾相识的共振在我们内心深处激荡，我们感觉自己又一次站在见证历史的起点线上。 我们也期待给自己一个见证，见证一群报人能否在数字世界里延续光荣与梦想。我们看到新媒体已成合围之势，听到四面楚歌正在响起，仿佛只待最后一击。但我们始终坚信，原创严肃新闻不会死，它只会创新阵地。三十岁本是成熟、内敛的年龄，我们却已准备好去新阵地开疆拓土。我们要让新闻理想的大旗在那里依旧高高飘起，让新闻人参与时代进程的荣誉感在那里依旧充盈。而我们深知这是一个需要勇气、智慧与决断力的艰难时刻，在过去三十年，我们有过坎坷、有过挫折，却从未如此需要浴火重生。现在，改革转型对于我们不仅仅意味着理想与见证，更是生存与发展。 我们是南方周末，我们三十而立。 我们希望有你同行，但更尊重你选择的权利。在这个美好的新年里，让我们共同站得更高，立得更直。 2015年新年献词：你对美好的向往关乎国家的方向 光阴之箭已经穿越年轮，抵达2015。 在这个南方温暖的新年元旦里，我们凝望着波澜壮阔的中国，仍然能听到，那些向往美好的心声有如横扫九州的滚滚春潮。 面对新年，人们常认为从此可以放下过去，同时无限畅想未来。然而，过去一直是未来的因果线索，历史也从未真正受到任何人工时间刻度的束缚，它一直自有逻辑。 2014年发生的许多事，可以在2013年里找到缘由伏笔。我们也相信，在2015年，同样还会感受到来自2014年的雷霆万钧。 是的，我们刚刚度过了雷霆万钧的一年。在这一年， 四十多只大老虎被打落在地，他们中包括四名副国级及以上官员。尽管这场被称为“输不起”的反腐斗争早在一年前已显露端倪，但它对国家和民族的深远影响，或许才刚刚开始。 人们往往期盼自己能躬逢一个大时代，但真当身处其中时，又是否有能力完整了解时代的面目与意义？ 当然，这并不妨碍我们要努力在当下绽放真实的自己，就像每一个被历史铭记的大时代，都曾留下过独一无二的生动印记。 刚刚过去的2014，当然还不仅仅只有打虎拍蝇。它确立了“宪法日”，对依法治国、宪法权威表达了信仰与敬畏；它加大了简政放权，鼓励全民创业；它是宣示“我们不惹事，但也不怕事”的一年，它也是一些人在“单独二孩”与生活现实间纠结的一年；它期待新型大国关系成为世界稳定的“压舱石”，它见证美国、香港证交所里中国面孔创造IPO纪录的狂欢；它听着马航乘客的家属悲伤哭泣，它看着昆明火车站的保安持棍救人……它是过去，它也是现在；它是历史，它也是未来。 在这个南方温暖的新年元旦里，我们抚今追昔，因为我们知道，历史一直自有逻辑。 其实归根结底，历史的最大逻辑就是人的逻辑，推动历史前行的最大力量就是符合人民利益。正如2012年执政党做出的庄严承诺：人民对美好生活的向往，就是我们的奋斗目标。 人民就是全体的我们，你就是人民之一，你对美好的向往关乎国家的方向。 你要敢于向往，敢于生活，敢于争取，敢于改变！ 你也要有条件向往，有条件劳动，有条件进步，有条件幸福！ 你还要坚持向往，坚持自我，坚持真理，坚持善良！ 是的，相信吧，世界本应如此。一切的一切，都应从你出发，又归于你。归于你的生活，归于你的生命，归于你的历史，归于你的意义。 在这个南方温暖的新年元旦里，让我们一起来凝望这波澜壮阔的中国。我们要真诚地祝福你新年快乐，祝福你向往美好，祝福你梦想成真！ 2016年新年献词：在巨变的时代相依前行 又是一年过去了，此刻的你无论怅然若失，还是踌躇满志，我们确定无疑的是，你的生活方式已经被悄然改变。 慢慢的，你习惯了视线水平向下45度或更多，习惯了拇指上下左右5厘米距离的游走。这样两个再简单不过的姿势能够产生的联想，可能是一餐饭、一场电影、一张车票、一件电器，也可能是一间房、一部TAXI、一次远足…… 对许多人而言，拇指在手机屏幕方寸间游走的距离，也许超过双脚走过的路程。没人去计算它不经意间吞噬的时间与记忆——看着一年前下载的客户端，你是不是时常会记不得它是什么；面对储存卡突然爆满的照片，也会偶尔疑惑究竟它们拍在何时；公众号关注的越来越多，可能够静下心来打开的却越来越少…… 身边的朋友，不是在谈创业，就是在真刀真枪的写计划书、搞项目。资本狂飙几度吹皱春水，互联网+、大数据、P2P、双创、孵化器、众筹……一些词被高高抛起，一些词却终于悄无声息地沉入水底，仅留下水面波澜。 太多的生活方式不是已经被颠覆，就是正在被颠覆中，当然一个积极的说法叫“迭代”。频繁的迭代声中，于是，一切行业随时都会变成传统行业。跟不上时代是这个时代最致命的挑战，多少坚固如长城的东西已迅速销声匿迹。创业者们则纷纷穿上T恤牛仔，站上演讲台，一个个自称产品经理。 是的，这是产品的时代，是一个强调变化远超以往的时代。百年老店与一夜明星，往往就在翻云覆雨间。戴尔、诺基亚、摩托罗拉、MSN……这些辉煌的名字瞬间就仿佛过眼云烟。 前所未有。这是一个被变化加速快进的中国。过去一年，无论城市中产还是小镇青年，无论社会精英还是草根平民，无不深处这一变局。 然而，在乱花迷眼的新时代，传统社会仍然在按照它的逻辑自然生长。在这一年，延续长达三十五年的独生子女政策终于终结，习马会创造了两岸领导人首度会面的历史，股市让股民大喜大悲了几轮过山车，十三五规划出台让中国未来五年的脉络清晰可见…… 无论身边微末之事的变化，还是宏大的国家时政变化，时代车轮滚滚向前。在快与变之中，在速生与速朽之间，那旋转的万花筒，有一个坚定稳固的内核，它们经历时间的淬炼，依然散发出不变的灼灼光芒：那就是我们对法治社会、公平正义的追求，对经济更发达、人民生活更美好的向往，对仁与义的期许，对更符合人性与人类发展方向的道德律的坚持。 这些不变之物，将一切快和变，护持在人类文明之轨。它们如同我们头顶的苍穹，日升月落，亘古如斯。 变化是表，不变是里。在所有的变化里，却总有一些东西会天荒地老，历久弥新。知止而后有定，激荡之中有静。有静气，然后能谋虑，我们才能积极适应和创造变化，以无愧于这个巨变的时代。 南方周末同样在拥抱这个新时代。无论媒体变局多么剧烈、传播介质如何进化，我们相信，人们永远需要优质稀缺的信息、深刻多元的思想和温暖心灵的情怀。在坚持中创新，在创新中坚持，这是我们不变的信念，也是我们准时与您相见的原因。南方周末移动客户端也选择在今天以一种全新面貌亮相，它代表着我们在变化中的坚守，它让我们在浩瀚的网络世界里继续在一起，逐梦天涯、相依前行。 互联网等新科技像一条巨大的鲶鱼，所涉之处，或静水流深，或暗流汹涌，而这个古老而伟大国家的大棋局，也正在深化改革，创新、协调、绿色、开放、共享，复兴文明，波澜壮阔。大风起于青萍之末，从微观到中观到宏观，牵一发动全身，中国这艘大船，在变与不变的历史洪流中，需要稳健，需要灵活，需要智慧与定力。 在2015年的最后一天，让我们一起重温苏轼的名句：盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也。无论是蜉蝣众生还是宇宙星辰，再大的变化，都只是天地一瞬。而不变的，是人类文明前行的身影。 2016，让我们继续相依前行！ 2017年新年献词: 锚住幸福，穿越这时光之海 滑动手机屏幕，问候从指尖轻轻启程；骑上网约单车，迎接新一天的美好朝阳。这是温暖的南国，这是雪飘的北方，这是我们站立的土地，这是我们自信的中国。你好，2017；你好，亲爱的读者。 这是巨变涌动的尖峰时刻。在打败李世石的“阿尔法狗”身上，在颇具安慰能力的“微软小冰”那里，基于大数据与深度学习的人工智能一往无前。如果克隆人技术门槛消失，“超人”是否真的“will be back”？当人类感知框架模糊于虚拟与现实的边界，今夕何夕如何区分？真实又该如何确认？科技带来了能力解放、生活便利，有时却让人们陷入隐私泄密和无所适从的纠结。兴奋与焦虑在人们心中同步积蓄，有人开始屏住呼吸，等待科技“奇点”或然降临。在这茫茫的时光之海，再有远见的泳者，也难以望到尽头；再悲观的人，也不能无视波峰浪谷后的风平浪静。 这也是文明反思的重要节点。英国退欧昭示着全球旧秩序在摇晃，特朗普拉开了新时代不确定性的帷幕。西方社会一切超我式政治正确，都将接受更现实的自利审视。民族国家体系与全球化之间的内在张力，正在艰难维持的脆弱平衡中发生位移。我们目睹地球村的乐观之幕徐徐降下，又看到希望之光照亮历史斑驳的暗影。从文艺复兴、宗教改革、启蒙运动到工业革命，从两次世界大战到冷战秩序解体，历史没有终结，人类文明又一次走到调整的边缘。 我们从这样的中途出发，泅渡历史三峡。我们胸藏百余年来的转型心智，追逐“两个一百年”和民族复兴的光荣梦想，参与五千年文明的涅槃重生。二孩政策全面放开，生与不生成为新的纠结。农地三权分置，切中有恒产者有恒心的朴素经验。精准扶贫与救助留守儿童，让获得感在山间小道延伸。监察委试点推行，延续自我警醒与励精图治的窑洞新对。新丝路上又响起的驼铃，传来人类命运共同体的集体乡愁，以及对全球治理中国方案的共同期待。古老中国的全球担当从来没有今天这样耀眼。 在大潮奔涌的时光之海，个体命运高低起伏。树斌妈妈的眼泪，述说着人性本然，善良的人们对正义的坚守从未松懈；罗一笑抱憾离去，孩子对生命的渴念，公众对真相的追求，推动社会不断向前。中产财富急剧变化，向上跃升或向下坠落。相信，且保持坚强，登上的方舟才不会迷航。 这是你拥有的时间，这是你编程的生活。汗水比泪水更有营养，站着比坐着更有力量。我们或许经历挫败，但梦想总会如旭日之升；我们也许曾经心痛，但希望总会如皓月之恒。这希望与梦想不在远处，就在你我对更美好生活的追求，就在你我对责任与权利的坚守，以及对人格道义的不断完成与超越。 没有一次经历会白费，没有一声叹息不留下回响。即便走遍千山万水，始终保持能力重回原乡。那里有泪水打湿的童年，那风中飘飞着母亲的白发。不妨停下匆匆的脚步，轻轻对自己道一声：辛苦了。然后每一天早起，去追赶即将驶走的地铁，或挤上正要离开的公交。 祝福在岁月中走失的伙伴，愿你们找到幸福。祝福身边的每一位朋友，愿你们在变与不变的永动中锁定美好，在确定与不确定的更替中确定幸福。且让我们伸出手，握一握，共同穿越这时光的海洋。 2018年新年献词：把孤岛连成大陆 始终有两种力量，在我们一生中激荡。一种推着我们向外走，一种拉着我们向内收。一种力量去远方，一种力量回原乡。 这一年，我们依然在工地上挥汗如雨，依然进出写字楼风风火火，或者像候鸟一样满世界飞翔……无论我们有多忙，走得有多远，却始终被一种力量牵绊，被一种惦记温暖，被一种责任召唤。 于是，我们看到阿拉善沙漠的沙生植物在公益人脚下不断绵延，看到山间角落里的尘肺病人被一个个找到送医，看到凉山格斗孤儿们被“遣送”后重新回来学习与训练。高速运转的时代陀螺，将社会切割成一个个网格，将人们隔离成一个个原子。但生命意志顽强地向外向上生长，激励我们从一个个原点走出，又将一个个原子彼此相连，让吾国斯民，遥相守望。 曾经，我们以为只要努力工作、播洒汗水，就可以自然获得更多的收入，站上更高的平台，让孩子得到更优的教育，使家人过上更好的生活。但总有一些意外，可能先于明天到达;总有一些事情，超出个人能力之外。 交了昂贵学费，幼儿园不一定就能安全放心;住了高档小区，空气不一定就比别处清新;攒了一辈子钱，银行卡收得再紧也不一定躲得过诈骗的厄运。 在万物互联的时代，独善其身越来越不可能。我们为自己奔忙，也给他人幸福。我们捡起一片废纸，也是在为自己清洁环境。你我都是社会生态链的一环，是休戚相依的命运共同体。美好生活需要你我发自内心的善意，也需要更温暖的公共产品和制度供给。政府放开生育政策，让信奉家庭价值的中国人更好地亲其亲、子其子，不仅滋养着个体的终极幸福，也涵育着中华民族的繁荣之源。 曾经，我们以为人类进入新世纪第二个十年，历史早已教会人们珍惜和平与发展，但大变革大调整的时代版图，一直波谲云诡。有的国家将国门打开，有的却关门“退群”;有的经济体高歌猛进，有的增长缺乏后劲;有的可能遍地黄金，有的满目战乱贫病…… 世界不稳定性不确定性的警报一直在为你我鸣响。气候变化利剑高悬，核爆危机阴魂不散，霸权与恐怖主义的双头怪胎竞相疯长，基因技术与人工智能将给人类带来怎样的伦理与法律挑战?没有一个国家能退回孤岛，自理人类的这些困难。只有深悟命运共同体的真义，穿过看似冰冷的商业与国家竞争，将一个个漂流的孤岛连成共享繁荣的大陆，我们才可能在“天下为公”中牵手大同，这个日夜旋转的星球，才不会在浩渺宇宙中显得寒冷寂寥。 时空坐标中，个体局限性总是影响对历史大转折的感知，即使亲历者，也往往在事后才突然醒悟。40年前，改革开放春雷炸响，父辈们筚路蓝缕，用一代人的时间，改变了自身的命运，也让百年中国告别积弱积贫，重拾伟大复兴的民族自信。今天，“八十年代的新一辈”已过中年，但新时期勇猛精进的图景，依然让人怦然心动。曾经念兹在兹近40年的“下个世纪中叶目标”，终于在2017年秋天正式由“基本实现现代化”变成“社会主义现代化强国”。历史的接力棒，由“新时期的新一辈”交给了“新时代的这几辈”。 拉开新时代的大幕，让现代化的列车带上每一个人。我们重申古老的中华文明，只因它既凝聚于内在的德性，又延伸到无限的远方。仁不在别处，就在你光明的初心;义不在别处，就在你该走的大道;文明不在别处，就在每一个居仁由义的现代中国人。在忙碌中懂得相互关爱，在逆境中记得坚守良知。无论何时都珍惜自己的选择，珍惜你我站立的中国。 没有一个冬天不可逾越，没有一个春天不会来临。沐浴新年的阳光，一些朝向内心的期许会在琐碎的生活中诞生，一些面向世界的梦想会从平淡的日子里升起。我们祝福你，祝福你的期许和梦想，在温暖的大陆栖息生长。 祝福新时代，祝你新年好! 2019年新年献词：每一个这样的你都是英雄 时光呼啸，2019年正迎面而来，我们与你又一次如约相见。 这是我们与你不变的约定，这是我们与你不变的仪式。生命需要一种仪式感，给约定加上些许情怀与重量。我们衷心地祝福你，新年快乐！ 我们正在从改革开放四十年积累的基业再出发，心是笃定的。但回望跌宕起伏的2018年，也有许多的不容易。英国在试水“硬脱欧”，美国对各主要贸易伙伴挥起了大棒；行走在灰黑地带的P2P大面积爆雷，伪劣疫苗引爆众怒自取其咎；一些著名人物像燃尽的恒星一样独自带走了他们的时代，而公交车上发生的事件则告诉我们，大家同在一辆疾驰的车上，谁也不是旁观者，谁也无法置身事外。 是的，生活常常不容易。当你告别象牙塔走向职场，却发现期望与现实之间落差巨大的时候；当你披星戴月驾驶大卡车行走四方，如期交货后发愁下一桩生意的时候；当你为了一个并不大的单子费尽唇舌，但甲方还是不置可否的时候；当你人过中年，上有老下有小，却为了工作与家人的平衡筋疲力尽的时候；当你左支右绌，努力按时出粮，让一帮跟你多年的兄弟能按时支付房贷车贷的时候……请继续怀有希望，请继续抱有信心，希望与信心，赋予你我前行的力量。 什么才是生活的本来面貌？是消除一切压力与焦虑，摆脱所有传统习俗与社会舆论，随心所欲，自由自在，还是体认到自由与责任永远相伴相生，人必须在责任与压力中淬炼生命？前一种只是乌托邦，后一种才是真实世界。既然如此，我们只有并且最好欣然，接纳世界的真实模样，接纳生活的本来面貌。在此基础上，不堕信心，不失希望，不断从中汲取前行的力量。 敢于直面人生，感受人生波折的苦乐，经受经济周期的考验，承受社会潮汐的冲击，这不是绝世英雄小说般的故事，这是每一位用双手、用头脑为自己和家人编织幸福生活的普通人本然的生活状态。在这个意义上，每一个这样的你，都是英雄。 我们行走在中国大地，与一个个你不期而遇。我们走过乡野，你在田间辛勤耕耘；我们走过城市，你在工地挥汗如雨；我们走入工厂，你在流水线上埋首奋战；我们走进大学，你在实验室里一丝不苟；我们凝眸办公室，你双手如梭、代码在指间行云流水；我们眺望钻井平台，你向深远处勘探，黑色的液体汩汩作响；我们走在路上，你骑着电瓶车穿行大街小巷，只为快递准时抵达；我们走过小区，你从早忙到晚，撑起一个家，小朋友咿呀学语、茁壮成长……我们看见一个个中国人在自己的位置上奋发，将旺盛的生命力焕发为光与热，只求对得起自己那份工，对得起自己对未来的期许，对得起家人一餐温热的饭菜。 这才是中国最真实、最动人的图景，这正是中国最深厚、最伟大的力量。中国的今天与明天就是这样干出来的。回望改革开放四十年，凭着这样的干劲，因着恒产催生出来的恒心，中国人几千年来不仅第一次全民解决了温饱问题，还实现了空前的繁荣。这足以说明，中国人的才智与努力不输世界上任何民族，一旦重新融入世界市场，一旦重续与世界的因缘，中国人内心对美好生活的向往就会像火山一样爆发出来，被压抑的创造力就会焕发出夺目的光彩。 这是你用生命力撰写的壮丽诗篇，这是你用生命力谱写的华美乐章。 我们感动，我们深思：什么才是生命的真谛？什么才是生命最大的神奇？我们思索着、倾听着这支配个体与共同体的元规则。 冷冰冰的热力学第二定律说，一切孤立系统都朝着熵增的方向演化。这是大前提。但生命的神奇就在于，生命通过同环境交换物质与能量，为自己制造“负熵”，并向环境释放“正熵”，以秩序来对抗无序与混乱。同样，由个人有机组成的共同体，也必须持续制造或有效输入“负熵流”、有力抑制“正熵流”的生成，并令“负熵”足以抵消“正熵”而有余，才能健壮强韧、维持向上的活力。 这个国度就是你我所依恃的共同体。她需要每一个你付出，需要每一个你贡献无数涓滴“负熵”，才能永葆青春的容颜与活力。 目光锁定那更美好的未来，你一直在努力，我们一直在呐喊。唯有我与你——每一个普通人——的行动与努力带来的每一个涓滴改进，汇入历史的江河，带来观念水位的不断提升，才是最强大的“熵减”力量。“天下之至柔，驰骋天下之至坚”，这就是柔韧的力量。 每一个涓滴改进，每一处“熵减”，都不应是强人所难，而应是义之所在；都不应是高不可攀，而应是踮起脚尖可以触及。西安卖菜的雷先生，起诉交警部门未履行法定告知程序而胜诉，昭示了权力不可任性；“昆山反杀案”的于海明，夺刀自卫，也为你我匡正了正当防卫的空间。小人物从来不是大时代的被动接受者，每一个小人物的参与和行动，汇成大时代的洪流；每一个小人物的祈望与呐喊，汇成大时代的最强音；每一个小人物的涓滴“熵减”，汇成大时代的茁壮成长。 这一切，都源于爱，你爱这片土地，你爱你的亲人！这一切，都源于希望，你希望自己的子孙后代生活的世界越来越好！这一切，都源于信心，你和你的奋斗配得上更好的未来！这一切，都源于亿万人每时每刻的行动，“一棒接着一棒跑下去，每一代人都要为下一代人跑出一个好成绩”！ 如今，船到中流浪更急，人到半山路更陡，但你不怕，我们也不怕。因为，你我同在一艘命运的船上，你我同在一辆疾驰的车上，生死相依，荣辱与共。在前行的旅途中，在向目标追逐的过程中，希望是一盏永不熄灭的灯，信心是一把愈烧愈旺的火，爱是永恒的动力之源。 再一次祝福你，新年快乐！ 2020年新年献词：考验如火 正在淬炼真金 这是新的一天，也是新的一年，还是本世纪20年代的起点，祝福你新年快乐！ 在这个特别的时间节点上，很容易想起那句曾广为人知的“预言”：2019，可能是过去十年里最差的一年，也可能是未来十年里最好的一年。 如果你依旧怀揣梦想，应该难以接受如此悲观。但当你意识到自己身处的历史场景，是在一个百年不遇的世界大变局中爬坡过坎，你是否感慨，脚步匆匆，走得并不容易？ 2019年，“我太难了”突然成了网红金句，它蕴含着那么多的无奈、自嘲与顾影自怜，却又展现出那么多在大时代考验下不服输不放弃的生动脸庞。 是的，考验，在2019年来得有点猛。 这一年，贸易战陡然升级，中美关系承压，全球化发展从未如此晦暗不明。确定性与规则共识仿佛正在退场，权力政治似乎正在回头。世界会重新沦为草莽与丛林吗？大争之世已经开启了吗？ 这一年，香港修例风波骤起，“东方之珠”蒙尘。一路急行军的新中国，既创造了七十年的辉煌成就，也面对着时代大潮新的喧嚣。但我们听见，“我和我的祖国”响起在这片大地的每个角落。我们相信，潮起潮落，遮不住“两个一百年”的大国路径。 这一年，猪价比房价、股价更牵动你的心，实体经济的冷暖直接凉热着你手中的饭碗；民众观点在无锡高架桥垮塌、北大女生自杀等事件中激荡，20年前就罪行累累的恶人孙小果，得到了应有的下场；你忘不了那31名消防指战员和地方干部在木里森林大火里的最后时刻，你想不到医患矛盾、工矿事故会在岁末卷土重来。 这一年，大到世界、中到国家、小到个人，都在承受巨大的考验，仿佛无所逃于天地之间。你在屏幕上笑说一句“我太难了”，可知屏幕下有多少含泪的共鸣？ 但共鸣不代表屈服，更多的是相互理解与支持。我们一次次看到，无论笑与哭，在直面考验的身影里，总藏着你的勇气与韧劲。 你是谁？你就是你所经历的一切。你面对考验的抉择、你挺身而出的担当、你的用力与坚守、你的鲜血和热泪，它们连成你的人生轨迹，造就你的真实存在。面对考验，你要么扼住命运的咽喉，要么被命运扼住咽喉，所以，你不能后退、不能屈服，而要努力奋斗，甚至起身战斗。你当然会疼痛，甚至会受伤，但绝不会让自己后悔。因为你懂得，考验如火，正在淬炼真金。 田埂边挥汗的是你，工地上忙碌的是你，在办公室里操劳的也是你。工厂排污被举报，那里有环保志愿者的你在奔走；贫困人口在锐减，那里有扶贫干部的你在奋战；国产航母入海、长征五号飞天，那里有工程师的你在攻坚克难；共和国颁发国家勋章和荣誉称号，那里有已成榜样的你在被世人颂扬追随。 没有什么比你内心的信念更加真切，没有什么比你内心的力量更加坚忍。像水滴击穿岩石，像火焰照亮星空。这信念与力量，源自你对超越考验的坚信，激荡着你，也激励着你身边每一个像你的他。这信念与力量，将撑开我们共同的硬核年代，趟过烈火，抵达梦想。 凡是过往，皆为序章。每一粒熬过冬天的种子，都有一个关于春天的梦想。我们扎根于这个伟大的国度，无畏一切考验的淬炼，因为这是我们的梦想之地，哪怕荆棘仍在，依然通向山顶，值得我们不停脚步，值得我们咬牙坚持。愿在新的十年里，我们彼此约定，相互温暖，相依前行。 而在今天这个特别的日子里，请再次接受我们的祝福： 新年快乐！ 2021年新年献词：哪怕世界在历史三峡中漂流，你我有彼此在 凛冬已至？ 想必每个人都有自己的感受。 2020年，历史扑面而来，现实的戏剧性令任何大片都显得苍白。你我不再是置身事外的观众，而是被推入其中的主角。 新冠病毒肆虐全球，已导致逾8100万人感染、逾178万人死亡。数字还在增加，每个名字都是一道难以愈合的伤口，撕扯着一个或更多摇摇欲坠的家庭。 年初，武汉。作为人类史上最大的一次隔离事件，封城的76个日和夜，血泪淌成悲伤的河。汽笛悲鸣，江水呜咽，这座英雄城市的巨大牺牲，当永被铭记。 一座大城，死守两月。四万医护空降，八方物资驰援，良心、勇气与职责被一个个瞬间重新照亮。李文亮与艾芬，接力讲述了一个勇敢的故事；84岁的钟南山挤进高铁餐车，北上于危难之际；除夕夜，整装待发的军医在洗手间门口抱别哭泣的女儿，火神山灯火通明抢建医院；一位志愿者坚定地写下“不计报酬，无论生死”，一位新郎愧疚地告诉新娘“疫情不散，婚礼延迟”；而当两大援鄂医疗天团在天河机场不期而遇时，空寂的大厅里响起数百人心有戚戚的招呼声、加油声，就像黑夜里冲天而起的光。 彼时彼处，人性光辉熠熠闪耀。90岁的母亲四天四夜陪护64岁的儿子；丈夫执意天天骑车送确诊却没床位的妻子去医院，最终“用我的命换你的命”；快递小哥冒险接送医护，只为“让救命的人去救更多的命”……一个个普通的人，在不同场景里默默演绎英雄的角色。而一些特别的人，更让这样的故事显出特别的意味。汶川村民千方百计运来了几大车蔬菜，女儿拉着17年前父亲抗击SARS的行李箱请战武汉，杭州保姆纵火案受害者家属悄悄捐出5000个口罩……善意与善意隔着时空回荡，勇气与勇气跨过山海呼啸，纵然彻骨痛过也依然那么努力在爱啊。 多少次泪目，多少声加油，多少个“最美”，多少夜不眠不休刷屏，多少回全民揪心接力，让多少微弱的力量在巨大的灾难与恐惧面前汇聚成墙，彼此依偎着迎向那未知的未来。 未来从未如此地未知。尽管中国迅速控制疫情，出口回暖经济复苏，世界引擎重新启动，但这一年，全球经济被重创甚于世界大战，多国政局之动荡堪称风雨飘摇，末日情绪四处弥漫，国际现实一片魔幻。 这一年，大选撕裂美国，脱欧折磨英国，恐袭缠上法国。中美关系空前承压，世仇难解的阿拉伯诸国却与以色列次第建交。整个世界暗潮涌动，哪里都是变局。 年初“地狱火”导弹定点斩杀伊朗将军，年末南高加索上空无人机精准摧毁亚美尼亚坦克。科技主宰战场，改变着千年来“一寸山河一寸血”的战争模式，还将重塑权力与政治的内在逻辑。 哨声还在不同地方吹响。比如口罩使用该不该强制，自由与安全的边界挑起全球争论；刷脸能不能推广，技术伦理引起多方关切。 是的，2020年，整个世界仿佛进入到历史的三峡中漂流，前方仍可能是凛冽的冰河，是汹涌的怒海，你我同在这一艘船上，无处可退，无人例外。你我的命运从未如此与国家命运生死相连，你我的历史从未如此与世界历史紧密相绕。 没有一滴水能独自成为大海，也没有一个春天不拥有万紫千红。但若失去那每一滴水、每一朵花的“我在”，大海也会干涸，春天终将无色。 “我在”是一个沉重的字眼，因为它寄寓于每一个负重的存在之中。 所谓“我在”，是“我在场”，是我在看、在听、在感受、在坚持。无论愿不愿意，你我都已被卷入这大历史的现场。历史流经我们，我们就要打上印记。 所谓“我在”，是“有我在”，是对真相与正义的信念，是担当，是责任。 世界乃是所有人共业所感。大洪水来袭之前，没有一滴水认为自己有罪；雪崩时，没有一片雪花无辜。须弥藏芥子，芥子纳须弥。你我是世界的一部分，世界亦是你我的一部分。世界刻画着我们，我们也要定义它的算法。 所谓“我在”，是“我还在”，是渡尽劫波人还在、爱还在。等你归家的那盏灯火，打开门孩子扑入怀中的笑脸，永远是那般动人。而在天灾人祸的命运前，在风刀霜剑的相逼下，你需要永远坚强。生命薪火代代相传，是基因绵延意义上的血脉永生；天之未丧斯文在兹，是模因绵延意义上的文明永生。但倘若岁月暗算我们，我们也别饶过它。 岁末寒冬，伦敦溃散，日本封国，巨星不断陨落，疫苗尚未普及病毒却多处变异，世界仍不太平。但万物始终运行，大地终将苏醒，世间流传着厚义与深情，时光滚滚向前绝不停息，新年终将到来。 我在，就是不幸中的万幸； 我在，就是绝望中的天籁； 我在，就是破釜沉舟，是披荆斩棘，是一诺千金，是虽九死其犹未悔，是越千山万壑也要与你共一个更美的春天。 我在，是国与民互相担当，是夫与妻一起承受，是父母与儿女共同坚持，是一个人给一个人壮胆，是一群人为一群人拼命。 我在，你在，我们在。 你有我们在，我们有你在，你我有彼此在。 今年的这一天，每年的这一刻，你我执手见证“我在”，互道一声早已相约的祝福： 新年快乐！ 愿今年所有的遗憾,都会是明年惊喜的铺垫.","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"flag-2021","date":"2020-12-31T11:59:59.000Z","path":"2020/12/31/flag-2021/","text":"岁暮时分,总有一种伤感莫名袭来. 怅然若失,却又明明没有失去哪些,甚至还可以说收获满满 ---- 这在我20岁刚出头时,是几乎不曾有过的. 这一年技术上又上层楼,渐进佳境.虽离目无全牛心手相忘 尚未达一间,但处正轨 研精覃思 未来可期. 这一年读完了Operating Systems: Three Easy Pieces,很有收获. 接下来还会按照这个豆列,一本本’厚黑书’看下去. 这一年本想深究Linux源代码,但实在体系庞大,兼之后半年工作繁忙,故而领悟有限. 操作系统导论 Linux源代码 这一年换了几份工作,去了当下正红的某互联网公司.作为其重度用户,既得心理作祟,有达成所愿的欣喜,也有随之而来的些微失落.把工作做好,但也不要自我设限.我的终点,虽烟岚云岫模糊不清,但能确定还很远很远 ---- 这种不确定感,也许是带来焦虑忐忑,和兴奋期待的重要诱因. 把这些当成体验,把这些当做经历,无论未来如何起伏跌宕,生死之外,没有什么不能逾越. 这一年,两年前的投资,收获了可观回报,算下来可能超过了我10年的税后收入之和 ---- 从实现财务自由角度说,占据80%以上时间的工作自然重要,但投资才是真的主角. 年中,奶奶卧于床榻半年后,撒手而去;年尾,两年来陪伴我漂泊流浪的爱猫黄橙橙,去了喵星. 都曾痛苦,我会带着对她们长久的思念,继续走下去. 这些年来,一直在不知疲乏奋力奔跑. 宴安鸩毒玩岁愒日,似乎与我从不曾有缘. 但我也在行色匆匆中丢失了很多---- 比如发自心底的愉悦,比如没有顾虑的欢笑,比如慢下来享受生活. 新的一年,心态平和,知足不辱,不要再苦大仇深严苛对己,不要再溪壑无厌而尝试自我和解,不要悒悒寡欢而去体味体验更多生活之趣. 在底线之上,直情径行, 再’玩世不羁’一些,再’潇洒自在’一些,再’漫不经心’一些,再’好吃懒做’一些. 有鉴之上,新的一年不需要任何有形的flag,不要硬性要求,不要填鸭充数. 一切的前提,是喜欢,是自愿,不是任务指标,不是绩效评分. 模糊的轮廓草拟如下: 技术 大话设计模式 (在看Go源码过程中,发现很多模块与设计模式高度相干) 深入理解计算机系统 (2020年3-6月份看完了后面几章,再把前面几章看完) 力扣上树相关的题目 翻一翻西瓜书 以较高效率恢复和提升数学水平 继续保持阅读外刊习惯 看一本英文原版技术书籍 生活 看完 棋王 抽丝若干本诗词读本 尝试港股和美股 期待她的出现,也珍惜最后的单身时光","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"星陨-2020","date":"2020-12-30T15:50:32.000Z","path":"2020/12/30/星陨-2020/","text":"维基百科 2020年逝世人物列表 科比 1978.08.23-2020.01.26 斯坦利·科恩 1922.11.17-2020.02.05 美国生物化学家,1986年诺贝尔生理学或医学奖获得者. 出生在美国的布鲁克林,父母是犹太移民后裔 Stanley Cohen-TheNobelPrize 纪念斯坦利·科恩：他发现了细胞生长的奥秘 拉里·泰斯勒 1945.04.24-2020.02.17 美国计算机科学家, 与同事Tim Mott一同开发了复制和粘贴功能 Larry Tesler 哈维尔·佩雷斯·德奎利亚尔 1920.01.19-2020.03.04 秘鲁外交官，曾任联合国第五任秘书长等职务 哈维尔·佩雷斯·德奎利亚尔 我的奶奶 1932-2020.05.21 近泪无干土,低空有断云 罢絮光阴萍满池,春风吹鬓白成丝 法兰·艾伦 1933.08.04-2020.08.04 计算机科学家, 编译器优化领域的先驱, 成就主要包括编译器的基本原理、代码优化和并行编译等. 2006年图灵奖得主,第一位获得此奖的女性 沃恩·琼斯 1952.12.31-2020.09.06 新西兰裔美国数学家,以在冯·诺依曼代数和扭结多项式上的研究而闻名. 1990年被授予菲尔茨奖 1990年菲尔兹奖得主沃恩·琼斯因病逝世 著名数学家沃恩·琼斯逝世，曾穿橄榄球队服领菲尔兹奖，陶哲轩发文悼念 阿瑟·阿什金 1922.09.02—2020.09.21 美国物理学家，在贝尔实验室和朗讯工作，2018年诺贝尔物理学奖得主。 他在1960年代后期开始研究使用激光操纵微观粒子，于1986年发明光镊。此外，他开创光学捕捉方法，其可以被用来操纵原子、分子和生物细胞，这方法主要是利用光的辐射压来移动微观粒子，阿瑟·阿什金因此被认为是光镊之父。 阿瑟·阿什金：生物学领域可能会因为用光镊做出的伟大工作而获得一次诺贝尔奖 年龄最长的诺贝尔奖得主阿瑟·阿什金：我觉得我被诺贝尔奖遗忘了 欧阳中石 1928.10-2020.11.05 学生追忆欧阳中石：淡泊名利，谦让一生 小柴昌俊 1916.09.19-2020.11.12 日本物理学家. 1987年，小柴在超级神冈探测器完成人类史上首次的中微子发生观测。2002年，小柴与户冢洋二、梶田隆章三人同获潘诺夫斯基实验粒子物理学奖。同年因其“在天体物理学领域做出的先驱性贡献，其中包括在探测宇宙中微子和发现宇宙X射线源方面的成就”而获得诺贝尔物理学奖。 首位“双博士”头衔的日本人诺贝尔奖得主，此外亦是日本人第2位诺贝尔奖暨沃尔夫奖双料得主。他的老师朝永振一郎、门生梶田隆章也都是诺贝尔物理学奖得主。 幼时曾梦想当军人或音乐家，但在12岁忽然罹患小儿麻痹症，其后遗症造成右臂残疾，致使梦想破灭。然而，就在他住院期间，导师送了他一本爱因斯坦的书，却使他从此走上了物理研究的道路。 马拉多纳 1960.10.30－2020.11.25 生于阿根廷布宜诺斯艾利斯，昵称“世纪球王”、“球场上帝”，阿根廷足球运动员和教练，是世界足球史上传奇球星之一，也是最具争议的球员之一。 爱猫黄橙橙 2016-2020.11.28 黄橙橙生平记 诺曼·艾布拉姆森 1932.04.01-2020.12.01 美国计算机科学家,开发出ALOHAnet无线通讯系统 当我们自由上网时，应该想到他，Wi-Fi 之父诺曼 · 艾布拉 爱德蒙·克拉克 1945.07.27-2020.12.22 美国计算机科学家。2007年，他与艾伦·爱默生和约瑟夫·斯发基斯一起因在模型检查取得的杰出贡献而获得图灵奖 巨星陨落！图灵奖得主Edmund Clarke感染新冠逝世","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"黄橙橙生平记","date":"2020-12-28T13:51:33.000Z","path":"2020/12/28/黄橙橙生平记/","text":"找黄橙橙的原主人，大致缕清了其生平 --- 在还活蹦乱跳，没失去她之前，我其实是不太care她的生平过往。现在，这成了我最想获取知道的信息. 16年年底从外面捡到，浑身跳蚤，瘦弱无肉。长毛，有些混血——据说流浪猫大多如此。 两次怀孕生小猫，都是跳门而出。有孕后再回来。第一胎在2017年8月，当时黄橙橙也就8-9个月大。生了5只小猫。第二胎是第二年，生了3只。 我是18年国庆前后领养。当时主人说，也是跳门逃了出去，后来其母亲散步时遇到，跟着回了家。以为又有了小猫，临走时嘱托我如果有就让其生下来。但是并没有。 陪我在古荡湾新村一幢农民别墅一楼北面潮湿的房间，度过了最艰难的三个月。而后坐在自行车筐里，和我去赴科技城。 2019年10月，随我离杭来沪。2020年5月初，做了绝育，之后短暂胖了一阵。 2020年10月，随我从浦东川沙搬到宝山高境。 2020年11月初，我楼下学习。短暂功夫，上去发现门户大开，喵已不见。刹时血涌，前前后后几个小时，在院中草丛发现。跑到楼梯下杂物堆，死命抓住不放松，抓ta归案！更新筑防线，怕其再次夺门而去。 2020年11月最后几天，健康直转直下。少吃，嗜睡，精神不佳。以为只是季节变换，未多留意。某次呕吐严重，带来医院。第二天医治无效去了喵星。 此刻，我无心上班，来到医院，找接诊医生，确认死因。更试图复盘，看看何时发现，能有一线之机。看毛发，大概年初时还是康健。8月份已见凌乱，或是肇始。医生或是宽慰，有钱难买命，可以释怀。这就是她短暂又传奇的一生。 我终于还是失去了你 昔日戏言身后意，今朝都到眼前来。 我原以为，之前或会丢掉她的那煎熬的几个小时，是后半年最丧的时刻。其实那还远远不是 感恩780多个日日夜夜的相守陪伴。在我最落魄不得志时刻，予我最温润熨帖的告慰。这两年多来，你是孤身在外的失意青年，最亲密无间的伙伴。 2020.11.28 永失我爱 这几年我惯于长夜，晚睡晚醒。只有少数时刻拂晓便辗转反侧，忧悒难寐。而此情境下披衣出门，寒宵中独立踯躅，还是在近两年前。年底的变故，成了压垮一年诸多无奈的稻草，那是最近些年一段最艰难的时光。从几多仅自己可见的状态，还能一感当日胸中块垒郁结，压得透不过气。也只在砭人肌骨的南方冬晨，在老和山和余杭塘河间一圈又一圈。至亲不在身旁，而我本就没有太多朋友，更鲜少可以诉说。 也是那时，领养不过一两月，刚从生疏变熟络的一只橘猫，或是趴在胸口，泰山压顶岿然不动。或是喵喵叫着，四肢活动踩我衣袖。无论是睡是醒，出门时多相送，归来时必相迎。在坎坷困顿时刻，那是沙漠泓泉，那是凛冬雪碳。在倍觉失意百无聊赖当口，她用粉嘟嘟肉垫抓挠剐蹭，告诉我人间很值得，我的奋斗依然大有意义。 几年来的四处奔走，我安之如素，体验并享受。却是遗漏或视而不见知而不闻，太过频繁地更迭住所甚至城市，于你们都是一次考验，需要比我更长时间的适应。这是第一次想，如果不离开杭州，我们就在自己的房子里，安安稳稳，情况会不会好。…而我要的虚无缥缈的未来，究竟是什么，又是在哪里。我记得离开时放你进笼子，那惶惑不安的眼神，大白天瞪起乌溜溜的黑眼珠。对着你同我一起，一钉一锤拼起，又如此拆卸的家具床铺，和从一室狼藉变得整洁复又一地狼藉的居室。我也有些惶惑，眺望远方如此相慰：存人失地，人地皆得。过几年我们还会回来，也许还有你的女主人。 有你在时觉得理所应当，失去时才发觉生活一角塌方。…我还想等我有了孩子，幼小的ta和年迈的你，一处眼神相会，才是你完成历史使命，可以回喵星之时。 我曾懊恼为何后知后觉，亲友相劝：自有定数，喵具灵性，自知时日无多，会拼命出走，不在家中羽化。月初遁逃，或已膏肓。原主人亦告，此猫天生体弱。愈是这般，愈觉未珍惜最后时光，以为永远如常。 此刻，我又独立寒宵，留下这些无关痛痒的图文，以悼曾陪伴我艰难岁月的挚友。此刻，也许你已在高温下泯为灰烬，消散四方，于世只残存我保存下的一团毛发，几缕白须，和烙印在我大脑皮层的痕迹。我的生活还要继续，你却不能再有这样的出镜率。 喵星苦寒，吃胖一点。几十年后还会再相见。 你永远留在了2020,但我还会带着你的一颦一笑,走很远很远.","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"仿射类型(Affine Type)","date":"2020-12-21T15:14:48.000Z","path":"2020/12/21/仿射类型-Affine-Type/","text":"https://www.zhihu.com/question/28702292","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"类型系统","date":"2020-12-20T13:28:40.000Z","path":"2020/12/20/类型系统/","text":"Go 相对小巧，类型系统很简单；而 Rust 借鉴了 Haskell，有完整的类型系统，支持泛型。为了性能的考虑，Rust 在处理泛型函数的时候会做单体化，泛型函数里每个用到的类型会编译出一份代码，这也是为什么在编译的时候 Rust 编译速度如此缓慢。 https://www.zhihu.com/question/23434097 https://zhuanlan.zhihu.com/p/65626985 https://www.jianshu.com/p/e9f96c34b768 https://zhuanlan.zhihu.com/p/158421251 How Gradual Typing System Helps Us 渐进式的类型系统如何帮助我们(Python是渐进式类型系统) https://baike.baidu.com/item/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/4273825?fr=aladdin 现代编程语言早已发展到了“程序即类型证明”的阶段，类型系统基本已经成为了各大编程语言的标配，尤其是近几年新出现的编程语言。类型系统提供了以下好处： 允许编译器侦测无意义甚至无效的代码，暴露程序中隐含的错误。 可以为编译器提供有意义的类型信息，帮助优化代码。 可以增强代码的可读性，更直白地阐述开发者的意图。 提供了一定程度的高级抽象，提升开发效率。 一般来说，一门语言只要保证类型安全，就可以说它是一门安全的语言。简单来说，类型安全是指类型系统可以保证程序的行为是意义明确、不出错的。像 C/C++ 语言的类型系统就不是类型安全的，因为它们并没有对无意义的行为进行约束。一个最简单的例子就是数组越界，在 C/C++ 语言中并不对其做任何检查，导致发生了语言规范规定之外的行为，也就是未定义行为（Undefined Behavior）。而这些未定义行为恰恰是漏洞的温床。所以，像 C/C++ 这种语言就是类型不安全的语言。 Rust 语言如果想保证内存安全，首先要做的就是保证类型安全。 原文链接：https://blog.csdn.net/weixin_39445733/article/details/99307054 在诸多编程语言中， OCaml 和 Haskell 是公认的类型安全的典范，它们的类型系统不仅仅有强大的类型理论“背书”，而且在实践生产环境中也久经考验。所以，Rust 语言借鉴了它们的类型系统来保证类型安全，尤其是 Haskell，你能在 Rust 语言中看到更多 Haskell 类型系统的影子。 那么，什么是内存安全呢？简单来说，就是不会出现内存访问错误。 只有当程序访问未定义内存的时候才会产生内存错误。一般来说，发生以下几种情况就会产生内存错误： 引用空指针。 使用未初始化内存。 释放后使用，也就是使用悬垂指针。 缓冲区溢出，比如数组越界。 非法释放已经释放过的指针或未分配的指针，也就是重复释放。 这些情况之所以会产生内存错误，是因为它们都访问了未定义内存。为了保证内存安全，Rust 语言建立了严格的安全内存管理模型： 所有权系统。每个被分配的内存都有一个独占其所有权的指针。只有当该指针被销毁时，其对应的内存才能随之被释放。 借用和生命周期。每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。 其中所有权系统还包括了从现代 C++ 那里借鉴的 RAII 机制，这是 Rust 无 GC 但是可以安全管理内存的基石。 建立了安全内存管理模型之后，再用类型系统表达出来即可。Rust 从 Haskell 的类型系统那里借鉴了以下特性： 没有空指针 默认不可变 表达式 高阶函数 代数数据类型 模式匹配 泛型 trait 和关联类型 本地类型推导 为了实现内存安全，Rust 还具备以下独有的特性： 仿射类型（Affine Type），该类型用来表达 Rust 所有权中的 Move 语义。 借用、生命周期。 借助类型系统的强大，Rust 编译器可以在编译期对类型进行检查，看其是否满足安全内存模型，在编译期就能发现内存不安全问题，有效地阻止未定义行为的发生。 内存安全的 Bug 和并发安全的 Bug 产生的内在原因是相同的，都是因为内存的不正当访问而造成的。同样，利用装载了所有权的强大类型系统，Rust 还解决了并发安全的问题。Rust 编译器会通过静态检查分析，在编译期就检查出多线程并发代码中所有的数据竞争问题 1.2.2 零成本抽象除了安全性，Rust 还追求高效开发和性能。 编程语言如果想做到高效开发，就必须拥有一定的抽象表达能力。关于抽象表达能力，最具代表性的语言就是 Ruby 。但是 Ruby 的抽象表达能力完全是靠牺牲性能换来的。而 Rust 的抽象是零成本的，Rust 的抽象并不会存在运行时性能开销，这一切都是在编译期完成的。代码清单 1-1 中的迭代 5 次的抽象代码，在编译期会被展开成和手写汇编代码相近的底层代码，所以不存在运行时因为解释这一层抽象而产生的性能开销。对于一门系统级编程语言而言，运行时零成本是非常重要的。这一点，Rust 做到了。Rust 中零成本抽象的基石就是泛型和 trait。 为了保证支持硬实时系统，Rust 从 C++ 那里借鉴了确定性析构、RAII 和智能指针，用于自动化地、确定性地管理内存，从而避免了 GC 的引入，因而就不会有“世界暂停”的问题了。这几项虽然借鉴自 C++，但是使用起来比 C++ 更加简洁。 Safe Rust 表示开发者将信任编译器能够在编译时保证安全，而 Unsafe Rust 表示让编译器信任开发者有能力保证安全。 虽然 Rust 官方团队做了以上诸多努力，但是目前还有一大部分开发者认为 Rust 语言学习曲线颇陡。其中最为诟病的就是 Rust 目前的借用检查系统。这其实是因为 Rust 语言的设计融合了诸多语言的特点，而当今大部分开发者只是擅长其中一门语言，对其他语言的特性不太了解。C 语言的开发者虽然对底层内存管理比较熟悉，但是未必熟悉 C++ 的 RAII 机制；即使熟悉 C++，也未必熟悉 Haskell 的类型系统；即便熟悉 Haskell 的类型系统，也未必懂得底层内存管理机制。更不用说内置 GC 的 Java、Ruby、Python 等面向对象语言的开发者了。 语言架构为了便于学习，笔者针对 Rust 语言概念的层次结构进行了梳理，将 Rust 语言中的概念分成了 4 个层次。最底层是安全内存管理层，该层主要是涉及内存管理相关的概念。倒数第二层是类型系统层，该层起到承上启下的作用。类型系统层承载了上层的所有权系统语义和混合编程范式，赋予了 Rust 语言高级的抽象表达能力和安全性。同时，还保留了对底层代码执行、数据表示和内存分配等操作的控制能力。 对于开发者而言，只需要掌握类型系统、所有权系统和混合式编程范式即可，不需要操心底层的内存是否安全，因为有编译器和类型系统帮忙处理。在这个语言架构之下，人和编译器共用同一套“心智模型”，这样可以极大地保证系统的安全和健壮性。————————————————版权声明：本文为CSDN博主「六点的清晨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_39445733/article/details/99307054 1.4 Rust 代码如何执行Rust 从诞生伊始，就考虑到了平台移植性问题。通常编译阶段被分为前端和后端两部分，Rust 作为编译语言，也是这样划分的。Rust 编译器是一个编译前端，它的工作是对代码进行词法分析、语法分析、类型检查、生成中间代码、进行独立于目标机器的优化等工作。使用 LLVM 作为编译器后端代码生成框架，则可以利用 LLVM 兼容多个目标机器的特性，实现跨平台编译和优化等工作。所以，用户在使用 Rust 时，大多数时候无须考虑各个目标机器平台的特有性质，基本上可以做到一次编写，到处运行。而当用户在需要处理跨平台兼容性问题的时候，Rust 也以第三方 crate 的形式提供了诸多辅助。 Rust 源码经过分词和解析，生成 AST（抽象语法树）。然后把 AST 进一步简化处理为 HIR（High-level IR），目的是让编译器更方便地做类型检查。HIR 会进一步被编译为 MIR（Middle IR），这是一种中间表示，它在 Rust1.12 版本中被引入，主要用于以下目的。 缩短编译时间。MIR 可以帮助实现增量编译，当你修改完代码重新编译的时候，编译器只计算更改过的部分，从而缩短了编译时间。 缩短执行时间。MIR 可以在 LLVM 编译之前实现更细粒度的优化，因为单纯依赖 LLVM 的优化粒度太粗，而且 Rust 无法控制，引入 MIR 就增加了更多的优化空间。 更精确的类型检查。MIR 将帮助实现更灵活的借用检查，从而可以提升 Rust 的使用体验。 最终，MIR 会被翻译为 LLVM IR，然后被 LLVM 的处理编译为能在各个平台上运行的目标机器码。 Rust 的产生看似偶然，其实是必然。未来的互联网注重安全和高性能是必然的趋势。GH 看到了这一点，Mozilla 也看到了这一点，所以两者才能一拍即合，创造出 Rust。 Rust 从 2006 年诞生之日开始，目标就很明确——追求安全、并发和高性能的现代系统级编程语言。为了达成这一目标，Rust 语言遵循着内存安全、零成本抽象和实用性三大设计哲学。借助现代化的类型系统，赋予了 Rust 语言高级的抽象表达能力，与此同时又保留了对底层的控制能力。开发者和 Rust 编译器共享着同一套“心智模型”，相互信任，相互协作，最大化地保证系统的安全和健壮性。Rust 语言有别于传统语言的另一点在于，它将开源社区视为语言的一部分。Rust 本身就是开源项目中的典范，非常值得学习。 有人把 Rust 称为”The New C“，我十分认同，Rust 是开启新时代的语言。但 Rust 可能不像其他语言那样，突然冒出一个杀手级应用来引领某个领域的一段潮流。Rust 改变世界的方式，正好可以用古人的诗词来形容，”好雨知时节，当春乃发生。随风潜入夜，润物细无声“。 Rust 语言不是银弹，它也不追求完美，它只是在由 C 和 C++ 构建的旧世界之上，寻求更好的问题解决之道。","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"数据流图","date":"2020-12-19T15:10:30.000Z","path":"2020/12/19/数据流图/","text":"数据流图（Data Flow Diagram, DFD）是结构化系统分析方法的主要表达工具，数据流图主要是为了说明在一个项目中，数据的处理与流动情况。 (UML图是面向对象分析方法的表达工具； DFD（数据流图）是面向数据流的设计方法（本质也是一种流程图）；UML图、DFD数据流、NS流程图有什么区别？) 基本语法: 数据流图里的符号极为简单，只有四个： 1）外部实体； 2）处理(即加工)； 3）连线(即数据流)； 4）数据存储 这四个符号也有两种。一种是Yourdon &amp; Coad法，另一种是Gane &amp; Sarson法。只是略有不同而已 加工 一般用圆形或圆角矩形来标识 绘制步骤: 1.确定系统的输入输出 2.由外向里画系统的顶层数据流图 3.画加工的内部 4.画子加工的分解图 5.对数据流图和加工进行编号 软件工程-数据流图 案例: 顶层图都很简单: 出现两次及以上的实体,矩形框的右下角加一个斜线 0层图: 更多详细: (软考(下午第二题)——数据流图 考察很稳定~容易拿高分 经典Demo: 记忆如下几个经典demo: 参考: 软件工程961-分层数据流图的画法 数据流图案例 图书订购与考务系统DFD数据流图 考务系统的分层数据流图实例 数据流图DFD画法 结构化——数据流图 谷歌图片-考务管理数据流图顶层图 几个不错的在线画图网站: 亿图图示","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"UML基础","date":"2020-12-16T15:59:11.000Z","path":"2020/12/16/UML基础/","text":"统一建模语言（UML是 Unified Modeling Language的缩写, 是用来对软件系统进行可视化建模的一种语言。UML为面向对象开发系统的产品 进行说明、可视化、和编制文档的一种标准语言。 共有9种图 UML中的图其实不止九种 (相同的图还可能会有不同的名称), 这里的九种图是被普遍认可的基础图, 分别为：用例图、类图、对象图、状态图、构件图、部署图、协作图、交互序列图、活动图。 之前在惠普时,用过时序图(即顺序图,交互序列图) UML图也可分为用例视图、设计视图、进程视图、实现视图和拓扑视图 又可以根据静动分为静态视图和动态视图 静态图分为：用例图，类图，对象图，包图，构件图，部署图 动态图分为：状态图，活动图，协作图，序列图 一般情况下,又以类图,状态图,用例图最为重要 类图(Class Diagram) 类图是使用频率最高的UML图之一 If someone were to come up to you in a dark alley and say, ‘Psst, wanna see a UML diagram?’ that diagram would probably be a class diagram. The majority of UML diagrams I see are class diagrams.” --- Martin Fowler 《UML Distilled: A Brief Guide to the Standard Object Modeling Language, Third Edition》 “如果有人在黑暗的小巷中向你走来并对你说：‘嘿，想不想看一张UML图？’那么这张图很有可能就是一张类图，我所见过的大部分的UML图都是类图”（《UML精粹：标准对象建模语言简明指南（第3版）》） 深入浅出UML类图 显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。那它其实就是用来帮助我们识别出人、事、物和业务的概念，并理清它们的关系的一种方法 如 计算机可以分为笔记本电脑和台式机，现在有主板、硬盘、内存、显示器、键盘、鼠标、无线鼠标、有线鼠标、机械鼠标、光电鼠标、蓝牙鼠标，请画出类之间的关系，不需要写属性，需要假设的地方在图中注明，如假设计算机只有一个显示器 类之间的关系 类与类之间的关系通常有6种，即 依赖关系（Dependency）: 用带箭头的虚线表示，箭头从使用类指向被依赖的类 关联关系（Association）: 单向关联用一个带箭头的实线表示，箭头从使用类指向被关联的类; 双向关联用带箭头或者没有箭头的实线来表示 聚合关系 (Aggregation) : 是关联关系的一种，表示整体和部分之间的关系(成员也可以脱离整体而存在)，如学校和老师，车子和轮胎. 用带空心菱形的实线来表示聚合关系, 菱形指向整体 组合关系 (Composition) : 也是关联关系的一种，是一种比聚合关系还要强的关系(部分对象不能脱离整体对象而单独存在，如人的身体和大脑之间的关系，大脑不能脱离身体而单独存在), 用带实心菱形的实线来表示组合关系，菱形指向整体 实现关系（Realization/implements）: 即 接口和实现类之间的关系。类实现了接口中的抽象方法。用带空心三角箭头的虚线来表示实现关系，箭头从实现类指向接口。 泛化关系（Generalization/extends）: 也称继承关系, 是父子类之间的继承关系，表示一般与特殊的关系，指定子类如何特殊化父类的特征和行为。 用带空心三角箭头的实线来表示泛化关系，箭头从子类指向父类。 六种关系中，从弱到强依次是： 依赖关系 &lt; 关联关系 &lt; 聚合关系 &lt; 组合关系 &lt; 实现关系 = 泛化关系 其中,依赖和关联还区分单向和双向 六大类UML类图之间的关系 UML类图详解 实例 车的类图结构为&lt;&lt;abstract&gt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 实例来自 看懂UML类图 常用的UML建模详解 状态(机)图(State Diagram) 状态机图描述的是围绕某一事物状态变化的图。它和活动图的区别在于，活动图是描述事物发生的流程，是多个角色参与的，而状态机描述的是事物的状态变化，并没有角色这个概念。 1、和活动图一样，状态机图也是只能有一个开始状态，可以有多个结束状态。 2、状态是通过某一事件来进行变迁的。 3、状态是离散的，且一般用形容词或名词描述。 4、转换也可加上条件，表示分支结构。 如: 空调开机进入自检状态，检测不通过进入错误状态并且亮红灯，检测通过默认进入制冷状态，按遥控器模式切换可以在制冷、制热、吹风切换，制冷可以设置温度，并有温度监控程序，室温低于设定温度则停止制冷，高于则开始制冷；制热则反过来；吹风就只能吹风，没有其他功能 实例 实心圆表示开始,只能有一个; “空心套实心圆”表示结束,可以有多个. 圆角矩形里都是状态, 转移(即直线箭头)上是动作或返回的状态 用例图(Use Case Diagram) 描述了作为一个外部观察者,以其视角对系统的印象。 通俗理解, 用例就是软件的功能模块，所以是设计系统分析阶段的起点 强调这个系统是什么而不是这个系统怎么工作。 角色是人状的图标，用例是一个椭圆，通讯是连接角色和用例的线。 用例之间的关系 包含(include) 扩展(extend) 泛化(generalization) UML—用例图，Use Case 实例 用例图的使用案例与分析 在线画图网站: VisualParadigm 亿图图示","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go源码分析之浮点型处理","date":"2020-12-02T13:00:36.000Z","path":"2020/12/02/Go源码分析之浮点型处理/","text":"带着问题出发: 12345value1 := strconv.FormatFloat(9.815, 'f', 2, 64)fmt.Println(value1) //9.81value2 := strconv.FormatFloat(9.185, 'f', 2, 64)fmt.Println(value2) //9.19 为什么会出现这样的情况? FormatFloat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// FormatFloat converts the floating-point number f to a string,// according to the format fmt and precision prec. It rounds the// result assuming that the original was obtained from a floating-point// value of bitSize bits (32 for float32, 64 for float64).//// The format fmt is one of// 'b' (-ddddp±ddd, a binary exponent),// 'e' (-d.dddde±dd, a decimal exponent),// 'E' (-d.ddddE±dd, a decimal exponent),// 'f' (-ddd.dddd, no exponent),// 'g' ('e' for large exponents, 'f' otherwise),// 'G' ('E' for large exponents, 'f' otherwise),// 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or// 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).//// The precision prec controls the number of digits (excluding the exponent)// printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats.// For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point.// For 'g' and 'G' it is the maximum number of significant digits (trailing// zeros are removed).// The special precision -1 uses the smallest number of digits// necessary such that ParseFloat will return f exactly.func FormatFloat(f float64, fmt byte, prec, bitSize int) string &#123; return string(genericFtoa(make([]byte, 0, max(prec+4, 24)), f, fmt, prec, bitSize))&#125;FormatFloat将浮点数f转换为字符串， 根据格式fmt和precision prec。它四舍五入 假定原始结果是从浮点数获得的结果 bitSize位的值（float32为32，float64为64）。 格式fmt是以下格式之一 'b'（-ddddp±ddd，二进制指数）， 'e'（-d.dddde±dd，十进制指数）， 'E'（-d.ddddE±dd，十进制指数）， 'f'（-ddd.dddd，无指数）， 'g'（对于大指数而言为'e'，否则为'f'）， 'G'（对于大指数而言为'E'，否则为'f'）， 'x'（-0xd.ddddp±ddd，十六进制分数和二进制指数），或 'X'（-0Xd.ddddP±ddd，十六进制分数和二进制指数）。 precision prec控制位数（不包括指数） 以“ e”，“ E”，“ f”，“ g”，“ G”，“ x”和“ X”格式打印。 对于“ e”，“ E”，“ f”，“ x”和“ X”，它是小数点后的位数。 对于“ g”和“ G”，它是有效数字的最大值（后跟 零）。 特殊精度-1使用最少的位数 以便ParseFloat准确返回f。 FormatFloat四个参数,分别是: float64类型的待处理值 格式fmt,如果是f表示 无指数 prec,精度,如果传2,即表示保留小数点后2位 bitSize,只能传32或64 max(prec+4, 24)和genericFtoa 简单比较大小. 123456func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; 比较传入的(精度值+4),和24的大小,取其中较大者. 即如果小数点后保留的位数小于20,这个值就是24 故而此时 make([]byte, 0, 24),就是初始化一个uint8类型,容量为24的切片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122func genericFtoa(dst []byte, val float64, fmt byte, prec, bitSize int) []byte &#123; var bits uint64 var flt *floatInfo //爽哥注解 print(\"传入的待创处理的float64类型的值:\",val,\"\\n\") switch bitSize &#123; case 32: bits = uint64(math.Float32bits(float32(val))) flt = &amp;float32info case 64: bits = math.Float64bits(val) flt = &amp;float64info default: panic(\"strconv: illegal AppendFloat/FormatFloat bitSize\") &#125; //爽哥注解 print(\"得到的bits的值:\",bits,\"\\n\") //爽哥注解 //如果此时打印: //传入的待创处理的float64类型的值:+9.815000e+000 //得到的bits的值:4621714971847588577 //9.81 //传入的待创处理的float64类型的值:+9.185000e+000 //得到的bits的值:4621360313376933151 //9.19 neg := bits&gt;&gt;(flt.expbits+flt.mantbits) != 0 exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1) mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1) switch exp &#123; case 1&lt;&lt;flt.expbits - 1: // Inf, NaN var s string switch &#123; case mant != 0: s = \"NaN\" case neg: s = \"-Inf\" default: s = \"+Inf\" &#125; return append(dst, s...) case 0: // denormalized exp++ default: // add implicit top bit mant |= uint64(1) &lt;&lt; flt.mantbits &#125; exp += flt.bias // Pick off easy binary, hex formats. if fmt == 'b' &#123; return fmtB(dst, neg, mant, exp, flt) &#125; if fmt == 'x' || fmt == 'X' &#123; return fmtX(dst, prec, fmt, neg, mant, exp, flt) &#125; if !optimize &#123; return bigFtoa(dst, prec, fmt, neg, mant, exp, flt) &#125; var digs decimalSlice ok := false // Negative precision means \"only as much as needed to be exact.\" shortest := prec &lt; 0 if shortest &#123; // Try Grisu3 algorithm. f := new(extFloat) lower, upper := f.AssignComputeBounds(mant, exp, neg, flt) var buf [32]byte digs.d = buf[:] ok = f.ShortestDecimal(&amp;digs, &amp;lower, &amp;upper) if !ok &#123; return bigFtoa(dst, prec, fmt, neg, mant, exp, flt) &#125; // Precision for shortest representation mode. switch fmt &#123; case 'e', 'E': prec = max(digs.nd-1, 0) case 'f': prec = max(digs.nd-digs.dp, 0) case 'g', 'G': prec = digs.nd &#125; &#125; else if fmt != 'f' &#123; // Fixed number of digits. digits := prec switch fmt &#123; case 'e', 'E': digits++ case 'g', 'G': if prec == 0 &#123; prec = 1 &#125; digits = prec &#125; if digits &lt;= 15 &#123; // try fast algorithm when the number of digits is reasonable. var buf [24]byte digs.d = buf[:] f := extFloat&#123;mant, exp - int(flt.mantbits), neg&#125; ok = f.FixedDecimal(&amp;digs, digits) &#125; &#125; if !ok &#123; return bigFtoa(dst, prec, fmt, neg, mant, exp, flt) &#125; return formatDigits(dst, shortest, neg, digs, prec, fmt)&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"明年我将衰老","date":"2020-12-01T06:10:56.000Z","path":"2020/12/01/明年我将衰老/","text":"作者：王蒙 仍然是在蓝天与白云之下，沐浴着阳光与雾气，沐浴着海洋的潮汐与波涌、洁净与污秽，忍受着海蜇与蚊虫，环顾着挺立的松柏、盘错的丁香。去年你在那里留了影，仍然丰匀而且健康，沉着中有些微的忧愁与比忧愁更强大的忍耐与平顺。 你和我一起，走到哪里，你的床我的床边，你的枕我的枕旁，你的声音我的耳际，你的温良我的方向。你的目光护佑着游泳，我仍然是一条笨鱼，一块木片，一只傻游的鳖。我还活着，我还游着，想着，动着。活着就是生命的满涨。哪怕紧接着是核磁共振的噪音，是静脉上安装一个龙头，从龙头里不断滴注液体的显像。是老与病的困扰，是我所致敬致哀以沉默无语的医疗药剂科学。是或有的远方。 我坚信我还活着，心在跳，好好活着，过了地狱就是天国，过了分别就是相会，我仍然获得了蓬蓬勃勃的夏天，风、阳光、浓荫、暴雨、潮与肌肉。浅海滨我去了三次，我喜欢踩上木栈道的感觉，也许光着脚丫子踩沙滩更好。去年与你同去的，我期待月出，更加期待繁星。在秋与冬春，我与渤海互相想念。 只是一个刚刚开始的梦，一个尚未结束的故事。","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"go get时出现terminal prompts disabled","date":"2020-11-23T13:52:09.000Z","path":"2020/11/23/go-get时出现terminal-prompts-disabled/","text":"go get下载/更新 私有代码库的时, 产生以下错误,而go get 公有代码库 没有影响 fatal: could not read Username for &#39;https://git.xxxxx.co&#39;: terminal prompts disabled 可以执行env GIT_TERMINAL_PROMPT=1 go get 私有仓库地址,而后输入username和password,就可以成功获取 参考: go get results in ‘terminal prompts disabled’ error for github private repo","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go栈调试的几种方式","date":"2020-11-21T08:43:53.000Z","path":"2020/11/21/Go栈调试的几种方式/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"初探Go语言编译器","date":"2020-11-21T01:53:08.000Z","path":"2020/11/21/初探Go语言编译器/","text":"相关代码： src/cmd/compile src/go 递归下降解析器，核心算法位于src/cmd/compile/internal/syntax/nodes.go和src/cmd/compile/internal/syntax/parser.go 逃逸分析阶段，构建了带权重的有向图。 Go使用Bellman Ford算法，遍历查找有向图中权重小于0的节点(src/cmd/compile/internal/escape.go) 汇编与链接：internal/obj。汇编与链接是编译器后端与特定指令集有关的阶段，使用了并不太主流的plan9汇编器的输入形式。链接就是将编写的程序与外部程序组合在一起的过程 go tool compile -S xx.go 汇编之下无秘密 静态链接与动态链接 Go语言在默认情况下使用静态链接。如果引用了C代码(即使用cgo)，则会使用操作系统的动态链接库 go build -x main.go, -x参数代表打印编译的执行过程 类型推断，在cmd/compile/internal/syntax/syntax.go的next函数中实现， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274func (s *scanner) next() &#123; nlsemi := s.nlsemi s.nlsemi = falseredo: // skip white space s.stop() startLine, startCol := s.pos() for s.ch == ' ' || s.ch == '\\t' || s.ch == '\\n' &amp;&amp; !nlsemi || s.ch == '\\r' &#123; s.nextch() &#125; // token start s.line, s.col = s.pos() s.blank = s.line &gt; startLine || startCol == colbase s.start() if isLetter(s.ch) || s.ch &gt;= utf8.RuneSelf &amp;&amp; s.atIdentChar(true) &#123; s.nextch() s.ident() return &#125; switch s.ch &#123; case -1: if nlsemi &#123; s.lit = \"EOF\" s.tok = _Semi break &#125; s.tok = _EOF case '\\n': s.nextch() s.lit = \"newline\" s.tok = _Semi case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': s.number(false) case '\"': s.stdString() case '`': s.rawString() case '\\'': s.rune() case '(': s.nextch() s.tok = _Lparen case '[': s.nextch() s.tok = _Lbrack case '&#123;': s.nextch() s.tok = _Lbrace case ',': s.nextch() s.tok = _Comma case ';': s.nextch() s.lit = \"semicolon\" s.tok = _Semi case ')': s.nextch() s.nlsemi = true s.tok = _Rparen case ']': s.nextch() s.nlsemi = true s.tok = _Rbrack case '&#125;': s.nextch() s.nlsemi = true s.tok = _Rbrace case ':': s.nextch() if s.ch == '=' &#123; s.nextch() s.tok = _Define break &#125; s.tok = _Colon case '.': s.nextch() if isDecimal(s.ch) &#123; s.number(true) break &#125; if s.ch == '.' &#123; s.nextch() if s.ch == '.' &#123; s.nextch() s.tok = _DotDotDot break &#125; s.rewind() // now s.ch holds 1st '.' s.nextch() // consume 1st '.' again &#125; s.tok = _Dot case '+': s.nextch() s.op, s.prec = Add, precAdd if s.ch != '+' &#123; goto assignop &#125; s.nextch() s.nlsemi = true s.tok = _IncOp case '-': s.nextch() s.op, s.prec = Sub, precAdd if s.ch != '-' &#123; goto assignop &#125; s.nextch() s.nlsemi = true s.tok = _IncOp case '*': s.nextch() s.op, s.prec = Mul, precMul // don't goto assignop - want _Star token if s.ch == '=' &#123; s.nextch() s.tok = _AssignOp break &#125; s.tok = _Star case '/': s.nextch() if s.ch == '/' &#123; s.nextch() s.lineComment() goto redo &#125; if s.ch == '*' &#123; s.nextch() s.fullComment() if line, _ := s.pos(); line &gt; s.line &amp;&amp; nlsemi &#123; // A multi-line comment acts like a newline; // it translates to a ';' if nlsemi is set. s.lit = \"newline\" s.tok = _Semi break &#125; goto redo &#125; s.op, s.prec = Div, precMul goto assignop case '%': s.nextch() s.op, s.prec = Rem, precMul goto assignop case '&amp;': s.nextch() if s.ch == '&amp;' &#123; s.nextch() s.op, s.prec = AndAnd, precAndAnd s.tok = _Operator break &#125; s.op, s.prec = And, precMul if s.ch == '^' &#123; s.nextch() s.op = AndNot &#125; goto assignop case '|': s.nextch() if s.ch == '|' &#123; s.nextch() s.op, s.prec = OrOr, precOrOr s.tok = _Operator break &#125; s.op, s.prec = Or, precAdd goto assignop case '^': s.nextch() s.op, s.prec = Xor, precAdd goto assignop case '&lt;': s.nextch() if s.ch == '=' &#123; s.nextch() s.op, s.prec = Leq, precCmp s.tok = _Operator break &#125; if s.ch == '&lt;' &#123; s.nextch() s.op, s.prec = Shl, precMul goto assignop &#125; if s.ch == '-' &#123; s.nextch() s.tok = _Arrow break &#125; s.op, s.prec = Lss, precCmp s.tok = _Operator case '&gt;': s.nextch() if s.ch == '=' &#123; s.nextch() s.op, s.prec = Geq, precCmp s.tok = _Operator break &#125; if s.ch == '&gt;' &#123; s.nextch() s.op, s.prec = Shr, precMul goto assignop &#125; s.op, s.prec = Gtr, precCmp s.tok = _Operator case '=': s.nextch() if s.ch == '=' &#123; s.nextch() s.op, s.prec = Eql, precCmp s.tok = _Operator break &#125; s.tok = _Assign case '!': s.nextch() if s.ch == '=' &#123; s.nextch() s.op, s.prec = Neq, precCmp s.tok = _Operator break &#125; s.op, s.prec = Not, 0 s.tok = _Operator default: s.errorf(\"invalid character %#U\", s.ch) s.nextch() goto redo &#125; returnassignop: if s.ch == '=' &#123; s.nextch() s.tok = _AssignOp return &#125; s.tok = _Operator&#125; 面向接口编程。 可以给某个结构体添加无限多的方法~","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"亲测体验Golang垃圾回收","date":"2020-11-20T11:12:39.000Z","path":"2020/11/20/亲测体验Golang垃圾回收/","text":"发展历程 这部分是对刘丹冰大佬的Golang中GC回收机制三色标记与混合写屏障学习的记录 尽可能在完成目标的情况下，缩短STW的时间(Stop the world时，业务代码需要暂停执行) go 1.3 标记-清除算法 最早的 go 1.3中的标记-清除算法， 后来将清除和业务并行处理，只在标记阶段STW 但在标记阶段，依然需要stw。于是 尝试采用新的标记模式，来替代mark and sweep标记法 go 1.5 三色标记法 三个集合：白色标记表，灰色标记表，黑色标记表 每次只遍历一层。动态逐层遍历，而不像标记-清除算法一次性遍历 循环遍历，知道没有灰色节点 灰色只是一种临时状态，最终要么是黑的，要么是白的 白色就是要收集的垃圾。 比之前版本的标记-清除算法要复杂一点。但是在遍历标记时，就不用stw了？？可以并行的标记和回收对象？ 如果三色标记没有stw，是否会有问题？ 假如没有stw，业务代码和GC并行进行，那在标记过程中，如果GC从对象2层刚要扫对象3，此时(业务代码)对象4有一个指针q也指向了对象3，巧的是，这时(业务代码中的操作)对象2和对象3的引用关系消失。 GC继续执行， 所以不stw的话，会有问题。如果二者同时出现，本来不是垃圾，结果被回收了(对象3) 存在隔代引用(爷爷B引用爷爷A的孙子) 儿子和孙子之间关系消失(A的儿子和孙子关系断裂) 强弱三色不变式 强三色不变式: 强制性的不允许黑色对象引用白色对象 弱三色不变式: 当白色对象存在其他灰色对象对它的引用，或可达它的链路上游存在灰色对象时，这种情况下黑色对象可以引用白色对象 (黑色可以直接引用白色，但要保证白色的上游有灰色对象---因为这样白色对象就可以被保护，而不会被当成垃圾) 屏障机制 插入屏障： 为保证栈的性能，插入屏障不在栈上使用 &nbsp;&nbsp;GC 垃圾回收不是只针对堆吗?为什么栈还需要三色标记呢?&gt; 每个调度器的结构体有两个G，一个是crug，代表结构体M当前绑定的结构体G。另一个是G0，是带有调度栈的goroutine，这是一个比较特殊的goroutine。 注意： 普通的goroutine的栈是在堆上分配的可增长的栈。 而G0的栈是M对应的线程的栈。 所有调度相关的代码，会先切换到该goroutine栈中再执行。也就是说线程的栈也是用的g实现，而不是使用os的。如何保证栈上的变量不被误清除？在准备回收白色前，重新遍历扫描(rescan)一次栈空间，此时要加STW保护..和之前比好多了。。但依然有stw删除屏障：删除也是写操作，只不过写的内容为nil对象5，2，3在这里其实都没有被引用，其实都是垃圾，但没有被(这次GC)回收另外，删除写屏障在启动前，也会启用stw，把当前的快照进行记录。为了清除时比较。### go 1.8及之后 混合写屏障 即把 插入写屏障和删除写屏障结合，且多了一个栈默认变为黑色的操作 为了优化掉rescan，一开始优先扫描栈并标记为黑色，GC期间新创建的栈上的变量也标记为黑色。 而且为保证性能，栈上依然没有任何屏障。 堆上启用混合写屏障 混合写屏障场景1：对象被一个堆对象删除引用，成为栈对象的下游 混合写屏障场景2：对象被一个栈对象删除引用，成为另一个栈对象的下游 在栈上延迟一轮被回收，代价比堆上的延迟一轮回收的代价要小得多~因为栈上的变量一般都比较小，不太会有很大的对象 混合写屏障场景3：对象被一个堆对象删除引用，成为另一个堆对象的下游 混合写屏障场景4：对象被一个栈对象删除引用，成为另一个堆对象的下游 更多资料： 《Golang修养之路》 思维导图 GC触发时机 分配内存时，达到GOGC比例 &nbsp; &nbsp;{分配内存时, 当前已分配内存与上一次GC 结束时存活对象的内存达到某个比例时就触发GC。（默认配置会在堆内存达到上一次垃圾收集的 2 倍时，触发新一轮的垃圾收集，可以通过环境变量 GOGC 调整，在默认情况下它的值为 100，即增长 100% 的堆内存才会触发 GC。} 后台触发---sysmon检测 &nbsp; &nbsp;{ {sysmon 检测出一段时间内（由 runtime.forcegcperiod 变量控制，默认为 2 分钟）没有触发过 GC，就会触发新的 GC。} 手动触发---runtime.GC &nbsp; &nbsp;{调用 runtime.GC() 强制触发GC } Go GC 亲测体验GC 的认识","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"math.Sqrt源码分析","date":"2020-11-19T11:47:04.000Z","path":"2020/11/19/math-Sqrt源码分析/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.package math// The original C code and the long comment below are// from FreeBSD's /usr/src/lib/msun/src/e_sqrt.c and// came with this notice. The go code is a simplified// version of the original C.//// ====================================================// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.//// Developed at SunPro, a Sun Microsystems, Inc. business.// Permission to use, copy, modify, and distribute this// software is freely granted, provided that this notice// is preserved.// ====================================================//// __ieee754_sqrt(x)// Return correctly rounded sqrt.// -----------------------------------------// | Use the hardware sqrt if you have one |// -----------------------------------------// Method:// Bit by bit method using integer arithmetic. (Slow, but portable)// 1. Normalization// Scale x to y in [1,4) with even powers of 2:// find an integer k such that 1 &lt;= (y=x*2**(2k)) &lt; 4, then// sqrt(x) = 2**k * sqrt(y)// 2. Bit by bit computation// Let q = sqrt(y) truncated to i bit after binary point (q = 1),// i 0// i+1 2// s = 2*q , and y = 2 * ( y - q ). (1)// i i i i//// To compute q from q , one checks whether// i+1 i//// -(i+1) 2// (q + 2 ) &lt;= y. (2)// i// -(i+1)// If (2) is false, then q = q ; otherwise q = q + 2 .// i+1 i i+1 i//// With some algebraic manipulation, it is not difficult to see// that (2) is equivalent to// -(i+1)// s + 2 &lt;= y (3)// i i//// The advantage of (3) is that s and y can be computed by// i i// the following recurrence formula:// if (3) is false//// s = s , y = y ; (4)// i+1 i i+1 i//// otherwise,// -i -(i+1)// s = s + 2 , y = y - s - 2 (5)// i+1 i i+1 i i//// One may easily use induction to prove (4) and (5).// Note. Since the left hand side of (3) contain only i+2 bits,// it does not necessary to do a full (53-bit) comparison// in (3).// 3. Final rounding// After generating the 53 bits result, we compute one more bit.// Together with the remainder, we can decide whether the// result is exact, bigger than 1/2ulp, or less than 1/2ulp// (it will never equal to 1/2ulp).// The rounding mode can be detected by checking whether// huge + tiny is equal to huge, and whether huge - tiny is// equal to huge for some floating point number \"huge\" and \"tiny\".////// Notes: Rounding mode detection omitted. The constants \"mask\", \"shift\",// and \"bias\" are found in src/math/bits.go// Sqrt returns the square root of x.//// Special cases are:// Sqrt(+Inf) = +Inf// Sqrt(±0) = ±0// Sqrt(x &lt; 0) = NaN// Sqrt(NaN) = NaNfunc Sqrt(x float64) float64// Note: Sqrt is implemented in assembly on some systems.// Others have assembly stubs that jump to func sqrt below.// On systems where Sqrt is a single instruction, the compiler// may turn a direct call into a direct use of that instruction instead.func sqrt(x float64) float64 &#123; // special cases switch &#123; case x == 0 || IsNaN(x) || IsInf(x, 1): return x case x &lt; 0: return NaN() &#125; ix := Float64bits(x) // normalize x exp := int((ix &gt;&gt; shift) &amp; mask) if exp == 0 &#123; // subnormal x for ix&amp;(1&lt;&lt;shift) == 0 &#123; ix &lt;&lt;= 1 exp-- &#125; exp++ &#125; exp -= bias // unbias exponent ix &amp;^= mask &lt;&lt; shift ix |= 1 &lt;&lt; shift if exp&amp;1 == 1 &#123; // odd exp, double x to make it even ix &lt;&lt;= 1 &#125; exp &gt;&gt;= 1 // exp = exp/2, exponent of square root // generate sqrt(x) bit by bit ix &lt;&lt;= 1 var q, s uint64 // q = sqrt(x) r := uint64(1 &lt;&lt; (shift + 1)) // r = moving bit from MSB to LSB for r != 0 &#123; t := s + r if t &lt;= ix &#123; s = t + r ix -= t q += r &#125; ix &lt;&lt;= 1 r &gt;&gt;= 1 &#125; // final rounding if ix != 0 &#123; // remainder, result not exact q += q &amp; 1 // round according to extra bit &#125; ix = q&gt;&gt;1 + uint64(exp-1+bias)&lt;&lt;shift // significand + biased exponent return Float64frombits(ix)&#125; IEEE二进制浮点数算术标准（IEEE 754） Leetcode中几道二分查找(Binary Search)的算法题总结","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"高度为2的5阶B树中,所含关键字的个数最少是多少","date":"2020-11-16T02:12:39.000Z","path":"2020/11/16/高度为2的5阶B树中-所含关键字的个数最少是多少/","text":"https://www.cnblogs.com/nullzx/p/8729425.html https://www.google.com/search?q=%E9%AB%98%E4%BD%8D2%E7%9A%845%E9%98%B6B%E6%A0%91%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0&amp;oq=%E9%AB%98%E4%BD%8D2%E7%9A%845%E9%98%B6B%E6%A0%91%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0&amp;aqs=chrome..69i57.7486j0j1&amp;sourceid=chrome&amp;ie=UTF-8","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Kruskal算法","date":"2020-11-15T14:35:37.000Z","path":"2020/11/15/Kruskal算法/","text":"中文一般译作克鲁斯卡尔算法 由Joseph Kruskal(犹太裔美国人,1928年1月29日–2010年9月19日)在1956年发表 用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用 时间复杂度为O（eloge）（e为网中的边数）,所以适合于求边稀疏的网的最小生成树 克鲁斯卡尔算法的时间复杂度主要由排序方法决定，而其排序方法只与网中边的条数有关，而与网中顶点的个数无关，当使用时间复杂度为O（elog2e）的排序方法时，克鲁斯卡尔算法的时间复杂度即为O（log2e) 伪代码: 参考: 最小生成树之Prim算法和Kruskal算法 最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示 克鲁斯卡尔算法（以边为中心，适合稀疏图）","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Prim算法","date":"2020-11-15T07:28:17.000Z","path":"2020/11/15/Prim算法/","text":"中文一般译作普里姆算法 该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆(Robert C. Prim,1921年出生于美国德州)独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法. 有些类似迪杰克斯拉算法 12345678910111213141516171819202122232425262728293031//来源：严蔚敏 吴伟民《数据结构(C语言版)》void MiniSpanTree_PRIM (MGraph G, VertexType u) &#123; /* 用普利姆算法從第u個頂點出發構造網G 的最小生成樹T,輸出T的各條邊。 記錄從頂點集U到V-U的代價最小的邊的輔助數組定義： struct &#123; VertexType adjvex; VRtype lowcost; &#125;closedge[MAX_VERTEX_NUM]; */ k = LocateVex(G, u); for (j = 0 ; j &lt; G.vexnum; j++) &#123; //輔助數組初始化 if (j != k) closedge[j] = &#123;u, G.arcs[k][j].adj&#125;; //&#123;adjvex, lowcost&#125; &#125; closedge[k].lowcost = 0; //初始，U=&#123;u&#125; for (i = 1; i &lt; G.vexnum ; i++) &#123; //選擇其餘G.vexnum -1 個頂點 k = minimum(closedge); //求出T的下個結點：第k結點 // 此时 closedge[k].lowcost = MIN&#123; closedge[Vi].lowcost|closedge[Vi].lowcost&gt;0,Vi∈V-U&#125; printf(closedge[k].adjvex, G.vexs[k]); //輸出生成樹的邊 closedge[k].lowcost = 0; //第k條邊併入U集 for (j = 0; j &lt; G.vexnum; j++) &#123; //新頂點併入U後重新選擇最小邊 if (G.arcs[k][j].adj &lt; closedge[j].lowcost &amp;&amp; closedge[j].lowcost!=0) closedge[j] = &#123;G.vex[k], G.arcs[k][j].adj&#125;; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Floyd算法","date":"2020-11-14T13:58:48.000Z","path":"2020/11/14/Floyd算法/","text":"上篇的Dijkstra算法,可以求某个确定的起始点到其他任何点的最短路径.但当需要计算任意两点间的最短距离时,Dijkstra算法就需要改变起点多次计算 而利用Floyd算法,可以求任意两个顶点之间的最短路径 形式非常简单,三层循环,故而也被谐称为”3f算法”,时间复杂度为O(n³) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport \"fmt\"//FMap is used to store point`s distancevar FMap [4][4]int32//PointNum is point numvar PointNum int = 4func main() &#123; var Inf int32 Inf = 1 &lt;&lt; 16 //2的16次方,即65536 initMap(Inf) fmt.Println(\"循环之前的FMap:\", FMap) //中间点 for k := 0; k &lt; PointNum; k++ &#123; //任意两点间距离更新 for i := 0; i &lt; PointNum; i++ &#123; for j := 0; j &lt; PointNum; j++ &#123; if i == j &#123; continue &#125; if FMap[i][j] &gt; FMap[i][k]+FMap[k][j] &#123; FMap[i][j] = FMap[i][k] + FMap[k][j] &#125; &#125; &#125; &#125; fmt.Println(\"循环之后的FMap:\", FMap)&#125;//init mapfunc initMap(inf int32) &#123; FMap[0][0] = 0 FMap[0][1] = 2 FMap[0][2] = 6 FMap[0][3] = 4 FMap[1][0] = inf FMap[1][1] = 0 FMap[1][2] = 3 FMap[1][3] = inf FMap[2][0] = 7 FMap[2][1] = inf FMap[2][2] = 0 FMap[2][3] = 1 FMap[3][0] = 5 FMap[3][1] = inf FMap[3][2] = 12 FMap[3][3] = 0&#125; 输出为: 12循环之前的FMap: [[0 2 6 4] [65536 0 3 65536] [7 65536 0 1] [5 65536 12 0]]循环之后的FMap: [[0 2 5 4] [9 0 3 4] [6 8 0 1] [5 7 10 0]] 真正核心的代码只有这寥寥几行: 三重循环k,i,j,最内层循环的跳出当次循环条件是i==j,否则如若 m[i][j]&gt; m[i][k]+m[k][j],变为等号即m[i][j] = m[i][k]+m[k][j] (即 23 &gt; 21+13时, 使23 = 21+13) 12345678910111213for k := 0; k &lt; PointNum; k++ &#123; //任意两点间距离更新 for i := 0; i &lt; PointNum; i++ &#123; for j := 0; j &lt; PointNum; j++ &#123; if i == j &#123; continue &#125; if FMap[i][j] &gt; FMap[i][k]+FMap[k][j] &#123; FMap[i][j] = FMap[i][k] + FMap[k][j] &#125; &#125; &#125; &#125; 更多阅读: 图的四种最短路径算法 深度或广度优先搜索算法（解决单源最短路径） 弗洛伊德算法（解决多源最短路径）：时间复杂度O(n^3),空间复杂度O(n^2) 迪杰斯特拉算法（解决单源最短路径） 福特算法 (解决负权边，解决单源最短路径，前几种方法不能求含负权边的图)：时间复杂度O(nm),空间复杂度O(m)","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Dijkstra算法","date":"2020-11-14T12:23:05.000Z","path":"2020/11/14/Dijkstra算法/","text":"之前在动态规划–最短路问题中阐述了Dijkstra算法的思想,在此用代码进行实现.(“在实际实现这个算法时,我们又正过来解决这个问题“) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainconst MAXVEX int = 9 //顶点数量const MAXWEIGHT int = 1000var shortestPath = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; //v0到vx的最短路径func main() &#123; graph := NewGraph() shortestV := make(map[int]int) //前驱节点的下标 var pathMin int //存放shortestPath中,未遍历的最小节点的值 var Vx int //存放shortestPath中,未遍历的最小节点的下标 var isgetPath [MAXVEX]bool //记录节点是否已经找到v0到vx的最小路径 for v := 0; v &lt; len(graph); v++ &#123; shortestPath[v] = graph[0][v] &#125; isgetPath[0] = true //v0至v0不需要求路径 for v := 1; v &lt; len(graph); v++ &#123; pathMin = MAXWEIGHT //当前所知的离v0最近的距离 for n := 0; n &lt; len(graph); n++ &#123; //寻找离v0最近的顶点 if !isgetPath[n] &amp;&amp; shortestPath[n] &lt; pathMin &#123; Vx = n pathMin = shortestPath[n] //w顶点距离v0距离更近 &#125; &#125; isgetPath[Vx] = true //将目前找到的最近的顶点置为true for n := 0; n &lt; len(graph); n++ &#123; //修正当前最短路径及距离 if !isgetPath[n] &amp;&amp; pathMin+graph[Vx][n] &lt; shortestPath[n] &#123; shortestPath[n] = pathMin + graph[Vx][n] shortestV[n] = Vx &#125; &#125; &#125;&#125;func NewGraph() [MAXVEX][MAXVEX]int &#123; var graph [MAXVEX][MAXVEX]int var v0 = [MAXVEX]int&#123;0, 1, 5, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v1 = [MAXVEX]int&#123;1, 0, 3, 7, 5, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v2 = [MAXVEX]int&#123;5, 3, 0, MAXWEIGHT, 1, 7, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v3 = [MAXVEX]int&#123;MAXWEIGHT, 7, MAXWEIGHT, 0, 2, MAXWEIGHT, 3, MAXWEIGHT, MAXWEIGHT&#125; var v4 = [MAXVEX]int&#123;MAXWEIGHT, 5, 1, 2, 0, 3, 6, 9, MAXWEIGHT&#125; var v5 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, 7, MAXWEIGHT, 3, 0, MAXWEIGHT, 5, MAXWEIGHT&#125; var v6 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 3, 6, MAXWEIGHT, 0, 2, 7&#125; var v7 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 9, 5, 2, 0, 4&#125; var v8 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 7, 4, 0&#125; graph[0] = v0 graph[1] = v1 graph[2] = v2 graph[3] = v3 graph[4] = v4 graph[5] = v5 graph[6] = v6 graph[7] = v7 graph[8] = v8 return graph&#125; 其真正核心的代码,只有不到20行,一个从1开始的大循环,里面包含两个小循环 时间复杂度很显然为O(n²) 先进行初始化(即准备工作),再进行贪心算法(大循环部分) 不断”松弛”,即将无穷大或者较大的值,改写为小的 最重要的两个变量是记录v0到各点最短距离的数组shortestPath,和标志位isgetPath shortestV这个map,用来记录每个节点的前驱节点,不是必要的 1234567891011121314151617181920for v := 0; v &lt; len(graph); v++ &#123; shortestPath[v] = graph[0][v]&#125;isgetPath[0] = true //v0至v0不需要求路径for v := 1; v &lt; len(graph); v++ &#123; pathMin = MAXWEIGHT //当前所知的离v0最近的距离 for n := 0; n &lt; len(graph); n++ &#123; //寻找离v0最近的顶点 if !isgetPath[n] &amp;&amp; shortestPath[n] &lt; pathMin &#123; Vx = n pathMin = shortestPath[n] //w顶点距离v0距离更近 &#125; &#125; isgetPath[Vx] = true //将目前找到的最近的顶点置为true for n := 0; n &lt; len(graph); n++ &#123; //修正当前最短路径及距离 if !isgetPath[n] &amp;&amp; pathMin+graph[Vx][n] &lt; shortestPath[n] &#123; shortestPath[n] = pathMin + graph[Vx][n] shortestV[n] = Vx &#125; &#125; &#125; 含有详细注释和辅助信息的完整代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package mainimport ( \"fmt\")const MAXVEX int = 9 //顶点数量const MAXWEIGHT int = 1000var shortestPath = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; //v0到vx的最短路径func main() &#123; graph := NewGraph() shortestV := make(map[int]int) //前驱节点的下标 var pathMin int //存放shortestPath中,未遍历的最小节点的值 var Vx int //存放shortestPath中,未遍历的最小节点的下标 var isgetPath [MAXVEX]bool //记录节点是否已经找到v0到vx的最小路径 //准备工作 // 获取v0这一行的权值数组 for v := 0; v &lt; len(graph); v++ &#123; shortestPath[v] = graph[0][v] &#125; fmt.Println(\"shortTablePath is:\", shortestPath) //shortTablePath is: [0 1 5 1000 1000 1000 1000 1000 1000] //shortestPath[0] = 0 //v0至v0的路径为0.这步可以不需要 isgetPath[0] = true //v0至v0不需要求路径 //遍历v1 ~ v8 //开始主循环,每次求得v0到某个v顶点的最短路径,因此v从1开始而非0 for v := 1; v &lt; len(graph); v++ &#123; fmt.Printf(\"------第%d次大循环开始------\\n\", v) //先令min为极大值,通过下面的第一个循环,与shortestPath[n]比较找到最小值,min=1,Vx=1 pathMin = MAXWEIGHT //当前所知的离v0最近的距离 //找出shortTablePath中,未遍历的最小节点的值 for n := 0; n &lt; len(graph); n++ &#123; //寻找离v0最近的顶点 fmt.Printf(\"----第%d次第一个小循环开始----\\n\", n) if !isgetPath[n] &amp;&amp; shortestPath[n] &lt; pathMin &#123; fmt.Println(\"Vx和n是:\", Vx, n) Vx = n pathMin = shortestPath[n] //w顶点距离v0距离更近 fmt.Println(\"当前的pathMin为:\", pathMin) &#125; fmt.Printf(\"~~~~第%d次第一个小循环结束~~~~\\n\\n\", n) &#125; //Vx=1,表示与v0最近的顶点是v1,且由shortestPath[1]=1,知道此时v0到v1的最短距离为1.改isgetPath[1]为true isgetPath[Vx] = true //将目前找到的最近的顶点置为true fmt.Println(\"此时的isgetPath为:\", isgetPath) //下面这个循环至关重要.其目的是在刚才已找到v0与v1最短路径基础上,对v1与其他顶点的边进行计算,得到v0与它们的当前最短距离. //(第一次)完成下面的小循环之后,shortestPath为(0,1,4,8,6,1000,1000,1000,1000). shortestV[2]=1,shortestV[3]=1,shortestV[4]=1,表示v0到v2,v3,v4点的前驱节点均为v1.此时 shortestV为[0,0,1,1,1,0,0,0,0] for n := 0; n &lt; len(graph); n++ &#123; //修正当前最短路径及距离 fmt.Printf(\"------第%d次第二个小循环开始------\\n\", n) //如果经过v顶点的路径比现在这条路径更短的话 fmt.Println(\"pathMin 和 graph[Vx][n]为\", pathMin, graph[Vx][n]) fmt.Println(\"shortestPath[n]\", shortestPath[n]) if !isgetPath[n] &amp;&amp; pathMin+graph[Vx][n] &lt; shortestPath[n] &#123; //说明找到了更短的路径,修改当前路径长度 shortestPath[n] = pathMin + graph[Vx][n] shortestV[n] = Vx fmt.Println(\"shortestPath为:\", shortestPath) fmt.Println(\"shortestV为:\", shortestV) &#125; fmt.Printf(\"~~~~~第%d次第二个小循环结束~~~~~~~\\n\\n\", n) &#125; fmt.Println(\"遍历完V\", v, \"后:\", shortestPath) fmt.Println(\"各个节点的前驱节点为\", shortestV) fmt.Printf(\"~~~~~~~第%d次大循环结束~~~~~~~\\n\\n\", v) &#125; //输出 for i := 0; i &lt; len(shortestPath); i++ &#123; fmt.Println(\"V0到V\", i, \"最小路径:\", shortestPath[i]) &#125;&#125;func NewGraph() [MAXVEX][MAXVEX]int &#123; var graph [MAXVEX][MAXVEX]int var v0 = [MAXVEX]int&#123;0, 1, 5, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v1 = [MAXVEX]int&#123;1, 0, 3, 7, 5, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v2 = [MAXVEX]int&#123;5, 3, 0, MAXWEIGHT, 1, 7, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT&#125; var v3 = [MAXVEX]int&#123;MAXWEIGHT, 7, MAXWEIGHT, 0, 2, MAXWEIGHT, 3, MAXWEIGHT, MAXWEIGHT&#125; var v4 = [MAXVEX]int&#123;MAXWEIGHT, 5, 1, 2, 0, 3, 6, 9, MAXWEIGHT&#125; var v5 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, 7, MAXWEIGHT, 3, 0, MAXWEIGHT, 5, MAXWEIGHT&#125; var v6 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 3, 6, MAXWEIGHT, 0, 2, 7&#125; var v7 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 9, 5, 2, 0, 4&#125; var v8 = [MAXVEX]int&#123;MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, MAXWEIGHT, 7, 4, 0&#125; graph[0] = v0 graph[1] = v1 graph[2] = v2 graph[3] = v3 graph[4] = v4 graph[5] = v5 graph[6] = v6 graph[7] = v7 graph[8] = v8 return graph&#125; 输出为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687shortTablePath is: [0 1 5 1000 1000 1000 1000 1000 1000]------第1次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----Vx和n是: 0 1当前的pathMin为: 1~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~爽哥评注,之所以从2-8均没有进入if逻辑,是因为 此时shortestPath为[0 1 5 1000 1000 1000 1000 1000 1000],而当前的pathMin在n=1这次循环时被设置为了1,故而[5 1000 1000 1000 1000 1000 1000]均不满足条件此时的isgetPath为: [true true false false false false false false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 1shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 0shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~爽哥评注:上面两次!isgetPath[n] &amp;&amp; pathMin+graph[Vx][n] &lt; shortestPath[n] 都不满足,(此时的isgetPath为: [true true false false false false false false false]),即v0到v0,v1节点的最小路径已经找到------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 3shortestPath[n] 5shortestPath为: [0 1 4 1000 1000 1000 1000 1000 1000]shortestV为: map[2:1] //即v2节点的前驱节点为v1~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 7shortestPath[n] 1000shortestPath为: [0 1 4 8 1000 1000 1000 1000 1000]shortestV为: map[2:1 3:1]//即v2节点的前驱节点为v1,v3节点的前驱节点也为v1~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 5shortestPath[n] 1000shortestPath为: [0 1 4 8 6 1000 1000 1000 1000]shortestV为: map[2:1 3:1 4:1]~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 1000shortestPath[n] 1000~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 1000shortestPath[n] 1000~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 1000shortestPath[n] 1000~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 1 1000shortestPath[n] 1000~~~~~第8次第二个小循环结束~~~~~~~遍历完V 1 后: [0 1 4 8 6 1000 1000 1000 1000]各个节点的前驱节点为 map[2:1 3:1 4:1]~~~~~~~第1次大循环结束~~~~~~~------第2次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----Vx和n是: 1 2当前的pathMin为: 4~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true false false false false false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 5shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 3shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 0shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 1000shortestPath[n] 8~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 1shortestPath[n] 6shortestPath为: [0 1 4 8 5 1000 1000 1000 1000]shortestV为: map[2:1 3:1 4:2]~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 7shortestPath[n] 1000shortestPath为: [0 1 4 8 5 11 1000 1000 1000]shortestV为: map[2:1 3:1 4:2 5:2]~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 1000shortestPath[n] 1000~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 1000shortestPath[n] 1000~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 4 1000shortestPath[n] 1000~~~~~第8次第二个小循环结束~~~~~~~遍历完V 2 后: [0 1 4 8 5 11 1000 1000 1000]各个节点的前驱节点为 map[2:1 3:1 4:2 5:2]~~~~~~~第2次大循环结束~~~~~~~------第3次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----Vx和n是: 2 3当前的pathMin为: 8~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----Vx和n是: 3 4当前的pathMin为: 5~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true false true false false false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 5shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 1shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 2shortestPath[n] 8shortestPath为: [0 1 4 7 5 11 1000 1000 1000]shortestV为: map[2:1 3:4 4:2 5:2]~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 0shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 3shortestPath[n] 11shortestPath为: [0 1 4 7 5 8 1000 1000 1000]shortestV为: map[2:1 3:4 4:2 5:4]~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 6shortestPath[n] 1000shortestPath为: [0 1 4 7 5 8 11 1000 1000]shortestV为: map[2:1 3:4 4:2 5:4 6:4]~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 9shortestPath[n] 1000shortestPath为: [0 1 4 7 5 8 11 14 1000]shortestV为: map[2:1 3:4 4:2 5:4 6:4 7:4]~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 5 1000shortestPath[n] 1000~~~~~第8次第二个小循环结束~~~~~~~遍历完V 3 后: [0 1 4 7 5 8 11 14 1000]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:4 7:4]~~~~~~~第3次大循环结束~~~~~~~------第4次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----Vx和n是: 4 3当前的pathMin为: 7~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true true true false false false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 7shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 1000shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 0shortestPath[n] 7~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 2shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 1000shortestPath[n] 8~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 3shortestPath[n] 11shortestPath为: [0 1 4 7 5 8 10 14 1000]shortestV为: map[2:1 3:4 4:2 5:4 6:3 7:4]~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 1000shortestPath[n] 14~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 7 1000shortestPath[n] 1000~~~~~第8次第二个小循环结束~~~~~~~遍历完V 4 后: [0 1 4 7 5 8 10 14 1000]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:3 7:4]~~~~~~~第4次大循环结束~~~~~~~------第5次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----Vx和n是: 3 5当前的pathMin为: 8~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true true true true false false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 1000shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 7shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 1000shortestPath[n] 7~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 3shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 0shortestPath[n] 8~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 1000shortestPath[n] 10~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 5shortestPath[n] 14shortestPath为: [0 1 4 7 5 8 10 13 1000]shortestV为: map[2:1 3:4 4:2 5:4 6:3 7:5]~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 8 1000shortestPath[n] 1000~~~~~第8次第二个小循环结束~~~~~~~遍历完V 5 后: [0 1 4 7 5 8 10 13 1000]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:3 7:5]~~~~~~~第5次大循环结束~~~~~~~------第6次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----Vx和n是: 5 6当前的pathMin为: 10~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true true true true true false false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 1000shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 1000shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 3shortestPath[n] 7~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 6shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 1000shortestPath[n] 8~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 0shortestPath[n] 10~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 2shortestPath[n] 13shortestPath为: [0 1 4 7 5 8 10 12 1000]shortestV为: map[2:1 3:4 4:2 5:4 6:3 7:6]~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 10 7shortestPath[n] 1000shortestPath为: [0 1 4 7 5 8 10 12 17]shortestV为: map[2:1 3:4 4:2 5:4 6:3 7:6 8:6]~~~~~第8次第二个小循环结束~~~~~~~遍历完V 6 后: [0 1 4 7 5 8 10 12 17]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:3 7:6 8:6]~~~~~~~第6次大循环结束~~~~~~~------第7次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----Vx和n是: 6 7当前的pathMin为: 12~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true true true true true true false]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 1000shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 1000shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 1000shortestPath[n] 7~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 9shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 5shortestPath[n] 8~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 2shortestPath[n] 10~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 0shortestPath[n] 12~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 12 4shortestPath[n] 17shortestPath为: [0 1 4 7 5 8 10 12 16]shortestV为: map[2:1 3:4 4:2 5:4 6:3 7:6 8:7]~~~~~第8次第二个小循环结束~~~~~~~遍历完V 7 后: [0 1 4 7 5 8 10 12 16]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:3 7:6 8:7]~~~~~~~第7次大循环结束~~~~~~~------第8次大循环开始----------第0次第一个小循环开始----~~~~第0次第一个小循环结束~~~~----第1次第一个小循环开始----~~~~第1次第一个小循环结束~~~~----第2次第一个小循环开始----~~~~第2次第一个小循环结束~~~~----第3次第一个小循环开始----~~~~第3次第一个小循环结束~~~~----第4次第一个小循环开始----~~~~第4次第一个小循环结束~~~~----第5次第一个小循环开始----~~~~第5次第一个小循环结束~~~~----第6次第一个小循环开始----~~~~第6次第一个小循环结束~~~~----第7次第一个小循环开始----~~~~第7次第一个小循环结束~~~~----第8次第一个小循环开始----Vx和n是: 7 8当前的pathMin为: 16~~~~第8次第一个小循环结束~~~~此时的isgetPath为: [true true true true true true true true true]------第0次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 0~~~~~第0次第二个小循环结束~~~~~~~------第1次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 1~~~~~第1次第二个小循环结束~~~~~~~------第2次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 4~~~~~第2次第二个小循环结束~~~~~~~------第3次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 7~~~~~第3次第二个小循环结束~~~~~~~------第4次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 5~~~~~第4次第二个小循环结束~~~~~~~------第5次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 1000shortestPath[n] 8~~~~~第5次第二个小循环结束~~~~~~~------第6次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 7shortestPath[n] 10~~~~~第6次第二个小循环结束~~~~~~~------第7次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 4shortestPath[n] 12~~~~~第7次第二个小循环结束~~~~~~~------第8次第二个小循环开始------pathMin 和 graph[Vx][n]为 16 0shortestPath[n] 16~~~~~第8次第二个小循环结束~~~~~~~遍历完V 8 后: [0 1 4 7 5 8 10 12 16]各个节点的前驱节点为 map[2:1 3:4 4:2 5:4 6:3 7:6 8:7]~~~~~~~第8次大循环结束~~~~~~~V0到V 0 最小路径: 0V0到V 1 最小路径: 1V0到V 2 最小路径: 4V0到V 3 最小路径: 7V0到V 4 最小路径: 5V0到V 5 最小路径: 8V0到V 6 最小路径: 10V0到V 7 最小路径: 12V0到V 8 最小路径: 16 总结一下： 迪杰斯特拉算法总共就干了两件事： 【1】不断运行广度优先算法找可见点，计算可见点到源点的距离长度 【2】从当前已知的路径中选择长度最短的将其顶点加入S作为确定找到的最短路径的顶点。 参考: 最短路问题之Dijkstra(Golang)算法 Dijkstra算法 迪杰斯特拉（Dijkstra)算法最通俗易懂的讲解 牛刀小用: leetcode-743. 网络延迟时间","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"节时增效之使用双拼","date":"2020-11-13T14:33:25.000Z","path":"2020/11/13/节时增效之使用双拼/","text":"小鹤双拼 双拼练习 使用小鹤双拼 秋闱软月云舒翅 松拥黛粉更航安 快鹰两望奏夏蛙 撇草追鱼滨鸟眠 自然码 中间的F和J是最常用的en和an，左en右an；再往中间去就是他们的扩展eng和ang。 C和M要一起记，因为他C是iao，M是ian。 L和W一起记，L是ai，W是ia。 O和B一起记，O是uo，B是ou。 Q记“球”。 其实没啥必要,对照图熟能生巧 怎样记忆双拼输入法？ 记住三句话，就会用双拼","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"排序相关问题","date":"2020-10-30T14:07:30.000Z","path":"2020/10/30/排序相关问题/","text":"本篇博客在B站做了内部分享,标题为「排序相关问题」 MySQL的ORDER BY有两种排序实现方式： 利用有序索引获取有序数据 (不得不进行)文件排序 在explain中分析时，利用有序索引获取有序数据显示Using index，文件排序显示Using filesort。 1. 能够 利用有序索引获取有序数据 的条件比较苛刻 以下几种优化方式,可能使order by利用到索引,而无需进行filesort： 12345678910111213141、ORDER BY的索引优化。如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort];在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。 2、WHERE + ORDER BY的索引优化，形如：SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort];建立一个联合索引(columnX,sort)来实现order by 优化。 注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort]; 3、WHERE+ 多个字段ORDER BYSELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。 Order By不能使用索引来优化排序的情况: 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM t1 ORDER BY key1, key2; 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2; 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM t1 WHERE key2=constant ORDER BY key1; 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10; 12345678910111213141516171819CREATE TABLE `weekxxxxxnor_detail` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id', `mid` int(11) NOT NULL DEFAULT '0' COMMENT '用户ID', `hid` int(11) NOT NULL DEFAULT '0' COMMENT '荣誉ID', `word` varchar(10) NOT NULL DEFAULT '' COMMENT '字', `text` varchar(20) NOT NULL DEFAULT '' COMMENT '文案', `description` varchar(40) NOT NULL DEFAULT '' COMMENT '说明', `xxxxx_date` date NOT NULL DEFAULT '0000-00-00' COMMENT 'xx生成日期(每周日)', `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`), KEY `ix_mtime` (`mtime`), KEY `ix_mid_honor_date` (`mid`,`honor_date`)) ENGINE=InnoDB AUTO_INCREMENT=149628474 DEFAULT CHARSET=utf8 COMMENT='xxxxxx详情记录'详细参见 https://note.youdao.com/web/#/file/WEB00c9fc9e542b90ea18d0c3cc53e74d96/note/WEBcb79302cc9f9cadb9d543963f9793baf/搜索 ENGINE=InnoDB AUTO_INCREMENT=149628474 DEFAULT CHARSET=utf8 COMMENT= 2. filesort 2.1 在内存中可能用 堆排序或快速排序， 具体使用哪一种排序方式是优化器决定的，基本原则如下 快速排序算法：大量排序堆排序算法：排序量不大 快速排序和堆排序都是不稳定的排序算法，对于重复值不能保证顺序。这就是Order by排序可能会不稳定的原因 之前遇到的坑： 2.1.1 在把数据加载到BUFFER内部时有两种方式： 双路排序：(rowid排序/二次访问排序/回表排序模式) 首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行指针信息，然后在sort buffer 中进行排序。排序后再把查询字段依照行指针取出，共执行两次磁盘io。 单路排序：MySQL4.1之后新增(全字段排序/一次访问排序) 一次性取出满足条件行的所有字段，然后在sort buffer中进行排序。 执行一次磁盘io。代价是对内存占用大 使用哪种方式，取决于设定的系统参数max_length_for_sort_data(默认为1K) 和Query 语句所取出的字段类型大小总和的大小关系， 来判定是使用双路排序还是单路排序。 如果单行的长度超过max_length_for_sort_data的值，MySQL就认为单行太大，使用双路排序方式； 如果 max_length_for_sort_data更大，则使用第二种优化后的算法。 所以如果希望 ORDER BY 操作的效率尽可能的高，一定要注意max_length_for_sort_data 参数的设置。 2.2 在外部使用多路归并排序算法： 2.3 整个filesort的过程如下: （1）根据表的索引或者全表扫描，读取所有满足条件的记录。 （2）对于每一行，存储一对值到缓冲区（排序列和行记录指针，或者是排序列和查询需要的所有列），缓冲区的大小为sort_buffer_size大小(默认为1M)。 （3）当缓冲区满后，运行一个快速排序（qsort； 数据量不大时也可能用堆排序）来将缓冲区中数据排序，并将排序完的数据存储到一个临时文件，并保存一个存储块的指针，当然如果缓冲区不满，则不会重建临时文件了。 （4）重复以上步骤，直到将所有行读完，并建立相应的有序的临时文件。 （5）对块级进行排序，使用归并排序算法，通过对几个临时文件的指针来不断交换数据，最终达到几个文件，都是有序的。 （6）重复5直到所有的数据都排序完毕。 （7）采取顺序读的方式，将每行数据读入内存（这里读取数据时并不是一行一行读），并取出数据传到客户端，读取缓存大小由read_rnd_buffer_size来指定。 2.4 对比Go中排序算法的实现： 参考： https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html#order-by-filesort-in-memory","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"order by与limit","date":"2020-10-26T12:18:28.000Z","path":"2020/10/26/order-by与limit/","text":"本篇博客在B站做了内部分享,标题为「排序相关问题」 order by “order by”是怎么工作的？ 12https://note.youdao.com/web/#/file/WEB00c9fc9e542b90ea18d0c3cc53e74d96/note/WEBe5cada40f24c94a34f75894edf735ee4/搜索 ENGINE=InnoDB AUTO_INCREMENT=206207915 DEFAULT CHARSET=utf8 COMMENT= MySQL的ORDER BY有两种排序实现方式： 利用有序索引获取有序数据 (不得不进行)文件排序 在explain中分析查询时，利用有序索引获取有序数据显示Using index，文件排序显示Using filesort。 Using index 能够 利用有序索引获取有序数据 的条件比较苛刻, 以下几种优化方式,可能使order by利用到索引,而无需就行filesort 1、ORDER BY的索引优化。如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort];在[sort]这个栏位上建立索引就可以实现利用索引进行order by 优化。 2、WHERE + ORDER BY的索引优化，形如：SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort];建立一个联合索引(columnX,sort)来实现order by 优化。 注意：如果columnX对应多个值，如下面语句就无法利用索引来实现order by的优化SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort]; 3、WHERE+ 多个字段ORDER BYSELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。 MySQL Order By不能使用索引来优化排序的情况: 对不同的索引键做 ORDER BY ：(key1,key2分别建立索引)SELECT * FROM t1 ORDER BY key1, key2; 在非连续的索引键部分上做 ORDER BY：(key_part1,key_part2建立联合索引;key2建立索引)SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2; 同时使用了 ASC 和 DESC：(key_part1,key_part2建立联合索引)SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; 用于搜索记录的索引键和做 ORDER BY 的不是同一个：(key1,key2分别建立索引)SELECT * FROM t1 WHERE key2=constant ORDER BY key1; 如果在WHERE和ORDER BY的栏位上应用表达式(函数)时，则无法利用索引来实现order by的优化SELECT * FROM t1 ORDER BY YEAR(logindate) LIMIT 0,10; Using filesort 全字段排序 filesort的时候可能在内存中出现堆排序或快速排序两种方式，具体使用哪一种排序方式是优化器决定的，基本原则如下 快速排序算法：大量排序堆排序算法：排序量不大 快速排序和堆排序是不稳定的排序算法，对于重复值不能保证顺序。Order by排序不稳定的原因也定位到了 filesort的原理如下: （1）根据表的索引或者全表扫描，读取所有满足条件的记录。 （2）对于每一行，存储一对值到缓冲区（排序列，行记录指针），一个是排序的索引列的值，即order by用到的列值，和指向该行数据的行指针，缓冲区的大小为sort_buffer_size大小。 （3）当缓冲区满后，运行一个快速排序（qsort）来将缓冲区中数据排序，并将排序完的数据存储到一个临时文件，并保存一个存储块的指针，当然如果缓冲区不满，则不会重建临时文件了。 （4）重复以上步骤，直到将所有行读完，并建立相应的有序的临时文件。 （5）对块级进行排序，这个类似归并排序算法，只通过两个临时文件的指针来不断交换数据，最终达到两个文件，都是有序的。 （6）重复5直到所有的数据都排序完毕。 （7）采取顺序读的方式，将每行数据读入内存（这里读取数据时并不是一行一行读），并取出数据传到客户端，读取缓存大小由read_rnd_buffer_size来指定。 双路排序：(rowid排序)首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行指针信息，然后在sort buffer 中进行排序。排序后再吧查询字段依照行指针取出，共执行两次磁盘io。 单路排序：MySQL4.1之后新增(全字段排序)一次性取出满足条件行的所有字段，然后在sort buffer中进行排序。 执行一次磁盘io。代价是对内存占用大 主要通过比较所设定的系统参数 max_length_for_sort_data的大小和Query 语句所取出的字段类型大小总和来判定需要使用哪一种排序算法。如果 max_length_for_sort_data更大，则使用第二种优化后的算法，反之使用第一种算法。 所以如果希望 ORDER BY 操作的效率尽可能的高，一定要注意max_length_for_sort_data 参数的设置。 filesort的优化策略开源 尝试提高 sort_buffer_size 不管使用哪种算法，提高这个参数都会提高效率要根据系统的自身能力去提高，因为这个参数是针对每个线程的 尝试提高 max_length_for_sort_data 改变 max_length_for_sort_data变量的值可以影响mysql选择的算法，提高这个参数，会增加用改进算法即单路排序的概率。 但如果设置得太高，数据总容量超出sort_buffer_size的概率会增大，超出之后，会创建tmp文件进行合并排序，导致多次的I\\O，使用单路排序出现临时文件的风险更大，所以要提高sort_buffer_size (明显症状是高的磁盘I\\O活动和低的处理器使用率) 节流order by 时，只 query 需要的字段这时取出的字段大小总和更可能小于max_length_for_sort_data(且排序字段不是TEXT｜BLOB类型，此时会使用单路排序算法) https://cloud.tencent.com/developer/article/1536886 https://learnku.com/articles/38925 https://plu.one/mysql/2019/02/24/mysql-understand-temporary-and-filesort/ https://blog.csdn.net/weixin_34082854/article/details/93633860 https://blog.csdn.net/shandalue/article/details/51658920","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"sort包源码分析","date":"2020-10-25T03:27:27.000Z","path":"2020/10/25/sort包源码分析/","text":"姊妹篇: 排序算法汇总 sort.Sort的实现: 当待排序元素≤12时，使用希尔排序；当阈值为0时，使用堆排序。否则使用快速排序。在确定其分区点时，有一个三值取中的逻辑（元素数量不大于40时进行一次，大于40时进行三次）。根据注释的Tukey’s Ninther，了解到这是取中值的一个算法… sort.Sort,不稳定排序 12345678910111213141516171819202122232425262728293031// Sort sorts data.// It makes one call to data.Len to determine n, and O(n*log(n)) calls to// data.Less and data.Swap. The sort is not guaranteed to be stable.// 对data.Len进行一次调用以确定n，对data.Less和data.Swap进行O（n * log（n））次调用。 不能保证排序是稳定的。// 注: 如果需要稳定排序,调用sort.Stablefunc Sort(data Interface) &#123; n := data.Len() //从下面maxDepth的注释中可以看出,并不一定是快速排序 quickSort(data, 0, n, maxDepth(n))&#125;// maxDepth returns a threshold at which quicksort should switch// to heapsort. It returns 2*ceil(lg(n+1)).// 该方法返回一个阈值，在该阈值处，快速排序应切换为堆排序。 它返回2 * ceil（lg（n + 1））。// ceil为向上取整函数. 如n=7,则该值为2*3=6func maxDepth(n int) int &#123; var depth int for i := n; i &gt; 0; i &gt;&gt;= 1 &#123; depth++ &#125; return depth * 2&#125; quickSort 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 为0,b为n,即切片中中元素的个数func quickSort(data Interface, a, b, maxDepth int) &#123; // 如果切片元素&lt;=12,则用希尔排序 for b-a &gt; 12 &#123; // Use ShellSort for slices &lt;= 12 elements // 当maxDepth为0时,进行堆排序 if maxDepth == 0 &#123; heapSort(data, a, b) return &#125; maxDepth-- //Pivot即快排的分区点,可参考之前的内容 mlo, mhi := doPivot(data, a, b) // Avoiding recursion on the larger subproblem guarantees // a stack depth of at most lg(b-a). //记得初始时a=0,b=n. mlo-a为分区点左边那段内容,b-mhi为分区点右边那段内容 if mlo-a &lt; b-mhi &#123; //对较小的那一段递归调用quickSort quickSort(data, a, mlo, maxDepth) //数据较大的赋值为mhi,继续进入for循环 a = mhi // i.e., quickSort(data, mhi, b) &#125; else &#123; quickSort(data, mhi, b, maxDepth) b = mlo // i.e., quickSort(data, a, mlo) &#125; &#125; if b-a &gt; 1 &#123; //b-a=1,即切片只有1个元素,无需排序 // Do ShellSort pass with gap 6 // It could be written in this simplified form cause b-a &lt;= 12 // 元素个数&lt;=12,进行一次gap为6的希尔排序 // 希尔排序(不稳定排序),是插入排序的改良版.(在堆排和快排出现前,算是最优的排序算法) //希尔排序时一种改进后的插入排序，因为插入排序对已经排好序的数据操作时更为有效，所以希尔排序先通过一定的间隔将元素划分成几个区域来先进行排序，然后逐步缩小间隔进行排序，最后采用插入排序，因为已经基本都排好了，所以插入排序的效率就很高。 for i := a + 6; i &lt; b; i++ &#123; if data.Less(i, i-6) &#123; data.Swap(i, i-6) &#125; &#125; // 而Golang中希尔排序中使用的Gap值是6，也就是间隔6位的为一组，先进行排序，然后不同于一般的希尔排序将Gap值减半，而是直接进行插入排序。 insertionSort(data, a, b) &#125;&#125; 来看一下Golang中的插入排序: 12345678// Insertion sortfunc insertionSort(data Interface, a, b int) &#123; for i := a + 1; i &lt; b; i++ &#123; for j := i; j &gt; a &amp;&amp; data.Less(j, j-1); j-- &#123; data.Swap(j, j-1) &#125; &#125;&#125; heapSort 1234567891011121314151617181920func heapSort(data Interface, a, b int) &#123; first := a lo := 0 hi := b - a // Build heap with greatest element at top. //用最顶部的元素构建堆。 //步骤一:(hi - 1) / 2到0的元素 向下堆化heapify for i := (hi - 1) / 2; i &gt;= 0; i-- &#123; siftDown(data, i, hi, first) &#125; // Pop elements, largest first, into end of data. //将元素按照 从大到小 Pop进数据结尾 //步骤二:排序,将最大值放到最后面,剩余部分再进行堆化 for i := hi - 1; i &gt;= 0; i-- &#123; data.Swap(first, first+i) siftDown(data, lo, i, first) &#125;&#125; siftDown 堆化操作 一般来说，堆排序的第一步是构建最大堆，第二步是从堆顶取出当前堆最大元素，与堆尾交换，并使堆大小减1；循环第二步，直到堆中没有元素。sort.go 中堆排序的核心函数是 siftDown(data Interface, lo, hi, first int)，它用于维护（和构建）最大堆的性质。 12345678910111213141516171819202122// siftDown implements the heap property on data[lo, hi).// first is an offset into the array where the root of the heap lies.// siftDown在data [lo，hi）上实现了heap属性。// 首先是堆根所在的数组的偏移量。func siftDown(data Interface, lo, hi, first int) &#123; root := lo for &#123; child := 2*root + 1 if child &gt;= hi &#123; break &#125; if child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) &#123; child++ &#125; if !data.Less(first+root, first+child) &#123; return &#125; data.Swap(first+root, first+child) root = child &#125;&#125; doPivot 选择分区点 根据数据量是否大于40,进行了三值取中或九值取中,最终的目的都是找到一个好的分区点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990func doPivot(data Interface, lo, hi int) (midlo, midhi int) &#123; m := int(uint(lo+hi) &gt;&gt; 1) // Written like this to avoid integer overflow. //这样写可以避免整数溢出 if hi-lo &gt; 40 &#123; // Tukey's ``Ninther,'' median of three medians of three. s := (hi - lo) / 8 medianOfThree(data, lo, lo+s, lo+2*s) medianOfThree(data, m, m-s, m+s) medianOfThree(data, hi-1, hi-1-s, hi-1-2*s) &#125; medianOfThree(data, lo, m, hi-1) // Invariants are: // data[lo] = pivot (set up by ChoosePivot) // data[lo &lt; i &lt; a] &lt; pivot // data[a &lt;= i &lt; b] &lt;= pivot // data[b &lt;= i &lt; c] unexamined // data[c &lt;= i &lt; hi-1] &gt; pivot // data[hi-1] &gt;= pivot pivot := lo a, c := lo+1, hi-1 for ; a &lt; c &amp;&amp; data.Less(a, pivot); a++ &#123; &#125; b := a for &#123; for ; b &lt; c &amp;&amp; !data.Less(pivot, b); b++ &#123; // data[b] &lt;= pivot &#125; for ; b &lt; c &amp;&amp; data.Less(pivot, c-1); c-- &#123; // data[c-1] &gt; pivot &#125; if b &gt;= c &#123; break &#125; // data[b] &gt; pivot; data[c-1] &lt;= pivot data.Swap(b, c-1) b++ c-- &#125; // If hi-c&lt;3 then there are duplicates (by property of median of nine). // Let's be a bit more conservative, and set border to 5. protect := hi-c &lt; 5 if !protect &amp;&amp; hi-c &lt; (hi-lo)/4 &#123; // Lets test some points for equality to pivot dups := 0 if !data.Less(pivot, hi-1) &#123; // data[hi-1] = pivot data.Swap(c, hi-1) c++ dups++ &#125; if !data.Less(b-1, pivot) &#123; // data[b-1] = pivot b-- dups++ &#125; // m-lo = (hi-lo)/2 &gt; 6 // b-lo &gt; (hi-lo)*3/4-1 &gt; 8 // ==&gt; m &lt; b ==&gt; data[m] &lt;= pivot if !data.Less(m, pivot) &#123; // data[m] = pivot data.Swap(m, b-1) b-- dups++ &#125; // if at least 2 points are equal to pivot, assume skewed distribution protect = dups &gt; 1 &#125; if protect &#123; // Protect against a lot of duplicates // Add invariant: // data[a &lt;= i &lt; b] unexamined // data[b &lt;= i &lt; c] = pivot for &#123; for ; a &lt; b &amp;&amp; !data.Less(b-1, pivot); b-- &#123; // data[b] == pivot &#125; for ; a &lt; b &amp;&amp; data.Less(a, pivot); a++ &#123; // data[a] &lt; pivot &#125; if a &gt;= b &#123; break &#125; // data[a] == pivot; data[b-1] &lt; pivot data.Swap(a, b-1) a++ b-- &#125; &#125; // Swap pivot into middle data.Swap(pivot, b-1) return b - 1, c&#125; medianOfThree 12345678910111213141516// medianOfThree moves the median of the three values data[m0], data[m1], data[m2] into data[m1].func medianOfThree(data Interface, m1, m0, m2 int) &#123; // sort 3 elements if data.Less(m1, m0) &#123; data.Swap(m1, m0) &#125; // data[m0] &lt;= data[m1] if data.Less(m2, m1) &#123; data.Swap(m2, m1) // data[m0] &lt;= data[m2] &amp;&amp; data[m1] &lt; data[m2] if data.Less(m1, m0) &#123; data.Swap(m1, m0) &#125; &#125; // now data[m0] &lt;= data[m1] &lt;= data[m2]&#125; 关于”Tukey’s Ninther,’’ median of three medians of three.”,更多浏览如下: The Ninther — Approximating Medians The Ninther, a Technique for Low-Effort Robust (Resistant) Location in Large Samples Median 普林斯顿大学红宝书之QUICKSORT 涉猎即可,不需深究 sort.Stable,稳定排序 从算法实现上看, Sort的速度会比 Stable快,再不要求稳定排序时, 优先使用 Sort 参考: 从Golang的排序算法看如何来优化排序 sort 包源码分析 【Go 源码分析】从 sort.go 看排序算法的工程实践","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"人物志-Amdahl","date":"2020-10-24T03:06:09.000Z","path":"2020/10/24/人物志-Amdahl/","text":"图文来自 维基百科 Gene Amdahl Gene Myron Amdahl (November 16, 1922 – November 10, 2015) was an American computer architect and high-tech entrepreneur, chiefly known for his work on mainframe computers at IBM and later his own companies, especially Amdahl Corporation. He formulated Amdahl’s law, which states a fundamental limitation of parallel computing. 吉恩·迈伦·阿姆达尔 (1922.11.16–2015.11.10），美国计算机架构师和高科技企业家，主要以在IBM及后来其自己的公司（尤其是阿姆达尔公司）从事大型计算机工作而闻名。 他阐释了阿姆达尔定律，指出了并行计算的基本局限性。 Childhood and education Amdahl was born to immigrant parents of Norwegian and Swedish descent in Flandreau, South Dakota. After serving in the Navy during World War II he completed a degree in engineering physics at South Dakota State University in 1948.He went on to study theoretical physics at the University of Wisconsin–Madison under Robert G. Sachs. However, in 1950, Amdahl and Charles H. “Charlie” Davidson, a fellow Ph.D. student in the Department of Physics, approached Harold A. Peterson with the idea of a digital computer. Amdahl and Davidson gained the support of Peterson and fellow electrical engineering professor Vincent C. Rideout, who encouraged them to build a computer of their unique design. Amdahl completed his doctorate at UW–Madison in 1952 with a thesis titled A Logical Design of an Intermediate Speed Digital Computer and creating his first computer, the Wisconsin Integrally Synchronized Computer, WISC. He then went straight from Wisconsin to a position at IBM in June 1952. Gene Amdahl is also related to former Minnesota Supreme Court Chief Justice Douglas K. Amdahl. Amdahl出生于南达科他州弗兰德鲁(爽哥注：位于南达科他州和明尼苏达州之交的小城，2010年人口约2300人)，父母是挪威裔和瑞典裔的移民。第二次世界大战期间在海军服役，之后于1948年在南达科他州立大学获得工程物理学学位。此后他继续在威斯康星大学麦迪逊分校，师从罗伯特·萨克斯（Robert G. Sachs）研究理论物理学。然而，在1950年，Amdahl和Charles Davidson，系里的一名博士同伴向哈罗德·彼得森（Harold A. Peterson）提出了数字计算机的想法。Amdahl和Davidson得到了Peterson和电气工程教授Vincent的支持，鼓励他们建造有自己独特设计的计算机。阿姆达尔 于1952年在威斯康星大学麦迪逊分校完成博士学位，题为“中速数字计算机的逻辑设计”，并创建了他的第一台计算机，即威斯康星州整体同步计算机WISC。随后，他于1952年6月从威斯康星州直接转到IBM任职。Gene Amdahl与前明尼苏达州最高法院首席法官Douglas K. Amdahl也有关系。 The IBM and Amdahl years At IBM, Amdahl worked on the IBM 704, the IBM 709, and then the Stretch project, the basis for the IBM 7030. He left IBM in December 1955, but returned in September 1960 (after working at Ramo-Wooldridge and at Aeronutronic). He quit out of frustration with the bureaucratic structure of the organization. In an interview[3] conducted in 1989 for the Charles Babbage Institute, he addressed this: “Well, what I felt was that with that kind of an organization I’m not going to be in control of what I want to do any time in the future. It’s going to be a much more bureaucratic structure. I’ll work in one area of it, and that’s all I’ll get experience in. And I decided that I didn’t want to have that kind of life, basically. It wasn’t just Dunwell. It was the way the structure was set up; I was going to be a peg-in-a-hole.”On his return, he became chief architect of IBM System/360 and was named an IBM Fellow in 1965, and head of the ACS Laboratory in Menlo Park, California. He left IBM again in September 1970, after his ideas for computer development were rejected, and set up Amdahl Corporation in Sunnyvale, California with aid from Fujitsu.Competing with IBM in the mainframe market, the company manufactured “plug-compatible” mainframes, shipping its first machine in 1975 — the Amdahl 470V/6, a less expensive, more reliable and faster replacement for the System 370/168. By purchasing an Amdahl 470 and plug-compatible peripheral devices from third-party manufacturers, customers could now run S/360 and S/370 applications without buying actual IBM hardware. Amdahl’s software team developed VM/PE (Virtual Machine/Performance Enhancement), software designed to optimize the performance of IBM’s MVS operating system when running under IBM’s VM operating system. By 1979, Amdahl Corporation had sold over a US$1 billion[citation needed] of V6 and V7 mainframes and had over 6,000 employees worldwide. The corporation went on to distribute an IBM-plug-compatible front-end processor (the 4705) as well as high-performance disk drives, both jointly developed with Fujitsu engineers.At the 1967 Spring Joint Computer Conference, Amdahl, along with three other computer architects, most notably ILLIAC IV architect Daniel Slotnick, engaged in a discussion on future architectural trends. Amdahl argued, verbally and in three written pages,[10] for performance limitations in any special feature or mode introduced to new machines. This resulted in two, major and lesser, “laws” of computer performance regarding sequential vs. parallel processing. These arguments continue to this day. 在IBM，Amdahl从事IBM 704，IBM 709，及之后的Stretch项目，这是IBM 7030的基础。他于1955年12月离开IBM，但于1960年9月返回（期间Ramo-Wooldridge[爽哥注：全球最大征信公司的前身，成立于1953年]和Aeronutronic[福特汽车的一个部门]工作） 。他辞职的原因，是因对该组织官僚结构充满失望。在1989年查尔斯·巴贝奇研究所（Charles Babbage Institute）的一次采访中，他谈到了以下问题： 好吧，我的感觉是，在这样一个机构，我无法控制我之后想要做的事情。这将是一个更加官僚的结构。我将在其中一个领域工作，这就是我将能得到的所有经验。我不想过这种生活。不只是因为Dunwell。这是组织架构的建立方式； 我将变成一枚螺丝钉。回归后，他成为IBM System/360 的首席架构师，并于1965年被任命为IBM 院士，同时任 加利福尼亚州门洛帕克的ACS实验室的负责人。在对计算机发展的想法遭到拒绝后，他于1970年9月再次离开IBM，并在富士通的帮助下在加利福尼亚州森尼韦尔成立了Amdahl公司。该公司在大型机市场上与IBM竞争，制造了“即插即用”的大型机，并于1975年交付了第一台机器--- Amdahl 470V/6，它比System 370/168更便宜，更可靠并可更快复位。客户可通过从第三方制造商处购买Amdahl 470和兼容插头的外围设备，就可以运行S/360和S/370应用程序，而无需购买实体的IBM硬件。 Amdahl的软件团队开发了VM/PE（虚拟机/性能增强），该软件旨在在IBM VM操作系统下运行时优化IBM MVS操作系统的性能。到1979年，Amdahl Corporation已售出超过10亿美元的 V6和V7大型机，在全球拥有6,000多名员工。该公司继续分销与富士通工程师共同开发的IBM兼容插头的前端处理器（4705）以及高性能磁盘驱动器。在1967年春季联合计算机会议上，Amdahl与其他三位计算机架构师，尤其是ILLIAC IV的架构师Daniel Slotnick一起，讨论了未来的架构趋势。 Amdahl口头和在三页文稿中指出了引入新机器的任何特殊功能或模式下的性能限制。 这导致了有关顺序处理与并行处理的两个主要的和次要的计算机性能定律。 这些争论一直持续到今天。 1979–2015: entrepreneur Amdahl left his eponymous company in August 1979 to set up Trilogy Systems, together with his son Carl Amdahl and Clifford Madden. With over US$200 million in funds, Trilogy was aimed at designing an integrated chip for even cheaper mainframes, but the chip development failed within months of the company’s $60 million public offering; thereafter, the company focused on developing its VLSI technology and, when that project failed, in 1985, Trilogy merged into Elxsi. Elxsi also did poorly and Amdahl left in 1989, having already founded his next venture, Andor International, in 1987. Andor hoped to compete in the mid-sized mainframe market, using improved manufacturing techniques developed by one of the company’s employees, Robert F. Brown, to make smaller, more efficient machines. Production problems and strong competition led the company into bankruptcy by 1995.Amdahl co-founded Commercial Data Servers in 1996, again in Sunnyvale, and again developing mainframe-like machines but this time with new super-cooled processor designs and aimed at physically smaller systems. One such machine, from 1997, was the ESP/490 (Enterprise Server Platform/490), an enhancement of IBM’s P/390 of the System/390 family. Since then, CDS has changed its name and narrowed its focus. As Xbridge Systems, the company now builds software to scan mainframe datasets and database tables for sensitive information such as credit card numbers, social security and other government identification numbers, sensitive medical diagnosis information that can be linked to an individual, and other information such as that needed for electronic discovery.In November 2004, Amdahl was appointed to the board of advisors of Massively Parallel Technologies. He died on November 10, 2015, in Palo Alto, California, from pneumonia, six days shy of his 93rd birthday. He also had Alzheimer’s disease in the last years of his life. Amdahl于1979年8月离开了他的同名公司，与他的儿子Carl Amdahl和Clifford Madden一起成立了Trilogy Systems。 Trilogy拥有超过2亿美元的资金，旨在为更便宜的大型机设计集成芯片，但该芯片开发在公司6000万美元的公开发售后的几个月内失败了；此后，该公司专注于开发其VLSI技术，当该项目失败时，1985年，Trilogy合并为Elxsi。 Elxsi的表现也很差，Amdahl于1989年离开公司，并于1987年成立了他的下一个合资企业Andor International。Andor希望通过使用公司员工Robert F. Brown开发改进的制造技术来竞争中型大型机市​​场，制造更小，更高效的机器。由于生产问题和激烈的竞争，该公司于1995年破产。Amdahl于1996年与他人再次在Sunnyvale共同创立了Commercial Data Servers，并再次开发了类似大型机的机器，但这次却采用了新的特级处理器设计，并针对体积更小的系统。从1997年开始，一台这样的机器就是ESP/490（企业服务器平台/490），它是对IBM System/390系列的P/390的增强。从那时起，CDS更改了名称并缩小了关注范围。作为Xbridge Systems公司，其现在可以构建软件来扫描大型机数据集和数据库表，以查找敏感信息，例如信用卡号，社会保险和其他政府标识号，可以链接到个人的敏感医疗诊断信息以及其他信息，例如电子发现所需的功能。2004年11月，Amdahl被任命为Massively Parallel Technologies顾问委员会的成员。他于93岁生日六天后，即2015年11月10日在加利福尼亚州帕洛阿尔托市死于肺炎。他生命的最后几年也患有阿尔茨海默氏病。 Awards Amdahl was named an IBM Fellow in 1965, became a member of the National Academy of Engineering in 1967 and was recognized as the Centennial Alumnus of South Dakota State University in 1986. He has numerous awards and patents to his credit and has received Honorary Doctorates from his two alma maters and two other institutions as well.Amdahl was elected Distinguished Fellow of the British Computer Society (DFBCS) in 1979 and in 1983, Amdahl was awarded the Harry H. Goode Memorial Award by the IEEE Computer Society “in recognition of his outstanding contributions to the design, applications and manufacture of large-scale high-performance computers.”In 1998, he was made a Fellow of the Computer History Museum “for his fundamental work in computer architecture and design, project management, and leadership.”In November 2007, Amdahl was recognized with the SIGDA Pioneering Achievement Award. A banquet dinner in his honor featured a short talk by Amdahl on his career, and a panel debate on the future of parallel processing. Panelists included John Gustafson (known for Gustafson’s law). The talk and debate were both videotaped, and are available through the SIGDA Web page, and the ACM Digital Library. “寻根之旅”— 2008年，Gene Amdahl和他的妻子 Marian, 在挪威小城Amdahl的一套房子前留影 Amdahl于1965年被任命为IBM院士，1967年成为美国国家工程院院士，并于1986年被公认为南达科他州立大学百年校友。他获得了许多奖项和专利，并获得了两个母校和其他两个机构的荣誉博士学位。阿姆达尔在1979年当选英国计算机协会（DFBCS）的特聘研究员，并于1983年，Amdahl被IEEE计算机协会授予“ Harry H. Goode纪念奖”，以表彰他对大型高性能计算机的设计，应用和制造做出的杰出贡献。1998年，他因“在计算机体系结构和设计，项目管理和领导力方面的基础性工作”而被授予计算机历史博物馆院士。2007年11月，Amdahl被授予SIGDA先驱成就奖。 在他的获奖晚宴上，Amdahl就他的职业做了简短的演讲，并就并行处理的未来进行了小组讨论。 小组成员包括约翰·古斯塔夫森（John Gustafson）（以古斯塔夫森法则著称）。 谈话和谈论均被录像，可通过SIGDA网页和ACM数字图书馆获得。 参考: Amdahl’s law IBM Fellows Computer History Museum 性能调优（一）— Amdahl定律及木桶原理","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"},{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"ErrGroup-有错误返回的Goroutine控制","date":"2020-10-15T13:36:13.000Z","path":"2020/10/15/ErrGroup-有错误返回的Goroutine控制/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\" \"time\")func main() &#123; timeNow := time.Now() a := f1() b := f2() c := f3() fmt.Println(\"和为:\", a+b+c) fmt.Println(\"耗时:\", time.Since(timeNow))&#125;func f1() int &#123; time.Sleep(1e9) return 1&#125;func f2() int &#123; time.Sleep(1e9) return 2&#125;func f3() int &#123; time.Sleep(1e9) return 3&#125; 运行结果为: 12和为: 6耗时: 3.00640904s 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( \"fmt\" \"golang.org/x/sync/errgroup\" \"time\")func main() &#123; var ( g = &amp;errgroup.Group&#123;&#125; a int b int c int ) timeNow := time.Now() g.Go(func() error &#123; a = f1() return nil &#125;) g.Go(func() error &#123; b = f2() return nil &#125;) g.Go(func() error &#123; c = f3() return nil &#125;) g.Wait() fmt.Println(\"和为:\", a+b+c) fmt.Println(\"耗时:\", time.Since(timeNow))&#125;func f1() int &#123; time.Sleep(1e9) return 1&#125;func f2() int &#123; time.Sleep(1e9) return 2&#125;func f3() int &#123; time.Sleep(1e9) return 3&#125; 运行结果为: 12和为: 6耗时: 1.003517107s","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之channel进阶","date":"2020-10-15T04:20:10.000Z","path":"2020/10/15/golang之channel进阶/","text":"Channel 在运行时的内部表示是 runtime.hchan，该结构体中包含了一个用于保护成员变量的互斥锁，从某种程度上说，Channel 是一个用于同步和通信的有锁队列。 有很多试图通过各种方式 实现 无锁 Channel 的方案,但目前都还有各种各样问题尚不够完美. 所以实际上也借助了锁 (sync.Mutex) Go 语言的 Channel 在运行时使用 runtime.hchan 结构体表示。我们在 Go 语言中创建新的 Channel 时，实际上创建的都是该结构体: src/runtime/chan.go 1234567891011121314151617181920type hchan struct &#123; qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex&#125; Go Channel 应用模式","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Semaphore-带权重的信号量","date":"2020-10-15T03:37:02.000Z","path":"2020/10/15/Semaphore-带权重的信号量/","text":"初入门径 Java中有Semaphore类,用来限制访问特定资源的并发线程的数量.相对于内置锁synchronized和重入锁ReentrantLock的互斥性来说,Semaphore可以允许多个线程同时访问共享资源 参考自 Go 并发编程-信号量的使用方法和其实现原理 信号量的概念由 Dijkstra 提出,广泛应用在不同的操作系统中。系统会给每一个进程一个信号量,代表每个进程当前的状态,未得到控制权的进程,会在特定的地方被迫停下来,等待可以继续进行的信号到来。 PV操作 一般用信号量来保护一组资源, 如数据库连接池、一组客户端的连接等等。每次获取资源时,都会将信号量中的计数器减去对应的数值,在释放资源时重新加回来。当遇到信号量资源不够时,尝试获取的线程就会进入休眠,等待其他线程释放归还信号量。如果信号量是只有0和1的二进位信号量,那么其 P/V 就和互斥锁的 Lock/Unlock 一样了。 Go 内部使用信号量来控制goroutine的阻塞和唤醒,如互斥锁sync.Mutex结构体的第二个字段,就是一个信号量: 1234type Mutex struct &#123; state int32 sema uint32&#125; 信号量的PV操作在Go内部是通过下面这几个底层函数实现的. 这几个函数都仅供Go语言内部调用,不能在编程时直接使用。 123func runtime_Semacquire(s *uint32)func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)func runtime_Semrelease(s *uint32, handoff bool, skipframes int) 更多可参考 sync包-Mutex 不过Go的 扩展并发原语包 中提供了带权重的信号量 semaphore.Weighted 使用场景 在实际开发中,当需要控制访问资源的线程数量时,就会需要信号量. 假设有一组要抓取的网站, 资源有限,最多允许同时执行三个抓取任务. 当同时有三个抓取任务在执行时,在执行完一个抓取任务后才能执行下一个排队等待的任务. 这个问题用Channel也能解决,在此使用Go提供的信号量原语来解决该问题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"context\" \"fmt\" \"sync\" \"time\" \"golang.org/x/sync/semaphore\")func doSomething(u string) &#123; // 模拟抓取任务的执行 fmt.Printf(\"开始抓取%s网站\\n\", u) time.Sleep(5 * time.Second)&#125;const ( Limit = 3 // 同時并行运行的goroutine上限 Weight = 1 // 每个goroutine获取信号量资源的权重)func main() &#123; urls := []string&#123; \"http://www.apple.com\", \"http://www.baidu.net\", \"http://www.c.com\", \"http://www.d.com\", \"http://www.ebay.com\", &#125; s := semaphore.NewWeighted(Limit) var w sync.WaitGroup for _, u := range urls &#123; //for的速度远远快过起协程,所以到这里并往下执行时,可能是5个字符串元素时间差不多 w.Add(1) go func(u string) &#123; s.Acquire(context.Background(), Weight) doSomething(u) s.Release(Weight) w.Done() &#125;(u) &#125; w.Wait() fmt.Println(\"All Done\")&#125; 输出为: 12345678开始抓取http://www.ebay.com网站开始抓取http://www.c.com网站开始抓取http://www.apple.com网站(等待5s后)开始抓取http://www.baidu.net网站开始抓取http://www.d.com网站All Done 源码实现 源码行数不多,加上注释一共136行. 点击查看 golang.org/x/sync/semaphore/semaphore.go源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// Copyright 2017 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package semaphore provides a weighted semaphore implementation.package semaphore // import \"golang.org/x/sync/semaphore\"import ( \"container/list\" \"context\" \"sync\")// 如果调用者请求不到信号量的资源就会被加入等待者列表里type waiter struct &#123; n int64 // 调用者请求的资源数 // ready通道会在调用者可以被重新唤醒的时候被close掉,从而起到通知正在阻塞读取ready通道的等待者的作用 ready chan&lt;- struct&#123;&#125; // Closed when semaphore acquired. // 当调用者可以获取到信号量资源时, close这个chan&#125;// NewWeighted creates a new weighted semaphore with the given// maximum combined weight for concurrent access.func NewWeighted(n int64) *Weighted &#123; w := &amp;Weighted&#123;size: n&#125; return w&#125;// Weighted provides a way to bound concurrent access to a resource.// The callers can request access with a given weight.type Weighted struct &#123; size int64 // 字段用来记录信号量拥有的最大资源数 cur int64 // 标识当前已被使用的资源数 mu sync.Mutex // 互斥锁,用来提供对其他字段的临界区保护 waiters list.List // 表示申请资源时由于可使用资源不够而陷入阻塞等待的调用者列表&#125;// Acquire acquires the semaphore with a weight of n, blocking until resources// are available or ctx is done. On success, returns nil. On failure, returns// ctx.Err() and leaves the semaphore unchanged.//// If ctx is already done, Acquire may still succeed without blocking.// Acquire方法会监控资源是否可用,且还会检测传递进来的context.Context对象是否发送了超时过期或者取消的信号func (s *Weighted) Acquire(ctx context.Context, n int64) error &#123; s.mu.Lock() // 如果恰好有足够的资源,也没有排队等待获取资源的goroutine,则将cur加上n后直接返回 if s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == 0 &#123; s.cur += n s.mu.Unlock() return nil &#125; // 请求的资源数 &gt; 能提供的最大资源数, 则该任务处理不了,走错误处理逻辑 if n &gt; s.size &#123; // Don't make other Acquire calls block on one that's doomed to fail. s.mu.Unlock() // 依赖ctx的状态返回,否则一直等待 &lt;-ctx.Done() return ctx.Err() &#125; // 现存资源不够, 需要把调用者加入到等待队列中 // 创建了一个ready chan,以便被通知唤醒 ready := make(chan struct&#123;&#125;) //如果调用者请求不到信号量的资源就会被加入等待者列表里 w := waiter&#123;n: n, ready: ready&#125; elem := s.waiters.PushBack(w) s.mu.Unlock() // 等待 select &#123; case &lt;-ctx.Done(): // context的Done被关闭 err := ctx.Err() s.mu.Lock() select &#123; case &lt;-ready: // 如果被唤醒了,则忽略ctx的状态 // Acquired the semaphore after we were canceled. Rather than trying to // fix up the queue, just pretend we didn't notice the cancelation. err = nil default: // 通知waiter isFront := s.waiters.Front() == elem s.waiters.Remove(elem) // If we're at the front and there're extra tokens left, notify other waiters. // 通知其它的waiters,检查是否有足够的资源 if isFront &amp;&amp; s.size &gt; s.cur &#123; s.notifyWaiters() &#125; &#125; s.mu.Unlock() return err case &lt;-ready: // 等待者被唤醒 return nil &#125;&#125;// TryAcquire acquires the semaphore with a weight of n without blocking.// On success, returns true. On failure, returns false and leaves the semaphore unchanged.func (s *Weighted) TryAcquire(n int64) bool &#123; s.mu.Lock() success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == 0 if success &#123; s.cur += n &#125; s.mu.Unlock() return success&#125;// Release releases the semaphore with a weight of n.//Release方法很简单, 它将当前计数值减去释放的资源数 n, 并调用notifyWaiters方法,尝试唤醒等待队列中的调用者,看是否有足够的资源被获取func (s *Weighted) Release(n int64) &#123; s.mu.Lock() s.cur -= n if s.cur &lt; 0 &#123; s.mu.Unlock() panic(\"semaphore: released more than held\") &#125; s.notifyWaiters() s.mu.Unlock()&#125;// notifyWaiters方法 会逐个检查队列里等待的调用者,如果现存资源 够等待者请求的数量n,或者是没有等待者了,就返回func (s *Weighted) notifyWaiters() &#123; for &#123; next := s.waiters.Front() if next == nil &#123; break // No more waiters blocked. // 没有等待者了,直接返回 &#125; w := next.Value.(waiter) if s.size-s.cur &lt; w.n &#123; // 如果现有资源不够队列头调用者请求的资源数,就退出所有等待者会继续等待 // 这里还是按照先入先出的方式处理是为了避免饥饿 // Not enough tokens for the next waiter. We could keep going (to try to // find a waiter with a smaller request), but under load that could cause // starvation for large requests; instead, we leave all remaining waiters // blocked. // // Consider a semaphore used as a read-write lock, with N tokens, N // readers, and one writer. Each reader can Acquire(1) to obtain a read // lock. The writer can Acquire(N) to obtain a write lock, excluding all // of the readers. If we allow the readers to jump ahead in the queue, // the writer will starve — there is always one token available for every // reader. break &#125; s.cur += w.n s.waiters.Remove(next) close(w.ready) &#125;&#125;// notifyWaiters方法 是按照先入先出的方式唤醒调用者。当释放 100 个资源时，如果第一个等待者需要 101 个资源，那么，队列中的所有等待者都会继续等待，即使队列后面有的等待者只需要 1 个资源。这样做的目的是避免饥饿，否则的话，资源可能总是被那些请求资源数小的调用者获取，这样一来，请求资源数巨大的调用者，就没有机会获得资源了。 注意事项 Go语言中使用到信号量的场景,一般会被channel所取代，因为一个buffered chan(带缓冲的channel)也可以代表 n 个资源.semaphore.Weight其实实际使用得不多,但如果用到需要注意: Acquire和 TryAcquire方法都可以用于获取资源,前者会阻塞的获取信号量,后者会非阻塞的获取信号量,如果获取不到就返回false Release归还信号量后,会以先进先出的顺序唤醒等待队列中的调用者.如果现有资源不够处于等待队列前面的调用者请求的资源数,所有等待者会继续等待。 如果一个goroutine申请较多的资源,由于上面说的归还后唤醒等待者的策略,它可能会等待比较长的时间。 官方库或知名项目中的使用 在docker项目中有使用: 而在大多数项目中,都用channel来替代semaphore.Weight作为信号量, 如Go的官方库net: 如golang.org/x/net/netutil/listen.go: 如go/pkg/mod/gopkg.in/gographics/imagick.v2@v2.6.0/imagick/magick_wand_env.go: 这里有另一种实现","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"SingleFlight-抑制对下游多次重复请求,防止缓存击穿的利器","date":"2020-10-15T03:34:43.000Z","path":"2020/10/15/SingleFlight-抑制对下游多次重复请求-防止缓存击穿的利器/","text":"初入门径 Package singleflight provides a duplicate function call suppression mechanism. singleflight包提供了一种抑制重复函数调用的机制 在处理多个goroutine同时调用同一函数时,SingleFlight可以只让一个goroutine去实际调用该函数,等到这个goroutine返回结果时,再将结果返回给其他几个同时调用该函数的goroutine. 这样可以减少并发调用的数量,减少对下游服务的并发重复请求,比较常见的使用场景是用来防止缓存击穿 使用场景 缓存击穿 如在双11时,维护有一个全局的活动是否结束的key,由运营配置,5分钟过期,重新从数据库里取. 当这个 Key 正好过期失效时, 大量请求会打到数据库上(即缓存击穿). 而用 SingleFlight 来解决缓存击穿问题再合适不过. 只需要只允许这些对同一个 Key 的并发请求中的一个能到数据库中查询,而后这些并发的请求可以共享该结果. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( \"errors\" \"fmt\" \"golang.org/x/sync/singleflight\" \"log\" \"sync\")var errorNotExist = errors.New(\"not exist\")func main() &#123; var wg sync.WaitGroup wg.Add(10) //模拟10个并发 for i := 0; i &lt; 10; i++ &#123; go func() &#123; defer wg.Done() data, err := getData(\"key\") if err != nil &#123; fmt.Print(err) return &#125; fmt.Println(data) fmt.Println(\"---------\") &#125;() &#125; wg.Wait()&#125;var g singleflight.Group//获取数据func getData(key string) (string, error) &#123; data, err := getDataFromCache(key) if err == errorNotExist &#123; //模拟从db中获取数据 data, err = getDataFromDB(key) if err != nil &#123; log.Println(err) return \"\", err &#125; //TOOD: set cache &#125; else if err != nil &#123; return \"\", err &#125; return data, nil&#125;//模拟从cache中获取值，cache中无该值func getDataFromCache(key string) (string, error) &#123; return \"\", errorNotExist&#125;//模拟从数据库中获取值func getDataFromDB(key string) (string, error) &#123; fmt.Printf(\"get %s from database\\n\", key) return \"数据库中的数据\", nil&#125; 执行结果为: 123456789101112131415161718192021222324252627282930get key from database数据库中的数据get key from databaseget key from database数据库中的数据---------get key from databaseget key from database数据库中的数据------------------数据库中的数据get key from database数据库中的数据---------get key from databaseget key from database数据库中的数据------------------数据库中的数据---------get key from database数据库中的数据---------数据库中的数据---------get key from database数据库中的数据--------- 可以看得到10个请求都走了db. 用singlefligth 包优化一下 getData： 123456789101112131415161718192021//获取数据func getData(key string) (string, error) &#123; data, err := getDataFromCache(key) if err == errorNotExist &#123; //模拟从db中获取数据 v, err, _ := g.Do(key, func() (interface&#123;&#125;, error) &#123; return getDataFromDB(key) //set cache &#125;) if err != nil &#123; log.Println(err) return \"\", err &#125; //TOOD: set cache data = v.(string) &#125; else if err != nil &#123; return \"\", err &#125; return data, nil&#125; 执行结果为: 123456789101112131415161718192021get key from database数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据---------数据库中的数据--------- 可以看得到只有一个请求走到了db,且其他请求也返回了正确的值. 从而可以大大降低DB的压力 源码实现 源码行数不多,加上注释一共212行. 点击查看 golang.org/x/sync/semaphore/semaphore.go源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246// Copyright 2013 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package singleflight provides a duplicate function call suppression// mechanism.package singleflight // import \"golang.org/x/sync/singleflight\"import ( \"bytes\" \"errors\" \"fmt\" \"runtime\" \"runtime/debug\" \"sync\")// errGoexit indicates the runtime.Goexit was called in// the user given function.var errGoexit = errors.New(\"runtime.Goexit was called\")// A panicError is an arbitrary value recovered from a panic// with the stack trace during the execution of given function.type panicError struct &#123; value interface&#123;&#125; stack []byte&#125;// Error implements error interface.func (p *panicError) Error() string &#123; return fmt.Sprintf(\"%v\\n\\n%s\", p.value, p.stack)&#125;func newPanicError(v interface&#123;&#125;) error &#123; stack := debug.Stack() // The first line of the stack trace is of the form \"goroutine N [status]:\" // but by the time the panic reaches Do the goroutine may no longer exist // and its status will have changed. Trim out the misleading line. if line := bytes.IndexByte(stack[:], '\\n'); line &gt;= 0 &#123; stack = stack[line+1:] &#125; return &amp;panicError&#123;value: v, stack: stack&#125;&#125;// call is an in-flight or completed singleflight.Do calltype call struct &#123; wg sync.WaitGroup // These fields are written once before the WaitGroup is done // and are only read after the WaitGroup is done. // 函数的返回值，在 wg 返回前只会写入一次 val interface&#123;&#125; err error // forgotten indicates whether Forget was called with this call's key // while the call was still in flight. // 使用调用了 Forgot 方法 forgotten bool // These fields are read and written with the singleflight // mutex held before the WaitGroup is done, and are read but // not written after the WaitGroup is done. // 统计调用次数以及返回的 channel dups int chans []chan&lt;- Result&#125;// Group represents a class of work and forms a namespace in// which units of work can be executed with duplicate suppression.type Group struct &#123; mu sync.Mutex // protects m m map[string]*call // lazily initialized&#125;// Result holds the results of Do, so they can be passed// on a channel.type Result struct &#123; Val interface&#123;&#125; Err error Shared bool&#125;// Do executes and returns the results of the given function, making// sure that only one execution is in-flight for a given key at a// time. If a duplicate comes in, the duplicate caller waits for the// original to complete and receives the same results.// The return value shared indicates whether v was given to multiple callers.func (g *Group) Do(key string, fn func() (interface&#123;&#125;, error)) (v interface&#123;&#125;, err error, shared bool) &#123; g.mu.Lock() // 前面提到的懒加载 if g.m == nil &#123; g.m = make(map[string]*call) &#125; // 会先去看 key 是否已经存在 if c, ok := g.m[key]; ok &#123; // 如果存在就会解锁 c.dups++ // 存在相同的key, 增加计数 g.mu.Unlock() // 然后等待 WaitGroup 执行完毕，只要一执行完，所有的 wait 都会被唤醒 c.wg.Wait() //等待这个key对应的fn调用完成 // 这里区分 panic 错误和 runtime 的错误，避免出现死锁，后面可以看到为什么这么做 if e, ok := c.err.(*panicError); ok &#123; panic(e) &#125; else if c.err == errGoexit &#123; runtime.Goexit() &#125; return c.val, c.err, true // 返回fn调用的结果 &#125; // 如果没有找到这个 key 就 new call c := new(call) // 不存在key, 是第一个请求, 创建一个call结构体 // 然后调用 waitgroup 这里只有第一次调用会 add 1，其他的都会调用 wait 阻塞掉 // 所以这要这次调用返回，所有阻塞的调用都会被唤醒 c.wg.Add(1) g.m[key] = c //加入到映射表中 g.mu.Unlock() // 然后调用 doCall 去执行 g.doCall(c, key, fn) // 调用方法 return c.val, c.err, c.dups &gt; 0&#125;// DoChan is like Do but returns a channel that will receive the// results when they are ready.//// The returned channel will not be closed.// Do chan 和 Do 类似，其实就是一个是同步等待，一个是异步返回，主要实现上:// 如果调用 DoChan 会给 call.chans 添加一个 channel 这样等第一次调用执行完毕之后就会循环向这些 channel 写入数据func (g *Group) DoChan(key string, fn func() (interface&#123;&#125;, error)) &lt;-chan Result &#123; ch := make(chan Result, 1) g.mu.Lock() if g.m == nil &#123; g.m = make(map[string]*call) &#125; if c, ok := g.m[key]; ok &#123; c.dups++ c.chans = append(c.chans, ch) g.mu.Unlock() return ch &#125; c := &amp;call&#123;chans: []chan&lt;- Result&#123;ch&#125;&#125; c.wg.Add(1) g.m[key] = c g.mu.Unlock() go g.doCall(c, key, fn) return ch&#125;// doCall handles the single call for a key.// 这个方法的实现有意思，使用了两个 defer 巧妙的将 runtime 的错误// 和我们传入 function 的 panic 区别开来// 避免了由于传入的 function panic 导致的死锁func (g *Group) doCall(c *call, key string, fn func() (interface&#123;&#125;, error)) &#123; normalReturn := false recovered := false // use double-defer to distinguish panic from runtime.Goexit, // more details see https://golang.org/cl/134395 // 第一个 defer 检查 runtime 错误 defer func() &#123; // the given function invoked runtime.Goexit // 如果既没有正常执行完毕，又没有 recover 那就说明需要直接退出了 if !normalReturn &amp;&amp; !recovered &#123; c.err = errGoexit &#125; c.wg.Done() g.mu.Lock() defer g.mu.Unlock() // 如果已经 forgot 过了，就不要重复删除这个 key 了 if !c.forgotten &#123; delete(g.m, key) &#125; if e, ok := c.err.(*panicError); ok &#123; // In order to prevent the waiting channels from being blocked forever, // needs to ensure that this panic cannot be recovered. // 如果返回的是 panic 错误，为了避免 channel 死锁，我们需要确保这个 panic 无法被恢复 if len(c.chans) &gt; 0 &#123; go panic(e) select &#123;&#125; // Keep this goroutine around so that it will appear in the crash dump. &#125; else &#123; panic(e) &#125; &#125; else if c.err == errGoexit &#123; // Already in the process of goexit, no need to call again // 已经准备退出了，也就不用做其他操作了 &#125; else &#123; // Normal return // 正常情况下向 channel 写入数据 for _, ch := range c.chans &#123; ch &lt;- Result&#123;c.val, c.err, c.dups &gt; 0&#125; &#125; &#125; &#125;() // 使用一个匿名函数来执行 func() &#123; defer func() &#123; if !normalReturn &#123; // Ideally, we would wait to take a stack trace until we've determined // whether this is a panic or a runtime.Goexit. // // Unfortunately, the only way we can distinguish the two is to see // whether the recover stopped the goroutine from terminating, and by // the time we know that, the part of the stack trace relevant to the // panic has been discarded. // 如果 panic 了我们就 recover 掉，然后 new 一个 panic 的错误 // 后面在上层重新 panic if r := recover(); r != nil &#123; c.err = newPanicError(r) &#125; &#125; &#125;() // 如果 fn 没有 panic 就会执行到这一步，如果 panic 了就不会执行到这一步 // 所以可以通过这个变量来判断是否 panic 了 c.val, c.err = fn() normalReturn = true &#125;() if !normalReturn &#123; recovered = true &#125;&#125;// Forget tells the singleflight to forget about a key. Future calls// to Do for this key will call the function rather than waiting for// an earlier call to complete.// 用于手动释放某个 key 下次调用就不会阻塞等待了func (g *Group) Forget(key string) &#123; g.mu.Lock() if c, ok := g.m[key]; ok &#123; c.forgotten = true &#125; delete(g.m, key) g.mu.Unlock()&#125; Do方法: 接收一个字符串Key和一个待调用的函数,会返回调用函数的结果和错误. 使用Do方法时,会根据提供的Key判断是否去真正调用fn函数.同一个 key,在同一时间只有第一次调用Do方法时才会去执行fn函数,其他并发的请求会等待调用的执行结果. Do方法的执行逻辑是每次调用Do方法都会先去获取互斥锁，随后判断在映射表里是否已经有Key对应的fn函数调用信息的call结构体。 当不存在时，证明是这个Key的第一次请求，那么会初始化一个call结构体指针，增加SingleFlight内部持有的sync.WaitGroup计数器到1。释放互斥锁，然后阻塞的等待doCall方法执行fn函数的返回结果当存在时，增加call结构体内代表fn重复调用次数的计数器dups，释放互斥锁，然后使用WaitGroup等待fn函数执行完成。 call结构体的val 和 err 两个字段只会在 doCall方法中执行fn有返回结果后才赋值，所以当 doCall方法 和 WaitGroup.Wait返回时，函数调用的结果和错误会返回给Do方法的所有调用者。 doCall方法会去实际调用fn函数，因为call结构体初始化后forgotten字段的默认值是false，fn调用有返回后，会把对应的Key删掉。这样这轮请求都返回后，下一轮使用同一的Key的请求会重新调用执行一次fn函数。 DoChan方法： 类似Do方法,只不过是异步调用.它会返回一个通道,等fn函数执行完,产生了结果后,就能从这个 chan 中接收这个结果. 它的执行逻辑和Do方法类似，唯一不同的是调用者不用阻塞等待调用的返回， DoChan方法会创建一个chan Result通道返回给调用者，调用者通过这个通道就能接受到fn函数的结果。这个chan Result通道，在返回给调用者前会先放到call结构体的维护的通知队列里，待fn函数返回结果后DoChan方法会把结果发送给通知队列中的每个通道。 Forget方法： 在SingleFlight中删除一个Key. 这样一来,之后这个Key的Do方法调用会执行fn函数,而不是等待前一个未完成的fn 函数的结果. 注意事项 一个阻塞，全员等待 一个出错，全部出错 即 “一荣俱荣,一损俱损” Go并发编程(十二) Singleflight Go Singleflight导致死锁问题分析 官方库或知名项目中的使用 项目中有大量使用,场景基本都是用于防止缓存击穿. 另外, net标准库里使用的lookupGroup结构,将对相同域名的DNS记录查询合并成一个查询. net库提供的DNS记录查询方法LookupIp, 使用lookupGroup这个SingleFlight进行合并查询的相关操作(使用的是异步查询的方法DoChan) net库的 h2_hundle.go ,以及[golang.org/x/net/http2/client_conn_pool.go],都试图用SingleFlight来优化现有代码 Docker之前的某个版本,/docker/builder/fscache/fscache.go中有使用到SingleFlight 参考自: 并发编程–用SingleFlight合并重复请求 不到100行代码做并发控制：防缓存击穿的 singleflight 使用及原理 Golang中的SingleFlight与CyclicBarrier","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Mac上的一些软件","date":"2020-10-11T08:55:51.000Z","path":"2020/10/11/Mac上的一些软件/","text":"Airy for Mac Youtube 视频下载工具 Alfred 3 可能是 Mac 上最强大的效率工具 支持软件和工具的快速启动与搜索, workflow 扩展功能, 记录剪贴板 等 Amadeus Pro Mac平台强大的多轨音频编辑器,简单却功能强大,支持现场录音,数字录音和记录软件,支持各种声音之间的转换 ApowerREC 实用的屏幕录像软件 Araxis Merge 一个可视化的文件比较、合并和同步的软件 Bartender 3 for Mac 菜单栏管理软件 Bartender 3 可以组织菜单栏应用程序. 可以隐藏,重新排列或将菜单栏图标移动到Bartender’s Bar Capslox Capslock+ 的Mac版本 旨在通过热键 减少重复操作, 提高文字编辑效率 Capslox将 Caps Lock 键变成与 Control 等按键类似的修饰键，与其他按键组成组合键，以提供顺手、快速的光标移动、文字选中、删除、窗口绑定以及多剪贴板等便捷功能。 Capslox 正常运行时，Caps Lock 键会成为一个修饰键，和其他键组合触发不同的功能，例如 Caps Lock + E / D / S / F 是上 / 下 / 左 / 右。短按 Caps Lock 键不再是切换大小写，而是发送 Esc。输出大写字母的任务交给 Shift + 字母键 来实现。 CheatSheet 推荐安装 快捷键提示工具 只需长按command键即可呼出当前可用快捷键 安装后需要在辅助功能里开启信任: 设置——安全性和隐私——辅助功能 先解锁, 勾选CheatSheet, 再锁上就ok了 Cinch / Magnet / ShiftIt / Slate 窗口分屏管理软件 通过将屏幕的左，右和上边缘定义为“热区”,提供简单的窗口管理, 可以快速把窗口分成左一半还是右一半,还可以像windows软件一样缩小或放大(Mac本身没有Windows上的win+方向键屏幕空间管理) Copy’em Paste 多次复制的粘贴板管理器 Dash Dash是一个API文档浏览器（ API Documentation Browser）, 以及代码片段管理工具（Code Snippet Manager） Data Creator 结构化数据生成工具.可用来创建非常大的(测试用)数据集 可根据用户喜好来创建结构化数据表(字段),并通过单击将其填充为随机适当的内容(记录),这些数据可以保存在磁盘上,并导入到数据库和应用程序中进行测试和演示. DayMap 一款直观计划应用. 可帮助安排每日和每周的计划,从而获得更高的工作效率 DbWrench 可视化数据库设计工具,特性如下: 图形化的 ERD 图形设计器 将设计的模型生成实际的数据库建库 SQL 脚本 可从已有数据库中反向工程为设计模型 内建 SQL 语法高亮的查询编辑器 支持 Windows, Mac OSX and Linux Discord 一款Mac OS平台上适合游戏玩家的语音聊天工具 Espresso / Sparkle / Touch Forms Pro Espresso: 一款强大的网页开发工具 Sparkle: 可视化网页开发工具 Touch Forms Pro: 一款非常实用的网页表单生成工具 零代码的可视化设计方式, 可以像画图一样设计开发网站,无需任何的编码, 自动生成HTML5和CSS代码 Flow for Mac 时间管理器 Flow可以帮助您专注于完成一项任务、学习功课，或者只是在一段时间内保持注意力不被分散。 Flow可以将您的流程划分为具有预定休息时间的多个时间段，从而使您能够轻松地保持注意力集中。经科学证明，这种方法可以有效地提高您的注意力和积极性，同时减轻压力。 Fork a fast and friendly git client for Mac and Windows 类似 Sourcetree (A free Git client for Windows and Mac) Go2Shell 可以在文件夹中直接打开对应目录的命令行 与cd to功能类似 goPanel 2 goPanel 2 是一款实用的Web服务器管理软件，拥有超过30种独特功能，能与专用服务器或虚拟专用服务器一起使用。可以安装与管理服务如Apache或Nginx、PHP、MySQL或MariaDB、Mail Server和FTP。 HandShaker 解决安卓手机与Mac的文件传输问题 IINA “一个现代的 macOS 视频播放器” iTubeDownloader YouTube视频播放和下载工具 Jumpcut 极简剪贴板历史 Kaleidoscope 大名鼎鼎的”万花筒” 一款很强大的文件和图像比较工具，支持任何文本文件和 jpeg、tiff、png、psd 等格式的图像文件，同时和 git、svn 等版本控制工具能够完美的结合. LICEcap GIF 屏幕录制工具, 录制的 GIF 动画具有较高的压缩率 Lighten for Mac 一款来自XMind的思维导图工具, 拥有极简的操作界面, 可以帮助用户理清头绪,捕捉每一个灵感瞬间,Lighten思维导图软件支持通过 .lighten文件、文本、Markdown、图像、PDF和.XMind共享思维导图. linux-command 推荐安装 Linux 命令搜索工具 MagicanRest 一款强制定时休息软件 Manico 是一个为 macOS 设计的快速的 App 启动和切换工具 如果是一个习惯使用键盘的效率型用户,Manico 将会帮助最大化使用 App 的效率 Medis / rdm / NoSQLBooster for MongoDB / Studio 3T Redis/MongoDB的GUI工具 Memory Clean 2 Mac内存清理工具 MindNode/XMind 思维导图工具 MockingBot / Sketch 均为 原型设计工具 MockingBot即 墨刀 Mounty / Paragon NTFS for Mac / Tuxera Disk Manager 均是 解决因为文件系统不一致,移动硬盘在Mac上无法写入的问题. MySQL Workbench / TablePlus 数据库GUI工具 NeatDownloadManager 下载工具,类似IDM OhMyStar GitHub Stars管理工具 OmniDiskSweeper 磁盘空间管理工具, 可以扫描出硬盘中所有目录、文件所占用的空间 Paintbrush 一款简单易用的绘图工具 Paste 剪切板记录&amp;管理工具 对这个需求,我是孜孜以求,尝试了好多款软件 Paw / RESTed Paw: The most advanced API tool for Mac RESTed :是一款macOS平台的简单的HTTP请求测试工具，RESTed Mac版可以帮助我们在mac电脑上进行HTTP请求测试，支持HTTP认证以及OAuth认证，给出相关的响应信息。 都是类似Postman的工具 Pencil / VisualDesigner 一款开源免费流程图绘制工具 Pencil Mac版是一款开源的原型图绘制工具, 手绘风格的, 就像自己在纸上画的那样 Pencil还可以用来绘制各种架构图和流程图, 同时还提供 Firefox 的插件 VisualDesigner Mac版是一个Macs上的多用途设计软件 VisualDesigner Mac版可以帮助您制作各种类型的图表,流程图,UML设计,平面图 Pendo 一款画风清奇的笔记应用 可以用于写笔记、记待办、计划日程以及社交分享,支持自然语言输入,拥有快速命令,时间轴显示,还可以直接用来发微博 Postico Mac平台上一款优秀的PostgreSQL客户端 PP助手 手机设备 同步管理工具 Proxifier Socks5客户端 配合代理,一台电脑即可做到开黑三国杀 ^_^ RapidWeaver 一款帮助用户更快更好的制作网页的软件 可以在几分钟之内创建具有专业性水准的网页 Scrivener 最佳写作软件 可以辅助作者完成从作品构思、搜集资料、组织结构、增删修改到排版输出的整个写作流程. 无论是结构化的论文还是信马由缰的随笔,各种写作方式都可以在 Scrivener 中找到适合的工具和功能 SiteSucker 一款帮助用户下载数据的下载工具 SiteSucke绝对是一扒网站的利器,不仅仅是下载网站的HTML源文件,他连网站整体架构以及下面的所有文本,程序文件,图片,视频,音频等数据一丝不漏的下载到Mac本地硬盘 Skim PDF阅读器 可通过brew cask 来安装 Slack / Telegram 无需解释 Snip 推荐安装 简单高效的截图工具,支持滚动截屏,获取长图 腾讯出品 SSH Config Editor ssh配置文件管理工具 可以帮助管理ssh配置文件 可添加或修改SSH配置文件、添加或修改端口转发规则、RSA密匙生成、分类管理配置文件等 SwitchHosts 一款快速切换hosts文件的工具 能够帮助你快速方便打造个人专用的网络环境,支持本地和在线两种方式,并且支持导入导出 TeamViewer 远程控制软件,特定场合非常实用. 今年疫情期间,发挥了很大作用 Throng 一款性能压力测试工具 Tunnelblick 一款OpenVPN客户端 在顺网时连接VPN曾用过.不过后来更多是用深信服的EasyConnect客户端 uTools 一款极简、插件化、跨平台、现代化的桌面增强效率软件 可以以插件化的形式把所有的工具集成到一起. 为用户提供了一个可以随时呼出的“看似简单”的输入框 (搜索框),但这个输入框却蕴含了近乎“无限”的能力 WebScraper 简单易用的网站数据抓取工具 WebScraper Mac版可以快速提取与某个网页（包括文本内容）相关的信息, 能够以最少的工作从在线源快速提取内容 可参考: Mac网站数据抓取软件-WebScraper WhatPulse 记录并观察你的电脑使用习惯,可以记录下鼠标/键盘点击次数等, 能显示鼠标点击热点图 甚至还可以统计网络流经国家统计等 参考: WhatPulse – 鼠标/键盘，网络流量统计高级工具 Xversion 一款macOS平台的版本控制工具,支持SVN 在顺网时短暂用过 Contexts 窗口管理神器 Vimac 键盘效率工具. 通过用键盘代替鼠标操作 从而提高效率","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Golang同步原语与锁","date":"2020-10-01T04:04:37.000Z","path":"2020/10/01/Golang同步原语与锁/","text":"基本原语 sync.Mutex与sync.RWMutex 互斥锁sync.Mutex比较暴力,一个协程锁住后,其他协程只能等待;而不管这个协程是读操作还是写操作. 读写(互斥)锁sync.RWMutex是细粒度的互斥锁, 它不限制资源的并发读. 但是读写、写写操作无法并行执行. 一个常见的服务对资源的读写比例会非常高，因为大多数的读请求之间不会相互影响，所以我们可以读写资源操作的分离，在类似场景下提高服务的性能。 读多写少的场景,推荐使用sync.RWMutex 二者的区别,有点类似mysql的排它锁(X锁/写锁)和共享锁(S锁/读锁) sync包–Mutex sync.RWMutex的实现需要基于sync.Mutex sync.Waitgroup sync包-Waitgroup实现原理 依赖了sync.Mutex sync.Once sync.Once-保证运行期间的某段代码只会执行一次 依赖了sync.Mutex sync.Cond sync.Cond-让一系列Goroutine在满足特定条件时被唤醒 依赖了sync.Mutex 扩展原语 ErrGroup ErrGroup-有错误返回的Goroutine控制 Semaphore Semaphore-带权重的信号量 SingleFlight SingleFlight-抑制对下游多次重复请求,防止缓存击穿的利器 番外:并发安全的几个工具 sync.Pool sync包-Pool sync.Map sync包-Map golang之map并发访问 参考: 同步原语与锁","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"为Rust项目贡献源代码","date":"2020-09-21T11:27:02.000Z","path":"2020/09/21/为Rust项目贡献源代码/","text":"https://blog.csdn.net/liigo/article/details/39272325","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"NSQ源码浅析","date":"2020-09-17T13:48:11.000Z","path":"2020/09/17/NSQ源码浅析/","text":"通过NSQ消息队列来学习GO语言 nsq项目地址 123456789101112131415161718➜ source big 16M ./nsq 16M .➜ source ➜ source cd nsq ➜ nsq git:(master) ✗ ➜ nsq git:(master) ✗ big 28K ./bench100K ./nsqlookupd188K ./internal2.1M ./nsqadmin 16K ./contrib380K ./nsqd 13M ./.git124K ./apps 20K ./.idea 16M .➜ nsq git:(master) ✗ tree nsq:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260nsq├── AUTHORS├── CODE_OF_CONDUCT.md├── CONTRIBUTING.md├── ChangeLog.md├── Dockerfile├── LICENSE├── Makefile├── README.md├── apps│ ├── nsq_stat│ │ └── nsq_stat.go│ ├── nsq_tail│ │ └── nsq_tail.go│ ├── nsq_to_file│ │ ├── file_logger.go│ │ ├── nsq_to_file.go│ │ ├── options.go│ │ ├── strftime.go│ │ └── topic_discoverer.go│ ├── nsq_to_http│ │ ├── http.go│ │ ├── nsq_to_http.go│ │ └── nsq_to_http_test.go│ ├── nsq_to_nsq│ │ └── nsq_to_nsq.go│ ├── nsqadmin│ │ └── main.go│ ├── nsqd│ │ ├── README.md│ │ ├── main.go│ │ ├── main_test.go│ │ └── options.go│ ├── nsqlookupd│ │ ├── README.md│ │ └── main.go│ └── to_nsq│ ├── README.md│ └── to_nsq.go├── bench│ ├── bench.py│ ├── bench_channels│ │ └── bench_channels.go│ ├── bench_reader│ │ └── bench_reader.go│ ├── bench_writer│ │ └── bench_writer.go│ └── requirements.txt├── bench.sh├── contrib│ ├── nsq.spec│ ├── nsqadmin.cfg.example│ ├── nsqd.cfg.example│ └── nsqlookupd.cfg.example├── coverage.sh├── dist.sh├── fmt.sh├── go.mod├── go.sum├── internal│ ├── app│ │ ├── float_array.go│ │ └── string_array.go│ ├── auth│ │ └── authorizations.go│ ├── clusterinfo│ │ ├── data.go│ │ ├── producer_test.go│ │ └── types.go│ ├── dirlock│ │ ├── dirlock.go│ │ ├── dirlock_illumos.go│ │ └── dirlock_windows.go│ ├── http_api│ │ ├── api_request.go│ │ ├── api_response.go│ │ ├── compress.go│ │ ├── http_server.go│ │ ├── req_params.go│ │ └── topic_channel_args.go│ ├── lg│ │ ├── lg.go│ │ └── lg_test.go│ ├── pqueue│ │ ├── pqueue.go│ │ └── pqueue_test.go│ ├── protocol│ │ ├── byte_base10.go│ │ ├── byte_base10_test.go│ │ ├── errors.go│ │ ├── names.go│ │ ├── protocol.go│ │ └── tcp_server.go│ ├── quantile│ │ ├── aggregate.go│ │ └── quantile.go│ ├── statsd│ │ ├── client.go│ │ └── host.go│ ├── stringy│ │ ├── slice.go│ │ └── template.go│ ├── test│ │ ├── assertions.go│ │ ├── fakes.go│ │ └── logger.go│ ├── util│ │ ├── rand.go│ │ ├── util_test.go│ │ └── wait_group_wrapper.go│ ├── version│ │ └── binary.go│ └── writers│ ├── boundary_buffered_writer.go│ └── spread_writer.go├── nsqadmin│ ├── README.md│ ├── bindata.go│ ├── context.go│ ├── gulp│ ├── gulpfile.js│ ├── http.go│ ├── http_test.go│ ├── logger.go│ ├── notify.go│ ├── nsqadmin.go│ ├── nsqadmin_test.go│ ├── options.go│ ├── package-lock.json│ ├── package.json│ ├── static│ │ ├── css│ │ │ ├── base.scss│ │ │ └── bootstrap.min.css│ │ ├── fonts│ │ │ ├── glyphicons-halflings-regular.eot│ │ │ ├── glyphicons-halflings-regular.svg│ │ │ ├── glyphicons-halflings-regular.ttf│ │ │ ├── glyphicons-halflings-regular.woff│ │ │ └── glyphicons-halflings-regular.woff2│ │ ├── html│ │ │ └── index.html│ │ ├── img│ │ │ ├── favicon.png│ │ │ └── nsq_blue.png│ │ └── js│ │ ├── app_state.js│ │ ├── collections│ │ │ ├── nodes.js│ │ │ └── topics.js│ │ ├── lib│ │ │ ├── ajax_setup.js│ │ │ ├── handlebars_helpers.js│ │ │ └── pubsub.js│ │ ├── main.js│ │ ├── models│ │ │ ├── channel.js│ │ │ ├── node.js│ │ │ └── topic.js│ │ ├── router.js│ │ └── views│ │ ├── app.js│ │ ├── base.js│ │ ├── channel.hbs│ │ ├── channel.js│ │ ├── counter.hbs│ │ ├── counter.js│ │ ├── error.hbs│ │ ├── header.hbs│ │ ├── header.js│ │ ├── lookup.hbs│ │ ├── lookup.js│ │ ├── node.hbs│ │ ├── node.js│ │ ├── nodes.hbs│ │ ├── nodes.js│ │ ├── spinner.hbs│ │ ├── topic.hbs│ │ ├── topic.js│ │ ├── topics.hbs│ │ ├── topics.js│ │ └── warning.hbs│ └── test│ ├── ca.key│ ├── ca.pem│ ├── ca.srl│ ├── cert.pem│ ├── client.key│ ├── client.pem│ ├── client.req│ ├── key.pem│ ├── server.key│ ├── server.pem│ └── server.req├── nsqd│ ├── README.md│ ├── backend_queue.go│ ├── buffer_pool.go│ ├── channel.go│ ├── channel_test.go│ ├── client_v2.go│ ├── context.go│ ├── dqname.go│ ├── dqname_windows.go│ ├── dummy_backend_queue.go│ ├── guid.go│ ├── guid_test.go│ ├── http.go│ ├── http_test.go│ ├── in_flight_pqueue.go│ ├── in_flight_pqueue_test.go│ ├── logger.go│ ├── lookup.go│ ├── lookup_peer.go│ ├── message.go│ ├── nsqd.go│ ├── nsqd_test.go│ ├── options.go│ ├── protocol_v2.go│ ├── protocol_v2_test.go│ ├── stats.go│ ├── stats_test.go│ ├── statsd.go│ ├── tcp.go│ ├── test│ │ ├── cert.sh│ │ ├── certs│ │ │ ├── ca.key│ │ │ ├── ca.pem│ │ │ ├── ca.srl│ │ │ ├── cert.pem│ │ │ ├── client.key│ │ │ ├── client.pem│ │ │ ├── client.req│ │ │ ├── key.pem│ │ │ ├── server.key│ │ │ ├── server.pem│ │ │ └── server.req│ │ └── openssl.conf│ ├── topic.go│ └── topic_test.go├── nsqlookupd│ ├── README.md│ ├── client_v1.go│ ├── context.go│ ├── http.go│ ├── http_test.go│ ├── logger.go│ ├── lookup_protocol_v1.go│ ├── lookup_protocol_v1_test.go│ ├── nsqlookupd.go│ ├── nsqlookupd_test.go│ ├── options.go│ ├── registration_db.go│ ├── registration_db_test.go│ └── tcp.go├── test.sh└── travis.sh47 directories, 210 files 在app目录下, nsqd(目录下的main.go)是nsq的主入口文件, nsqadmin和nsqlookupd是两个辅助(管理/监控)组件,另外几个也是辅助类的工具 官方文档 UTILITIES-实用工具 internal目录下是公用的代码 启动/运行 也可直接在 nsq/apps/nsqd 下执行go build .,而后运行编译出的二进制文件 此时,绑定4150端口来监听TCPnsq绑定了4151端口监听HTTP请求. 切换到nsq/apps/nsq_to_file目录下,运行go build ., tree ./1234567./├── file_logger.go├── nsq_to_file├── nsq_to_file.go├── options.go├── strftime.go└── topic_discoverer.go 执行 ./nsq_to_file -nsqd-tcp-address=127.0.0.1:4150 -topic=China -channel=ShanDong -output-dir=/Users/dashen/Desktop 此时在指定的文件路径(此处为桌面)就多了一个China.shuangdeMacBook-Pro.2020-09-17_00.log, 但内容为空. 在命令行执行 curl -d &quot;I come from ShanDong Province&quot; http://127.0.0.1:4151/pub?topic=China, 此时再看日志文件,就有了内容: I come from ShanDong Province 注: 一个topic下可能有多个channel.发送消息是到topic,所有订阅都是到channel当发送一条消息到topic, 它下面的每个channel都能收到该消息.而对于某个channel下面的多个客户端,只能有(随机的)其中一个可以收到消息 源码阅读 引入spew包, 添加辅助代码如下: 12345678910111213func (p *program) Init(env svc.Environment) error &#123; spew.Dump(\"env.IsWindowsService is:\", env.IsWindowsService) if env.IsWindowsService() || 1 == 1 &#123; dir := filepath.Dir(os.Args[0]) fmt.Println(\"dir 是:\", dir) fmt.Println(\"os.Chdir(dir) 是:\", os.Chdir(dir)) return os.Chdir(dir) &#125; return nil&#125; 执行go build .,而后运行得到的二进制文件, 在Mac上,执行结果为: 123456789(string) (len=24) \"env.IsWindowsService is:\"(func() bool) 0x1419e50dir 是: .os.Chdir(dir) 是: &lt;nil&gt;[nsqd] 2020/09/17 21:24:45.547745 INFO: nsqd v1.2.1-alpha (built w/go1.14.7)[nsqd] 2020/09/17 21:24:45.547905 INFO: ID: 109[nsqd] 2020/09/17 21:24:45.548293 INFO: NSQ: persisting topic/channel metadata to nsqd.dat[nsqd] 2020/09/17 21:24:45.580097 INFO: TCP: listening on [::]:4150[nsqd] 2020/09/17 21:24:45.580168 INFO: HTTP: listening on [::]:4151 nsq/nsqd/nsqd.go 123456789101112131415161718192021222324type program struct &#123; once sync.Once nsqd *nsqd.NSQD&#125;func (p *program) Start() error &#123; //...省略 go func() &#123; err := p.nsqd.Main() if err != nil &#123; p.Stop() os.Exit(1) &#125; &#125;() return nil&#125;func (p *program) Stop() error &#123; p.once.Do(func() &#123; p.nsqd.Exit() &#125;) return nil&#125; 实现了单例,保证只”运行一次”. 结构体的组合,用的非常标准 1234567891011121314151617181920212223242526272829303132333435type NSQD struct &#123; // 64bit atomic vars need to be first for proper alignment on 32bit platforms clientIDSequence int64 sync.RWMutex opts atomic.Value dl *dirlock.DirLock isLoading int32 errValue atomic.Value startTime time.Time topicMap map[string]*Topic clientLock sync.RWMutex clients map[int64]Client lookupPeers atomic.Value tcpServer *tcpServer tcpListener net.Listener httpListener net.Listener httpsListener net.Listener tlsConfig *tls.Config poolSize int notifyChan chan interface&#123;&#125; optsNotificationChan chan struct&#123;&#125; exitChan chan int waitGroup util.WaitGroupWrapper ci *clusterinfo.ClusterInfo&#125; nsq/nsqd/nsqd.go123456type NSQD struct &#123; //... waitGroup util.WaitGroupWrapper ci *clusterinfo.ClusterInfo&#125; nsq/internal/util/wait_group_wrapper.go1234567891011121314151617package utilimport ( \"sync\")type WaitGroupWrapper struct &#123; sync.WaitGroup&#125;func (w *WaitGroupWrapper) Wrap(cb func()) &#123; w.Add(1) go func() &#123; cb() w.Done() &#125;()&#125; 只是做了一层封装 不同于slice, 对于map和channel,必须make之后才算初始化,才可以正常使用 12345678910type meta struct &#123; Topics []struct &#123; Name string `json:\"name\"` Paused bool `json:\"paused\"` Channels []struct &#123; Name string `json:\"name\"` Paused bool `json:\"paused\"` &#125; `json:\"channels\"` &#125; `json:\"topics\"`&#125; nsq的http服务,使用了httprouter这个包做路由分发","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"sysmon--Runtime Monitoring","date":"2020-09-15T13:37:30.000Z","path":"2020/09/15/sysmon-Runtime-Monitoring/","text":"关于Sysmon，可先参考这篇 Go Sysmon或 该地址 原文作者Vincent Blanchon, 地址Go: sysmon, Runtime Monitoring,仅作翻译及注解 该篇博文被GoCN收录 插图来自A Journey With Go,由 Renee French方面提供 这篇文章基于Go 1.14 Go的标准库提供了一种监测应用程序的线程,并帮你(找寻)程序可能遇到的瓶颈. 该线程称为sysmon，即系统监视器(system monitor).在GMP模型中,这个(特殊)线程未链接任何的P, 这意味着调度器(scheduler)没有将其考虑在内, 因此始终处于运行状态. 如下是带有此特殊线程的图: 更多关于GMP模型的内容,推荐阅读作者的另一篇文章 协程,系统线程及CPU管理 同样, 通过Go tool trace无法追踪到此线程. ( 译者注:Go并发的最小逻辑单位叫做goroutine, 是Go为实现并发提供的用户态线程，这种用户态线程运行在内核态线程(OS线程)之上,也称为协程. 协程是一种用户态的轻量级线程, 其调度完全由用户控制. 从技术角度说，“协程就是你可以暂停执行的函数”. 协程拥有自己的寄存器上下文和栈. 协程调度切换时, 将寄存器上下文和栈保存到其他地方, 在切回来时，恢复先前保存的寄存器上下文和栈. 直接操作栈则基本没有内核切换的开销, 可以不加锁的访问全局变量,所以上下文的切换非常快.Go中的协程有三种：一种是主(轻量级)线程，一种是用来跑 sysmon 的(轻量级)线程，一种是普通的(轻量级)线程,Q: 在调度过程中,如果一个goroutine一直占有CPU又不会有阻塞或则主动让出CPU的调度，scheduler怎么做抢占式调度让出CPU？A: 有一个特殊的sysmon线程做抢占式调度, 当一个goroutine占用CPU超过10毫秒之后,调度器会根据实际情况提供不保证的协程切换参考:Golang-Scheduler原理解析协程与线程的区别) Scope sysmon线程的作用很广, 主要涉及以下方面: 由应用程序创建的计时器(timers). sysmon线程查看应该在运行却仍在等待执行时间的计时器. 在这种情况下, Go将查看空闲的M和P列表, 以便尽可能快地运行它们. 网络轮询器和系统调用. 它将运行在网络操作中被阻塞的goroutine. 垃圾回收器（如果已经很长时间没有运行）. 如果垃圾回收器已经两分钟没有运行,则sysmon将强制执行一轮垃圾回收(GC). 如下是用Go tool trace工具生成的追踪示例: 长时间运行的goroutine的抢占. 任何运行时间超过10毫秒的goroutine都会被抢占, 将运行时间(running time)留给其他goroutine. 有关异步抢占的更多信息,推荐阅读作者 Go：异步抢占 Pace sysmon足够聪明, 在无事可做时不会消耗资源. 其周期(循环时间)是动态的,取决于正在运行的程序的当前活动. 初始速度(执行频次)设置为20纳秒,这意味着sysmon线程一直在寻求(哪里需要)帮助. 然后，经过几个周期, 如果sysmon线程没有执行任何操作, 则两个周期之间的休眠将加倍, 直至达到10毫秒. 如果应用程序没有很多系统调用或 长时间运行的goroutine, 则该线程将在大多数情形下,回退变为10毫秒的延迟(执行频次),从而给应用程序带来非常小的开销. sysmon线程还能够检测其何时不应运行, 如以下两种情况: 垃圾回收器即将要运行. (sysmon线程将在垃圾回收结束时恢复) 所有线程都处于空闲状态,没有任何一个在运行中 在这两种情况下, sysmon都会休眠，从而不会有任何不必要的资源消耗. sysmon有关的源码, 主要在runtime/proc.go和runtime/runtime2.go中","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"prometheus入门","date":"2020-09-14T11:37:24.000Z","path":"2020/09/14/prometheus入门/","text":"Prometheus(普罗米修斯) 是一种 新型监控告警工具,Kubernetes的流行带动了Prometheus的应用。 全文参考自 prometheus学习笔记(1)-mac单机版环境搭建 Mac上安装Prometheus brew install prometheus 安装路径在 /usr/local/Cellar/prometheus/2.20.1, 配置文件在 /usr/local/etc/prometheus.yml: 1234567global: scrape_interval: 15sscrape_configs: - job_name: \"prometheus\" static_configs: - targets: [\"localhost:9090\"] 切换到安装目录的bin文件夹, cd /usr/local/Cellar/prometheus/2.20.1/bin 执行: ./prometheus –config.file=/usr/local/etc/prometheus.yml 此时可访问localhost:9090,有如下页面: 在Status中可以看到若干元信息. 安装grafana brew install grafana 安装路径在 /usr/local/Cellar/grafana/7.1.5, 配置文件在 /usr/local/etc/grafana/grafana.ini, 可在此修改默认的端口等信息 启动: grafana-server –config=/usr/local/etc/grafana/grafana.ini –homepath /usr/local/share/grafana –packaging=brew cfg:default.paths.logs=/usr/local/var/log/grafana cfg:default.paths.data=/usr/local/var/lib/grafana cfg:default.paths.plugins=/usr/local/var/lib/grafana/plugins 访问localhost:3000,有如下页面: (默认的用户名/密码均为admin,首次登陆必须修改密码) Grafana 是一个单纯的前端图表展示工具, 必须为其添加数据源,才能读取到数据进而进行展示, 参考下图: Grafana 支持非常多的数据源. 选择Prometheus数据源, 指定URL地址, 然后保存即可 安装pushgateway 在 Prometheus官网搜索pushgateway, 下载 pushgateway-1.2.0.darwin-amd64.tar.gz 本地解压,运行 ./pushgateway 此时, 在localhost:9091/页面Status这个Tab页,可见: pushgateway的作用:(图片来自网络) (图片来自煎鱼大佬的 Prometheus 快速入门) 即 客户端(不管是通过代码, 还是直接终端敲命令行) 将数据push到网关(pushgateway), 然后Prometheus从网关pull数据 修改Prometheus的配置文件 vim /usr/local/etc/prometheus.yml 增加如下几行,重启Prometheus,以让新的配置文件生效. 1234- job_name: \"push-metrics\" static_configs: - targets: [\"localhost:9091\"] honor_labels: true (Prometheus提供了多种语言的sdk, 最简单的方式是通过shell) 推送一个指标: 1echo \"cui_metric 100\" | curl --data-binary @- http://localhost:9091/metrics/job/dashen_blog 推送多个指标:12345cat &lt;&lt;EOF | curl --data-binary @- http://localhost:9091/metrics/job/dashen_blogblog_visit_total&#123;blogid=\"12345\",domain=\"dashen.tech\",clientip=\"10.0.1.1\"&#125; 20blog_visit_total&#123;blogid=\"34567\",domain=\"dashen.tech\",clientip=\"10.0.1.2\"&#125; 30blog_visit_total&#123;blogid=\"56789\",domain=\"dashen.tech\",clientip=\"10.0.1.3\"&#125; 40EOF blog_visit_total相当于指标名称，{ }中的内容相当于tag，在查询时可根据tag进行过滤，最后的20、30、40相当于具体的指标值。 dashen_blog是job名称, 可根据需要修改 此时http://localhost:9091上, 已能看到刚才push的数据: http://localhost:9090, Prometheus里也能感知刚添加的数据 Prometheus本质上是一个时序数据库. curl命令可以多执行几次, 相当于持续向时序数据库中写入数据. 配置Grafana 1.新建Dashboard 可在设置中进行相关修改 2.添加图表 (可以用sum/max/min/avg这类聚合函数统计指标) 参考&amp;进阶: 新型监控告警工具prometheus（普罗米修斯）的入门使用 Prometheus 快速入门 Prometheus 四大度量指标的了解和应用 使用 Prometheus 对 Go 程序进行指标采集","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"golang性能分析实战","date":"2020-09-12T15:35:32.000Z","path":"2020/09/12/golang性能分析实战/","text":"很早之前写过一篇递归的缺点–以斐波那契数列为例, 只进行了程序的时间消耗对比,对于内存/CPU资源的占用,没有进行比照. 再以此为例,继续分析. 参考:","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"田螺","date":"2020-09-06T06:59:42.000Z","path":"2020/09/06/田螺/","text":"深宵郊外，看着徐大Sao 制作&amp;享用 田螺的视频，赤脚盘坐在临河的长椅，啃着鸭头，聊以慰藉。 有两样挺实用的技能，迄今没能自然而然学会：一是吹口哨，二是嘬田螺。在杭州时，我一老铁H哥，温州人，亦喜食此物。他可以用筷子夹起，吸一口，壳吐掉，像嗑瓜子一样。而我屡试不成，嘬得牙花子生疼，无奈只得用牙签挑食，如弹幕言“实在没了灵魂”。 一眨眼快三十了，人生不折不扣过了三分之一。而这近三十载，除去南国的荔枝，极少再有某样食材，与之相干的回忆多是温馨美好。 一 初次品尝这种并不算健康，吃起来也颇麻烦的食物，是幼年一天傍晚，在外公家的葡萄架下。暑假临近结束，吃完饭，爸妈要接我回去，复又接受学校的钤束。 对这餐告别，姥爷极是在意，从村头肴菜店买来几样菜品，其一便是爆炒田螺。孩童不知吃法，也拿起牙签照猫画虎，却把整个挑出吞下。尾部滋长的小螺被咬得吱呀作响，爸闻声忙说: 那不能吃 不能吃。我愣了，接着听他说起怖人的血吸虫病，和不知所云的“绿水青山枉自多，华佗无奈小虫何”。也是那鲜红似火的辣椒放得多而入味，两样交织，头前还晴空万里，转瞬便阴转多云哇哇大哭起来。 …… 那个年纪，以为漫长的暑假，芊绵的院落，梧桐树上的蝉鸣，淡紫色花朵的幽香，永远如常不会结束，外公也会健硕超脱岁月。 二 九岁十岁，在群山环抱的南北寺，度过了最开心的两年。一年盛夏，忘年交 由大爷，带我去附近的 上河水库 摸田螺。夕阳攲斜，散碎的熹光打在黑虎山。我只在齐膝深的浅滩，在被水淹没的野草间寻落，不多时便有满满战果。这时，由大爷从水深处来，风轻云淡说：“那边有条长虫（蛇），正盘着吐芯子，你先上去，别被它咬到”。我闻言踮脚看去，那边水间一块石头上，确有模模糊糊一团，吐着芯子似在示威启衅。想起动画片里被蛇一口吞掉的桥段，急忙朝岸边走。但感觉踩下的每一脚，都好似恰踏在那蛇身上。 回去后，就在由大爷家歆享佳肴。谈起那条蛇，他颇带遗憾：“要逮住送饭店，得要好几十”。由大娘白了一眼道：“被它咬着你就好了”。 …… 没过多久，南北寺裁撤，合到了县里的中学。我也匆匆离开了百草园，一脚从乡野顽童成了“市民”。初去时的各种不适，尚还犹记。县城某些芝麻绿豆的惺惺作态，迄今作呕。 县城才是中国的底色:一位中西部“前浪”青年的来信 三 十七八岁，亦在暑假。西面的黛溪河汛期涨水。一日早起趁着清凉，爸妈连同还要抱在怀中不愿走路的幼小堂弟，去河里摸索。爸妈轮流，一在河岸抱着跃跃欲试也想参与的弟弟，一人同我下河。清水濯足，算是快事。而我心事萦绕，如雨后初歇的夏日午后般潮湿，实在心不在焉，不觉如何。…当时只道是寻常，却是在多年后才心痛惊觉，这般别无间隙其乐融融，都是莫大幸福。 后来去南方求学务工，像千年前同是弱冠之年南下的同乡辛稼轩。这一晃近10年没能北归，也习惯他乡作故里在此终老。在看不对眼的城市，对并不算吃货的我，不多的几处亮点，竟是三五瓦舍几盘田螺 --- 那感觉实在是好，口感筋弹，入味三分。以至于后来一年中秋，去某市小住，心头最为期待，不是火红的革命旧迹，亦非打卡幼年邮票上的5A景区，而是当年那个极是小众的品牌，在外市开出的第一家加盟店面。千山万水，为那一种老滋味。…工作以后，确乎发现，那衣食无忧，亦有大把时间的四年，年轻时仅有一次。我过得比99%的人充实，但过后看其实还能再好。 四 结束第一份工作，无房车按揭，有过万存款。奢侈休息了一个半月，西去古都高岳。佯作侠客，从华山而下，至洛城东郊，再到嵩山少林，临在离开时，曾在小城对月浅酌。 千里孤行，徐唱吟游，而今思来，好不快哉。 …… 后来，兜兜转转，又回了曾作别，再见是游客的魔都。公务繁踵恐再难得闲，奉钱数万仍捉襟见肘。那种四海无家四海为家，茕茕孑立浪荡江湖的豪情，也伴随年岁渐长而被压缩黯淡。 五 在初次食用田螺的20年后，昔时咿呀孩童长大，在南方某地下工坊劳作；当日古稀耆宿耄耋，于病榻痛苦残喘。青年闻之失声，北上一千六百里归家。泪目之后，在那间承载无数幼年回忆，近些年将要倒掉的西屋里，午饭桌上又见一碟田螺，不由将思绪，拉回20年前那个当时觉来平平无奇的傍晚。 青年已经嗜辣成性甚至无辣不欢，几口下去，却还是落得像小时涕泗横流，布满浓密的须眉，和脸庞的褶皱。 …… 因地处矿区，近些年的过度采煤，令地下塌陷。也正有并居之策，当地政府已在数公里外的别村，开始修建社区。几年之后，这些村落，将伴随几代人回忆，消逝而成为苍茫一片的硗薄田地。 如果把人的一辈子，比作一幅水墨长卷，幼年童年少年，就好似画作的开篇，初时漫漫不感光阴疏忽世事迁流。而到青年到了人生1/3处，忽得意识到，只需对折再对折，就要结束了，开始有些恐慌。 时日一长，也就在日常琐屑的厮磨中，在生活重锤敲击下慢慢接受，到最后，终究是要如星球上过往的千亿访客，悄悄地来，静静地走。 … 这些承载回忆的物件，就是过往勾勒出的远山近水，接下来也只有泼墨挥毫径自朝前，为画作结束前卑微地短暂回瞰，尽可能不留什么缺憾。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"interface,鸭子类型与泛型","date":"2020-09-04T16:08:06.000Z","path":"2020/09/05/interface-鸭子类型与泛型/","text":"golang实现多态 golang利用组合实现继承,和php或java面向对象的继承有何不同 golang之struct入门 泛型 为什么 Go 语言没有泛型 系列文章： golang实现多态 golang利用组合实现继承,和php或java面向对象的继承有何不同 Golang类型断言 golang之interface入门 interface,鸭子类型与泛型","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"血泪教训--拿到新移动硬盘该做的第一件事","date":"2020-09-03T16:11:59.000Z","path":"2020/09/04/血泪教训-拿到新移动硬盘该做的第一件事/","text":"在Mac上使用移动硬盘,只能读不能写,需下载特定软件支持,如 每次不胜其烦,且可能有各种各样神奇问题,该一直困扰我,直到发现阮老师的这篇博客 exFAT 文件系统指南 选择ExFAT,点击抹掉, 输出如下: 12345678910111213141516Volume name : TOSHIBA EXTPartition offset : 2048 sectors (1048576 bytes)Volume size : 3907025072 sectors (2000396836864 bytes)Bytes per sector : 512Bytes per cluster: 131072FAT offset : 2048 sectors (1048576 bytes)# FAT sectors : 120832Number of FATs : 1Cluster offset : 122880 sectors (62914560 bytes)# Clusters : 15261336Volume Serial # : 5f511941Bitmap start : 2Bitmap file size : 1907667Upcase start : 17Upcase file size : 5836Root start : 18 此时,就可以在Mac上对其轻松进行写操作了 后来看了文件系统相关内容,有了更深层次的认识. Linux内核分析与应用8-文件系统 文件系统的中枢—Inode结构体","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"深入探究MySQL的存储引擎","date":"2020-09-03T14:27:01.000Z","path":"2020/09/03/深入探究MySQL的存储引擎/","text":"导出sql文件时,表记录多的对应的sql文件体积也大. 但查看mysql的安装目录,只有区区几百兆, 那mysql将这些数据文件存到了什么位置? 执行: show global variables like “%datadir%”; 在 InnoDB一棵B+树,可以存放多少行数据中,提到了使用 hexdump命令, 在此深入研究,探究Innodb存储引擎","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"点睛之笔--JetBrains系列软件中那些好用的插件","date":"2020-09-03T13:14:51.000Z","path":"2020/09/03/点睛之笔-JetBrains系列软件中那些好用的插件/","text":"曾装过的一些插件: 强烈推荐: Rainbow Brackets 如 彩虹括号 其名,可以使层层嵌套的{},()显示为不同的色彩,对服务端开发,这个插件不要太有用 WakaTime 可以记录在每种编程语言,每个项目上花费的时间. 该插件同时支持VSCode,iTerm2,甚至是Chrome,Word等 更多可参考其 官网 统计代码的网站 CodeGlance 可以使IDE右侧,出现像 Sublime 那样的全局预览 IDE本身的几处功能/设置 在此选一张意境高远望之心旷神怡的图片作为背景 勾掉 匹配大小写, 这样在搜索时,不会区分关键词的大小写 勾选 显示方法分隔符, 这样每个func之间,便会出现一条分隔线 另外,还有几个tips,如 可以设置全局软换行. 双击shift可以搜索全部,在解决git冲突时,可以非常方便跳到相应文件,而不用一层层地点击 建议安装: Key Promoter X 会提示某个操作有快捷键 Chinese(Simplified) Language Pack EAP 比较便捷的IDE汉化方案 GitToolBox 安装之后,在代码中会显示某一行提交的时间和人员信息 Material Theme UI 一系列 有些花里胡哨 的主题 Statistic 统计语言种类和代码行数,类似命令行工具cloc","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"更换机器后,Hexo博客的迁移","date":"2020-08-28T14:41:23.000Z","path":"2020/08/28/更换机器后-Hexo博客的迁移/","text":"1.起 将原机器的博客目录打包,通过scp等方式传到新机器 2.承 新机器安装brew,并用brew安装node&amp;npm 使用 npm install hexo 安装hexo 3.转 将博客解压 进行编辑后,使用hexo g生成静态文件. (还要将新机器的公钥,贴在github/gitee的设置里) 在hexo d 进行部署时,可能会出现错误,如图 搜索可知,是因为此时node版本为14+(原机器node版本为v13.5.0),而hexo版本较低,可通过升级hexo解决. 但因为有轻松控制node版本的nvm,降低node的版本显然更容易 将source /usr/local/opt/nvm/nvm.sh 写入.zshrc或bash_profile 可参考 MAC系统使用Homebrew安装nvm nvm与npm配置“前缀”选项不兼容 比较好的解决流程是: (卸载掉已安装的node和nvm), 使用传统方式安装nvm(因为默认写入的路径对于zsh有误) 再执行nvm install 13.5.0 此时再hexo d可成功执行 注意:node版本的切换仅对当前命令行窗口有效,可配置全局生效 4.合 图片独立部署在gitee上.记得修改node_modules文件夹中hexo-asset-image中的index.js,替换为如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); //新增 var newLink = data.permalink; var infoArr = link.split(\"/\") var year = infoArr[0] var month = infoArr[1] $('img').each(function() &#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem) &#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem) &#123; return elem != ''; &#125;); if (linkArray[linkArray.length - 1] == srcArray[0]) srcArray.shift(); src = srcArray.join('/'); //region 爽哥调试用 // var fs = require(\"fs\"); // // console.log(\"准备写入文件\"); // fs.writeFile('input.txt', '我是通过fs.writeFile写入文件的内容', function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // // fs.writeFile('input123.txt', newLink[0], function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // // fs.writeFile('input456.txt', newLink[1], function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // // // fs.writeFile('input789.txt', newLink.toString(), function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // fs.writeFile('input000.txt', infoArr, function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // // // // fs.writeFile('input9999.txt', year, function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // // // fs.writeFile('input99990000.txt', month, function(err) &#123; // if (err) &#123; // return console.error(err); // &#125; // &#125;); // console.log(\"shuangge1:\",newLink[0]) // console.log(\"shuangge2:\",newLink[1]) // if (newLink[0] &gt; \"2020\" &amp;&amp; newLink[1] &gt; \"05\") &#123; //endregion // 有朝一日码云倒闭,还可以用下面这行代码快速换回github的图片 // $(this).attr('src', '/' + link + src); // 下面这行为码云的博客图片地址,后来仓库容量超过了1G,注释掉这行,用下面的办法 //$(this).attr('src', 'https://geekblog.gitee.io/' + link + src); // 2020.06.01新增,解决gitee仓库超过1G问题;使图片分开存储 //if (year &gt;= \"2018\" &amp;&amp; month &gt; \"03\") &#123; if (year &gt;= \"2018\" || year == \"2015\") &#123; $(this).attr('src', 'http://geekblog.gitee.io/blog-img/' + link + src) &#125; else &#123; $(this).attr('src', 'https://geekblog.gitee.io/' + link + src); &#125; &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"两台Mac之间的资料互传","date":"2020-08-28T14:00:32.000Z","path":"2020/08/28/两台Mac之间的资料互传/","text":"使用最原始的scp 机器A和B可以通过 ssh 用户名@ip的方式(互相)登陆,自然也可以用scp的方式(或rz/sz),如下图: 使用Mac特有的”隔空投送” 必须要都打开蓝牙","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"配置一台符合使用习惯的新Mac之brew篇","date":"2020-08-27T13:45:47.000Z","path":"2020/08/27/配置一台符合使用习惯的新Mac之brew篇/","text":"安装brew从xx类软件中,”复制终端代理命令”,在命令行执行. 而后执行 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" (如无代理软件,可能会出现rufused,可参考解决) 更换Homebrew镜像源 更换Homebrew镜像源 12345678# 替换brew.gitcd \"$(brew --repo)\"git remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 替换homebrew-core.gitcd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.gitcd &amp;&amp; brew update 12345678910# 替换Homebrew Bottles源# 对于bash用户：echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile# 对于zsh用户echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.zshrcsource ~/.zshrc 关闭每次install前的自动更新123vim ~/.zshrc或.bash_profileexport HOMEBREW_NO_AUTO_UPDATE=true 软件安装 使用brew曾安装过的软件: cd /usr/local/opt/ &amp;&amp; ll 如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215total 0lrwxr-xr-x 1 shuangcui admin 24 1 14 2020 aalib -&gt; ../Cellar/aalib/1.4rc5_1lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 ack -&gt; ../Cellar/ack/3.2.0lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 adns -&gt; ../Cellar/adns/1.5.1lrwxr-xr-x 1 shuangcui admin 35 1 13 2020 ag -&gt; ../Cellar/the_silver_searcher/2.2.0lrwxr-xr-x 1 shuangcui admin 29 10 30 2019 aircrack-ng -&gt; ../Cellar/aircrack-ng/1.5.2_1lrwxr-xr-x 1 shuangcui admin 19 4 28 14:13 aom -&gt; ../Cellar/aom/1.0.0lrwxr-xr-x 1 shuangcui admin 19 10 30 2019 apr -&gt; ../Cellar/apr/1.7.0lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 apr-util -&gt; ../Cellar/apr-util/1.6.1_3lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 argon2 -&gt; ../Cellar/argon2/20190702_1lrwxr-xr-x 1 shuangcui admin 28 1 14 2020 asciiquarium -&gt; ../Cellar/asciiquarium/1.1_1lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 aspell -&gt; ../Cellar/aspell/0.60.8lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 autoconf -&gt; ../Cellar/autoconf/2.69lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 autoconf@2.69 -&gt; ../Cellar/autoconf/2.69lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 automake -&gt; ../Cellar/automake/1.16.1_1lrwxr-xr-x 1 shuangcui admin 21 1 13 2020 axel -&gt; ../Cellar/axel/2.17.6lrwxr-xr-x 1 shuangcui admin 31 1 14 2020 bash-completion -&gt; ../Cellar/bash-completion/1.3_3lrwxr-xr-x 1 shuangcui admin 31 1 14 2020 bash-completion@1 -&gt; ../Cellar/bash-completion/1.3_3lrwxr-xr-x 1 shuangcui admin 20 1 14 2020 bat -&gt; ../Cellar/bat/0.12.1lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 boost -&gt; ../Cellar/boost/1.71.0lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 boost@1.71 -&gt; ../Cellar/boost/1.71.0lrwxr-xr-x 1 shuangcui admin 31 12 20 2019 brew-php-switcher -&gt; ../Cellar/brew-php-switcher/2.2lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 brotli -&gt; ../Cellar/brotli/1.0.7lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 c-ares -&gt; ../Cellar/c-ares/1.15.0lrwxr-xr-x 1 shuangcui admin 24 4 28 14:17 cairo -&gt; ../Cellar/cairo/1.16.0_2lrwxr-xr-x 1 shuangcui admin 30 10 30 2019 cookiecutter -&gt; ../Cellar/cookiecutter/1.6.0_1lrwxr-xr-x 1 shuangcui admin 20 1 13 2020 ctop -&gt; ../Cellar/ctop/0.7.2lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 curl -&gt; ../Cellar/curl/7.67.0lrwxr-xr-x 1 shuangcui admin 29 12 20 2019 curl-openssl -&gt; ../Cellar/curl-openssl/7.67.0lrwxr-xr-x 1 shuangcui admin 25 1 14 2020 dash -&gt; ../Cellar/dash/0.5.10.2_1lrwxr-xr-x 1 shuangcui admin 19 12 3 2019 dep -&gt; ../Cellar/dep/0.5.4lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 etcd -&gt; ../Cellar/etcd/3.4.3lrwxr-xr-x 1 shuangcui admin 24 4 28 14:50 ffmpeg -&gt; ../Cellar/ffmpeg/4.2.1_2lrwxr-xr-x 1 shuangcui admin 24 4 28 14:50 ffmpeg@4 -&gt; ../Cellar/ffmpeg/4.2.1_2lrwxr-xr-x 1 shuangcui admin 20 4 28 14:21 flac -&gt; ../Cellar/flac/1.3.3lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 fontconfig -&gt; ../Cellar/fontconfig/2.13.1lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 fortune -&gt; ../Cellar/fortune/9708lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 freetds -&gt; ../Cellar/freetds/1.1.15_1lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 freetype -&gt; ../Cellar/freetype/2.10.1lrwxr-xr-x 1 shuangcui admin 22 4 28 14:13 frei0r -&gt; ../Cellar/frei0r/1.6.1lrwxr-xr-x 1 shuangcui admin 23 4 28 14:14 fribidi -&gt; ../Cellar/fribidi/1.0.8lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 gawk -&gt; ../Cellar/gawk/5.0.1lrwxr-xr-x 1 shuangcui admin 18 10 30 2019 gd -&gt; ../Cellar/gd/2.2.5lrwxr-xr-x 1 shuangcui admin 17 10 30 2019 gdb -&gt; ../Cellar/gdb/8.3lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 gdbm -&gt; ../Cellar/gdbm/1.18.1lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 gearman -&gt; ../Cellar/gearman/1.1.18_2lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 gearmand -&gt; ../Cellar/gearman/1.1.18_2lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 geoip -&gt; ../Cellar/geoip/1.6.12lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 gettext -&gt; ../Cellar/gettext/0.20.1lrwxr-xr-x 1 shuangcui admin 26 3 21 18:25 ghostscript -&gt; ../Cellar/ghostscript/9.50lrwxr-xr-x 1 shuangcui admin 22 4 28 14:40 giflib -&gt; ../Cellar/giflib/5.2.1lrwxr-xr-x 1 shuangcui admin 23 4 20 10:36 git-lfs -&gt; ../Cellar/git-lfs/2.8.0lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 glib -&gt; ../Cellar/glib/2.62.3lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 gmp -&gt; ../Cellar/gmp/6.1.2_2lrwxr-xr-x 1 shuangcui admin 21 11 21 2019 gnu-sed -&gt; ../Cellar/gnu-sed/4.7lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 gnupg -&gt; ../Cellar/gnupg/2.2.19lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 gnupg2 -&gt; ../Cellar/gnupg/2.2.19lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 gnutls -&gt; ../Cellar/gnutls/3.6.11.1lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 go -&gt; ../Cellar/go/1.13.5lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 go-swagger -&gt; ../Cellar/go-swagger/0.21.0lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 golang -&gt; ../Cellar/go/1.13.5lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 google-go -&gt; ../Cellar/go/1.13.5lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 gpg -&gt; ../Cellar/gnupg/2.2.19lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 gpg2 -&gt; ../Cellar/gnupg/2.2.19lrwxr-xr-x 1 shuangcui admin 31 10 30 2019 graphicsmagick -&gt; ../Cellar/graphicsmagick/1.3.33lrwxr-xr-x 1 shuangcui admin 26 4 28 14:17 graphite2 -&gt; ../Cellar/graphite2/1.3.13lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 graphviz -&gt; ../Cellar/graphviz/2.42.2lrwxr-xr-x 1 shuangcui admin 26 3 21 18:25 gs -&gt; ../Cellar/ghostscript/9.50lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 gts -&gt; ../Cellar/gts/0.7.6_1lrwxr-xr-x 1 shuangcui admin 24 4 28 14:18 harfbuzz -&gt; ../Cellar/harfbuzz/2.6.4lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 heroku -&gt; ../Cellar/heroku/7.35.1lrwxr-xr-x 1 shuangcui admin 29 12 20 2019 heroku-node -&gt; ../Cellar/heroku-node/12.13.0lrwxr-xr-x 1 shuangcui admin 22 1 13 2020 htop -&gt; ../Cellar/htop/2.2.0_1lrwxr-xr-x 1 shuangcui admin 22 1 13 2020 htop-osx -&gt; ../Cellar/htop/2.2.0_1lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 hudson -&gt; ../Cellar/jenkins/2.209lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 icu4c -&gt; ../Cellar/icu4c/64.2lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 ilmbase -&gt; ../Cellar/ilmbase/2.3.0lrwxr-xr-x 1 shuangcui admin 29 12 20 2019 imagemagick -&gt; ../Cellar/imagemagick/7.0.9-8lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 jansson -&gt; ../Cellar/jansson/2.12lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 jasper -&gt; ../Cellar/jasper/2.0.16_1lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 jemalloc -&gt; ../Cellar/jemalloc/5.2.1lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 jenkins -&gt; ../Cellar/jenkins/2.209lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 jmeter -&gt; ../Cellar/jmeter/5.2.1lrwxr-xr-x 1 shuangcui admin 17 10 30 2019 jpeg -&gt; ../Cellar/jpeg/9clrwxr-xr-x 1 shuangcui admin 16 10 30 2019 jq -&gt; ../Cellar/jq/1.6lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 kafka -&gt; ../Cellar/kafka/2.3.1lrwxr-xr-x 1 shuangcui admin 20 4 28 14:13 lame -&gt; ../Cellar/lame/3.100lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 lcms2 -&gt; ../Cellar/little-cms2/2.9lrwxr-xr-x 1 shuangcui admin 28 4 28 14:43 leptonica -&gt; ../Cellar/leptonica/1.78.0_1lrwxr-xr-x 1 shuangcui admin 25 4 28 14:18 libass -&gt; ../Cellar/libass/0.14.0_1lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 libassuan -&gt; ../Cellar/libassuan/2.5.3lrwxr-xr-x 1 shuangcui admin 25 4 28 14:18 libbluray -&gt; ../Cellar/libbluray/1.1.2lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 libde265 -&gt; ../Cellar/libde265/1.0.3lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 libev -&gt; ../Cellar/libev/4.27lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 libevent -&gt; ../Cellar/libevent/2.1.11_1lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libffi -&gt; ../Cellar/libffi/3.2.1lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 libgcrypt -&gt; ../Cellar/libgcrypt/1.8.5lrwxr-xr-x 1 shuangcui admin 18 10 30 2019 libgd -&gt; ../Cellar/gd/2.2.5lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libgeoip -&gt; ../Cellar/geoip/1.6.12lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 libgpg-error -&gt; ../Cellar/libgpg-error/1.36lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 libheif -&gt; ../Cellar/libheif/1.6.0lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 libidn -&gt; ../Cellar/libidn/1.35lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 libidn2 -&gt; ../Cellar/libidn2/2.3.0lrwxr-xr-x 1 shuangcui admin 17 10 30 2019 libjpeg -&gt; ../Cellar/jpeg/9clrwxr-xr-x 1 shuangcui admin 17 10 30 2019 libjpg -&gt; ../Cellar/jpeg/9clrwxr-xr-x 1 shuangcui admin 23 10 30 2019 libksba -&gt; ../Cellar/libksba/1.3.5lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libmcrypt -&gt; ../Cellar/mcrypt/2.6.8lrwxr-xr-x 1 shuangcui admin 31 10 30 2019 libmemcached -&gt; ../Cellar/libmemcached/1.0.18_2lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 libmetalink -&gt; ../Cellar/libmetalink/0.1.3lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libnettle -&gt; ../Cellar/nettle/3.4.1lrwxr-xr-x 1 shuangcui admin 22 4 28 14:19 libogg -&gt; ../Cellar/libogg/1.3.4lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libomp -&gt; ../Cellar/libomp/9.0.0lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 libpng -&gt; ../Cellar/libpng/1.6.37lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 libpq -&gt; ../Cellar/libpq/12.1_1lrwxr-xr-x 1 shuangcui admin 31 4 28 14:24 libsamplerate -&gt; ../Cellar/libsamplerate/0.1.9_1lrwxr-xr-x 1 shuangcui admin 27 4 28 14:21 libsndfile -&gt; ../Cellar/libsndfile/1.0.28lrwxr-xr-x 1 shuangcui admin 28 12 20 2019 libsodium -&gt; ../Cellar/libsodium/1.0.18_1lrwxr-xr-x 1 shuangcui admin 23 4 28 14:19 libsoxr -&gt; ../Cellar/libsoxr/0.1.3lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 libssh2 -&gt; ../Cellar/libssh2/1.9.0_1lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 libtasn -&gt; ../Cellar/libtasn1/4.15.0lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 libtasn1 -&gt; ../Cellar/libtasn1/4.15.0lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 libtiff -&gt; ../Cellar/libtiff/4.1.0lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 libtool -&gt; ../Cellar/libtool/2.4.6_1lrwxr-xr-x 1 shuangcui admin 29 10 30 2019 libunistring -&gt; ../Cellar/libunistring/0.9.10lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 libusb -&gt; ../Cellar/libusb/1.0.23lrwxr-xr-x 1 shuangcui admin 26 4 28 14:19 libvidstab -&gt; ../Cellar/libvidstab/1.1.0lrwxr-xr-x 1 shuangcui admin 25 4 28 14:19 libvorbis -&gt; ../Cellar/libvorbis/1.3.6lrwxr-xr-x 1 shuangcui admin 22 4 28 14:20 libvpx -&gt; ../Cellar/libvpx/1.8.1lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 libzip -&gt; ../Cellar/libzip/1.5.2lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 little-cms2 -&gt; ../Cellar/little-cms2/2.9lrwxr-xr-x 1 shuangcui admin 24 1 14 2020 lolcat -&gt; ../Cellar/lolcat/100.0.0lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 lrzsz -&gt; ../Cellar/lrzsz/0.12.20_1lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 lua -&gt; ../Cellar/lua/5.3.5_1lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 lua@5.3 -&gt; ../Cellar/lua/5.3.5_1lrwxr-xr-x 1 shuangcui admin 18 4 28 14:14 lzo -&gt; ../Cellar/lzo/2.10lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 mcrypt -&gt; ../Cellar/mcrypt/2.6.8lrwxr-xr-x 1 shuangcui admin 26 12 20 2019 memcached -&gt; ../Cellar/memcached/1.5.20lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 mhash -&gt; ../Cellar/mhash/0.9.9.9lrwxr-xr-x 1 shuangcui admin 33 1 3 2020 mongodb-community -&gt; ../Cellar/mongodb-community/4.2.2lrwxr-xr-x 1 shuangcui admin 33 1 3 2020 mongodb-community@4.2 -&gt; ../Cellar/mongodb-community/4.2.2lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 mpfr -&gt; ../Cellar/mpfr/4.0.2lrwxr-xr-x 1 shuangcui admin 29 12 20 2019 mysql-client -&gt; ../Cellar/mysql-client/8.0.18lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 mysql@5.7 -&gt; ../Cellar/mysql@5.7/5.7.28lrwxr-xr-x 1 shuangcui admin 21 1 13 2020 ncdu -&gt; ../Cellar/ncdu/1.14.1lrwxr-xr-x 1 shuangcui admin 21 10 30 2019 ncurses -&gt; ../Cellar/ncurses/6.1lrwxr-xr-x 1 shuangcui admin 25 10 30 2019 netpbm -&gt; ../Cellar/netpbm/10.73.27lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 nettle -&gt; ../Cellar/nettle/3.4.1lrwxr-xr-x 1 shuangcui admin 24 12 20 2019 nghttp2 -&gt; ../Cellar/nghttp2/1.40.0lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 node -&gt; ../Cellar/node/13.5.0lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 node.js -&gt; ../Cellar/node/13.5.0lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 nodejs -&gt; ../Cellar/node/13.5.0lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 npm -&gt; ../Cellar/node/13.5.0lrwxr-xr-x 1 shuangcui admin 18 10 30 2019 npth -&gt; ../Cellar/npth/1.6lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 oniguruma -&gt; ../Cellar/oniguruma/6.9.4lrwxr-xr-x 1 shuangcui admin 28 4 28 14:20 opencore-amr -&gt; ../Cellar/opencore-amr/0.1.5lrwxr-xr-x 1 shuangcui admin 23 10 30 2019 openexr -&gt; ../Cellar/openexr/2.3.0lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 openjpeg -&gt; ../Cellar/openjpeg/2.3.1lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 openldap -&gt; ../Cellar/openldap/2.4.48_1lrwxr-xr-x 1 shuangcui admin 28 10 30 2019 openssl@1.1 -&gt; ../Cellar/openssl@1.1/1.1.1dlrwxr-xr-x 1 shuangcui admin 20 4 28 14:21 opus -&gt; ../Cellar/opus/1.3.1lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 p11-kit -&gt; ../Cellar/p11-kit/0.23.18.1lrwxr-xr-x 1 shuangcui admin 19 10 30 2019 pcre -&gt; ../Cellar/pcre/8.43lrwxr-xr-x 1 shuangcui admin 19 10 30 2019 pcre1 -&gt; ../Cellar/pcre/8.43lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 pcre2 -&gt; ../Cellar/pcre2/10.34lrwxr-xr-x 1 shuangcui admin 20 1 14 2020 peco -&gt; ../Cellar/peco/0.5.3lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 php -&gt; ../Cellar/php/7.4.1lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 pinentry -&gt; ../Cellar/pinentry/1.1.0_1lrwxr-xr-x 1 shuangcui admin 23 4 28 14:15 pixman -&gt; ../Cellar/pixman/0.38.4lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 pkg-config -&gt; ../Cellar/pkg-config/0.29.2lrwxr-xr-x 1 shuangcui admin 27 10 30 2019 pkgconfig -&gt; ../Cellar/pkg-config/0.29.2lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 polipo -&gt; ../Cellar/polipo/1.1.1lrwxr-xr-x 1 shuangcui admin 25 5 25 17:15 postgres -&gt; ../Cellar/postgresql/12.1lrwxr-xr-x 1 shuangcui admin 25 5 25 17:15 postgresql -&gt; ../Cellar/postgresql/12.1lrwxr-xr-x 1 shuangcui admin 25 5 25 17:15 postgresql@12 -&gt; ../Cellar/postgresql/12.1lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 protobuf -&gt; ../Cellar/protobuf/3.11.2lrwxr-xr-x 1 shuangcui admin 21 1 14 2020 pstree -&gt; ../Cellar/pstree/2.39lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 python -&gt; ../Cellar/python/3.7.5lrwxr-xr-x 1 shuangcui admin 22 12 20 2019 python3 -&gt; ../Cellar/python/3.7.5lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 readline -&gt; ../Cellar/readline/8.0.1lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 redis -&gt; ../Cellar/redis/5.0.7lrwxr-xr-x 1 shuangcui admin 33 10 30 2019 rtmpdump -&gt; ../Cellar/rtmpdump/2.4+20151223_1lrwxr-xr-x 1 shuangcui admin 28 4 28 14:24 rubberband -&gt; ../Cellar/rubberband/1.8.2_1lrwxr-xr-x 1 shuangcui admin 27 1 13 2020 screenfetch -&gt; ../Cellar/screenfetch/3.9.1lrwxr-xr-x 1 shuangcui admin 21 4 28 14:25 sdl2 -&gt; ../Cellar/sdl2/2.0.10lrwxr-xr-x 1 shuangcui admin 31 12 20 2019 shared-mime-info -&gt; ../Cellar/shared-mime-info/1.15lrwxr-xr-x 1 shuangcui admin 23 11 13 2019 siege -&gt; ../Cellar/siege/4.0.4_2lrwxr-xr-x 1 shuangcui admin 24 4 28 14:25 snappy -&gt; ../Cellar/snappy/1.1.7_1lrwxr-xr-x 1 shuangcui admin 21 4 28 14:39 speex -&gt; ../Cellar/speex/1.2.0lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 sqlite -&gt; ../Cellar/sqlite/3.30.1lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 sqlite3 -&gt; ../Cellar/sqlite/3.30.1lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 supervisor -&gt; ../Cellar/supervisor/4.1.0lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 supervisord -&gt; ../Cellar/supervisor/4.1.0lrwxr-xr-x 1 shuangcui admin 25 12 20 2019 sysbench -&gt; ../Cellar/sysbench/1.0.19lrwxr-xr-x 1 shuangcui admin 19 10 30 2019 telnet -&gt; ../Cellar/telnet/60lrwxr-xr-x 1 shuangcui admin 25 4 28 14:44 tesseract -&gt; ../Cellar/tesseract/4.1.0lrwxr-xr-x 1 shuangcui admin 35 1 13 2020 the_silver_searcher -&gt; ../Cellar/the_silver_searcher/2.2.0lrwxr-xr-x 1 shuangcui admin 22 1 13 2020 thefuck -&gt; ../Cellar/thefuck/3.29lrwxr-xr-x 1 shuangcui admin 22 4 28 14:44 theora -&gt; ../Cellar/theora/1.1.1lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 thrift -&gt; ../Cellar/thrift/0.13.0lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 tidy-html5 -&gt; ../Cellar/tidy-html5/5.6.0lrwxr-xr-x 1 shuangcui admin 22 10 30 2019 tldr -&gt; ../Cellar/tldr/1.3.0_2lrwxr-xr-x 1 shuangcui admin 19 12 20 2019 tmux -&gt; ../Cellar/tmux/3.0alrwxr-xr-x 1 shuangcui admin 20 10 30 2019 tree -&gt; ../Cellar/tree/1.8.0lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 unbound -&gt; ../Cellar/unbound/1.9.6lrwxr-xr-x 1 shuangcui admin 24 10 30 2019 unixodbc -&gt; ../Cellar/unixodbc/2.3.7lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 unrar -&gt; ../Cellar/unrar/5.8.5lrwxr-xr-x 1 shuangcui admin 26 4 28 14:19 vid.stab -&gt; ../Cellar/libvidstab/1.1.0lrwxr-xr-x 1 shuangcui admin 20 10 30 2019 webp -&gt; ../Cellar/webp/1.0.3lrwxr-xr-x 1 shuangcui admin 23 12 20 2019 wget -&gt; ../Cellar/wget/1.20.3_2lrwxr-xr-x 1 shuangcui admin 22 4 28 14:44 x264 -&gt; ../Cellar/x264/r2917_1lrwxr-xr-x 1 shuangcui admin 20 12 20 2019 x265 -&gt; ../Cellar/x265/3.2.1lrwxr-xr-x 1 shuangcui admin 20 4 28 14:45 xvid -&gt; ../Cellar/xvid/1.3.6lrwxr-xr-x 1 shuangcui admin 18 10 30 2019 xz -&gt; ../Cellar/xz/5.2.4lrwxr-xr-x 1 shuangcui admin 21 12 20 2019 yarn -&gt; ../Cellar/yarn/1.21.1lrwxr-xr-x 1 shuangcui admin 26 10 30 2019 zookeeper -&gt; ../Cellar/zookeeper/3.4.14 使用brew安装golang可能需要代理 之前机器go env的结果:1234567891011121314151617181920212223242526272829303132GO111MODULE=\"on\"GOARCH=\"amd64\"GOBIN=\"\"GOCACHE=\"/Users/shuangcui/Library/Caches/go-build\"GOENV=\"/Users/shuangcui/Library/Application Support/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GONOPROXY=\"git.xxxxx.com\"GONOSUMDB=\"git.xxxxx.com\"GOOS=\"darwin\"GOPATH=\"/Users/shuangcui/go\"GOPRIVATE=\"\"GOPROXY=\"https://goproxy.cn,direct\"GOROOT=\"/usr/local/Cellar/go/1.13.5/libexec\"GOSUMDB=\"off\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/Cellar/go/1.13.5/libexec/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"GOMOD=\"/dev/null\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/go-build001703830=/tmp/go-build -gno-record-gcc-switches -fno-common\" 现在机器go env的结果:123456789101112131415161718192021222324252627282930313233GO111MODULE=\"\"GOARCH=\"amd64\"GOBIN=\"\"GOCACHE=\"/Users/dashen/Library/Caches/go-build\"GOENV=\"/Users/dashen/Library/Application Support/go/env\"GOEXE=\"\"GOFLAGS=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOINSECURE=\"\"GONOPROXY=\"\"GONOSUMDB=\"\"GOOS=\"darwin\"GOPATH=\"/Users/dashen/go\"GOPRIVATE=\"\"GOPROXY=\"https://proxy.golang.org,direct\"GOROOT=\"/usr/local/opt/go@1.14\"GOSUMDB=\"sum.golang.org\"GOTMPDIR=\"\"GOTOOLDIR=\"/usr/local/opt/go@1.14/pkg/tool/darwin_amd64\"GCCGO=\"gccgo\"AR=\"ar\"CC=\"clang\"CXX=\"clang++\"CGO_ENABLED=\"1\"GOMOD=\"\"CGO_CFLAGS=\"-g -O2\"CGO_CPPFLAGS=\"\"CGO_CXXFLAGS=\"-g -O2\"CGO_FFLAGS=\"-g -O2\"CGO_LDFLAGS=\"-g -O2\"PKG_CONFIG=\"pkg-config\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/rg/1vmp1gc17r397j5xzs0h72ym0000gn/T/go-build990650087=/tmp/go-build -gno-record-gcc-switches -fno-common\" 使用brew安装php 使用brew安装mysql 参考 : mac 安装mysql@5.7 (brew 安装配置) Mac上用 homebrew 装 mysql,完美解决 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 报错问题 使用brew安装openresty 现在openresty官方推荐使用brew安装… ngnix二进制文件在/usr/local/Cellar/openresty/1.17.8.2_1/nginx (如果为编译安装的方式,是在/usr/local/openresty/nginx/sbin/) 读取的config文件在/usr/local/etc/openresty 可以配置快捷命令 alias nginx=&#39;/usr/local/Cellar/openresty/1.17.8.2_1/nginx/sbin/nginx&#39; 第一次使用时,记得要在nginx.conf里加一行 1include domains/*.conf; 完整的nginx.conf如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#user nobody;worker_processes 2;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 2048;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; charset utf-8; include domains/*.conf;server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 使用brew安装node 进阶&amp;可选 使用brew安装命令行工具bat/ag/tmux brew install bat brew install the_silver_searcher brew install tmux 使用brew安装 htop/tree/pstree/wget/gawk/gnu-sed/telnet等 brew install htop brew install tree brew install pstree brew install wget brew install gawk brew install gnu-sed brew install telnet brew install gdu (Go语言实现的更好用的du命令) brew install wader/tap/fq (好用的二进制分析工具) 使用brew安装性能调试&amp;压测工具 gdb/jmeter/siege brew install gdb brew install jmeter brew install siege 使用brew安装命令行工具tldr和f**k参考 brew install tldr brew install thefuck 使用brew安装命令行json解析工具jq brew install jq 使用brew安装代码行统计工具——cloc brew install cloc cloc 某路径 统计该目录下代码行数和语言信息 cloc 某路径 –exclude-dir=某路径 统计该目录下代码行数和语言信息(排除后面指定的文件夹) Go 1.14源码信息: 使用brew cask安装postman brew cask install postman 使用brew cask安装pdf阅读软件skim brew cask install skim","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"配置一台符合使用习惯的新Mac","date":"2020-08-24T14:04:23.000Z","path":"2020/08/24/配置一台符合使用习惯的新Mac/","text":"手势重置滚动方向 设置三指拖拽「Mac技巧」三指拖移窗口功能如何设置 caffeinate -disu此命令为系统自带,可防止进入睡眠状态; 可为其配置别名nosleep如下: 关闭自动锁屏 安装xx(略) 安装brew参考配置一台符合使用习惯的新Mac之brew篇 安装gitMac上Xcode集成了Git,如有Xcode可无需再安装 生成公钥/私钥.配置github/gitlab/gitee等1234cd ~/.ssh# 如果没有则创建该文件夹ssh-keygen# 后面参数可加可不加;一直Enter即可 将公钥复制到cvm/aws等机器的.ssh/authorized_keys中,即可免密码登陆 安装常用软件 安装vs code,并配置code命令 vs code 在终端下使用code命令打开文件 安装Jetbrains全家桶 配置.bash_profile或.zshrc如下内容,可供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175export PATH=$&#123;PATH&#125;:/usr/local/MongoDB/binalias mongostart='mongod --dbpath \"/Users/shuangcui/mongo-data/db\"'alias run-rs='run-rs -v 4.0.0 --shell'export PATH=$&#123;PATH&#125;:/usr/local/Cellar/ffmpeg/4.2.1_2/bin# for mysql by 爽哥#用alias mysql='/usr/local/Cellar/mysql@5.7/5.7.28/bin/mysql'这种方式,5.7.28/bin目录下的mysql.server还是显示为command not find,把这个路径直接加进PATH,而不是用别名alias方式肯定更好~PATH=\"/usr/local/Cellar/mysql@5.7/5.7.28/bin:$&#123;PATH&#125;\"export PATH# 超级实用alias sn=\"git shortlog -sn\"alias big=\"du -d 1 -h\"alias ll='ls -al'alias c='clear'alias d='docker'alias p='python'alias p3='python3'#alias aws='ssh -i ~/aws/aws_ec2_cuishuang.pem ubuntu@ec2-3-112-12-235.ap-northeast-1.compute.amazonaws.com'alias aws='ssh ubuntu@3.112.12.235'alias cvm='ssh ubuntu@118.126.97.71'# git快捷键alias gt=\"git status\"alias ga=\"git add -A\"alias gm=\"git commit -m\"alias gp=\"git push\"alias gba=\"git branch -a\"alias gf=\"git fetch\"alias gc='git clone'alias etcd=\"/usr/local/Cellar/etcd/3.4.3/bin/etcd\"alias etcdctl=\"/usr/local/Cellar/etcd/3.4.3/bin/etcdctl\"alias up=\"echo go get -insecure -u -v git.xxxxxx.com/xxx_xxx/xxx@develop\"alias k6='sudo fuser -k 80/tcp'alias hao='open http://man.linuxde.net/'alias linux='open http://man.linuxde.net/'alias ss='open http://www.dashen.tech/'alias ym='open https://dnspod.cloud.tencent.com/'alias pqstart='pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start '# 配置sublime命令行启动alias subl=\\''/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\\'alias u='ubuntu@118.126.97.71:/home/ubuntu/public'alias e='ETCDCTL_API=3 /usr/local/Cellar/etcd/3.3.10/bin/etcdctl'alias k1='kubectl get namespaces'alias sed='gsed'alias nosleep='echo caffeinate -disu'# 客户端开发# 打开一个模拟器alias ios='open -a Simulator'#下面是爽哥加的为了给终端和ls配色的代码#enables colorin the terminal bash shell exportexport CLICOLOR=1#setsup thecolor scheme for list exportexport LSCOLORS=gxfxcxdxbxegedabagacad#sets up theprompt color (currently a green similar to linux terminal)export PS1='\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;36m\\]\\w\\[\\033[00m\\]\\$ '#enables colorfor iTermexport TERM=xterm-256color#上面是爽哥加的为了给终端和ls配色的代码#export PATH=$PATH:~/.composer/vendor/bin#export PATH=\"$(brew --prefix php55)/bin:$PATH\"#export PATH=\"$(brew --prefix php55)/sbin:$PATH\"#export PATH=\"/usr/local/bin:/usr/local/sbib:$PATH\"#关闭brew每次执行命令时的自动更新export HOMEBREW_NO_AUTO_UPDATE=true# golang相关配置export GOPATH=/Users/shuangcui/goexport PATH=\"/Users/shuangcui/go/bin:$PATH\"alias r='go run *.go'alias gr='go run'alias gb='go build'alias goservice=\"export GOPATH=/Users/shuangcui/shunwang/go_service\"alias micro-old=\"export GOPATH=/Users/shuangcui/micro-service\"alias go-hp=\"export GOPATH=/Users/shuangcui/hp\"# flutter 相关配置export PUB_HOSTED_URL=https://pub.flutter-io.cn #国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn #国内用户需要设置export PATH=\"/Users/shuangcui/flutter/bin:$PATH\"#命令提示符PS1=\"\\[\\033[0;32m\\]&lt;\\u@\\\\w&gt;\\$\\[\\033[0m\\] \"export PS1#java配置JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/HomeCLASSPAHT=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATH:export JAVA_HOMEexport CLASSPATHexport PATH#node环境变量export NODE_PATH=/usr/local/Cellar/node/10.1.0/lib/node_modules/# vue 不知道为啥3.0+的也要配置export PATH=\"$PATH:/usr/local/Cellar/node/10.1.0/bin\"#maven配置export M2_HOME=/Users/shuangcui/maven/apache-maven-3.6.1export PATH=$PATH:$M2_HOME/bin# history配置export HISTTIMEFORMAT=\"%Y-%M-%D %H:%M:%S \" export HISTSIZE=100000 export HISTFILESIZE=1000000 export HISTFILE=~/.commandline_warrior shopt -s histappend PROMPT_COMMAND='history -a'complete -C /usr/local/bin/vault vault# macOS catalina默认用zsh,词条设置可以继续使用bashexport BASH_SILENCE_DEPRECATION_WARNING=1eval $(thefuck --alias)eval $(thefuck --alias)# bash-completion,命令行自动补全[[ -r \"/usr/local/etc/profile.d/bash_completion.sh\" ]] &amp;&amp; . \"/usr/local/etc/profile.d/bash_completion.sh\"","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Rust vs Go","date":"2020-08-15T13:41:41.000Z","path":"2020/08/15/Rust-vs-Go/","text":"原文作者BITFIELD CONSULTING, 地址Rust vs Go,仅作翻译及注解 Which is better, Rust or Go? Which language should you choose for your next project, and why? How do the two compare in areas like performance, simplicity, safety, features, scale, and concurrency? What do they have in common, and where do they fundamentally differ? Let’s find out, in this friendly and even-handed comparison of Rust and Golang, from the author of the For the Love of Go book series. ‘For the Love of Go’ is a series of fun, easy-to-follow ebooks introducing software engineering in Go. even-handedadj. 平坦的；平稳的；相等的；均衡的；偶数的；同样大小的；平分的；平局的；镇静的comparisonn. 比较；对照；比喻；比较关系easy-to-followadj. 容易的；舒适的adv. 不费力地，从容地 Rust and Go are both awesome First, it’s really important to say that both Go and Rust are absolutely excellent programming languages. They’re modern, powerful, widely-adopted, and offer excellent performance. You may have read articles and blog posts aiming to convince you that Go is better than Rust, or vice versa. But that really makes no sense; every programming language represents a set of trade-offs. Each language is optimised for different things, so your choice of language should be determined by what suits you and the problems you want to solve with it. awesomeadj. 令人敬畏的；使人畏惧的；可怕的；极好的widely-adoptedadj.被广泛采用的aim tovt. 计划，打算；目标在于…；以…为目标convincevt. 说服；使确信，使信服or vice versa或相反,反之亦然 makes no sense 毫无意义 optimised 最佳 In this article, I’ll try to give a brief overview of where I think Go is the ideal choice, and where I think Rust is a better alternative. Ideally, though, you should have a working familiarity with both languages. While they’re very different in syntax and style, both Rust and Go are first-class tools for building software. With that said, let’s take a closer look at the two languages. idealadj. 理想的；完美的；想象的；不切实际的n. 理想；典范take a closer look仔细看看 The similarities Rust and Go have a lot in common, which is one reason you often hear them mentioned together. What are some of the common goals of both languages? Rust is a low-level statically-typed multi-paradigm programming language that’s focused on safety and performance.—&gt; Gints Dreimanis Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.—&gt; Golang.org low-level statically-typed multi-paradigm低级 静态类型 多范式 Memory safety Both Go and Rust belong to the group of modern programming languages whose priority is memory safety. It’s become clear over many decades of using older languages such as C and C++ that one of the biggest causes of bugs and security vulnerabilities is accessing memory unsafely or incorrectly. Rust and Go deal with this problem in different ways, but both aim to be smarter and safer than other languages about managing memory, and to help you write correct and performant programs. vulnerabilitiesn. 缺陷（vulnerability 的复数形式）；脆弱点accessing memory unsafely or incorrectly不安全或不正确地访问内存 Fast, compact executables They’re both compiled languages, which means your programs are translated directly to executable machine code, so that you can deploy your program as a single binary file; unlike interpreted languages such as Python and Ruby, you don’t need to distribute an interpreter and lots of libraries and dependencies along with your program, which is a big plus. This also makes both Rust and Go programs extremely fast in comparison to interpreted languages. compiled languages编译型语言interpreted languages解释型语言executableadj. 可执行的；可实行的interpretern. 解释者；口译者；注释器plusn. 优势；加号；加法；附加额in comparison to与…相比 General-purpose languages Rust and Go are also both powerful, scalable general-purpose programming languages, which you can use to develop all kinds of modern software, from web applications to distributed microservices, or from embedded microcontrollers to mobile apps. Both have excellent standard libraries and a thriving third-party ecosystem, as well as great commercial support and a large user base. They’ve both been around for many years, and will continue to be widely used for years to come. Learning either Go or Rust today will be a sound investment of your time and effort. scalable可扩展的embedded microcontrollers嵌入式微控制器thrivingv. 兴旺发达；喜欢（thrive 的现在分词）adj. 欣欣向荣的，兴旺发达的commercial support商务支持sound, 居然有这么多意思a sound investment明智的投资 Pragmatic programming style Neither are primarily functional languages (like Scala or Elixir, for example), and neither are exclusively object-oriented (like Java and C#). Instead, while both Go and Rust have features associated with functional and object-oriented programming, they’re pragmatic languages aimed at solving problems in whatever way is most appropriate, rather than forcing you into a particular way of doing things. (If you like the functional style of programming, though, you’ll find a lot more facilities for it in Rust, because Rust has a lot more facilities than Go in general.) We can debate about what an ‘object-oriented’ language is, but it’s fair to say that the &gt; style&gt; of object-oriented programming that C++, Java, or C# users would expect is not present in either Go or Rust.—Jack Mott pragmaticadj. 实际的；实用主义的exclusivelyadv. 唯一地，专有地，排外地；作为唯一的（消息）来源facilitiesn. 设施；工具，设备.此处译为功能比较好debaten. 辩论；（正式的）讨论v. （尤指正式）讨论，辩论；仔细考虑 Development at scale Both Rust and Go have some useful features which make them suitable for programming in the large, whether that means large teams, or large codebases, or both. For example, whereas C programmers have argued for years about where to put their brackets, and whether code should be indented with tabs or spaces, both Rust and Go eliminate such issues completely by using a standard formatting tool (gofmt for Go, rustfmt for Rust) which rewrites your code automatically using the canonical style. It’s not that this particular style is so wonderful in itself: it’s the standardisation which Rust and Go programmers appreciate. gofmt&gt; ’s style is no one’s favourite, yet &gt; gofmt&gt; is everyone’s favourite. —&gt; Rob Pike Another area where both languages score highly is in the build pipeline. Both have excellent, built-in, high-performance standard build and dependency management tools; no more wrestling with complex third-party build systems and having to learn a new one every couple of years. Building Go and Rust code, having come from a Java and Ruby background in my early career, felt like an impossible weight off my shoulders. When I was at Google, it was a relief to come across a service that was written in Go, because I knew it would be easy to build and run. This has also been true of Rust, though I’ve only worked on that at much smaller scale. I’m hoping that the days of infinitely configurable build systems are dead, and languages all ship with their own purpose-built build tools that just work out of the box.—&gt; Sam Rose codebasen. 代码库；indentedadj. 犬牙交错的；受契约约束的；缩进排印的v. 缩进；切割成锯齿状（indent的过去分词eliminatevt. 消除；排除canonicaladj. 按照宗法教规的；真经的；经典的；（数学表达式）最简洁的；准确的；权威的；公认的；与公理有关的；与教会有关的，与教士有关的n. 教士的法衣（常复数）standardisationn. 标准化 gofmt&gt; ’s style is no one’s favourite, yet &gt; gofmt&gt; is everyone’s favourite. —&gt; Rob Pike Another area where both languages score highly is in the build pipeline. Both have excellent, built-in, high-performance standard build and dependency management tools; no more wrestling with complex third-party build systems and having to learn a new one every couple of years. Building Go and Rust code, having come from a Java and Ruby background in my early career, felt like an impossible weight off my shoulders. When I was at Google, it was a relief to come across a service that was written in Go, because I knew it would be easy to build and run. This has also been true of Rust, though I’ve only worked on that at much smaller scale. I’m hoping that the days of infinitely configurable build systems are dead, and languages all ship with their own purpose-built build tools that just work out of the box.—&gt; Sam Rose built-inadj. 是…的组成部分的; 嵌入式的; 内置的;wrestlingn. 摔跤；扭斗an impossible weight off my shoulders不能承受之重reliefn. 救济；减轻，解除；安慰；浮雕ship (with)此处译为附带比较好 So what’s all the fuss about? With all that in mind, and seeing that both languages are so well-designed and powerful, you might be wondering what all the holy wars are about (me too). Why do people make such a fuss about ‘Go versus Rust’, getting into angry social media spats and writing long blog posts about how only an idiot would use Rust, or that Go isn’t a real programming language, or whatever. It might make them feel better, but it doesn’t exactly help you, as someone trying to decide which language to use for your project, or which you should learn to advance your programming career. A wise person doesn’t make important choices based on who shouts the loudest. Let’s continue our grown-up discussion now by looking at some areas where a reasonable person might prefer one language over the other. With all that in mind\b考虑到所有这些holy wars圣战fussn. 大惊小怪；反对，抗议；繁琐的手续；（为小事）大发牢骚v. 瞎操心；忙乱；打扰；过分关怀；过于讲究细节；吵闹spatsn. 护脚；争执（spat的复数）v. 溅；轻打；争吵（spat的第三人称单数）advance your programming career促进你的编程事业grown-upadj. 成熟的; 成年的; 长大的; 适于成人的; 成年人特有的;n. 大人; 成人; Performance We’ve said that both Go and Rust produce extremely fast programs because they’re compiled to native machine code, without having to go through an interpreter or virtual machine. However, Rust’s performance is particularly outstanding. It’s comparable with C and C++, which are often regarded as the highest-performance compiled languages, but unlike these older languages, it also offers memory safety and concurrency safety at essentially no cost in execution speed. Rust also allows you to create complex abstractions without paying a performance penalty at run-time. By comparison, although Go programs also perform extremely well, Go is primarily designed for speed of development (including compilation), rather than speed of execution. The Go compiler doesn’t spend a lot of time trying to generate the most efficient possible machine code; it cares more about compiling lots of code quickly. So Rust will usually beat Go in run-time benchmarks. Rust’s run-time performance is also consistent and predictable, because it doesn’t use garbage collection. Go’s garbage collector is very efficient, and it’s optimised to make its stop-the-world pauses as short as possible (and getting shorter with every new Go release). But garbage collection inevitably introduces some unpredictability in the way programs behave, which can be a serious issue in some applications, such as embedded systems. Because Rust aims to give the programmer complete control of the underlying hardware, it’s possible to optimise Rust programs to be pretty close to the maximum theoretical performance of the machine. This makes Rust an excellent choice for areas where speed of execution beats all other considerations, such as game programming, operating system kernels, web browser components, and real-time control systems. By comparison 相比之下consistent [kənˈsɪstənt]adj. 始终如一的，一致的；坚持的predictableadj. 可预言的,可预测的inevitablyadv. 不可避免地；必然地unpredictabilityn. 不可预测性，不可预知性；不可预见性embedded systems 嵌入式系统 Simplicity It doesn’t matter how fast a programming language is if nobody can figure out how to use it. Go was deliberately conceived as a reaction against the ever-growing complexity of languages like C++; it has very little syntax, very few keywords, and, indeed, few features. This means it doesn’t take long to learn the Go language to the point where you can write useful programs in it. Go is incredibly easy to learn. I know this is an often-touted benefit, but I was really surprised at how quickly I was able to be productive. Thanks to the language, docs, and tools, I was writing interesting, committable code after literally two days.—&gt; Early Impressions of Go From a Rust Programmer The key word here is simplicity. Simple isn’t the same as easy, for sure, but a small, simple language is easier to learn than a large, complex one. There just aren’t that many different ways to do things, so all well-written Go code tends to look the same. It’s easy to just dive into an unfamiliar service and understand what it’s doing. figure out想出; 理解; 弄清;deliberatelyadv. 故意地；缓慢而谨慎地reactionn. 反应，感应；反动，复古；反作用incrediblyadv. 难以置信地；非常地literallyadv. 照字面地；逐字地；不夸张地；正确地；简直 1234fmt.Println(\"Gopher's Diner Breakfast Menu\")for dish, price := range menu &#123; fmt.Println(dish, price)&#125; (In the Code Club series, I do exactly that: pick Go projects semi-randomly from GitHub and explore them with a group of Go beginners, to see how much of the code we can understand. It always turns out to be more than we expected!) Although the core language is small, Go’s standard library is very powerful. That means your learning curve will also need to include the parts of the standard library that you need, not just Go syntax. On the other hand, moving functionality out of the language and into the standard library means that you can focus on learning only the libraries that are relevant to you right now. Go is also designed for software development at scale, with large codebases and large teams. In these situations, it’s important that new developers can get up to speed as quickly as possible. With Go, you get things done—fast. Go is one of the most productive languages I’ve ever worked with. The mantra is: &gt; solve real problems today&gt; .—&gt; Matthias Endler relevantadj. 相关的；切题的；中肯的；有重大关系的；有意义的，目的明确的mantran. 咒语（尤指四吠陀经典内作为咒文或祷告唱念的）；颂歌此处翻译为 口头禅 较好 Features Rust supports more complexity than several other programming languages, therefore, you can achieve more with it. For example, it supports generics.—&gt; Devathon Rust is specifically designed to include lots of powerful and useful features to help programmers do the most with the least code. For example, Rust’s match feature lets you write flexible, expressive logic quite concisely: 123456fn is_prime(n: u64) -&gt; bool &#123; match n &#123; 0...1 =&gt; false, _ =&gt; !(2..n).any(|d| n % d == 0), &#125;&#125; Because Rust does a lot, this means there’s a lot to learn, especially at the start. But that’s okay: there’s a lot to learn in C++ or Java, too, and you don’t get the advanced features that come with Rust, like memory safety. To criticise Rust for being a complex language misses the point: it’s designed to be expressive, which means having a lot of features, and in many situations that’s what you want from a programming language. There’s a learning curve, for sure, but once you’re up and running with it, you’ll be fine. Rust competes for mindshare with C++ and D for programmers who are prepared to accept more complex syntax and semantics (and presumably higher readability costs) in return for the maximum possible performance.—&gt; Dave Cheney expressiveadj. 表现的；有表现力的conciselyadv. 简明地，简洁地learning curve学习曲线presumablyadv. 大概；推测起来；可假定 Concurrency Most languages have some form of support for concurrent programming (doing multiple things at once), but Go was designed for this job from the ground up. Instead of using operating system threads, Go provides a lightweight alternative: goroutines. Each goroutine is an independently executing Go function, which the Go scheduler will map to one of the OS threads under its control. This means that the scheduler can very efficiently manage a large number of concurrent goroutines, using only a limited number of OS threads. Consequently, you can run millions of concurrent goroutines in a single program without creating serious performance problems. That makes Go the perfect choice for high-scale concurrent applications such as webservers and microservices. Go also features fast, safe, efficient ways for goroutines to communicate and share data, using channels. Go’s concurrency support feels well-designed, and a pleasure to use. Reasoning about concurrent programs is hard in general, and building reliable, correct concurrent programs is a challenge in any language. Because it was built into the language from the start, though, instead of being an afterthought, concurrent programming in Go is about as simple and well-integrated as it could reasonably be. Go makes it very easy to build a nicely factored application that takes full advantage of concurrency while being deployed as a set of microservices. Rust can do those things, too, but it’s arguably a bit tougher. In some respects, Rust’s obsession with preventing memory-related security vulnerabilities means that programmers have to go out of their way to perform tasks that would be simpler in other languages, including Go.—&gt; Sonya Koptyev The concurrency story in Rust is very new, by comparison, and still stabilising, but it’s under very active development, so watch this space. For example, Rust’s rayon library provides a very elegant and lightweight way of turning sequential computations into parallel ones. Having lightweight syntax for spawning Go routines and using channels are really nice. It really shows the power of syntax that such small details make concurrent programming feel so much nicer than in other languages.—&gt; Early Impressions of Go From a Rust Programmer While it may be a bit less straightforward to implement concurrent programs in Rust, it’s still possible, and those programs can take advantage of Rust’s guarantees about safety. A good example is the standard library’s Mutex class: in Go, you can forget to obtain a mutex lock before accessing something, but Rust won’t let you do that. Go is focused on concurrency as a first class concept. That is not to say you cannot find aspects of Go’s actor oriented concurrency in Rust, but it is left as an exercise to the programmer.—&gt; Dave Cheney from the ground upafterthoughtn. 事后的想法，马后炮；后来添加的东西rayonn. 人造丝；人造纤维sequentialadj. 顺序的paralleladj.并行的straightforwardadj. 简单的；坦率的；明确的；径直的adv. 直截了当地；坦率地 Safety We saw earlier that both Go and Rust aim, in different ways, to prevent a large class of common programming errors, to do with memory management. But Rust in particular goes to great lengths to ensure that you can’t do something unsafe that you didn’t mean to do. Rust’s very strict and pedantic compiler checks each and every variable you use and every memory address you reference. It avoids possible data race conditions and informs you about undefined behavior. Concurrency and memory safety issues are fundamentally impossible to get in the safe subset of Rust.—&gt; Why Rust? This is going to make programming in Rust a different experience to almost all other languages, and it may be a challenging one at first. But for many people, the hard work is worth it. For me the key advantage of Rust is a feeling that the compiler has my back and won’t let through any bug it could possibly detect (seriously, it feels like magic sometimes).—Grzegorz Nosek Many languages, including Go, have facilities to help programmers avoid mistakes, but Rust takes this to a new level, so that potentially incorrect programs won’t even compile. With Rust, the library programmer has a lot of tools to prevent her users making mistakes. Rust gives us the ability to say that we &gt; own&gt; a specific piece of data; it’s not possible for anything else to claim ownership, so we know nothing else will be able to modify it. I can’t think of a time I’ve ever been given this many tools to prevent accidental misuse before. It’s a wonderful feeling.—&gt; Sam Rose “Fighting with the borrow checker” is a common syndrome for new Rust programmers, but in most cases the problems that it finds are genuine bugs (or at least potential bugs) in your code. It may force you to fundamentally re-architect your program to avoid running into these issues; and that’s a good thing, when correctness and reliability are your top priority. What’s the point of a language that doesn’t change the way you program? The lessons that Rust teaches about safety can be useful when you’re working in other languages, too. If you choose Rust, usually you need the guarantees that the language provides: safety against null pointers and data races, predictable runtime behaviour, and total control over the hardware. If you don’t require any of these features, Rust might be a poor choice for your next project. That’s because these guarantees come with a cost: ramp-up time. You’ll need to unlearn bad habits and learn new concepts. Chances are, you will fight with the borrow checker a lot when you start out.—&gt; Matthias Endler How challenging you find Rust’s programming model probably depends on what previous experience you have in other languages. Python or Ruby programmers may find it restrictive; others will be delighted. If you’re a C or C++ programmer who’s spent weeks chasing down memory safety bugs in those languages, you’ll really appreciate Rust. “Fighting the borrow checker” becomes “The compiler can detect that? Cool!”—Grzegorz Nosek preventvt. 预防，防止；阻止vi. 妨碍，阻止pedanticadj. 迂腐的；学究式的；卖弄学问的；假装学者的subsetn. [数] 子集；子设备；小团体syndromen. [临床] 综合症状；并发症状；校验子restrictiveadj. 限制的；限制性的；约束的n. 限制词 Scale Today’s server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. Go was designed and developed to make working in this environment more productive. Go’s design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components.—&gt; Rob Pike When you’re working on a problem by yourself or in small teams, the choice of a simple language or a rich language is a matter of preference. But as the software grows bigger and more complex, and the teams grow larger, the differences really start to show. For large applications and distributed systems, speed of execution is less important than speed of development: a deliberately minimal language like Go reduces the ramp-up time for new developers, and makes it easier for them to work with a large codebase. With Go, it’s easier as a junior developer to be more productive, and harder as a mid-level developer to introduce brittle abstractions that will cause problems down the line. For these reasons, Rust is less compelling than Go for enterprise software development.—&gt; Loris Cro When it comes to software development in the large, clear is better than clever. Go’s limitations actually make it more suitable for enterprises and big organisations than more complex and powerful languages such as Rust. comprisevt. 包含；由…组成tens of millions of 数以千万计的literallyadv. 照字面地；逐字地；不夸张地；正确地；rigorousadj. 严格的，严厉的；严密的；严酷的a deliberately minimal language故意最小化的语言brittleadj. 易碎的，脆弱的；易生气的down the line[词典] 其间某时; 在某一时刻; 在某一环节;[例句]We’ll make a decision on that further down the line.我们将在以后的阶段对此问题作出决策。compellingadj. 引人注目的；令人信服的；非常强烈的；不可抗拒的 The differences Although Rust and Go are both popular, modern, widely-used languages, they’re not really competitors, in the sense that they’re deliberately targeting quite different use cases. Go’s whole approach to programming is radically different to Rust’s, and each language will suit some people while irritating others. That’s absolutely fine, and if both Rust and Go did more or less the same things in more or less the same way, we wouldn’t really need two different languages. So can we get a sense of the respective natures of Rust and Go by finding issues on which they take drastically different approaches? Let’s find out. approachv. 走进；与……接洽；处理；临近，逐渐接近（某时间或事件）；几乎达到（某水平或状态）n. 方法，方式；接近；接洽；（某事的）临近；路径；进场（着陆）；相似的事物此处译为 方法,方式radicallyadv. 根本上；彻底地；以激进的方式irritatingadj. 刺激的；气人的；使愤怒的；烦人的，使人恼火的vt. 刺激；激怒；使烦恼；使发炎，使不适；使不耐烦；使（身体某部分）疼痛（irritate 的现在分词）respectiveadj. 分别的，各自的drasticallyadv. 彻底地；激烈地 Garbage collection “To garbage-collect, or not to garbage-collect” is one of those questions that has no right answer. Garbage collection, and automatic memory management in general, makes it quick and easy to develop reliable, efficient programs, and for some people that makes it essential. But others say that garbage collection, with its performance overhead and stop-the-world pauses, makes programs behave unpredictably at run-time, and introduces unacceptable latency. The debate rumbles on. Go is a very different language to Rust. Although both can vaguely be described as systems languages or replacements for C, they have different goals and applications, styles of language design, and priorities. Garbage collection is a really huge differentiator. Having GC in Go makes the language much simpler and smaller, and easy to reason about.Not having GC in Rust makes it really fast (especially if you need guaranteed latency, not just high throughput) and enables features and programming patterns that are not possible in Go (or at least not without sacrificing performance).—&gt; PingCAP The debate rumbles on.争论仍在继续/争论不休。vaguelyadv. 含糊地；暧昧地；茫然地throughputn. （某一时期内的）生产量，接待人数，吞吐量 Close to the metal The history of computer programming has been a story of increasingly sophisticated abstractions that let the programmer solve problems without worrying too much about how the underlying machine actually works. That makes programs easier to write and perhaps more portable. But for many programs, access to the hardware, and precise control of how the program is executed, are more important. Rust aims to let programmers get “closer to the metal”, with more control, but Go abstracts away the architectural details to let programmers get closer to the problem. Both languages have a different scope. Golang shines for writing microservices and for typical “DevOps” tasks, but it is not a systems programming language. Rust is stronger for tasks where concurrency, safety and/or performance are important; but it has a steeper learning curve than Go.—&gt; Matthias Endler sophisticatedadj. 复杂的；精致的；久经世故的；富有经验的v. 使变得世故；使迷惑；篡改（sophisticate的过去分词形式）underlyingadj. 潜在的；根本的；在下面的；优先的v. 放在…的下面；为…的基础；优先于（underlie的ing形式）在此译为’底层的’typicaladj. 典型的；特有的；象征性的steepern. 浸泡用的容器adj. 更陡峭的，更险峻的；更急剧的；更不合理的 Must go faster I’ve written elsewhere that performance is less important than readability for most programs. But when performance does matter, it really matters. Rust makes a number of design trade-offs to achieve the best possible execution speed. By contrast, Go is more concerned about simplicity, and it’s willing to sacrifice some (run-time) performance for it. But Go’s build speed is unbeatable, and that’s important for large codebases. Rust is faster than Go. In the benchmarks above, Rust was faster, and in some cases, an order of magnitude faster. But before you run off choosing to write everything in Rust, consider that Go wasn’t that far behind it in many of those benchmarks, and it’s still much faster than the likes of Java, C#, JavaScript, Python and so on. If what you need is top-of-the-line performance, then you’ll be ahead of the game choosing either of these two languages. If you’re building a web service that handles high load, that you want to be able to scale both vertically and horizontally, either language will suit you perfectly.—&gt; Andrew Lader trade-offs折中an order of magnitude(快)一个数量级be able to scale both vertically and horizontally能够纵向和横向扩展 Correctness On the other hand, a program can be arbitrarily fast if it doesn’t have to work properly. Most code is not written for the long term, but it’s often surprising how long some programs can stay running in production: in some cases, many decades. In these situations it’s worth taking a little extra time in development to make sure that the program is correct, reliable, and won’t need a lot of maintenance in the future. My take: Go for the code that has to ship tomorrow, Rust for the code that has to keep running untouched for the next five years.—Grzegorz Nosek While both Go and Rust are great choices for any serious project, it’s a good idea to make yourself as well-informed as possible about each language and its characteristics. Ultimately, it doesn’t matter what anyone else thinks: only you can decide which is right for you and your team. If you want to develop faster, perhaps because you have many different services to write, or you have a large team of developers, then Go is your language of choice. Go gives you concurrency as a first-class citizen, and does not tolerate unsafe memory access (neither does Rust), but without forcing you to manage every last detail. Go is fast and powerful, but it avoids bogging the developer down, focusing instead on simplicity and uniformity. If on the other hand, wringing out every last ounce of performance is a necessity, then Rust should be your choice.—&gt; Andrew Lader arbitrarilyadv. 武断地；反复无常地；专横地well-informedadj. 博识的；确知的；消息灵通的;[例句]This is a subject for serious, well-informed discussion, not tabloid headlines.这个主题不同于通俗小报的标题，适合进行严肃而深入的讨论。characteristicsn. 特性，特征；特色（characteristic的复数）；特质boggingn. 沼泽土化；陷入；沉入v. 陷入泥沼；陷入困境（bog的ing形式）uniformityn. 均匀性；一致；同样在此译为’统一性’较好 Conclusion I hope this article has convinced you that both Rust and Go deserve your serious consideration. If at all possible, you should aim to get at least some level of experience in both languages, because they will be incredibly useful to you in any tech career, or even if you enjoy programming as a hobby. If you only have time to invest in learning one language well, don’t make your final decision until you’ve used both Go and Rust for a variety of different kinds of programs, large and small. And knowledge of a programming language is really only a small part of being a successful software engineer. By far the most important skills you’ll need are design, engineering, architecture, communication, and collaboration. If you excel at these, you’ll be a great software engineer regardless of your choice of language. Happy learning! Comparing Rust and Go code There’s a great website called programming-idioms.org which has a “cheat sheet” showing what the Rust and Go code looks like for over 200 common programming tasks: Go vs Rust idioms Getting started If you’re interested in learning to program with Rust and Go, here are a few resources you may find helpful. Go Install Go Go tutorials by Bitfield For the Love of Go A Tour of Go Go By Example The Go Playground Awesome Go Rust Install Rust A Gentle Introduction to Rust The Rust Programming Language Rust books Rust By Example The Rust Playground One Hundred Rust Binaries Acknowledgements I am not young enough to know everything, as the saying goes, so I’m very grateful to a number of distinguished Gophers and Rustaceans who took the time to review and correct this piece, as well as providing some really useful suggestions. My special thanks go to Bill Kennedy, Grzegorz Nosek, Sam Rose, Jack Mott, Steve Klabnik, MN Mark, Ola Nordstrom, Levi Lovelock, Emile Pels, Sebastian Lauwers, Carl Lerche, and everyone else who contributed. You might get the impression from reading online hot takes that the Rust and Go communities don’t get along. Nothing could be further from the truth, in my experience; we had very civilised and fruitful discussions about the draft article, and it’s made a big difference to the finished product. Thanks again. John Arundel civilisedadj. 文明的fruitfuladj. 富有成效的；多产的；果实结得多的finished product 成品,最终作品","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Trie三兄弟","date":"2020-08-10T15:15:10.000Z","path":"2020/08/10/Trie三兄弟/","text":"相关博客 前缀树(字典树)/Trie Rust-vs-Go-常用语法对比-8 之 Trie 力扣相关题目： leetcode上的字典树问题 leetcode-208 实现 Trie (前缀树)leetcode-212 单词搜索IIleetcode-336 回文对 导引 Trie 树，又称前缀树或字典树，(也有称单词查找树)。主要应用在信息检索中进行模式匹配和前缀匹配 「用空间换时间」,最大限度地减少无谓的字符串比较，使得查询高效率，再利用共同前缀来提高查询效率。 Trie这个术语来自于retrieval。trie的发明者Edward Fredkin将其读作/ˈtriː/ “tree” ； 但是，其他作者读作/ˈtraɪ/ “try；一般也多称为 try 树 除去标准的trie树,还有两种常见的变体， 压缩Trie(即基树树)和后缀Trie，有种说法将三者统称为Trie三兄弟 Trie三兄弟——标准Trie、压缩Trie、后缀Trie 标准Trie 如有待匹配的字符串apple,apply,bed,bear,beat,beach等， 如果不考虑空间开销，第一大目标是能够快速匹配，则是前缀树的典型使用场景 Trie树 的三个特点 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同 Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。假设字符的种数有m个，有若干个长度为n的字符串构成了一个 Trie树 ，则每个节点的出度为 m（即每个节点的可能子节点数量为m），Trie树 的高度为n。很明显浪费了大量的空间来存储字符，此时Trie树的最坏空间复杂度为$O(m^n)$。 也正由于每个节点的出度为m，所以才能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时Trie树的最坏时间复杂度为O(n)。 更多关于Trie树的构造，插入，查询和删除，可参见 吴师兄学编程-看动画轻松理解「Trie树」 前缀树 基数树/压缩前缀树/Radix Trie 基数树（Radix Trie，也叫基数特里树或压缩前缀树）, 是一种比标准Trie更节省空间的数据结构 其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数r ，其中r为正整数，x为2的幂，x≥1，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合 即 不再遵循标准Trie树 每一个节点都只包含一个字符的特点，即如上图这样，更省空间 其全部特点如下： 一般由根节点、中间节点和叶子节点组成。 每个节点可以包含一个或多个字符。 树的叶子结点数即是数据条目数。 从根节点到某一节点经过路径的字符连起来即为该节点对应的字符串。 每个节点的所有子节点字符串都不相同。 基数树支持插入、删除、查找操作。查找包括完全匹配、前缀匹配、前驱查找、后继查找。 所有这些操作都是O(k)复杂度，其中k是所有字符串中最大的长度。 Radix Trie相比于入门款的标准Trie，有更多的使用 包括httprouter库中用于快速路由，Linux和Go中用于更快的内存分配 Linux 内核中的数据结构：基数树(radix tree) 数据结构之Radix Tree 如何克服字典树(Trie Tree)的缺点? 这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。 基数树的查找方式也与常规树不同（常规的树查找一开始就对整个键进行比较，直到不相同为止），基数树查找时节点时，对于节点上的键都按块进行逐块比较，其中该节点中块的长度是基数r； 当r为2时，基数树为二进制的（即该节点的键的长度为1比特位），能最大程度地减小树的深度来最小化稀疏性（最大限度地合并键中没有分叉的节点）。 当r≥4且为2的整数次幂时，基数树是r元基数树，能以潜在的稀疏性为代价降低基数树的深度。 相关论文 其实还有一种数据结构 Patricia Tree(简称 PAT tree)，也能减少额外减少额外的节点，节点个数严格的和插入的元素个数相同，且Patricia trie算法中只有一种节点，不存在中间节点和叶子节点的区别Patricia Trie与Radix Trie的不同 Patricia Tree经常和Merkle Tree(即Hash Tree)混合成为一种新的数据结构---MPT(Merkle Patricia Tree)树,提供了一个基于加密学的，自校验防篡改的数据结构，用来存储键值对关系 树形结构-基数树、Patricia树、默克尔树、梅克尔帕特里夏树( Merkle Patricia Tree, MPT) gin中用到的httprouter库 The router relies on a tree structure which makes heavy use of common prefixes, it is basically a compact prefix tree (or just Radix tree). Nodes with a common prefix also share a common parent. 如果沿着从树根到叶的路径穿过树，则会得到完整的路径 Since URL paths have a hierarchical structure and make use only of a limited set of characters (byte values), it is very likely that there are a lot of common prefixes. This allows us to easily reduce the routing into ever smaller problems. Moreover the router manages a separate tree for every request method. For one thing it is more space efficient than holding a method-&gt;handle map in every single node, it also allows us to greatly reduce the routing problem before even starting the look-up in the prefix-tree. 由于URL路径具有层次结构，并且仅使用有限的字符集（字节值），因此很可能存在许多公共前缀。这使我们可以轻松地将路由减少到越来越小的问题中。此外，路由器为每种请求方法管理一棵单独的树。一方面，它比在每个单个节点中保存method-&gt; handle map更加节省空间，它还使我们甚至可以在开始在前缀树中查找之前极大地减少路由问题。 gin框架的路由，用的就是httprouter库，该库底层用的数据结构是 压缩前缀树(即基数树，Radix树) (还加入了优先级) go路由httprouter中的压缩字典树算法图解及c++实现 为什么 Gin 这么流行？一探 gin 框架路由和中间件的秘密 Gin 框架的路由结构浅析 Go内存管理中的使用 后缀Trie 即 字符串集合是由指定字符串的后缀子串构成的 完整字符串”minimize”的后缀子串组成的集合S分别如下： s1=minimize s2=inimize s3=nimize s4=imize s5=mize s6=ize s7=ze s8=e 然后把这些子串的公共前缀作为内部结点构成一棵”minimize”的后缀树","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"两个golang小问题","date":"2020-08-05T00:03:36.000Z","path":"2020/08/05/两个golang小问题/","text":"切片的长度和容量123456789101112131415161718192021222324package mainimport \"fmt\"func main()&#123; a := []byte(\"0123456789\") fmt.Printf(\"[a_src] len: %v\\n\", len(a)) fmt.Printf(\"[a_src] cap: %v\\n\", cap(a)) b := make([]byte, 5) copy(b, a[:5]) fmt.Printf(\"[b_cpy] len: %v\\n\", len(b)) fmt.Printf(\"[b_cpy] cap: %v\\n\", cap(b)) a = a[:5] fmt.Printf(\"[a_dst] len: %v\\n\", len(a)) fmt.Printf(\"[a_dst] cap: %v\\n\", cap(a))&#125; 结果为： 123456[a_src] len: 10[a_src] cap: 10[b_cpy] len: 5[b_cpy] cap: 5[a_dst] len: 5[a_dst] cap: 10 参考： golang中slice扩容一定是double或1.25倍吗 defer，以及return不是原子操作的问题1234567891011121314151617181920212223package mainimport \"fmt\"func Add200(z *int) int &#123; fmt.Println(\"Add200:\", *z) *z += 200 return *z&#125;func deferRet(x, y int) (z int) &#123; defer func() &#123; fmt.Println(\"func:\", z) z += 100 &#125;() z = x + y return Add200(&amp;z)&#125;func main() &#123; i := deferRet(1, 1) fmt.Println(\"main:\", i)&#125; 结果为： 123Add200: 2func: 202main: 302 参考： Golang中的defer","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"猿鸣三峡","date":"2020-08-03T15:55:28.000Z","path":"2020/08/03/猿鸣三峡/","text":"火车从恩施到宜昌这一段，群山起伏，隧道相连。半小时下来大概只有2-3分钟能见天日。 正像是郦道元“自三峡七百里中，两岸连山，略无阙处。重岩叠嶂，隐天蔽日，自非亭午夜分，不见曦月” 真实版的“群山万壑赴荆门” 实际上，秭归归辖于宜昌而非荆门。且因为区划拆合，昭君故里也已不在秭归，而属兴山县 “更立西江石壁,截断巫山云雨,高峡出平湖” 夏水襄陵，沿溯阻绝。朝发白帝，暮到江陵。其间千二百里，乘奔御风，不足以疾。 长江冲出西陵峡，逐渐从上游的“川江”变为中游的“荆江”，水面从700米，一下子开阔到2000多米。 弱冠之年的李白仗剑出川，行舟至荆门山，刹那便被这一江宽广所震慑，投笔写下“山随平野尽，江入大荒流”。彼时的李唐王朝，如同这个大鹏随风九万里的青年，好似有源源不竭的无尽活力，有任人想象驰骋的各样可能。此刻自命才高的青年，想去长安朝堂施展抱负，但离家之际，还是有些矫情地表达“仍怜故乡水，万里送行舟”——像是一个循环，暮年他将不得已沿江逆流而上，却是被流放发配。行至白帝，得闻新皇大赦天下，旋即调转航向，“千里江陵一日还”。 40年后，渔阳鞞鼓天崩地坼。年近花甲多病缠身的暮年老杜，因友人去世生计无着，不得已离开成都草堂，买舟东下。某天夜里，江平波静，皓月孤悬，诗人独立船头，咏出一句“星垂平野阔，月涌大江流”。仰天而叹，颠连无告的凄怆心情再也压抑不住，接着便“名岂文章著，官应老病休”，发起了牢骚。 他自是不知，三年前，这位年长他十多岁的挚友，在长江下游的安徽当涂，“醉酒追月 落水溺亡”。也无法预料，他自己也将在五年后，客死于湘江上的一叶扁舟，“致君尧舜”最终成了笑柄，甚至连“巴峡穿巫峡，襄阳向洛阳”的行程，都未能实现。 青山依旧在，异代不同时。伴随二人而去的，除去诗歌的巅峰，还有盛唐时代这个民族包容万千的雍容气魄。 起承转合–由陈子昂&lt;国殇&gt; 正是江南好风景 潜山–皖国古都&amp;&amp;安徽之源 盛唐之殇–观&lt;长安十二时辰&gt;记 葛洲坝船闸，上下落差几十米，连通器原理，实现“水落船低” 宜昌江滨 经由三峡机场，折返浦东。搭2号线末班车，自此，继7/16号线，这条乘坐近千次，穿越城市东西的繁忙线路，于我实现了首尾贯通。 附：三峡诗作 送友人使夷陵— 崔翘 —猿鸣三峡里，行客旧沾裳。复道从兹去，思君不暂忘。开襟春叶短，分手夏条长。独有幽庭桂，年年空自芳。 宿空泠峡青树村浦— 陈子昂 —的的明月水，啾啾寒夜猿。客思浩方乱，洲浦寂无喧。忆作千金子，宁知九逝魂。虚闻事朱阙，结绶骛华轩。委别高堂爱，窥觎明主恩。今成转蓬去，叹息复何言。 秋夜题夷陵水馆— 李涉 —凝碧初高海气秋，桂轮斜落到江楼。三更浦上巴歌歇，山影沉沉水不流。 上三峡— 李白 —巫山夹青天，巴水流若兹。巴水忽可尽，青天无到时。三朝上黄牛，三暮行太迟。三朝又三暮，不觉鬓成丝。 卢溪送别— 王昌龄 —武陵溪口驻扁舟，溪水随君向北流。行到荆门上三峡，莫将孤月对猿愁。 早发白帝城— 李白 —朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 西陵峡— 杨炯 —绝壁耸万仞，长波射千里。盘薄荆之门，滔滔南国纪。楚都昔全盛，高丘烜望祀。秦兵一旦侵，夷陵火潜起。四维不复设，关塞良难恃。洞庭且忽焉，孟门终已矣。自古天地辟，流为峡中水。行旅相赠言，风涛无极已。及余践斯地，瑰奇信为美。江山若有灵，千载伸知己。 度荆门望楚— 陈子昂 —遥遥去巫峡，望望下章台。巴国山川尽，荆门烟雾开。城分苍野外，树断白云隈。今日狂歌客，谁知入楚来。 渡荆门送别— 李白 —渡远荆门外，来从楚国游。山随平野尽，江入大荒流。月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。 阁夜— 杜甫 —岁暮阴阳催短景，天涯霜雪霁寒宵。五更鼓角声悲壮，三峡星河影动摇。野哭几家闻战伐，夷歌数处起渔樵。卧龙跃马终黄土，人事依依漫寂寥。 咏怀古迹五首·其一— 杜甫 —支离东北风尘际，漂泊西南天地间。三峡楼台淹日月，五溪衣服共云山。羯胡事主终无赖，词客哀时且未还。庾信平生最萧瑟，暮年诗赋动江关。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"一些有用的git log技巧","date":"2020-07-26T13:07:41.000Z","path":"2020/07/26/一些有用的git-log技巧/","text":"雪中送炭 锦上添花 查看某用户一天24小时的提交分布信息 git log --author=&quot;某个username&quot; --date=iso | perl -nalE &#39;if (/^Date:\\s+[\\d-]{10}\\s(\\d{2})/) { say $1+0 }&#39; | sort | uniq -c|perl -MList::Util=max -nalE &#39;$h{$F[1]} = $F[0]; }{ $m = max values %h; foreach (0..23) { $h{$_} = 0 if not exists $h{$_} } foreach (sort {$a &lt;=&gt; $b } keys %h) { say sprintf &quot;%02d - %4d %s&quot;, $_, $h{$_}, &quot;*&quot;x ($h{$_} / $m * 50); }&#39; 查看仓库 commit 前 10 名贡献者 git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 10 统计每个人增删的行数 git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }&#39; -; done 查看在当前仓库的上的个人代码量 git log --author=&quot;cuishuang&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc }&#39; 查看某用户在当前仓库上 周一-周五，周六周日提交的占比情况 git show|head -1; git log --author=&#39;cuishuang&#39; --format=&quot;%H %ai&quot; | perl script.pl script.pl如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/perl# This script is made to show graphs with git commit time made on workweek vs weekend## The desription of this script and results of its usage is available at:# https://ivan.bessarabov.com/blog/famous-programmers-work-time-part-2-workweek-vs-weekend## usage:## git log --author=\"Sebastian Riedel\" --format=\"%H %ai\" | perl script.pl#use strict;use warnings FATAL =&gt; 'all';use utf8;use open qw(:std :utf8);use feature qw(say);use List::Util qw(max sum);use Time::Local;my %workweek;my %weekend;sub is_saturday_or_is_sunday &#123; my ($yyyy_mm_dd) = @_; my ($year, $month, $day) = split /-/, $yyyy_mm_dd; my $timestamp = timegm( 0, 0, 0, $day, $month - 1, $year, ); my $wday = [gmtime($timestamp)]-&gt;[6]; return $wday == 0 || $wday == 6;&#125;while (my $line = &lt;&gt;) &#123; # 181971ff7774853fceb0459966177d51eeab032c 2019-04-26 19:53:58 +0200 my ($commit_hash, $date, $time, $timezone) = split / /, $line; my ($hour, $minute, $second) = split /:/, $time; $hour += 0; if (is_saturday_or_is_sunday($date)) &#123; $weekend&#123;$hour&#125;++; &#125; else &#123; $workweek&#123;$hour&#125;++; &#125;&#125;my $max = max(values(%workweek), values(%weekend));my $format = \"%6s %6s %-30s %6s %-30s\",say '';say sprintf $format, 'hour', '', 'Monday to Friday', '', 'Saturday and Sunday';foreach my $hour (0..23) &#123; $workweek&#123;$hour&#125; //= 0; $weekend&#123;$hour&#125; //= 0; say sprintf $format, sprintf('%02d', $hour), $workweek&#123;$hour&#125;, '*' x ($workweek&#123;$hour&#125; / $max * 25), $weekend&#123;$hour&#125;, '*' x ($weekend&#123;$hour&#125; / $max * 25), ;&#125;my $total_commits_workweek = sum(values %workweek);my $total_commits_weekend = sum(values %weekend);my $total_commits = $total_commits_workweek + $total_commits_weekend;say '';say sprintf $format, 'Total:', $total_commits_workweek, sprintf('(%.1f%%)', $total_commits_workweek * 100 / $total_commits), $total_commits_weekend, sprintf('(%.1f%%)', $total_commits_weekend* 100 / $total_commits), ;say ''; 参考: git commit 提交历史的一些有趣统计 Ten Useful Git Log Tricks","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Redis中SDS和C字符串的区别","date":"2020-07-20T02:11:32.000Z","path":"2020/07/20/Redis中SDS和C字符串的区别/","text":"最近在看huangz大神的Redis 设计与实现. 说来惭愧,工作中一直有使用Redis,这本书也购置多时.MySQL相关的书籍看过好几本,而关于Redis的,这却是第一本. 第一部分数据结构与对象,分7章讲述了 简单动态字符串,链表,字典,跳跃表,整数集合,压缩列表,对象在Redis中的实现与应用. 本篇只简要记述SDS及其与C语言中字符串的区别. Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。 SDS结构体如下: 12345678910111213struct sdshdr &#123; // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125;; 相比于C字符串,SDS优势如下: . O(1)时间复杂度获取字符串长度 因为 C 字符串并不记录自身的长度信息， 所以为获取一个 C 字符串长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 该操作的复杂度为 O(N)和 C 字符串不同， 因为 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。 . 防止缓冲区溢出 C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现缓冲区溢出问题。 . 减少修改字符串时带来的内存重分配次数 对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次修改(增长或者缩短)一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作而内存重分配涉及复杂的算法， 并可能需要执行系统调用， 所以通常是一个比较耗时的操作：- 在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。- 但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。 . 二进制安全 C 字符串中的字符必须符合某种编码（如 ASCII）， 且除了字符串末尾之外， 字符串里不能包含有空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。虽说数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。这也是将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。 . 兼容部分 C 字符串函数 SDS 的 API 一样遵循了 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这样就可以让那些保存文本数据的 SDS 能够重用一部分 &lt;string.h&gt; 库定义的函数， 从而不需要重写，避免不必要的代码重复。 参考: SDS 与 C 字符串的区别 redis sds和c的string区别","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"选择困难?试试libhunt","date":"2020-07-14T14:20:39.000Z","path":"2020/07/14/选择困难-试试libhunt/","text":"在引入开源库时,选择太多也会面临 甜蜜烦恼. 如Golang的日志库,较为流行的就有glog,go-logging,logrus. 而生成uuid的知名库更多,好坏优劣纷至沓来,跋前踕后进退触籓: (图片来自 golang 生成良好的唯一ID/uuid库比较) 想起了当年热衷”玩机”时,zol的一个产品对比功能,各项参数条分缕析一目了然. 如果也有类似比选功能相似package的工具,也可以使得选择困难大为避免. 搜索之下,果不其然. libhunt.com这个网站,slogan是Find The Software You Need,其中有一项功能就是相近包的比较. 以命令行构建功能为例,可以看到urfave/cli和cobra之间的数据对比.包括流行程度,star数,fork数,上一次提交时间,热度等指标.","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Golang源码之syscall包","date":"2020-07-09T13:13:18.000Z","path":"2020/07/09/Golang源码之syscall包/","text":"go 版本为1.14, Mac电脑, 1.7 GHz 四核Intel Core i7 在src/syscall/路径下,打开zerrors_darwin_amd64.go文件, 第1245行: 1234567891011121314151617181920212223242526272829303132333435// Signalsconst ( SIGABRT = Signal(0x6) //十进制数6 SIGALRM = Signal(0xe) //14 SIGBUS = Signal(0xa) //10 SIGCHLD = Signal(0x14) //20 SIGCONT = Signal(0x13) //19 SIGEMT = Signal(0x7) //7 SIGFPE = Signal(0x8) //8 SIGHUP = Signal(0x1) //1 SIGILL = Signal(0x4) //4 SIGINFO = Signal(0x1d) //29 SIGINT = Signal(0x2) //2 SIGIO = Signal(0x17) //23 SIGIOT = Signal(0x6) //6,为什么该值有两个? SIGKILL = Signal(0x9) //9 SIGPIPE = Signal(0xd) //13 SIGPROF = Signal(0x1b) //27 SIGQUIT = Signal(0x3) //3 SIGSEGV = Signal(0xb) //11 SIGSTOP = Signal(0x11) //17 SIGSYS = Signal(0xc) //12 SIGTERM = Signal(0xf) //15 SIGTRAP = Signal(0x5) //5 SIGTSTP = Signal(0x12) //18 SIGTTIN = Signal(0x15) //21 SIGTTOU = Signal(0x16) //22 SIGURG = Signal(0x10) //16 SIGUSR1 = Signal(0x1e) //30 SIGUSR2 = Signal(0x1f) //31 SIGVTALRM = Signal(0x1a) //26 SIGWINCH = Signal(0x1c) //28 SIGXCPU = Signal(0x18) //24 SIGXFSZ = Signal(0x19) //25) 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31, 共31个 SIGIOT和SIGABRT都是6,二者同义 参考: Linux进程间通信(IPC)的几种方式 linux kill -l 信号列表","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go GC 优化","date":"2020-07-07T07:50:13.000Z","path":"2020/07/07/Go-GC-优化/","text":"Go的gc分几个阶段？每个阶段工作是什么，大致用时是什么数量级？哪些需要stw，哪些可以和用户程序并行执行？怎样解决回收的内存跟不上新申请的速度？…混合写屏障满足强三色标记还是弱三色标记？ 一般都卷不到这程度 https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/history/ https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"MySQL存储引擎－－MyISAM与InnoDB区别","date":"2020-07-07T07:26:09.000Z","path":"2020/07/07/MySQL存储引擎－－MyISAM与InnoDB区别/","text":"InnoDB 支持·事务处理/外键/行级锁（共享锁和排他锁）·等高级处理，而MyISAM不支持； InnoDB 为聚簇索引，MyISAM为非聚簇索引； 以下是一些细节和具体实现的差别： ◆1.InnoDB不支持FULLTEXT类型的索引。 ◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。 ◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 ◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 ◆5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。 另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%” 参考：MySQL存储引擎－－MyISAM与InnoDB区别 InnoDB在事务执行过程中，使用两阶段锁协议： 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁； 锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。 再谈mysql锁机制及原理—锁的诠释 mysql锁机制浅析 1、MyISAM是非事务安全的，而InnoDB是事务安全的 2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁 3、MyISAM支持全文类型索引，而InnoDB不支持全文索引 4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM 5、MyISAM表保存成文件形式，跨平台使用更加方便 6、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择 7、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"多进程与多线程","date":"2020-07-04T09:17:13.000Z","path":"2020/07/04/多进程与多线程/","text":"Golang Golang的GPM调度模型，多个G即goroutine，是建立在线程之上还是进程之上？ 据资料，P为逻辑处理器，M为机器cpu核心数（不是物理核心数，如果有超频，则是超频后的cpu数量），两者数量一致。 用代码验证： 1234567891011121314151617181920package mainimport ( \"fmt\" \"sync\")func main() &#123; var wg sync.WaitGroup wg.Add(1) go func() &#123; defer wg.Done() for &#123; fmt.Println(\"A:\", 1) &#125; &#125;() wg.Wait()&#125; 运行上述代码go run t.go，而后查看活动监视器 使用runtime.GOMAXPROCS(num)来设置允许该程序使用的cpu数量，最早版本默认为1，后来改为机器的（逻辑）cpu数。所以不设置，就等同于runtime.GOMAXPROCS(runtime.NumCPU())。 查看进程的线程列表: 参考： mac 进程和线程工具 故而，GPM中的M实际指线程。通过抽象，在用户级别实现了m个goroutine和n个线程之间的对应（一般m远远大于n） 更多关于golang的调度，可参考： 6.5 调度器 Go goroutine理解 nginx 典型的多进程处理模型 启动ngnix后，查看 活动监视器 如下： 此处的2个用户为nobody的工作进程，在nginx.conf中设置： php 同nginx一样，php-fpm也是多进程模式： 可以查看并修改PHP-CGI进程的数量 redis服务端 面试常问，redis（服务端） 的所谓单线程，指的仅仅是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。且最新版本中，网络请求模也支持多线程 参考： 为什么 Redis 选择单线程模型 redis网络IO模型 mysql服务端和postgresql服务端 两大数据库显著差异之一，就是mysql通过多线程方式，实现高并发；而pg和nginx类似，使用多进程方式。 如下： 所以mysql有线程池的说法。 而对于pg： 进程有独立的地址空间,线程则没有独立地址空间. 同一个进程的不同线程, 它们之间共享地址空间的. 对于多进程模型, 因为之间相互独立, 其优点就是安全性比较好. 一个进程的crash, 不会导致整个软件的崩溃;而线程则不行,一个进程里的某个线程crash,会影响整个进程. 多进程的缺点, 是其创建和上下文切换的开销比较大, 另外进程之间要想相互通讯需要专门的机制(IPC)才能实现进程间通讯. 这恰恰是线程的优点, 如果是同一个进程的不同线程, 它们在一个进程的地址空间里，所以, 其相互通讯比较方便, 它们之间的切换也比较简单. (创建线程比较简单, 切换也比较轻巧, 通讯也比较方便, 相互协作比较好). 但多线程也有缺点,就是不稳定.因为同一个进程里的若干个线程，如果有一个(线程)崩溃, 就会使得整个进程的其他线程也一起崩溃, 相互干扰比较大. (相互通讯比较容易,相互干扰也比较大) 那软件设计时,一般采用多进程模型还是多线程模型呢? 要看具体的应用场景, 比如对于浏览器软件, (浏览器的每一个选项卡, 或说每一个浏览器页面, 是用多线程还是多进程实现更好呢?) 显然是多进程，为什么呢, 因为浏览器页面之间几乎没什么通讯需求, 所以这时候线程易于通讯的优点就发挥不出来, 反而是一个线程崩溃,导致同进程其他线程崩溃这个缺点非常致命. (肯定不希望一个页面崩溃,会连带导致其他页面也崩溃) . 所以我们一般是用多进程来实现浏览器的 ,实际上是访问同一个网站的若干页面是在一个进程的不同线程(如打开了三个新浪的新闻页,这三个页面对应一个进程), 但访问不同的网站是不同的进程(如打开了两个新浪,三个搜狐,一个网易,对应三个进程) 因为早期Linux对线程支持不好,导致很多软件的Linux版本大多是多进程模型,如Oracle和Postgre.而Windows早期对线程相对就支持较好,故而某些软件的Win版本,大多采用多线程模型. 现在Linux提供了多线程支持,一般来说多线程模型更多一些.","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"有关自旋锁","date":"2020-07-03T09:26:45.000Z","path":"2020/07/03/有关自旋锁/","text":"线程同步之详解自旋锁 自旋锁+信号量+互斥量+临界区+死锁简介 深入理解自旋锁 自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。 它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。 自旋锁(Spinlock)是一种广泛运用的底层同步机制。自旋锁是一个互斥设备，它只有两个值：“锁定”和“解锁”。它通常实现为某个整数值中的某个位。希望获得某个特定锁得代码测试相关的位。如果锁可用，则“锁定”被设置，而代码继续进入临界区；相反，如果锁被其他人获得，则代码进入忙循环（而不是休眠，这也是自旋锁和一般锁的区别）并重复检查这个锁，直到该锁可用为止，这就是自旋的过程。“测试并设置位”的操作必须是原子的，这样，即使多个线程在给定时间自旋，也只有一个线程可获得该锁。 自旋锁对于SMP和单处理器可抢占内核都适用。可以想象，当一个处理器处于自旋状态时，它做不了任何有用的工作，因此自旋锁对于单处理器不可抢占内核没有意义，实际上，非抢占式的单处理器系统上自旋锁被实现为空操作，不做任何事情。 曾经有个经典的例子来比喻自旋锁：A，B两个人合租一套房子，共用一个厕所，那么这个厕所就是共享资源，且在任一时刻最多只能有一个人在使用。当厕所闲置时，谁来了都可以使用，当A使用时，就会关上厕所门，而B也要使用，但是急啊，就得在门外焦急地等待，急得团团转，是为“自旋”，这也是要求锁的持有时间尽量短的原因！ 自旋锁的优点 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能） 自旋锁与互斥锁 自旋锁与互斥锁都是为了实现保护资源共享的机制。无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。 总结： 自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。自旋锁本身无法保证公平性，同时也无法保证可重入性。基于自旋锁，可以实现具备公平性和可重入性质的锁。TicketLock:采用类似银行排号叫好的方式实现自旋锁的公平性，但是由于不停的读取serviceNum，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。CLHLock和MCSLock通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能，区别在于CLHLock是通过轮询其前驱节点的状态，而MCS则是查看当前节点的锁状态。CLHLock在NUMA架构下使用会存在问题。在没有cache的NUMA系统架构中，由于CLHLock是在当前节点的前一个节点上自旋,NUMA架构中处理器访问本地内存的速度高于通过网络访问其他节点的内存，所以CLHLock在NUMA架构上不是最优的自旋锁。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"僵尸进程与孤儿进程","date":"2020-07-03T09:16:17.000Z","path":"2020/07/03/僵尸进程与孤儿进程/","text":"孤儿进程与僵尸进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。 任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"一条sql的执行过程","date":"2020-07-03T05:13:58.000Z","path":"2020/07/03/一条sql的执行过程/","text":"mysql 执行过程 一条SQL语句在MySQL中如何执行的 - GitHub MySQL探秘(二)：SQL语句执行过程详解","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"利用反射,探究Go语言中的数据类型","date":"2020-06-27T15:06:10.000Z","path":"2020/06/27/反射/","text":"Go共有多少数据类型? 12345678910111213package mainimport ( \"fmt\" \"reflect\")func main() &#123; for i := reflect.Invalid; i &lt;= reflect.UnsafePointer; i++ &#123; fmt.Printf(\"%d:%s\\n\", i, i.String()) &#125;&#125; 结果为: 1234567891011121314151617181920212223242526270:invalid1:bool2:int3:int84:int165:int326:int647:uint8:uint89:uint1610:uint3211:uint6412:uintptr13:float3214:float6415:complex6416:complex12817:array18:chan19:func20:interface21:map22:ptr23:slice24:string25:struct26:unsafe.Pointer 即Go中共有 27 种类型,包括invalid,unsafe.Pointer等 对应源码为 123456789101112131415161718192021222324252627282930313233// A Kind represents the specific kind of type that a Type represents.// The zero Kind is not a valid kind.type Kind uintconst ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 Uint Uint8 Uint16 Uint32 Uint64 Uintptr Float32 Float64 Complex64 Complex128 Array Chan Func Interface Map Ptr Slice String Struct UnsafePointer) 各种数据类型在内存中的结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"fmt\" \"reflect\" \"unsafe\")func main() &#123; var ( boolA bool intB int int8C int8 int16D int16 int32E int32 int64F int64 uintptrG uintptr float32H float32 float64I float64 arrayJ [3]int chanK chan int // 函数 在go语言中是一等公民 funcL func() // go语言中的泛型,可代表任何类型 //interfaceM interface&#123;&#125; mapN map[int]int ptrO *int sliceP []int stringQ string structR struct&#123;&#125; unsafaPointerS unsafe.Pointer ) var list []interface&#123;&#125; list = append(list, boolA, intB, int8C, int16D, int32E, int64F, uintptrG, float32H, float64I, arrayJ, chanK, funcL, mapN, ptrO, sliceP, stringQ, structR, unsafaPointerS) for _, v := range list &#123; // 1.各种数据类型在内存中的结构 // 类型名称,存储大小,对齐方式 fmt.Printf(\"类型名称:%s,存储大小:%d,对齐方式:%d\\n\", reflect.TypeOf(v).Kind(), reflect.TypeOf(v).Size(), reflect.TypeOf(v).Align()) &#125;&#125; 结果为: 123456789101112131415161718类型名称:bool,存储大小:1,对齐方式:1类型名称:int,存储大小:8,对齐方式:8类型名称:int8,存储大小:1,对齐方式:1类型名称:int16,存储大小:2,对齐方式:2类型名称:int32,存储大小:4,对齐方式:4类型名称:int64,存储大小:8,对齐方式:8类型名称:uintptr,存储大小:8,对齐方式:8类型名称:float32,存储大小:4,对齐方式:4类型名称:float64,存储大小:8,对齐方式:8类型名称:array,存储大小:24,对齐方式:8类型名称:chan,存储大小:8,对齐方式:8类型名称:func,存储大小:8,对齐方式:8类型名称:map,存储大小:8,对齐方式:8类型名称:ptr,存储大小:8,对齐方式:8类型名称:slice,存储大小:24,对齐方式:8类型名称:string,存储大小:16,对齐方式:8类型名称:struct,存储大小:0,对齐方式:1类型名称:unsafe.Pointer,存储大小:8,对齐方式:8 复合类型的内存大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\" \"reflect\")func main() &#123; var ( arrayJ [3]int chanK chan int mapN map[int]int ptrO *int sliceP []int ) var list []interface&#123;&#125; list = append(list, arrayJ, chanK, mapN, ptrO, sliceP) for _, v := range list &#123; // 1.各种数据类型在内存中的结构 // 类型名称,存储大小,对齐方式 fmt.Printf(\"类型名称:%s,存储大小:%d,对齐方式:%d\\n\", reflect.TypeOf(v).Kind(), reflect.TypeOf(v).Size(), reflect.TypeOf(v).Align()) &#125; var ( arrayJ2 [3]int8 chanK2 chan int8 mapN2 map[int8]int8 ptrO2 *int8 sliceP2 []int8 ) fmt.Printf(\"array: %d,%d\\n\", reflect.TypeOf(arrayJ).Size(), reflect.TypeOf(arrayJ2).Size()) fmt.Printf(\"chan: %d,%d\\n\", reflect.TypeOf(chanK).Size(), reflect.TypeOf(chanK2).Size()) fmt.Printf(\"map: %d,%d\\n\", reflect.TypeOf(mapN).Size(), reflect.TypeOf(mapN2).Size()) fmt.Printf(\"ptr: %d,%d\\n\", reflect.TypeOf(ptrO).Size(), reflect.TypeOf(ptrO2).Size()) fmt.Printf(\"slice: %d,%d\\n\", reflect.TypeOf(sliceP).Size(), reflect.TypeOf(sliceP2).Size())&#125; 结果为: 123456789101112类型名称:array,存储大小:24,对齐方式:8类型名称:chan,存储大小:8,对齐方式:8类型名称:map,存储大小:8,对齐方式:8类型名称:ptr,存储大小:8,对齐方式:8类型名称:slice,存储大小:24,对齐方式:8array: 24,3 // 根据其基本类型,乘以数组长度决定其内存占用 (int占用8个byte,int8只占一个byte )chan: 8,8map: 8,8ptr: 8,8 // channel,map,pointer的值都是一个地址(地址只需要一个byte)slice: 24,24 // slice的24,对应3个地址,即具体地址,长度信息,容量信息 channel,map,slice传递的是一个地址信息,而不是像其他的类型是具体数值 字节对齐 有关内存对齐 哪些数据类型可以对比? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"reflect\" \"unsafe\")func main() &#123; var ( boolA bool intB int int8C int8 int16D int16 int32E int32 int64F int64 uintptrG uintptr float32H float32 float64I float64 arrayJ [3]int chanK chan int // 函数 在go语言中是一等公民 funcL func() // go语言中的泛型,可代表任何类型 //interfaceM interface&#123;&#125; mapN map[int]int ptrO *int sliceP []int stringQ string structR struct&#123;&#125; unsafaPointerS unsafe.Pointer ) var list []interface&#123;&#125; list = append(list, boolA, intB, int8C, int16D, int32E, int64F, uintptrG, float32H, float64I, arrayJ, chanK, funcL, mapN, ptrO, sliceP, stringQ, structR, unsafaPointerS) for _, v := range list &#123; // 是否可以对比 fmt.Printf(\"类型名称:%s,是否可以对比:%t\\n\", reflect.TypeOf(v).Kind(), reflect.TypeOf(v).Comparable()) &#125;&#125; 结果为: 123456789101112131415161718类型名称:bool,是否可以对比:true类型名称:int,是否可以对比:true类型名称:int8,是否可以对比:true类型名称:int16,是否可以对比:true类型名称:int32,是否可以对比:true类型名称:int64,是否可以对比:true类型名称:uintptr,是否可以对比:true类型名称:float32,是否可以对比:true类型名称:float64,是否可以对比:true类型名称:array,是否可以对比:true类型名称:chan,是否可以对比:true类型名称:func,是否可以对比:false类型名称:map,是否可以对比:false类型名称:ptr,是否可以对比:true类型名称:slice,是否可以对比:false类型名称:string,是否可以对比:true类型名称:struct,是否可以对比:true类型名称:unsafe.Pointer,是否可以对比:true 可见,只有func,map,slice不可对比 slice和map的值为地址,而不是该地址对应的具体值,故而无法直接对比. 只能通过reflect.DeepEqual方式间接对比 为什么 channel 可以对比? 参见 func的值也是一个地址 数值类型和引用类型 func,slice,map,channel 为引用类型, 其余为 数值类型 参考自 走出新人误区，了解类型底层 - 从reflect谈谈Go语言的类型 Go语言基础22 反射reflect01","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"用户态与内核态","date":"2020-06-22T13:33:33.000Z","path":"2020/06/22/用户态与内核态/","text":"概述有三种方式,可以触发用户态到内核态的切换,即 系统调用, 中断,异常, 其中系统调用最为常见,中断和异常有很多相似之处 如读写文件,就会触发从用户态到内核态,会进行一个系统调用. 如申请内存,malloc命令后面有系统调用,即brk和mmap 系统调用:分为五大类型 进程: 进程控制相关. 文件 设备 信息 如获取当前cpu,操作系统的信息 通信 如进程间的通信(如pipe,即管道符|) man syscalls查看所有系统调用 12345678910111213141516171819202122232425262728293031323334353637383940414243SYSCALLS(2) Linux Programmer's Manual SYSCALLS(2)NAME syscalls - Linux system callsSYNOPSIS Linux system calls.DESCRIPTION The system call is the fundamental interface between an application and the Linux kernel. System calls and library wrapper functions System calls are generally not invoked directly, but rather via wrapper functions in glibc (or perhaps some other library). For details of direct invocation of a system call, see intro(2). Often, but not always, the name of the wrapper function is the same as the name of the system call that it invokes. For example, glibc contains a function truncate() which invokes the underlying \"truncate\" system call. Often the glibc wrapper function is quite thin, doing little work other than copying arguments to the right registers before invoking the system call, and then setting errno appropriately after the system call has returned. (These are the same steps that are performed by syscall(2), which can be used to invoke system calls for which no wrapper function is provided.) Note: system calls indicate a failure by returning a negative error number to the caller; when this happens, the wrapper function negates the returned error number (to make it positive), copies it to errno, and returns -1 to the caller of the wrapper. Sometimes, however, the wrapper function does some extra work before invoking the system call. For example, nowadays there are (for reasons described below) two related system calls, truncate(2) and truncate64(2), and the glibc truncate() wrapper function checks which of those system calls are provided by the kernel and determines which should be employed. System call list Below is a list of the Linux system calls. In the list, the Kernel column indicates the kernel version for those system calls that were new in Linux 2.2, or have appeared since that kernel version. Note the following points: * Where no kernel version is indicated, the system call appeared in kernel 1.0 or earlier. * Where a system call is marked \"1.2\" this means the system call probably appeared in a 1.1.x kernel version, and first appeared in a stable kernel with 1.2. (Development of the 1.2 kernel was initiated from a branch of kernel 1.0.6 via the 1.1.x unsta‐ ble kernel series.) * Where a system call is marked \"2.0\" this means the system call probably appeared in a 1.3.x kernel version, and first appeared in a stable kernel with 2.0. (Development of the 2.0 kernel was initiated from a branch of kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel series.) * Where a system call is marked \"2.2\" this means the system call probably appeared in a 2.1.x kernel version, and first appeared in a stable kernel with 2.2.0. (Development of the 2.2 kernel was initiated from a branch of kernel 2.0.21 via the 2.1.x 中断: 异常: 用户态与内核态切换,与cpu上下文切换的关系 上下文切换 指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在进程控制块（PCB-Process Control Block）中。PCB又被称作切换桢（SwitchFrame）。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。 上下文的切换流程如下（1）挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB中。（2）在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程。 时间片轮转方式使多个任务在同一CPU上的执行有了可能。 引起线程上下文切换的原因如下:（1）当前正在执行的任务完成，系统的CPU正常调度下一个任务。（2）当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。（3）多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。（4）用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。（5）硬件中断。 参考: 为什么内核态和用户态的切换损耗要大于多线程上下文切换的损耗？ 多线程上下文切换的主要损耗:多线程的上下文切换不需要更新虚拟内存，而且只有一次cpu上下文切换 内核态和用户态切换主要损耗:从用户态切换到内核态，需要通过系统调用的方式(也可以是异常/中断)。该过程也是有CPU上下文切换的：切换时，先保存CPU寄存器中用户态的指令位置，再重新更新为内核指令的位置。当系统调用结束时，CPU寄存器恢复到原来保存的用户态。一次系统调用，发生了两次CPU上下文切换 为什么系统调用会消耗较多资源","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"route命令小结","date":"2020-06-21T13:41:13.000Z","path":"2020/06/21/route命令小结/","text":"Destination: 如果不满足该列的任何一个ip,则走默认的default Gataway: *是 不指定gateway.有的系统是0.0.0.0,与*意义相同 Genmask: 0.0.0.0是不指定掩码, 255.255.0.0掩码了16位,172.17 开头的ip,会走这个网关 255.255.255.0掩码了16位,192.168.0 开头的ip都会走这个网关 当是255.255.255.255时,则说明指定的是具体的一个ip,掩码全掩了 Flasgs指定不是很重要, 可能有三种标识: U: used G: gateway H: host Metric 是下一跳,也不重要 Ref 为被引用次数,不重要 Iface 是指通过哪张网卡进行数据的路由 traceroute命令比ping指令好用","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"一些Linux命令返回值的意义","date":"2020-06-16T15:21:54.000Z","path":"2020/06/16/一些Linux命令返回值的意义/","text":"nice,renice,ps -l,chrt,uptime nice值是反应一个进程“优先级”状态的值，其取值范围是-20至19，共40个级别。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。可以通过nice命令来对一个将要执行的命令进行nice值设置 来自 Zorro’s Linux Book-Linux的进程优先级 free命令的buff/cache,以及swap buffer和cache是两个在计算机技术中被用滥的名词，放在不同语境下会有不同意义。在Linux的内存管理中，这里的buffer指Linux内存的：Buffer cache。这里的cache指Linux内存中的：Page cache。翻译成中文可以叫做缓冲区缓存和页面缓存。在当前的内核中，page cache顾名思义就是针对内存页的缓存，说白了就是，如果有内存是以page进行分配管理的，都可以使用page cache作为其缓存来管理使用。当然，不是所有的内存都是以页（page）进行管理的，也有很多是针对块（block）进行管理的，这部分内存使用如果要用到cache功能，则都集中到buffer cache中来使用。（从这个角度出发，是不是buffer cache改名叫做block cache更好？）然而，也不是所有块（block）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在X86上无论是32位还是64位都是4k。 cache(即page cache)用的更多 清除cache的办法,及为何”某些情况下cache是没法被回收的”,参见: Zorro’s Linux Book-Linux内存中的Cache真的能被回收么？ 关于swap,参见: Zorro’s Linux Book-Linux的内存回收和交换 ####","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux进程间通信(IPC)的几种方式","date":"2020-06-16T07:32:38.000Z","path":"2020/06/16/Linux进程间通信-IPC-的几种方式/","text":"概述: 进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法。进程是计算机系统分配资源的最小单位(进程是分配资源最小的单位，而线程是调度的最小单位，线程共用进程资源)。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。 主要方法: 管道:分为两种, 软管道: 如 ps -ef | grep xxxx, 硬管道: 消息队列:内核创建一个消息队列,操作系统中的多个进程都可以操作这个消息队列.可以向其发送消息,也可从中接收消息. 共享内存:每个进程都有一个虚拟内存地址和物理内存地址的映射,一般两个进程的映射的物理内存地址是不同的,共享内存即是将其映射的物理内存地址变成一样的.这样两个进程就可以访问相同的物理内存,也就可以实现进程之间的通信. 套接字:非常常见,如通过3306端口访问某个远程mysql服务, 我访问mysql的这个进程,和远程的这个mysql服务的进程之间的通信,就是通过3306端口创建的TCP的套接字. 如果是访问本机的mysql服务,则不会走TCP套接字,而是走Linux底层的套接字 信号量:类似一个计数器.控制多个进程对一个共享资源的访问. 信号:一个进程可以向另一个进程发送一个信号.通过kill -l指令可以列出所有的信号 (64种死法…) Linux中的信号 大多数作用是把一个进程杀死,于是叫kill了.. 当tail -f xxx文件时,是会一直是阻塞. 如何结束? 一般会按ctrl+c, 其实该命令就是当前的shell($$可以看到当前shell的pid),向tail -f进程发送了一个信号,该信号值是2,即SIGINT kill -9 pid, 9号信号是SIGKILL. 如果不加,则默认15号信号SIGTERM(即Terminal) 9号信号即kill信号是不能被捕捉的,必须强制停止. 其他信号可以在程序中捕捉到. ctrl+c : SIGINT kill不带参数: SIGTERM KILL -9: SIGKILL 各个编号的含义,可参见linux kill -l 信号列表","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"理解Linux的Cgroup","date":"2020-06-16T07:08:26.000Z","path":"2020/06/16/理解Linux的Cgroup/","text":"cgroups，control groups的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。 参考: Zorro’s Linux Book - Cgroup系列 Linux CGroup 基础","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"CPU及并发","date":"2020-06-13T13:04:52.000Z","path":"2020/06/13/CPU及并发/","text":"2.9G Hz,即每秒进行2.9G次运算(即29亿次) 几个命令 us: 用户使用的cpu sy: 系统(内核)使用的cpu id: idle,即空闲cpu wa: 等待I/O的cpu st: 开虚拟机后会有的一个指标,即虚拟机的cpu使用率 一个进程拥有一整套虚拟地址空间,该进程的所有线程都共享该地址空间. 线程是CPU运算的最小单位.CPU不关注是哪个进程,只是轮换着线程来运行,不需要知道该线程属于哪个进程. 线程的五种状态:只有运行中占用CPU资源,其他包括阻塞状态,都不占用CPU资源. 使用线程池,可以优化线程创建/销毁带来的性能损耗(申请cpu计算资源需进入内核态) 协程是用户自定义的线程,不需要进入内核态进入申请计算资源.(这里的用户就是指应用程序及编程语言了..) CPU性能衡量参数 主频 主频又称时钟频率，指CPU内部晶振的频率，常用单位为MHz或GHz，它反映了CPU的基本工作节拍; 一般用 f 表示 (frequency) 时钟周期 时钟周期 $ t = \\frac{1}{f} $ 即 时钟周期 = 主频的倒数 机器周期 机器周期 = m*t 一个机器周期包含若干个时钟周期 指令周期 指令周期 = m*t*n 执行一条指令所需要的时间，一般包含若干个机器周期 CPI CPI = m*n; 每条指令的平均时钟周期个数 指令周期 = CPI×机器周期 = n（CPI=n）×m×时钟周期=nm/主频f 注意指令周期单位是s或者ns，CPI无量纲 MIPS(MillionInstructions Per Second） MIPS = 每秒执行百万条指令数 = 1/（CPI×时钟周期）= 主频/CPI MFLOPS 每秒百万浮点运算次数。 表示秒钟所能执行的指令条数，对于微型计算机, 可用CPU的主频和每条指令执行所需的时钟周期来衡量。 包含关系：指令周期通常用若干个机器周期来表示，在机器语言中，使用执行一条指令所需要的机器周期数来说明指令执行的速度。而机器周期又包含若干个时钟周期。时钟周期是最基本的操作单位。 注意：计算机的运算速度一般用每秒钟所能执行的指令条数来表示。由于不同类型的指令所需时间长度不同，因而运算速度的计算方法也不同。例如，根据不同类型的指令出现的频度，乘上不同的系数求得统计平均值，得到平均运算速度。这种方法用MIPS(Millions of Instruction Per Second)作单位，即每秒百万条指令。 又如，直接给出CPU的主频和每条指令的执行所需的时钟周期。周期一般以MHz为单位。主频即计算机的时钟频率，它在很大程度上决定了主机的工作速度。例如，型号为486DX-133的微型计算机，表明它的CPU型号为486，DX为含浮点处理器，数字133的含义是主频为133MHz。 例题 ： 若某处理器的时钟频率为500MHz，每4个时钟周期组成一个机器周期，执行一条指令需要3个机器周期，则该处理器的一个机器周期▁8▁ns，平均执行速度为▁42▁MIPS 解析如下： 时钟周期T等于主频的倒数，即T=1/500MHz=1/（0.5×10的9次方Hz）=2 ns，机器周期等于4个时钟周期即=4T=4×2 ns=8 ns，每条指令的时钟周期数CPI=3×4=12，则平均速度为：f/（CPI×10的6次方）=（500×10的6次方）/（12×10的6次 方）=500/12=41.6≈42MIPS.计算主频的倒数时要注意把主频的MHz换算成Hz即500后面加6个0=500×10的6次方=0.5×10的9次方，1/10的9次方 Hz=1ns 每条指令的时钟周期数CPI=3×4=12，执行一条指令需要3个机器周期数，一个机器周期包含4个时钟周期，所以CPI=3×4=12，这里计算 的都是周期的个数，和具体的时间ns纳秒没有关系，若带上具体的时间，一个时钟周期T=2ns，一个机器周期就是2×4=8ns，执行一条指令需要三个机 器周期得出执行一条指令需要的具体时间为3×8=24ns，执行每条指令的需要的时钟周期数CPI换句话说就是把执行每条指令需要的时间24ns换算成时 钟周期个数表示，为多少个时钟周期个数?时钟周期是最基本的时间操作单位，500MHz主频的处理器一个时钟周期为2ns，24ns等于多少个时钟周期？24/2=12个时钟周期，即那一句：“每条指令的时钟周期数CPI=12”。 :某计算机系统的CPU主频为2.8GHz。某应用程序包括3类指令，各类指令的CPI(执行每条指令所需要的时钟周期数)及指令比例 如下表所示。 执行该应用程序时的平均CPI为（ ）； A、25 B、3 C、3.5 D、4 运算速度用MIPS表示，约为（ ）。 A、700 B、800 C、930 D、1100 解: (1) 求 平均CPI,即对列出的CPI求平均数 4*35% + 2*45% + 6*20% = 3.5 (2) 求MIPS,即每秒执行的百万条指令数 根据第一问CPI，每条指令需要的时钟周期为4，每个时钟周期为主频的倒数，即1/2.8G秒，则每条指令需要时间3.5/2.8G秒。 每秒执行指令数为1/(3.5/2.8G)=2.8G/3.5=0.8G=800M。 （1M=106，1G=109） 拓展阅读： 阮一峰-为什么寄存器比内存快？ 阮一峰-汇编语言入门教程 CPU性能衡量参数-主频，MIPS，CPI，时钟周期，机器周期，指令周期","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"有关I/O多路复用","date":"2020-06-10T12:43:18.000Z","path":"2020/06/10/有关I-O多路复用/","text":"多线程的弊端是需要CPU上下文切换,代价很高. 如何用单线程来处理大量客户端的同时连接呢? DMA控制器,专注于I/O. Linux中一切皆文件,每一个网络连接,都有一个文件描述符(fd), 方式一: 轮询.即用一个while(1) 死循环 方式二: select,poll,epoll用户态和内核态切换,也有一定开销 select这个API在198x年就有了,到现在还有部分系统在使用 Redis,Nginx,Java中的Nio(Linux版),其底层都是使用epoll实现的 思考: 为什么SSD比机械硬盘快? 哪些数据库对SSD进行了优化? 这些优化基于什么原理?","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"文件系统的中枢---Inode结构体","date":"2020-06-10T12:26:10.000Z","path":"2020/06/10/文件系统的中枢-Inode结构体/","text":"Inode记录了文件的元数据: 类型 权限 拥有者 各种时间(上次创建/修改内容/访问 时间) 连接数(一个文件只能有一个连接,但一个连接可以对用多个文件) 文件内容所在的位置(磁盘上块(block) 的下标) 一般文件系统的Inode大小是128或256Byte. Inode以数组形式存放,每个元素都是一个Inode. File System还会维护一个映射表(Map),存储 文件名 和 Inode的下标 之间的对应关系. 先根据文件名,去Map中找到对应Inode的index,再去存储Inode的数组中,去找到Value即Inode 扇区(sector)出厂之后就是固定的,早期老的磁盘 扇区一般是512Byte,现在新的磁盘,一般都是4K. 一个块(block),包含2的n次方个扇区(即必须是2的幂次方个) 块 过大或过小都不好,需要权衡. 当有非常非常多小文件时,可能出现Inode用完的现象,即便磁盘还有空间,也无法继续存储信息 (如Docker overlay 用尽inode…) 阮一峰-理解inode","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"计算机网络中常见缩略词翻译及简明释要","date":"2020-06-09T16:01:16.000Z","path":"2020/06/10/计算机网络中常见缩略词翻译及简明释要/","text":"WireShark 抓包,是学习网络协议最快速,最有效的方式! SW: 集线器（Hub）、交换机（SW）、路由器（router）对比区别 集线器是在物理层; 交换机&amp;Mac地址是在数据链路层(Mac物理地址不是在物理层!). 交换机的方式,在网络内部可以进行高效的传输,但在跨局域网时,效率较低(因为需要不停广播,而广播的效率不高) 于是有了路由器(有时也称为网关,因为是跨两个或多个网络之间的一个连接点) 路由算法到现在仍然在不断地迭代中 路由器是工作在网络层的设备,交换机和网桥是数据链路层,中继器是工作在物理层上的连接设备 ICMP协议 (Internet Control Message Protocol） Internet控制报文协议 选择一块流量较大的网卡 网际控制报文协议ICMP ARP协议: Address Resolution Protocol，地址解析协议 局域网中的数据传输不是通过网络层的 IP 地址进行路由和转发的，然而 IP 地址一般都是发送数据主机知道的唯一信息，想要在局域网中发送数据，还是需要知道它们的 MAC 地址。当我们的设备想要向其他的设备发送数据时，它会先通过 ARP(Address Resolution Protocol，地址解析协议) 在局域网中获取目的 IP 地址对应的 MAC 地址：源主机会向当前局域网中发送 ARP 请求，目标的 MAC 地址是 FF-FF-FF-FF-FF-FF，这表示当前请求是一个广播请求，局域网内的所有设备都会收到该请求；接收到 ARP 请求的主机都会检查目的 IP 和自己的 IP 地址是否一致；如果 IP 地址不一致，主机会忽略当前的 ARP 请求；如果 IP 地址一致，主机会直接向源主机发送 ARP 响应；源主机在接收到 ARP 的响应之后，会更新本地的缓存表并继续向目的主机发送数据； arp -a 可查看ip和网卡的对应(绑定)关系 ICMP与ARP协议详解 NAT协议: MTU:最大传输单元（Maximum Transmission Unit，MTU） IP 协议是用于传输数据包的协议，作为网络层协议，它能提供数据的路由和寻址功能，让数据通过网络到达目的地2。不同设备之间传输数据前，需要先确定一个 IP 数据包的大小上限，即最大传输单元（Maximum transmission unit，即 MTU），MTU 是 IP 数据包能够传输的数据上限。MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定。以太网对数据帧的限制一般都是 1500 字节，一般情况下，IP 主机的路径 MTU 都是 1500，去掉 IP 首部的 20 字节，如果待传输的数据大于 1480 节，那么该 IP 协议就会将数据包分片传输 MSS: 最大分段大小 (Maximum segment size) TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。IP 协议的 MTU 是物理设备上的限制，它限制了路径能够发送数据包的上限，而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次连接的 MSS。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据进行拆分，构成多个数据段。需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包（Package）为单位组织数据，而 TCP 协议以数据段（Segment）为单位组织数据。 为什么 TCP/IP 协议会拆分数据 MSL:最长报文段寿命(Maximum segment lifetime, MSL) TIME_WAIT 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 CLOSED 状态，进入 TIME_WAIT 的客户端需要等待 2 MSL 才可以真正关闭连接。TCP 协议需要 TIME_WAIT 状态的原因和客户端需要等待两个 MSL 不能直接进入 CLOSED 状态的原因是一样的：防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息； 为什么 TCP 协议有 TIME_WAIT 状态","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"操作系统中常见缩略词翻译及简明释要","date":"2020-06-09T16:01:06.000Z","path":"2020/06/10/操作系统中常见缩略词翻译及简明释要/","text":"CPU CPU: central processing unit,中央处理器,主要包括两个部分，即运算器、控制器 运算器: ALU: Arithmetic and Logic Unit,算术逻辑单元 ACC: Accumulator,累加寄存器 DR: Data Register,数据缓冲寄存器 PSW: Program Status Word,程序状态字(也称程序状态寄存器) 控制器: IR: Instruction Register,指令寄存器, 临时放置从内存里面取得的程序指令的寄存器 PC: Program Counter,程序计数器, 用于存放下一条指令所在单元的地址的地方 AR: Address Register,地址寄存器. 用来保存当前CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止 ID: Instruction Decoder,指令译码器. 内存篇 DMA:直接内存访问 DMAC:直接内存访问 控制器 DMAC位于主板的另一块芯片南桥中. 读取文件是非常机械重复性地工作,CPU这么金贵不适合干.DMAC可以直接访问内存,将磁盘中的文件读取到内存.而后以中断的形式通知CPU, 为什么DMA可以直接访问内存?因为CPU在把读取文件的指令给DMA时,也会把总线的控制权给它.这时CPU与总线是隔离的… DMA在读取文件过程中,不是一直持有总线的控制权,而是与CPU约定,轮流坐庄. 即像之前普京和梅德韦杰夫那样,轮换掌握总线的控制权..因为时间极短极短,用户是无感知的 MMU:内存管理单元（memory management unit，MMU），有时称作分页内存管理单元（paged memory management unit，PMMU）。 是一种负责处理CPU内存访问请求的计算机硬件。其功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制 MMU通常借助一种叫做转译旁观缓冲器（Translation Lookaside Buffer，TLB） 的相联高速缓存（associative cache）来将虚拟页号转换为物理页号。当后备缓冲器中没有转换记录时，则使用一种较慢的机制，其中包括专用硬件（hardware-specific）的数据结构（Data structure）或软件辅助手段。这个数据结构称为分页表，页表中的数据就叫做分页表项（page table entry，缩写为PTE）。物理页号结合页偏移量便提供出了完整的物理地址。 页表或转换后备缓冲器中数据项包括的信息有： 一、“脏位”（页面重写标志位，dirty bit）——表示该页是否被写过。 二、“访问位”（accessed bit）——表示该页最后使用于何时，以便于最近最少使用页面置换算法（least recently used page replacement algorithm）的实现。 三、哪种进程可以读写该页的信息，例如用户模式（user mode）进程还是特权模式（supervisor mode）进程。 四、该页是否应被高速缓冲的信息。 有时，TLB或PTE会禁止对虚拟页的访问，这可能是因为没有物理随机存取存储器（random access memory）与虚拟页相关联。如果是这种情况，MMU将向CPU发出页错误（page fault）的信号。操作系统(operating system）将进行处理，也许会尝试寻找RAM的空白帧，同时创建一个新的PTE将之映射到所请求的虚拟地址。如果没有空闲的RAM，可能必须关闭一个已经存在的页面，使用一些替换算法，将之保存到磁盘中（这被称之为页面调度（paging）。在一些MMU中，PTEs或者TLB也存在一些缺点，在这样的情况下操作系统将必须释放空间以供新的映射。 为什么 Linux 默认页大小是 4KB 虚拟地址和物理内存映射,虚拟地址还可以映射到磁盘上,即Swap分区. cache和buffer的区别:两者有在合二为一的趋向 Windows中的pagefiles.sys相当于Linux的Swap 已提交的量可以远远大于物理硬件的上限..类似好几个T的网盘,实际占用的空间根本没那么多,用多少给多少,几个T只是一个给你分配的上限. 系统调用是 用户态 切换到 内核态 的方式之一(还有另外两种方式,中断和异常). 申请内存时就需要进行系统调用. C语言的malloc只是一个库函数,封装了brk和mmap这两个系统调用的封装.小于128K时,调用brk,大于128k时,调用mmap brk分配的是连续内存(即并不是在堆空间随意找内存,即提高了Heap部分的上界),可以用C语言的sbrk库来测试检验 mmap是在堆和栈之间的一段(游离)区域来申请内存 pidstat工具可用来检测进程 关于零拷贝技术 Java中的内存: 内存五区: 程序记录器 记录程序运行到哪里了. 局部变量存在栈上,全局变量在堆上分配.(经逃逸分析后发现没有出方法的变量仍然定义在栈上)","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"读<操作系统导论>( Operating Systems---Three Easy Pieces)","date":"2020-06-09T15:46:38.000Z","path":"2020/06/09/读-操作系统导论-Operating-Systems-Three-Easy-Pieces/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"博客优化3--悬崖山庄奇案","date":"2020-06-06T14:15:02.000Z","path":"2020/06/06/博客优化3-悬崖山庄奇案/","text":"案情简介: 正常情况下,git仓库中应当只存放代码,像编译成的二进制包,以及许多静态资源如图片/视频,都不应该放在里面.但对于我的博客项目,为方便添加图片使用了hexo-asset-image,该package会在hexo new article-title时生成(近似)同名的文件夹,用以存放该篇博客用到的图片. 这样做的问题是伴随文章数量的增加,尤其是许多图片较多的文章,会使仓库体积变得愈发庞大臃肿.github对单个仓库的限制较为宽泛,但码云的免费版,单仓库大小不能超过1G,否则就会提交失败. (注: 之所以用gitee,是为解决github图片国内访问速度极慢的问题,而采用[bai piao]码云的CDN加速—具体办法是同时将代码提交至gitee,然后访问的图片地址前拼接地址.魔改hexo-asset-image的index.js如下: 1$(this).attr('src', 'https://geekblog.gitee.io/' + link + src); ) 最直接的解决方案自然是开通码云企业版,但纵是如此,单仓库的容量上线也不过3G,不过几年又会面临同样问题. 审视hexo-asset-image这个插件,其会在hexo g将markdown转换成静态网页时,将每篇文章&lt;img src&gt;后的内容加上permalink里的年月日等信息,生成新的图片地址. 采用这样一种方案: 解绑老的gitee仓库, 然后在为每篇博客生成图片引用的地址时加一个判断, 如果时间小于”2020.06”,则读取老gitee仓库地址; 另外建一个新的gitee仓库,专门用来存储图片,”2020.06”及之后的博客,图片读取该地址. 原则上这样就可以永久解决容量上限的问题. 当然这样会稍稍增大操作成本,原本博客完成后hexo g &amp;&amp; hexo d两个命令.现在还需要将对应文件夹及图片上传新的码云仓库,这个可以后续考虑脚本自动化实现. 修改hexo-asset-image的index.js代码如下: 1234567891011121314//新增//permalink: :year/:month/:day/:title/ var newLink = data.permalink;var infoArr = link.split(\"/\")var year = infoArr[0]var month = infoArr[1]if (year &gt;= \"2020\" &amp;&amp; month &gt; \"05\") &#123; $(this).attr('src','http://geekblog.gitee.io/blog666888-img/' + link + src) &#125; else &#123; $(this).attr('src', 'https://geekblog.gitee.io/' + link + src); &#125; 匪夷所思: 但在实践过程中,每次都会将全部图片地址变为http://geekblog.gitee.io/blog666888-img/,让我一度感到困惑. 由于对js了解有限,最开始云里雾里. 开始一步步调试,用写文件的方式,将year和month两个变量写到一个新文件中: 1234567891011121314151617181920212223242526272829var fs = require(\"fs\");fs.writeFile('input.txt', '这是通过fs.writeFile写入文件的内容', function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;);fs.writeFile('input123.txt', newLink[0], function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;);fs.writeFile('input456.txt', newLink[1], function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;);fs.writeFile('input789.txt', newLink.toString(), function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;); (虽然console.log不仅可以在浏览器控制台打印内容,在终端同样可以.但hexo g终端输出大量数据,寻找不易,故用写文件的方式…好吧其实最开始以为console.log在终端中无效..) 发现得到的h和t..这大概是过程中的某步骤,在原字符串前拼接了http://,修正后, 最新的博客其图片地址如愿读新的仓库. 这样一来,之前困扰百思不解的问题就变成了, “t” &gt; “2020”甚至 “t” &gt; “10000000” 为何成立的问题. 水落石出: 参考: js字符串与数字比较大小的问题 两个比较的变量都是字符串,则比较其对应的字符编码值(ASCII值),先比较第一位,如果第一位相同,再比较第二位…直至区分出大小. 对于字符串”t”,其ascii值为116,而字符串”100000000000000…”其第一个元素”1”的ascii值为49,第一轮即分出高下…. 如对以下几种编程语言,有 在js中: 12345678910111213141516$str = \"t\";$num1 = \"1000000000\";$num2 = \"10000000000000000000000000000000000000000\";$num3 = \"9\";$num4 = 1000000000;console.log($str &gt; $num1);console.log($str &gt; $num2);console.log($str &gt; $num3);console.log($str &gt; $num4);console.log($str.charCodeAt());console.log($num1.charCodeAt()); 在php中: 12345678910111213141516171819&lt;?php&lt;?php$str = \"t\";$num1 = \"1000000000\";$num2 = \"10000000000000000000000000000000000000000\";$num3 = \"9\";$num4 = 1000000000;var_dump($str &gt; $num1);var_dump($str &gt; $num2);var_dump($str &gt; $num3);var_dump($str &gt; $num4);var_dump(ord($str));var_dump(ord($num1)); 在golang中: 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; str := \"t\" num1 := \"1000000000\" num2 := \"10000000000000000000000000000000000000000\" num3 := \"9\" //num4 := 1000000000 fmt.Println(str &gt; num1) fmt.Println(str &gt; num2) fmt.Println(str &gt; num3) //fmt.Println(str &gt; num4) fmt.Println([]byte(str)) fmt.Println([]byte(num1))&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://www.dashen.tech/tags/前端/"}]},{"title":"Linux性能优化","date":"2020-06-02T13:40:14.000Z","path":"2020/06/02/Linux性能优化/","text":"平均负载 uptime 最后这三个值,分别代表在过去1分钟,5分钟,15分钟 平均活跃进程数 可以知道系统负载升高了,但具体是CPU还是I/O升高了,还不能确定. 阮一峰-理解Linux系统负荷 psi Facebook贡献给Linux内核一个psi工具,4.2以后的内核都有该命令. 最新版本在/proc/pressure下面,有cpu,io,memory三项 指数衰减平均值 内存优化 为什么内存池可以优化内存性能? malloc分配小块内存时,基于brk(使用内存里的缓存,从缓存取出一小段,使用完了并不返回给系统,仍然放在内存里,下次用时可以直接用)实现; 分配大块内存时,使用mmap(内存映射)实现 快速定位磁盘I/O性能问题 iostat和sum命令,确定是否有I/O性能问题 pidstat和wimstat 为什么网络性能优化相对更难? Linux到底支持多少并发连接? c10k,c100k,c10m问题 怎样解决恼人的TIME_WAIT问题 三次握手比较简单, 而四处挥手,相对麻烦.在某些场景也可以合并为三次. time_wait就是四次挥手时的一个中间状态 主动关闭连接的过程中,当主动关闭的一方发出syn包后,会进入time_wait状态..从time_wait到close状态之间有一个time_out,在内核中time_out是两个MSL,只有过了time_wait这个状态的TCP的socket,才会被内核回收 如果没有time_wait,将会有各种问题,如下: 对于被动关闭的一端,会是close_wait状态.只需要一个ack,就可以变成close状态了,相对来说要简单很多 即只有主动关闭连接那一方,才会出现time_wait状态 time_wait过多, 危害是每个time_wait会占用一个端口号和连接跟踪表,相对内存来说, 这两者数量都是有限的 解决办法: 修改内核中连接跟踪表的数量,改的大一点 减小time_out的值,使网络连接尽快释放 重用属于time_wait状态的TCP连接,可以开启tcp_reuse选项. 修改增大系统文件描述符的数量(socket也是一种文件描述符)","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"罢絮光阴萍满池,春风吹鬓白成丝","date":"2020-05-23T00:20:15.000Z","path":"2020/05/23/罢絮光阴萍满池-春风吹鬓白成丝/","text":"星夜归故里，晨来动征铎，却还是紧赶慢赶迟了一步，更确切说，只差有一个小时。大概是激进的殡葬改革，再兼疫情期间从简:下午离开的逝者，必须在第二天正午前，完成一系列『注销社会身份』的操作，包括形体消失，寿盒入土。或许政有其因，但从亲属角度看，这规定冰冷而不人道。 在青砖修葺的“通天银行”前，坚定的唯物主义者认知土崩瓦解，我只动也不动守在坛前，机械接过递来的一沓沓纸钱。带有余温的灰烬扑簌簌升腾飘出，不做闪避，只感到眩晕，像是一个时代的落幕。在成行翠柏间，发现一株蒲公英，弯身细细打量。“吊影分为千里雁，辞根散作九秋蓬”，这是1000多年前，生逢经乱阻饥年代的白乐天，写他离散各地的同根兄弟。今四海承平，叔侄兄姊，在京在沪在杭在邹，也似这辞根而去各寻新乡的种子。“共看明月应垂泪，一夜乡心五处同”，而今以后，这座举头可见的青青北山，将有别样意义。那是亲情聚集的渊薮，也希望是一甲子后我结束旅途，最终的归宿。 下山后，大人们讨论人情往来，需到各户人家门外致意。听着各种与我父伯相近的名字，却大多无法对应起鲜活的形象。我离乡太早，又只假期偶来，伴随一代人芳华故去，即便再坚持“望京村第一程序员”称号，却知再过数十载，蓬头稚子 笑问客来的场景，将必然发生。小侄子喊着要吃冰激凌，堂哥带他出去，不多时带回一袋雪糕。这个不谙世事的孩童，听命取出一支送将过来。我低头接下，竟是『美伦』劲香豆—- “颖乎尔诚能，无以冰炭置我肠”。 自古以来，红豆就是中国人表达相思寄托思忆的载体，在温庭筠和牛希济的诗文里，在晏几道和黄庭坚的新词间，在周密刘过和纳兰性德的篇章里。“红豆不堪看，满眼相思泪”，“几度相思，红豆都销，碧丝空袅”，这是有情人之间离别的郁闷愁苦;而“红豆生南国，春来发几枝”，则是诗画音律皆通的全才王维，思念被流放江南的乐师挚友李龟年。 而我捏着这小小一支雪糕，盯着包装的文字，则是另一种情愫。我起身走到庭院葡萄藤下，小满时节万物生长，亭亭如盖。而再几个节气到白露秋分，又将如常硕果压枝。一过霜降，“紫葡萄化为深秋露水，枯藤凄凉凝霜”，如此周而复始。光束透过叶隙打在手上，闪转腾挪似如无痕之流苏，我盯着浆果上忙碌的蚁虫，回荡着庄生“夏虫不可语秋”，和帕斯卡“人是有思想的苇草”，“怜我世人，忧患实多;喜乐悲愁，皆归尘土”，“来如流水兮去如风，不知何处来兮何所终”。我想到山中老人和波斯明教，想到幽邃瑰凄的李贺那些匠心独运的思索。等意识回流，人生观又像是经过一次重构:君言百年弹指，白驹过隙，且看光阴流飞，劝酒一杯。难识青天之高，黄土之厚，唯见月寒日暖，来煎人寿。","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"近泪无干土,低空有断云","date":"2020-05-22T14:39:10.000Z","path":"2020/05/22/近泪无干土-低空有断云/","text":"p{ text-indent:2em;} 我乜斜倚在车座，连日晚睡早起的丝丝倦意来袭。渐昏的暮夜，摇摇拽拽的长途巴士，在降噪耳机舒畅低缓的钢琴声中，不多时陷入梦乡，抱着书包沉沉睡去。不知是过了几分钟还是数小时，夹层里手机的振铃声将我惊起。拿开发现是我爸，对话很简短，他告知: 奶奶下午过世了。前刻还处休眠状态，瞬时气血上涌目眦尽裂，错愕之余，本想再多说些什么。心有万语千言，到嘴边却期期艾艾上下打颤。嘱咐我和叔叔商议坐哪班高铁回来，匆匆几句后便挂了电话。去年暑假的一个周末，我从科技城CBD一处餐馆饱食出门，沿着沁有凉气的河边惬意走着，想起按往常，该和家里视频了。拨通后，爸放暑假，在老家照看抱恙的爷爷。我让奶奶接过手机，指着后面霓彩恢煌的金融城，中气十足说:奶奶，我宅子就在这里，你看看你看看。大概是网络延迟，也有她反应已见迟钝，“响应”总要隔上片刻。与向往街的通明灯火截然相反，那边如豆的灯盏，只隐约映衬出轮廓。说了半晌，最后却还是错认成堂哥，我只当口误，心里不太痛快。暑假过后，国庆节前，意外摔倒卧病在床，意识还是清醒，身体却不受驱使，难以正常饮食，日渐憔悴消瘦。我在楼梯间接到爸的电话，只感天旋地转后蓦然泪下。向隅而泣到涕泗横流，在半年多前那刻几乎用尽了，知道盈亏有数终有一日。但当到来，当最后一段对话，永远永远定格在隔着屏幕的那个夏日夜晚，有些愁眉不展，有些怅然若失，有些说不出的遗缺抱憾。…我有清晰记忆的这15年来，和奶奶交流总不用刻意，感到很自然而舒服。5年前，未能去北境高寒之地继续“深造”，却令她欣慰不已: 你爷爷年轻时去那打过勺子，冰天雪地，举目无亲，不去是最好。我转而南下开始闯荡，她叮嘱处在同城的叔叔:他也还是个孩子，你也多照顾。那年春节回去，饶有趣味问我工作。回答是在一家o2o洗衣公司，她惊讶，“你给人洗衣服？你会吗？”。我咧嘴笑过，说都是机器洗。接着又问“那你给人算账？”我说也不是，倒腾电脑，进而解释何为“o2o”。实在有太多前因后果需要铺垫，我几乎从雅虎和瀛海威起头，滔滔不绝，串联起风险投资，各种所谓的“商业模式”。这些对一个平生从未触网的耄耋老人，当浑如天书云里雾里。但惊讶是，能大致听下去，并恰到好处不时发问。…最近几年，老态明显。曾立flag，无论“如何繁忙”，不管“多么重要”，纵有万难，也不再缺席ta们的每一个生日。可惜自那以后，物是人非约空许，连一次机会也不再有。两年前姥爷姥姥离世，支撑我幼年世界观大厦的两根台柱已然颓倒。不复有天崩地坼的惶惑，眼见宽 心渐大，那个躲在冰糕箱和胡同里的幼童，始终要脱离庇护，迎受属于自己的风浪。而对一路相伴关怀备至的长辈，总有最深的敬意和绵长无尽的思念。——————","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"Linux内核分析与应用9-设备驱动","date":"2020-05-17T11:53:02.000Z","path":"2020/05/17/Linux内核分析与应用9-设备驱动/","text":"9.1 设备驱动概述 因为UNIX/Linux一切皆文件,所以也将设备纳入文件管理体系下 Linux将设备分为三大类,一类是像磁盘那样,以块或扇区为单位,成块进行输入输出的设备,称为块设备; 另一类像键盘那样,以字符为单位,进行输入/输出,称为字符设备; 还有一类,是网络设备,与前两者有很大不同 ----块设备和字符设备对应/dev下的一个设备文件,而网络设备不存在这样的设备文件,采用套接字socket来访问. 文件系统通常都建立在块设备上,也有部分放在内存,如proc文件系统,则不需要驱动程序. 建立设备文件的两种方式: Linux内核分为五大部分: 进程管理 内存管理 文件系统管理 设备管理 网络管理 每一部分都有承上启下的作用. 思考: 应用程序以什么形式访问各种硬件设备?为什么采用这种方式? 9.2 IO空间的管理 设备控制器: I/O内存和I/O端口 思考: 内核对I/O资源的管理为什么采用树结构? 9.3 设备驱动模型 Linux支持世界上几乎所有不同功能的硬件设备,导致Linux内核中有一半的代码是设备驱动,且随着硬件的快速升级迭代,设备驱动的代码量也快速增长..为了降低设备多样性带来的Linux驱动开发的复杂度,以及设备热插拔处理,电源管理等,Linux提出了设备模型(Driver Model) (2.x只有200多M,现在5.x版接近3G) Sys文件系统,是一个类似proc文件系统的特殊的文件系统 地位相当于面向对象中的总基类 机制与策略分离: 设备与驱动 匹配的过程 设备和驱动是男女方,红娘相当于总线, 进行撮合 思考: platform平台模型的优势是什么? 9.4 字符设备驱动程序简介 只能一个字节一个字节进行读写操作的设备,不能随机读取设备中的某个设备,必须按照先后次序来进行, 字符设备是面向流的设备.常见的字符设备有鼠标,键盘等 Linux字符设备驱动 思考: 从原理上说明file_operations操作方法集,为什么说它是定义了字符设备提供给VFS的接口函数? 9.5 块设备驱动程序简介 字符设备与块设备的区别: I/O调度: 希望磁头总能往一个方向移动,到底了再向另一个方向移动. 电梯调度算法 第三种调度算法常用于数据库.第四种是内核默认的调度算法. 块和扇区的关系: 扇区是磁盘读写的基本单位,是磁盘上最小的操作单位,是文件系统和块设备之间传送数据的单位. 一般一个扇区的大小是512字节,但如果是SSD,则为4096个字节. 当一个扇区的大小超过512字节时,需要将多个内核扇区对应一个设备扇区. Linux块设备IO子系统(一) _驱动模型 linux内核之块设备驱动图解 思考: 从虚拟文件系统到硬件,为什么要对块设备进行分层管理? 9.6 动手实践-编写字符设备驱动程序 9.7 工程实践-编写块设备驱动的基础(上) 9.7 工程实践-块设备驱动程序分析(中) 9.7 工程实践-块设备驱动程序实现(下)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用8-文件系统","date":"2020-05-17T11:52:51.000Z","path":"2020/05/17/Linux内核分析与应用8-文件系统/","text":"8.1 虚拟文件系统的引入 Linux文件系统中最重要的一个概念: 索引节点 Inode 文件系统是具体到分区的,所以不同分区格式化时,可以是不同的文件系统类型 ext2,ext3,ext4是Linux的标准文件系统,系统将其磁盘分区作为系统的根文件系统; 除此以外的文件系统则安装在根目录系统下的某个目录中,称为系统树形结构中的一个分支. VFS中的”S”是”switch”开关,而不是”system” 思考: 虚拟文件系统VFS与实际文件系统到底是什么关系? 8.2 虚拟文件系统(VFS)中的主要数据结构 本讲介绍了文件系统的四种对象,每个对象都对应有两个数据结构,即对象的属性和其操作方法,这是面向对象思想在文件系统设计中的一种体现. 思考: 给定一个文件名,通过文件系统的数据结构关系图,如何查找到相关的文件?请初步阅读open源代码. 8.3 虚拟文件系统(VFS)中的各种缓存 在文件系统中,有四种类型的缓冲区 cat /proc/meminfo dcache用于把路径转换为索引节点(Inode) inode cache用于表示文件系统中的文件或目录 打开文件的核心是”查找” 查找根目录信息 循环查找路径名后续分量 HashTable和LRU Buffer Cache也用到了LRU 思考: 给定一个文件名,如何查找到相关的文件?继续阅读open的源代码,并说明缓冲区到底起什么作用 8.4 页高速缓存机制以及读写 大小是2的n次方个扇区,如1k,2k,4k,4M等 延迟写技术 思考: 请分析从一个文件读取数据的过程,page cache到底起什么作用? 8.5 动手实践-编写一个文件系统(上) 8.6 动手实践-编写一个文件系统(中) 8.7 动手实践-编写一个文件系统(下)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用7-内核同步","date":"2020-05-17T11:52:42.000Z","path":"2020/05/17/Linux内核分析与应用7-内核同步/","text":"7.1 Linux同步概述 竞态条件,也称竞争条件,race condition 临界区 原子操作,Linux专门有一个atomic_t结构体 问题: 在多核系统中遇到原子操作,在系统层面上原子操作还是原子的吗?在核级还是原子的吗? 死锁:所有的任务都在相互等待,但他们永远不会释放已占有的资源,于是任何任务都无法继续执行 死锁的避免: 加锁的顺序是关键 思考: 死锁是一种小概率事件还是大概率事件?如果内核出现死锁,该如何应对? 7.2 内核同步机制 原子操作已经讲过. 中断屏蔽: 自旋锁:(spin lock) 专为多处理器并发而引入的一种锁,在内核中大量应用于中断处理部分 在短期时间内,进行轻量级的锁定 同一时刻,只能为一个处理器所持有, 防止多处理器并发访问临界区,防止内核抢占造成的竞争 信号量: P/V操作 经典实例: 生产者-消费者并发实例 参考: 内核中的调度与同步 7.3 动手实践-内核多任务并发实例(上) 7.4 动手实践-内核多任务并发实例(下)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用6-系统调用","date":"2020-05-17T11:52:33.000Z","path":"2020/05/17/Linux内核分析与应用6-系统调用/","text":"6.1 Linux中的各种API LSB (Linux Standards Base) POSIX: 可移植操作系统接口(Portable Operating System Interface of UNIX) Linux ABI: (为了兼容) 内核API: 主要是内核中标记为”EXPORT_SYMBOL”的函数 思考: 保持一个稳定的ABI和保持一个稳定的API相比,谁更困难,为什么? 6.2 系统调用机制 系统调用—内核的出口 各种工具: 如 strace ls,就可以看到ls命令所调用的系统调用 中断是异步的,异常是同步的,系统调用既可以是同步,也可以是异步 系统调用号存放在eax寄存器中, 其实现所在的源文件也不在一起. 参数存放在寄存器中,一般参数不超过6个 参考: 系统调用 Linux内核之旅-电子杂志 6.3 动手实践-添加系统调用 (系统调用的实例–日志收集系统)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用5-中断","date":"2020-05-17T11:52:21.000Z","path":"2020/05/17/Linux内核分析与应用5-中断/","text":"中断机制概述 中断是CPU对系统发生的某个事件作出的一种反应, 当中断发生时,CPU暂停正在执行的程序,保留现场后,自动转去执行相应事件的处理程序,处理完成后,返回断点,继续执行被打断的程序. 中断是操作系统的脉搏,是并发处理的基础. 中断的引入,是为了支持CPU和设备之间的并行操作. 中断看似简单,但工程性非常强 5.2 中断处理机制 0x80,系统门的编号 思考: “中断返回”除了返回现场外,从源代码角度分析内核还做了什么? 5.3 中断下半部处理机制 软中断机制 小任务(tasklet)机制 思考: 为什么要有中断下半部分处理机制?而且有好几种机制? 中断下半部分处理机制中,你认为是否还有改进的余地? 5.4 时钟中断机制 在考察了如基树树,哈希表等多种数据结构后, hrtimer使用了红黑树(rbtree). 树最左边的节点是最快到期的时间 在内核中,除了被广泛使用的双向链表,红黑树使用场景也非常多. 思考: 系统有了低精度定时器,为什么还要有高精度定时器? 二者之间兼容么,在实现上有关系吗? 5.5 动手实践(上) 5.6 动手实践(下)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用4-内存管理","date":"2020-05-17T11:52:10.000Z","path":"2020/05/17/Linux内核分析与应用4-内存管理/","text":"4.1 Linux内存管理机制lscpu 命令, 类似是优化后的 cat /proc/cpuinfo 实现虚拟内存的几种机制: 当 程序一旦跑起来,那就变成了一个进程 一个进程的用户地址空间由两个数据结构来描述, mm_struct和 vma_area_struct,前者对进程整个用户空间进行描述,后者对用户空间的各个内存区进行描述 内存映射区(MMR,Memory Mapping Region) 虚拟内存区(VMA) 对于mm_struct,最新版本的内核代码定义在[mm_types.h]这个文件中 对于vma_area_struct: mm_struct结构是由一个个VMA组成的 参考&lt;深入理解Linux内核&gt;第8,9章 4.2 进程用户空间管理机制 写时复制技术(copy on write) 调用do_mmap()创建一个”虚存区” 虚存区分三种: 私有映射,共享映射,匿名映射 上图显示了该进程 各个区的 起始地址 请页机制,实现虚存管理的重要手段. 当一个进程运行的时候,CPU访问的是用户空间的虚地址, Linux仅把当前要使用的少量页面装入到内存, 需要时通过请页机制将特定的页面调入到内存;当访问的页不在内存时,就产生一个页故障,并报告故障的原因. 如果是编程引起的异常,而且还发生在内核态,那需要毫不含糊地杀死该进程;如果发生在用户态,说明是一个无效的内存引用,程序要停止执行;如果是一个真正的缺页引起的异常,而且有合法的权限,这时会进入到缺页异常处理程序 do_page_fault()函数 用户进程访问内存 分析: 用户态进程独占 虚拟地址空间,两个进程的虚拟地址空间完全可能是相同的. 在访问用户态虚拟内存空间时,如果没有映射到物理地址,这时就需要通过请页机制发出缺页异常的请求, 缺页异常陷入内核,分配物理地址空间,与用户态虚拟地址空间就建立起了映射关系 4.3 物理内存的 分配与回收机制(上) 当我们说一个进程在执行的时候, 我们在说什么呢? 从操作系统角度看,一看进程最关键的特征,是其拥有独立的虚拟地址空间. “请页机制”:可以为进程请求物理内存 malloc()从堆中分配一块内存,并将首地址返回给用户. “低端内存”和”高端内存” 伙伴算法: 负责大块连续物理内存的分配和释放,以页框为基本单位. 该机制可以避免外部碎片. per-CPU页框高速缓存: 内核经常请求和释放单个页框,该缓存包含预先分配的页框,用于满足本地CPU发出的单一页框请求. slab缓存: 服务小块物理内存的分配,并且它也作为高速缓存,主要针对内核中经常分配并释放的对象. vmalloc机制: 使得内核通过连续的线性地址来访问非连续的物理页框,这样可以最大限度的使用高端物理内存. slab分配机制 – 分配小块内存 内核空间非连续内存区的分配 最后都要调用”伙伴算法” 参考&lt;深入理解Linux内核&gt;第三版第八章 思考: 用户空间(进程)是否有高端内存概念? 64位 内核中有高端内存的说法吗? 在32位和64位系统上,用户进程能访问多少物理内存? 内核代码能访问多少物理内存? 4.4 物理内存的 分配与回收机制(下) UMA架构与NUMA架构下的自旋锁（CLH锁与MCS锁） Linux内核学习笔记：SMP、UMA、NUMA NUMA 的结构比 SMP 的结构更有优势，为什么现在的电脑不用 NUMA 的结构呢？ 从用户态到内核态的内存分配: 当用户程序通过系统调用,申请内存时,首先陷入内核,建立虚拟地址空间的映射,获得一块虚拟内存区VMA. 当进程对这块虚存区进行访问时,如果物理内存尚未分配,此时发生一个缺页异常,通过getfreepage申请一个或者多个物理页面,并将此物理内存和虚拟内存的映射关系写入页表. 思考: 在物理内存为1G的计算机中,能否malloc(1.6G)? 为什么? 4.5 动手实践-Linux内存映射基础(上) 4.6 动手实践-Linux内存映射实现(中) 4.7 动手实践-Linux内存映射测试(下)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用3-进程管理","date":"2020-05-17T11:51:57.000Z","path":"2020/05/17/Linux内核分析与应用3-进程管理/","text":"3.1 进程概述一个程序通过编译器将其编译成汇编程序,经过汇编器将其汇编成目标代码,通过链接器形成可执行文件a.out或者elf格式,最后交给操作系统来执行 进程最基本的状态有三种: 就绪态,睡眠态和运行态,在具体的操作系统中,可能实例化出多个状态. PCB: Process Control Block task_struct结构体位于sched.h中 对于进程来说,它的静态表现就是程序,平时都安安静静呆在磁盘上,而一旦运行起来,就变成了计算机里的数据和状态的总和; 运行着的程序就是一个进程. 3.2 Linux进程创建 对于进程,线程,内核线程,内核使用唯一的数据结构task_struct来分别表示,也使用相同的调度算法对其进行调度. 尽管看起来差异很大,但最后都通过do_fork分别创建. 创建进程和创建线程调用了不同的函数,分别为fork和pthread_create,而对应的系统调用分别为fork和clone. 所有的系统调用进入内核只有一个入口,但进入以后就分道扬镳,各有各的服务历程;而分手是暂时的,最终还是会归到一处,do_fork就是它们的聚合点. 父子进程共享内存的地址空间,但父进程的页表除外 copy_process()函数主要是为子进程创建父进程PCB的副本 3.3 Linux进程调度 所谓调度,实际就是从就绪队列中,选择一个进程投入到CPU中运行. “主战场”是就绪队列,核心是调度算法,实质是进程的切换 O(1)调度: 将单链表变为多链表来实现,从O(n)降低到了O(1) 机制与策略分离 完全公平调度—CFS, 没有了时间片的概念,而是分配CPU使用的比例 同一时刻,一个CPU上运行的进程只能有一个. 当一个进程占用CPU的时候,其他进程必须等待 使用到了红黑树 CFS中的就绪队列,就是一棵已虚拟时间为键值的红黑树, 虚拟时间越小的进程,越靠近红黑树的左端, 调度器每次选择位于红黑树左端的进程. 更多可参阅&lt;深入理解Linux内核&gt;第三版第七章 蜗窝科技 3.4 动手实践-打印进程描述符task_struct中的字段 3.5 工程实践-基于内核模块的负载监控 章节检测","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用2-内存寻址","date":"2020-05-17T11:51:48.000Z","path":"2020/05/17/Linux内核分析与应用2-内存寻址/","text":"2.1 内存寻址 数据连续存储和选择读取思想,是目前我们使用的几乎所有机器运行背后的灵魂 计算机体系结构中的核心问题之一,就是如何有效地进行内存寻址; 内存寻址技术,从某种程度上代表了计算机技术. “段”的引入: 段描述了一块有限的内存区域,区域的起始位置存在专门的寄存器,也就是段寄存器中. “保护模式”的引入: 访问内存时不能直接从段寄存器中获得段的起始地址,而需经过额外的转化或检查 “黄金时代”: Linux内核中的C和汇编语言 用的GNU的扩展C 汇编语言用的是AT&amp;T的汇编格式与Intel的汇编格式稍有差异 在C语言中,也可以嵌入汇编语言,叫做GCC嵌入式汇编 2.2 段机制将虚地址转换为线性地址 使用readelf和objdump解析目标文件 MMU: 内存管理单元,和CPU是在一起的.MMU把虚地址转化成物理地址,送给存储器. (Intel)I386的体系结构 2.3 分页机制分页在分段之后进行,其作用是完成从线性地址到物理地址的转换 必须在保护模式下才能启动分页功能 在32位系统上一般默认为4K大小,也可以是2MB或4MB 64位系统上,可以是4KB,8KB,最大可以是256MB 分页使得每个进程可以拥有自己独立的虚拟地址空间 (更多可参考 为什么 Linux 默认页大小是 4KB) 两级页表: Linux四级分页模式 I386体系结构（下） 2.4 动手实践-将虚拟地址转换成物理地址 页全局目录 所有的进程都共享一个内核页表 最新的CPU已经支持五级页表 64位系统中已经不再用”高级内存” mknod命令 章节测试: .操作系统启动时，处理器处于保护模式 (错) .X86中段的描述包含基地址和界限 (错) .Intel8086的寻址范围是1MB，80386的寻址范围是 4GB (对) .分页机制是在保护模式下开启的。 (对) .在保护模式下，段的大小可以达到4GB (对) . CR3寄存器存放页目录基地址 (对) .x86的保护模式就是来保护操作系统的 (错) . 分页的原理使得每个进程可以拥有自己独立的虚拟内存空间 (对) . 分Linux之所以巧妙地绕过段机制，主要是因为将段的基址设为0，即偏移量等于线性地址 (对) . 在x86中，启用分页机制是通过启用保护允许位PE而达到的 (错) x86 保护模式 + 分页管理机制 开启分页机制———《x86汇编语言：从实模式到保护模式》读书笔记44 . 链接以后形成的地址空间是虚拟地址空间。 (对) . 虚拟地址是程序访问存储器所使用的逻辑地址 ；线性地址是逻辑地址到物理地址变换之间的中间层；物理地址是每一个字节单元的一个唯一的存储器地址 (对) . CPU访问的是虚拟地址。(对) . 80x86的控制寄存机器主要用于分段机制 (错) . 80x86的分段机制是必选的，分页机制是可选的 (对) 但是现实情况不是的,操作系统大多都用了分页机制 . 保护模式提供了四个特权级，Linux使用了其中的2个，0级对应内核态，2级对应用户态 (错) 段被分为了4个特权级，分别为0-3级，有时候我们也叫做ring0-ring3，其中，数值越小特权级越高核心代码和数据所在的段的特权级都比较高，一般在ring0，而用户程序所在的段的特权级较低，一般在ring3。当低特权级的任务试图在未被允许的情况下访问高特权级的段时，将会产生常规保护错误。而处理器是如何区分所在段的特权级，进而对其进行保护的呢？这就不得不提到CPL、DPL和RPL三者了。但是在开始之前，我们需要先了解一下一致代码段和非一致代码段。 保护模式特权级概述 操作系统-保护模式中的特权级 . 页面大小是由操作系统设计者确定的 (错) . 页面高速缓存是一种硬件机制，专门用来支持地址转换的 (对) 与程序员相关的CPU缓存知识 . intel的保护模式是在80386处理器中首次出现的 (错) . 页目录存放在（ ）中。 D A.CR0 B.CR1 C.CR2 D.CR3 控制寄存器(Control Register)（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。CR0中含有控制处理器操作模式和状态的系统控制标志；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）。 控制寄存器 CR* 控制寄存器 . 一个32位虚拟地址被分为a、b、c三个域，其中a、b用于一个2级页表系统，c为页内偏移地址，则页面数为（ ）。D A. a+b B. a×b C. 2a×b D. 2a+b . 以下（ ）处理器不是冯诺伊曼体系(普林斯顿体系)结构 C(属于哈佛体系) A. Intel X86 B. AMD C. ARM D. MIPS . 如下缩写，（ ）是中断描述符表 B A. GDT B. IDT C. LDT D. RPL 中断描述符表 中断机制和中断描述符表、中断和异常的处理 . “段：偏移量”的形式描述的是（ ） B A. 物理地址 B. 虚拟地址 C. 线性地址 D. 段地址 虚拟地址转换与段分割","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"Linux内核分析与应用","date":"2020-05-17T10:58:58.000Z","path":"2020/05/17/Linux内核分析与应用/","text":"Linux 内核分析与应用 蜻蜓点水,可作抛砖引玉 1.概述 用到的几个命令:insmod dmesglsmod 章节测试:部分可参考 . Linux得以流行，是因为遵循了GPL协议，并不是因为遵循POSIX标准 (错) linux操作系统概述 linux概述 . 从Linux操作系统的整体结构来看，分两大部分，用户空间的应用程序和内核空间的os内核，二者之间是一种c/s结构，os是服务者，应用程序是客户，是一种请求和响应的关系。 (对) Linux用户空间与内核空间 阮一峰-User space 与 Kernel space .Linux内核提供机制而不是策略，系统调用是一种策略 (错) 关于Unix/Linux的设计有一句通用的格言“提供机制而不是策略”。换句话说，系统调用抽象出了用于完成某种确定目的的函数。至干这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix/Linux设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。 .内核源码中的双向链表和哈希表都相当于内核源码中的基本类型，对其操作只需要调用内核提供的相应API就可以。 (对) Linux内核中对双向链表的使用,简直和int型一样频繁 .Linux内核把双链表作为基本类型存放于types.h文件中，是为了隐藏双链表的指针特性。 (对) Linux双向链表的定义主要涉及到两个文件： include/linux/types.h include/linux/list.h Linux内核中双向链表的经典实现 . list.h中的list_entry（）宏通过一个结构体中字段的地址可以求出该结构体的地址，从而可以访问结构体的其他成员，是一种逆向思维。 (对) Linux内核中的list_head结构体以及list_entry宏 .Linux内核是单内核结构，执行效率高，可维护性好 (错) 微内核效率不如单内核，但可维护性要好。minix，qnx，l4，还有谷歌刚推出的fuchsia，均为微内核。linux大多数为单内核 .内核文档中https://www.kernel.org/doc/html/latest/ 只包含各个子系统的文档 (错) .可加装的内核模块在内核运行时候可加载和卸载，是开发一个新的文件系统，驱动程序的基本机制。 (对) .内核模块的修饰符__init可加可不加，对模块的运行没有什么影响 (错) linux kernel init和exit宏的作用 Linux开发实战指南文档(这篇不错) .编写Linux内核模块时，不需要单独写一个Makefile文件，直接编译就可以 (错) .Linux内核模块运行在用户空间 (错) . 微内核比单内核的效率高 (错) . Linux内核模块的插入和运行必须用root权限 (对) . Linux的内核模块不属于Linux的几个子系统 (对) .Linux在超级计算机，可穿戴设备，嵌入式系统，移动终端，桌面等系统上都可以运行。 (对) . Linux内核、GNU工具以及其他一些自由软件组成了人们常熟的Linux系统或者Linux发布版。 (对) . lisit_entry(ptr,type,member)宏返回的是member的地址 (错) Linux内核双链表语句list_entry(ptr, type, member)理解 .list_for_each_saft()宏和list_for_each()宏功能一样，安全性有差异 (对) . 与体系结构（如x86，ARM等）相关的代码存放在arch目录下 (对) . 创建进程属于一种策略而不是机制 (错) . ( )不属于Linux的子系统 D A.进程管理 B.内存管理 C.文件系统 D.模块 .Linux操作系统遵循（ ）标准 C A.GUN B.GPL C.POSIX D.MMU .触摸屏属于（ ）管理 B A.应用程序 B.操作系统 C.硬件厂家 D.系统调用 .如果要从磁盘读取一个文件，则主要与（ ）子系统打交道 C A.内存管理 B.进程调度 C.文件系统 D.网络 . struct list_head 无法表达（ ）种数据结构 D A.队和栈 B.图 C.树 D.集合 深入理解linux内核list_head的实现 . 谷歌的Fuchsia操作系统属于( )结构 A A.微内核 B.单内核 C.C/S D.面向对象","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"天神荟萃","date":"2020-05-07T11:51:49.000Z","path":"2020/05/07/天神荟萃/","text":"任何一个行业中，必定会有这么一到两个让你想想就很兴奋的大师级人物，他们远远地走在前面，背影缥缈而伟岸，让懵懵懂懂的后来者不乏追随的勇气和梦想 Alan Perlis 1966年图灵奖得主贡献领域: 高级程序设计和编译器构造 艾伦·佩利,1922年4月1日生于美国宾州匹兹堡, 1990年2月7日去世,终年68岁. 首届图灵奖得主，在Algol 58 和Algol 60 的形成和修改过程中起到核心和关键作用 ALGOL，名称源自算法语言（ALGOrithmic Language）的缩写，指令式编程语言，发展于1950年代中期，对许多其它编程语言产生重大影响。ALGOL与差不多同时期的FORTRAN、LISP及COBOL并列为四大最有影响力的高阶语言1960年1月， 艾伦·佩利在巴黎举行的有全世界一流软件专家参加的讨论会上，发表了”算法语言Algol 60报告”，确定了程序设计语言Algol 60。Algol60语言的第一个编译器由艾兹赫尔·戴克斯特拉来实现 巴科斯范式（Backus Normal Form，BNF），又称巴科斯-诺尔范式（Backus-Naur Form， BNF，也译为巴科斯-瑙尔范式、巴克斯-诺尔范式），是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。约翰·巴科斯首次在ALGOL 58中实现巴科斯范式。彼得·诺尔在ALGOL 60之中，进一步发展它的概念并将它的符号加以简化，称其为巴科斯范式（Backus Normal Form）。但高德纳主张应称为巴科斯-诺尔范式（Backus–Naur Form），因为它不算是一种正规形式（Normal form）一种典型的元语言 Maurice Wilkes 1967年图灵奖得主贡献领域: 第一个实际存储程序的电子计算机 莫里斯·威尔克斯，1913年6月26日生于英国斯塔福德郡 2010年11月29日去世，终年97岁. 就读于剑桥大学圣约翰学院，之后进入卡文迪许实验室，并于1936年完成其物理学博士学位。 EDSAC（Electronic Delay Storage Auto-matic Calculator），延迟存储电子自动计算器，世界上第一台实际运行的存储程序式电子计算。 受EDVAC启发(Electronic Discrete Variable Automatic Computer,离散变量自动电子计算机,是一台美国早期电子计算机。与它的前任ENIAC不同，EDVAC采用二进制，且是一台冯·诺伊曼结构的计算机) First Draft of a Report on the EDVAC by EngrToday ENIAC,电子数值积分计算机（Electronic Numerical Integrator And Computer）,简称为埃尼阿克,是世界上第一台通用计算机。它是图灵完全的电子计算机，能够重新编程，解决各种计算问题 和历史上的 牛顿，戴维，约瑟夫·汤姆森，威廉·汤姆森(开尔文勋爵)，弗莱明， 及后来的 蒂姆·伯纳斯-李一样，获封爵士 Richard Hamming 汉明码（利用汉明矩阵），汉明窗，汉明数，球面堆积（或汉明界）和汉明距离.. 1968年图灵奖得主贡献领域: 数值方法，自动编码系统，错误检测和纠错码 理查德·汉明，1915年2月11日生于 伊利诺伊州芝加哥市， 1998年1月7日逝世于加州蒙特雷 美国数学家，博士论文为《一些线性微分方程边界值理论上的问题》。主要贡献在计算机科学 美国电脑协会（ACM）的创立人之一，曾任该组织的主席 参见 海明校验码 IEEE 理查德·卫斯里·汉明奖章（IEEE Richard W. Hamming Medal）每年颁发，最多颁给三个人，以表彰在资讯科学、资讯系统和资讯技术方面取得的杰出成就。 获奖者可获得一面金牌奖章、铜制复制品、获奖证书和一笔奖金。该奖项由电机电子工程师学会（IEEE）于1986年设立，并由高通公司赞助。以 理查·卫斯里·汉明的名字来命名以纪念他在计算机科学和电信产生的深远影响。 他的贡献包括发明汉明码和纠错码等, 也是该奖首位得主(1988年) 汉明问题 Erasure-Code: 工作原理, 数学解释, 实践和分析 在Linux，Go等项目中，多处可见其名 Marvin Minsky “人工智能之父” 1969年图灵奖得主贡献领域: 人工智能 计算机逻辑奠基者艾伦·麦席森·图灵、提出“人工智能”概念的约翰·麦卡锡、首个创建Snare的马文·明斯、将科技与教育融合的西摩尔·帕普特四人常常被称为人工智能之父 马文·明斯基(1927年8月9日－2016年1月24日)，生于美国纽约犹太人家庭 与西摩尔·派普特共同发展了第一个以Logo语言建构的机器人，命名为海龟（Turtle） 1951年，设计并建构了第一部能自我学习的人工神经网络机器，SNARC 1952年，发明会自行关闭电源的无用机器(Useless Machine) 1956年，与约翰·麦卡锡组织了达特茅斯会议，在这场会议中，人工智能的概念被提出，在之后形成了一个新的学门。 在麻省理工学院，与约翰·麦卡锡共同创立了人工智能研究室（MIT计算机科学与人工智能实验室的前身） 奠定了人工神经网络的研究基础 获得图灵奖的犹太风云人物（上） James Wilkinson “for his research in numerical analysis to facilitate the use of the high-speed digital computer, having received special recognition for his work in computations in linear algebra and ‘backward’ error analysis.” 1969年图灵奖得主贡献领域: 数值分析，线性代数，倒退错误分析 詹姆斯·威尔金森(1919—1986),英国皇家学会会员、著名数值分析专家，在建造由图灵设计的ACE计算机中扮演了举足轻重甚至最关键的角色 大学就读于剑桥大学三一学院，二战爆发后，开始研究弹道学。 1946年进入英国最著名的学术机构之一---英国国家物理实验室（NPL）数学部. 一开始协助图灵设计计算机 Pilot ACE。图灵离开NPL后，其接手整个项目，并使Pilot ACE于1950年5月10日，第一次正式试运行成功。 当时ACE成功演示了三个程序：由参观者任意给出一个6位数，机器判定它是否是素数，如果不是素数，给出其一个因子；由参观者任意说出0—9999年中的任意一个日期，由机器给出这天是星期几；由机器跟踪光线通过一组棱镜后的偏振光 为NPL服务长达34年，直至1980年退休 组织开发过一个用以测试系统浮点运算能力的基准程序(Benchmark),叫Whetstone 1991年设立了以他命名的威尔金森奖，用于表彰优秀的数值分析软件作者 John McCarthy “人工智能之父” 1971年图灵奖得主贡献领域: Lisp语言, 人工智能 约翰·麦卡锡,1927年9月4日生于美国波士顿, 2011年10月24日去世,终年84岁. 人工智能先驱人物篇之约翰·麦卡锡 不走寻常路的编程语言大家 Dijkstra “计算机领域的欧拉”(爽哥评注) 1972年图灵奖得主贡献领域: Dijkstra算法,银行家算法,信号量,PV原语 中文一般译作”迪杰斯特拉”,1930年出生于鹿特丹,大学就读于莱顿大学,研究理论物理学. 但他很快就发现自己的兴趣是计算机科学. 2002年在荷兰家中逝世,终年72岁. Charles Bachman “网状数据库之父”，数据库领域第一位图灵奖得主 1973年图灵奖得主贡献领域: 数据库技术 中文一般译作”查尔斯·巴赫曼”(1924年11月11日－2017年7月13日) 1924年生于堪萨斯州曼哈顿 二战爆发后，加入美国陆军防空高炮师；1944年3月至1946年2月，在西南太平洋战场，到过新几内亚，澳大利亚和菲律宾群岛等地。 之后，离开军队，进入密歇根州立大学和宾夕法尼亚大学学习 第一个没有博士学位的图灵奖获得者，第一个工程学背景而不是科学背景的图灵奖，第一个因某个特定的软件而得图灵奖的得主，第一个在职业生涯完全在企业度过，而未在大学担任教职的图灵奖获得者。 职业生涯主要经历陶氏化工，通用电气，Honeywell，而后创办了自己的公司---巴赫曼信息系统公司。 主要成就有两项： 在通用电气时，开发出了最早的网状数据库管理系统---IDS。其设计思想和实现技术，被后来很多数据库产品所效仿。（第二位数据库领域的图灵奖得主，关系型数据库之父，英国人 Edgar Codd，则是在IBM工作期间，首创了关系模型理论；有意思的是也参加过二战，在英国空军服役，当过3年机长，参加过多次空战..也是战争结束后，继续学业） 另外其积极推动与促进数据库标准的制定，包括DBTC和DDL，DML DBA概念即其首次提出 缅怀数据库之父——查尔斯·巴赫曼 中国未来需要什么样的数据库？ | CNCC 2019 整理 | 数据库领域的杰出人物 50年长盛不衰，SQL为什么如此成功？ Donald Knuth “程序设计引路人” 1974年图灵奖得主贡献领域: 算法分析、程序设计语言的设计、程序设计 36岁获奖, 至今仍保持着图灵奖最年轻获奖者的纪录. KMP算法中的”K” 是Knuth独特的审美感决定了他兴趣广泛、富有多方面造诣的特点。Knuth传奇般的生产力也是源于这一点。对于Knuth来说，衡量一个计算机程序是否完整的标准不只在于它是否可以执行，他觉得一个计算机程序应该是雅致的、甚至可以说是美的。计算机程序设计应该是一门艺术，一个算法应该像一段音乐，而一个好的程序应该如一部文学作品一般。 估计国内的老板们不会喜欢… 尝试使用过LaTeX，且写过一篇博客，但在初次使用时还不知道TeX竟是 Donald 牛刀小作。 TeX的版本号不是惯常所见的1.0，1.1…，2.0，而是用圆周率π，每个版本向下一位。现在版本号为3.1415926。 大师还有一项“创举”，每发现一个bug，就“奖励”2.56美元，第二个5.12美元，第三个10.24美元，以此类推——考虑到“象棋发明”的那个讲述指数爆炸型增长的故事，这无疑需要强大的勇气与自信。 但事实是，他并没有为此付出太多美刀。一是错误极少趋于完美;二则如同当下将持有伯克希尔哈撒韦公司股票作为财富象征，许多更“高级”的人，将持有高德纳签名的支票视若珍宝，作为智力超群的佐证。时有说法:什么是聪明？找出Knuth的错误;什么是愚蠢？去兑换那张两块五毛六的支票。 甚至设立了高德纳奖，首届得主是姚期智 (在计算机领域，名字可以作为奖项名称的，还有图灵奖/冯诺依曼奖/汉明奖) 参考: 计算机大师-Donald Knuth（高德纳） 的传奇 关于大师的著作,&lt;计算机程序设计艺术&gt;,参见: 那些有简称的计算机书籍 Allen Newell &amp; Herbert Simon “人工智能之父”(举世公认的人工智能之父有四位，前两位之前已经获奖) 1975年图灵奖得主贡献领域: 人工智能，人类认知心理学和列表处理（list processing） 中文一般译作”艾伦·纽厄尔”(1927年3月19日－1992年7月19日)。 1927年3月19日生于旧金山，其父是斯坦福医学院放射学教授，精通物理和古典文学，会约鱼/淘金/做木工，甚至在山上亲手盖了一座小木屋。其对父亲十分崇拜，称是“一个十全十美的知识分子”。 二战期间在海军服预备役两年。战后进入斯坦福大学学习物理，1949年获得学士学位。之后在普林斯顿大学研究生院攻读数学，一年以后辍学到RAND公司工作 和CMU的西蒙建立合作关系，提出“中间结分析法”作为求解人工智能问题的一种技术。利用这种技术，二人成功开发最早的启发式程序“逻辑理论家”和“通用问题求解器”。在开发逻辑理论家的过程中，首次提出并成功应用了单链表作为基本的数据结构，并设计与实现了 信息处理语言IPL（Information Processing Language）。IPL是所有表处理语言的始祖，也是最早使用递归子程序的语言。 合作过程中其所表现出的才能与创新精神深得西蒙赞赏，在西蒙竭力推荐下，得以在CMU注册为研究生，并在西蒙指导下完成博士论文，于1957年获得博士学位。 中文一般译作”赫伯特·西蒙”(1916年6月15日－2001年2月9日)。1916年6月15日生于威斯康辛州米尔沃尔一户富裕的犹太家庭，其父在1903年从德国移居美国。 1933年 进入芝加哥大学政治系学习; 1949年 在CMU的经济管理研究生院任教,其一生中最辉煌成就多是在这里做出。 1956年夏天 数十名来自数学、心理学、神经学、计算机科学与电气工程等各种领域的学者聚集在位于新罕布什尔州汉诺威市的达特茅斯学院，讨论如何用计算机模拟人的智能，并根据麦卡锡的建议，正式把这一学科领域命名为“人工智能”。因此，西蒙、纽厄尔以及达特茅斯会议的发起人麦卡锡和明斯基被公认为是人工智能的奠基人，被称为“人工智能之父” 当时的部分与会人员： 是20世纪一位奇特通才，学识渊博、兴趣广泛，研究涉及经济学、政治学、管理学、社会学、心理学、运筹学、计算机科学、认知科学、人工智能等广大领域,并做出了创造性贡献. 具有传奇般的经历。会画画，会弹钢琴，既爱爬山、旅行，又爱学习各种外国语，能流利地说多种外语。作为科学家，涉足的领域之多，成果之丰，影响之深远，令人叹为观止。 1972年他参与中美建交，花甲之年开始学习汉语，并取汉名“司马贺”。痴迷于汉语与书法 20世纪70年代中期，研究住宅的自动空间综合取得巨大的进展，成为了智能建筑之父。与此同时开发智能版CAD即ICAD，成为ICAD奠基人 直到2018年，都是计算机领域论文被引用次数最高的计算机科学家 (更多可参考2018全球Top 1000 计算机科学家h指数发布，中国29名学者上榜！) 获得过9个博士头衔：1943年的加利福尼亚大学哲学博士学位、1963年凯斯工学院科学博士学位、1963年耶鲁大学科学博士学位、1963年法学博士学位、1968年瑞典伦德大学哲学博士学位、1970年麦吉尔大学法学博士、1973年鹿特丹伊拉斯莫斯大学经济学博士、 1978年米之根大学法学博士、1979年匹茨堡大学法学博士。 此外还是1978年诺贝尔经济学奖得主，也是唯一一位诺贝尔奖/图灵奖双料得主。。瑞典皇家科学院总结性地指出：“就经济学最广泛的意义上来说，西蒙首先是一名经济学家，他的名字主要是与经济组织中的结构和决策这一相当新的经济研究领域联系在一起的。” &nbsp; &nbsp; The Sveriges Riksbank Prize in Economic Sciences in Memory of Alfred Nobel 1978 和艾伦·纽厄尔(Allen Newell)曾是师生，后成为极其亲密的合作者，共事长达42年，直至纽厄尔于1992年去世。1975年二人同时获奖，是图灵奖历史上首次同时授予两位学者。 拒绝边界，永远好奇 其自画像： “我诚然是一个科学家，但是是许多学科的科学家。我曾经在许多科学迷宫中探索，这些迷宫并未连成一体。我的抱负未能扩大到如此程度，使我的一生有连贯性。我扮演了许多不同角色，角色之间有时难免互相借用。但我对我所扮演的每一种角色都是尽了力的，从而是有信誉的，这也就足够了”。—1991年出版的自传《我的生活的模型》 走过半个世纪的图灵奖和摘得桂冠的AI大师们 62年前，“人工智能”这个词诞生于小镇上的一所大学，科学大咖谈论一个不食人间烟火的主题，AI元年由此开启… 同拿诺贝尔经济学奖和计算机图灵奖的司马贺之彪悍人生 Michael Rabin 1976年图灵奖得主贡献领域: 非确定性自动机, 拉宾-卡普算法 中文一般译作”迈克尔·拉宾”,1931年出生于德国布雷斯劳（二战后成为波兰弗罗茨瓦夫). 以色列计算机科学家,犹太人. 1956年获普林斯顿大学博士学位. 1959年，拉宾和达纳·斯科特共同发表了“有限自动机与其判定性问题”（Finite Automata and Their Decision Problems）的论文,提出非确定自动机的观点.他们也因此获得了1976年的图灵奖，并做“计算机复杂性”（Complexity of Computations）的演讲 1969年, 证明 N successors的二阶逻辑是可判定的.证明的关键部分暗示了奇偶游戏的确定性 1975年, 发明米勒-拉宾检验. 这是一个相当快速的随机化算法（有较小的可能性错误）,用于判断一个大数是否是素数. 快速素数检验是目前大部分公钥密码体系的关键. 1979年, 发明第一个非对称密码系统--- 拉宾密码系统,它的安全性被证明和整数因式分解的复杂度相同. 1981年, 提出不经意传输技术 1987年, 和理查德·卡普提出了著名的字符串搜索算法—— 拉宾-卡普算法 1976年获奖后,依然成果不断… Dana Scott 1976年图灵奖得主贡献领域: 非确定性自动机 中文一般译作”达纳·斯科特”,1932年出生于美国加利福尼亚州. 图灵奖的引文是：“因他们的合著论文“有限自动机与其判定性问题”。论文中引入了非确定自动机的概念，被证明是（计算理论科学研究中的）一个非常重要的概念。拉宾和斯科特的这篇经典论文成为了这个领域后续研究的源泉 John Backus 1977年图灵奖得主贡献领域: 高级编程系统，程序设计语言规范的形式化定义 FORTRAN 巴科斯范式 函数级编程 中文一般译作”约翰·巴科斯”,1924年12月3日出生于美国宾州费城，青少年时期平时不爱读书，勉强毕业，没什么过人之处。 后对数学产生极大兴趣,进入IBM工作。 获图灵奖时发表“程序设计能从冯诺伊曼形式中解脱出来吗？函数式风格及其程序的代数”（Can Programming be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs）演说，提出了叫做FP的函数级编程语言(这篇演说有时被看作是他为发明了Fortran而致歉) 2007年3月17日在美国俄勒冈州的家中去世，享年82岁 Fortran，音译为”福传”，源自于“公式翻译”（Formula Translation）的缩写，是一种编程语言。1957年由IBM开发出，是世界上第一个被正式采用并流传至今的高级编程语言。是为满足数值计算的需求而发展出，1953年12月，IBM工程师约翰·巴科斯（J. Backus）因深深体会编写程序很困难，而写了一份备忘录给董事长斯伯特·赫德（Cuthbert Hurd），建议为IBM704系统设计全新的电脑语言以提升开发效率。当时IBM公司的顾问冯·诺伊曼强烈反对，因为他认为不切实际而且根本不必要。但赫德批准了这项计划。西屋电气公司成为FORTRAN的第一个商业用户 【冷知识】基于ABNF重新学习HTTP报文格式 BNF rules of JAVA The syntax is specified using Extended Backus-Naur Form (EBNF): Robert W. Floyd 1978年图灵奖得主贡献领域: Floyd算法, 堆结构及堆排序 弗洛伊德（1936年6月8日－2001年9月25日）,美国计算机科学家, 出生于美国纽约,14岁即完成高中学业. 1953年从芝加哥大学获得文学学士学位，年仅17岁，并于1958年在物理学获得了第二个学士学位 与高德纳工作很密切,是其著作《计算机程序设计艺术》的主要评审,并在书中被多次提及. 最初文学专业毕业，找不到合适工作，在西屋电气做基础到几乎对候选人没什么要求的“计算机操作员”工作(类似打字机打字员，并不需要懂得机器怎么运作，在外面负责敲两下就可以)，决心搞清背后运作原理。 开发了世界上最早的Algol 60编译器之一。堆排序算法和弗洛伊德算法。发表“如何确定程序的意义（Assigning Meanings to Programs）”的学术论文，在当时的计算机界引起巨大轰动。该论文后来被公认为继麦卡锡1963年提出的“以递归函数作为程序模型的方法”后，最为重大的一项进展。 42岁获图灵奖 证明了整个计算机界对他的认可，证明了这个来自纽约的文科生，因为热爱计算机领域，即使通过自学，也能达成影响世界的伟大成就 从14岁上大学的文科生，到拿图灵奖的计算机教授，写在罗伯特·弗洛伊德85周年诞辰 Kenneth Iverson 1979年图灵奖得主贡献领域: 程序设计语言和数学符号，互动系统的设计，APL语言之父，程序设计语言的理论与实践 中文一般译作”肯尼斯·艾弗森”（1920年12月17日-2004年10月19日） APL语言之父，后来还设计了J语言 APL 是 A Programming Language 或 Array Processing Language 的缩写。肯尼斯·艾佛森在1962年设计这个语言时他正在哈佛大学工作, 是一种表达能力很强的会话语言。应用范围包括数学统计、事务经营、信息检索、报表生成、财务预算等。也可用于模拟计划管理、图形处理、正文编辑、计算机辅助教学等方面。APL的特点是，语法规则简单，运算符丰富，表达式简练，并包含多种构造和处理数据的运算符。它在数据加工和矩阵计算上特别有效，不过程序员需具有较高的数学素养 Tony Hoare “计算机领域的爵士” 1980年图灵奖得主贡献领域: 快速排序,CSP理论,哲学家就餐问题 1934年出生于英属锡兰(今斯里兰卡)，1959年博士毕业于俄罗斯莫斯科国立大学 1960年，霍尔进入艾略特兄弟（Elliott Brothers Ltd) 伦敦公司，成为一名程序员。他接到的第一个任务，就是为Elliott 803计算机编写一个库程序，实现新发明出来的Shell排序算法。在此过程中，霍尔对不断提升代码的效率着了迷。他不仅很好地完成了任务，还发明了一种新算法，比Shell还快，而且不会多耗费太多空间。这就是后来闻名于世的快速排序算法Quicksort。值得一提的是，发明该算法时他只有26岁。随后，霍尔又接到了新任务——在公司新机型Elliott 503上实现Algol 60语言。Elliott Algol的开发非常顺利，大获成功，霍尔本人也从此受到国际学术界的重视。当然，对他来说，另一件事情更为重要，他和项目中另一位当时比自己更专业的女程序员Jill Pym相识相知，并最后结婚。 1971年，Dijkstra提出了一个同步问题，即假设有五台计算机都试图访问五份共享的磁带驱动器。稍后，这个问题被Tony Hoare重新表述为哲学家就餐问题。这个问题可以用来解释死锁和资源耗尽。 希尔排序于1959年被D.L.Shell提出,第二年Tony Hoare就提出了更优的快速排序.. 排序算法汇总 快速排序 读「Go语言并发之道」 过早优化的谬误 改变世界的十位算法大师 Edgar Frank Codd “关系型数据库之父” 1981年图灵奖得主贡献领域: 数据库系统 埃德加·弗兰克·科德，(1923年8月23-2003年4月18) 生于英格兰多塞特郡波特兰,牛津埃克塞特学院学习数学与化学, 而后作为英国皇家空军飞行员参加二次世界大战 1948年，来到纽约加入IBM，成为一名数学程序员。之后到密歇根大学取得计算机科学博士学位 在IBM工作期间，首创了关系模型理论。为关系型数据库理论做出了奠基性的贡献。 科德十二定律（Codd’s 12 rules）使数据库管理系统关系化需满足的十三条（从0至12）准则,又称为“黄金十二定律”sql1972年，IBM以科德所在的加州圣何塞研究院为中心，想要开发一套关系数据库的原型产品。加入该项目的有两个年轻的博士生，张伯伦和博伊斯。他们决定把科德关系模型中的数学部分隐藏起来，将关系称为表，把复杂的数学符号替换成简单的英语单词 SELECT FROM WHERE。本来想把这门语言叫做 SEQUEL(Structured English Query Language，结构化英语查询语言）。由于SEQUEL已是一家英国公司商标，二人将其改名为更简单，更容易记忆的SQL。不多久后博伊斯因脑瘤去世，年仅27岁。27岁发明SQL以后，上帝把他带走了 BCNF范式博伊斯还和科德合作，建立了一个数据库中必讲的概念：BCNF范式数据库第一二三范式到底在说什么？数据库设计三大范式 Codd发表在「ACM通讯」上的关系型数据理论的学术论文启发了Larry Ellison，他1979年创建Relational Software Inc（简称RSI，1983年更名为Oracle Corporation) SQL数据库软件的历史沿革: ​1992年IT近代史 ｜ 改变世界的25人（四）—— 数据库软件之父 1993 年，70岁的Codd 认为 OLTP（联机事务处理）不足以满足用户的需要，提出了多维数据库和多维分析的概念，即OLAP（联机分析处理） 计算机先驱诞生日；万维网面世 30 周年|历史上的今天 从空军机长到大厂程序员，关系数据库之父传奇 Stephen Arthur Cook 1982年图灵奖得主贡献领域: 计算复杂度理论,NP完全性理论 斯蒂芬·亚瑟·库克，1939年12月14日生于纽约州布法罗，1961年从University of Michigan获得学士学位，1962年和1966年从哈佛大学获硕士与博士学位。 1966-1970年，在加州伯克利担任助理教授。 1970年，加盟多伦多大学并工作直到现在。 NP完全性理论的奠基人，1971年发表Cook定理，奠定了NP完全理论的基础而获1982年图灵奖。 但其论文只证明了命题演算的可满足行问题是NP完全的，没有继续深入证明下去。 但在此启发下，卡普在第二年就证明了21个有关组合优化的NP完全问题，从而加强发展了NP完全性理论。 Cook是对计算复杂性理论有突出贡献的计算机科学家之一(1971年 Cook 和 Leonid Levin 相对独立的提出了P/NP问题) 计算复杂度理论和编译理论，是诞生图灵奖得主最多的两个领域 Stephen A. Cook–多伦多大学个人页 Ken &amp; Dmr 1983年图灵奖得主贡献领域: UNIX操作系统和C语言 Write in C 123456789101112131415161718192021222324252627282930WRITE IN C ('LET IT BE')When I find my code in tons of trouble,Friends and colleagues come to me,Speaking words of wisdom:\"Write in C.\"As the deadline fast approaches,And bugs are all that I can see,Somewhere, someone whispers:\"Write in C.\"Write in C, Write in C,Write in C, oh, Write in C.LOGO's dead and buried,Write in C.I used to write a lot of FORTRAN,For science it worked flawlessly.Try using it for graphics!Write in C.If you've just spent nearly 30 hours,Debugging some assembly,Soon you will be glad toWrite in C.Write in C, Write in C,Write in C, yeah, Write in C.BASIC's not the answer.Write in C.Write in C, Write in CWrite in C, oh, Write in C.Pascal won't quite cut it.Write in C. Niklaus Wirth “Pascal语言之父” 1984年图灵奖得主贡献领域: 程序设计语言设计、程序设计 中文一般译作”尼克劳斯·维尔特”,1934年出生于瑞士 好几种编程语言的主设计师： Algol W (基于与东尼·霍尔共同提出的草案而设计) Modula,Modula-2 Pascal Oberon 尼克劳斯·维尔特 的姓名曾以不准确的英文读法，被译为“尼古拉斯·沃斯”。欧洲人通常都将他的名字读得正确，读作“Nih-klaus Virt”；但美国人通常读成“Nickel’s Worth”近似的音。于是有人便开玩笑说，欧洲人用传址调用(Call by Address)叫他，美国人用传值调用(Call by Value)叫他（“传值调用”英文双关“按照价值称呼”，而“Nickel’s Worth”中文意为“价值一分钱”） “软件变慢的速度永远快过硬件变快的速度” Richard Karp 1985年图灵奖得主贡献领域: 算法理论(尤其是NP-完全性理论), 拉宾-卡普算法 中文一般译作”理查德·卡普”,1935年出生于波士顿 1955年先获得哈佛大学文学学士学位,第二年又获得理科硕士学位.之后进入哈佛大学的计算机实验室攻读博士.毕业后进入IBM. 主要研究领域：路径问题、背包问题、覆盖问题、匹配问题、分区问题、调度问题，并取得了许多成果. 这些问题有一个共同的特点:即如果图上增加一个节点,计算机就会爆炸. 在解决“旅行推销商”问题时,提出 分支限界法, 是一种构造性的探索法,可在整个允许的解空间中进行最优搜索.(该方法的要点是：对解集合反复进行分支,每次分支时,都对所得的子集计算最优解的界. 如果对某个子集求得的界不优于已知的允许解,则抛弃此子集不再进行分支;否则继续分支以探索更好的解,直到所得到的子集仅含有一个解为止) 卡普的二十一个NP-完全问题 John Edward Hopcroft &amp; Robert Endre Tarjan 1986年图灵奖得主贡献领域: 算法和数据结构的设计与分析，如 深度优先搜索算法 中文一般译作”约翰·霍普克罗夫特”,”罗伯特·塔扬”。二人发明用于遍历或搜索树或图的深度优先搜索算法（Depth-First-Search，DFS）。 Hopcroft-Tarjan平面嵌入算法是第一个线性时间平面算法 约翰·霍普克罗夫特,1939年10月7日生于西雅图,1961年在西雅图大学获电子工程学士学位,1962、1964年在斯坦福大学分别获电子工程硕士和博士学位。 目前在国内多所高校任顾问等 同时也与2020年图灵奖得主Alfred Aho及Jeffrey David Ullman合著大量计算机科学领域的参考书，包括算法、数据结构以及计算机科学基础 霍普克罗夫特“教”出了两位图灵奖得主：1986年与他同获图灵奖的罗伯特·塔扬，是其在斯坦福大学学术休假期间指导的博士生；2020年图灵奖得主、“龙书”（编译原理课程的经典教材）作者之一阿尔弗雷德·阿霍则是他在普林斯顿大学任教期间指导的第一位博士生。 获图灵奖的师生，还有这样几对: 一门三杰：约翰·麦卡锡及罗杰·瑞迪（Raj Reddy），芭芭拉·丽兹科（Barbara Liskov） 1975年获图灵奖的赫伯特·西蒙（Herbert Alexander Simon）和艾伦·纽厄尔（Allen Newell）（前者还是诺贝尔经济奖得主） 1986年图灵奖得主约翰·霍普克罗夫特（John Hopcroft）和罗伯特·塔扬（Robert E. Tarjan） 2007年获奖的爱德蒙·克拉克（Edmund M. Clarke）和艾伦·艾默生（Allen Emerson）（前者于2020年因新冠肺炎去世） 更多参见 图灵的遗产和后继者们的责任 罗伯特·塔扬，1948年4月30日生于加州波莫纳。 Tarjan也开创了重要的数据结构如：斐波纳契堆和splay树（splay发明者还有Daniel Sleator） Splay Tree即伸展树， 是一种能够自我平衡的二叉查找树，由丹尼尔·斯立特（Daniel Sleator）和罗伯特·塔扬在1985年发明更多参见 常见的树某项算法的提出者，某个数据结构的创造者 另外他是第一个证明了计算反阿克曼函数的乐观时间复杂度的科学家 图灵奖得主约翰•霍普克罗夫特：中国高校过于看重国际声望，应更关注本科教学质量 上海交通大学约翰·霍普克罗夫特计算机科学中心 约翰·霍普克罗夫特 | 图灵奖获得者 追逐人生的下半场：人类教育 John Cocke “RISC架构之父” 1987年图灵奖得主贡献领域: 编译理论,大型系统的体系结构,精简指令集（RISC）计算机的开发,CYK算法 约翰·科克, 1925年5月30日生于美国北卡罗来纳州夏洛特, 2002年7月16日去世,终年79岁. IBM-RISC Architecture A.M. TURING AWARD WINNERS Transcript Ivan Edward Sutherland “计算机图形学之父”, “虚拟现实之父” 1988年图灵奖得主贡献领域: 计算机图形学 伊凡·爱德华·苏泽兰（1938年5月16日－），生于生于美国内布拉斯加州。于卡内基技术学院（今卡内基梅隆大学）取得学士学位，于加州理工学院取得硕士。1963年，于麻省理工学院取得计算机工程博士学位。 在博士论文中设计了一个叫Sketchpad的程序，用户可以利用当时刚被发明出来的光电笔在屏幕上实时绘图。Sketchpad在许多方面都具有开创性的地位,被认为是现代计算机辅助设计（CAD）和图形用户界面（GUI）的鼻祖，为了管理图形提出了面向对象编程的概念 图片来自 中国的高校计算机教育存在哪些问题？ 1965年在一篇名为&lt;终极的显示&gt;的论文中首次提出虚拟现实系统的基本思想.1968年发明了第一款VR头盔——“达摩克利斯之剑”,被称为 虚拟现实之父 (后来Jaron Lanier的VPL Research公司是第一家将VR设备推向民用市场的公司，因此也被称为”虚拟现实之父“) 参考: VR凭什么能火爆全球？诞生了85年，它究竟经历了什么… 论有趣，你不得不服这几个严肃的科学家 改变世界的先驱，是他在50年前真正定义了计算机图形学和人机共生关系 “终极显示”与“快乐人生” William Morton Kahan “浮点数之父” 1989年图灵奖得主贡献领域: 浮点数表示 威廉·墨顿·卡韩（1933年6月5日－），生于加拿大安大略多伦多，数学与计算机科学家，专长于数值分析。1989年图灵奖得主，1994年被提名为ACM院士。现为加州大学伯克利分校 计算机科学名誉教授。卡韩是IEEE 754-1985浮点数运算架构规格书的主要架构师，IEEE 754 系列的标准主要依据他的研究而制定，因此被称为浮点数之父 参考: Go源码分析之浮点型处理 William Kahan Fernando José Corbató 1990年图灵奖得主贡献领域: 分时操作系统 中文一般译作”费尔南多·考巴托” 更多参考: 星陨-2019 Robin Milner 1991年图灵奖得主贡献领域: LCF、ML编程语言、并发理论(CCS) 中文一般译作”罗宾·米尔纳”, 1934年1月13日－2010年3月20日 生于英国，曾入伍并获少尉军衔。1952年入读剑桥大学国王学院(1954年毕业于国王学院的图灵自杀)，但当时他没听说过图灵。 1991年获图灵奖，是继威尔克斯（M.V.Wilkes, 1967）、威尔金森（J.H.Wilkinson, 1970）和霍尔（C.ARHoare, 1980）之后第四位获此殊荣的英国计算机科学家，也使英国成为除美国之外获得图灵奖的学者最多的国 他说自己从不喜欢编程.. 可计算功能的逻辑 (LCF）是其及其合作者在1970年代初期根据逻辑的理论基础在斯坦福和爱丁堡开发的一种交互式自动定理证明器。 引入了通用编程语言ML，以允许用户编写证明定理的策略，支持代数数据类型，参数多态性，抽象数据类型和异常 罗宾·米尔纳——标准元语言ML发明者 罗宾·米尔纳 Butler Lampson 1992年图灵奖得主贡献领域: 分布式，个人计算机 中文一般译作”巴特勒·兰普森”, 1943年12月23日生于华盛顿特区 1970年，成为PARC研究中心最早一批员工，属于其中的计算机科学实验室（Computer Science Laboratory）。1972年，在一份备忘录中，首次提出个人电脑设计概念。 Alto是PARC在20世纪60年代末70年代初设计与开发的世界上第一个个人计算机系统，1973年完成并正式投入运行。 是当时最先进的计算机系统 另外还有著作 《分布式系统–体系结构和实现：高级课程》 有句著名格言，常被认为由其提出。但其本人则认为这格言最早出自于David Wheeler： Any problem in computer science can be solved with another level of indirection (在计算机科学中的任何问题，都可以用加上另一层间接参照来解决) 另：企业界的 PC之父/个人电脑奠基人当属 亨利·罗伯茨, 也是让比尔盖茨唯一打过工的人 巴特勒·兰普森——Alto系统首席科学家 Juris Hartmanis &amp; Richard Stearns 1993年图灵奖得主贡献领域: 计算复杂度理论 中文一般译作”尤里斯·哈特马尼斯”，1928年7月7日生于拉脱维亚。二战期间，躲避战火，一家人背井离乡沦为“流民”(displaced person)。在德国，完成大学学习物理。而后在美国完成硕士/博士，研究抽象代数中的格论。 毕业后在康奈尔大学数学系任教。一年后去通用电气的实验室，和来此实习的斯特恩斯合作，完成那篇著名的论文 “论算法的计算复杂性”(On the computational complexity Of algorithms）。 该论文开辟了计算机科学的一个新的研究领域，即“计算复杂性”，并奠定了其理论基础。 而后重返康乃尔大学，没有回到数学系，而是负责筹建计算机科学系。由于其眼光魄力和民主作风，康乃尔大学计算机科学系吸引了一批著名学者加盟，如1986年图灵奖得主霍普克洛夫特 中文一般译作”理查德·斯特恩斯”，1936年7月5日生于新泽西州考德威尔。 1960年夏天在位于纽约州东部的斯克内克塔迪 通用电气研究实验室，和尤里斯·哈特马尼斯开始一起研究状态指定问题。在1961年获得博士学位后，加入通用电气研究实验室的信息学习分支。在研究实验室的气氛和环境鼓励了他们所热爱的自由的、不受约束的研究方式。 和哈特马尼斯一开始在进行线性机器的分解方面的工作：简单电脑的模型如何能被分解成一些更小的线性机器的结合，且能完成相同的任务。关于这个主题发表了一些论文，并在1966年将他们的工作总结写入了一本书。后来他们开始研究计算复杂性，并在1965年发表了那篇让他们获得图灵奖的论文。 之后还研究过编译器设计原理，并发数据库系统，归约相关问题，和积问题，动态系统方面的问题 在这种数据库中会有一些事务在同一个数据库中进行读和写操作。这种系统的目标之一是让事务尽可能并发地执行以增加系统的输出，但同时不会破坏数据库的正确性。他们写的关于这个主题的论文指出并发执行的一致性和正确性的充分必要条件是事务的可串行性——它指的是，所有并发运行事务的读写操作的影响必须和他们在某种顺序下串行运行（一个接一个）一样。在这之前已经知道可串行性是一致性的充分条件：如果执行时可串行的，结果就是对的。这篇论文指出除去一些特定的只有读操作的事务的情况，这也是一个必要条件：执行必须要可串行化才能保证正确。这个结论现在已经是所有数据库课程和数据库系统设计的核心部分 Edward Feigenbaum &amp; Raj Reddy 1994年图灵奖得主贡献领域: 大规模人工智能系统 中文一般译作”爱德华·费根鲍姆”，1936年1月20日生于新泽西州维霍肯，经常被人称为专家系统之父。 斯坦福大学计算机科学系任教授，美国空军首席科学家。 其父是波兰移民，在他不到一岁就去世了。他的继父是一位食品商店会计，使用了笨拙的机电式蒙特卡洛计算器（发明于20世纪初），引起了年轻的费根鲍姆的好奇和兴趣 1956年在卡内基技术学院（卡内基梅隆大学前身）取得学士学位，1960年取得博士学位，指导教授为赫伯特·西蒙（即“司马贺”，1975年图灵奖得主，1978年诺贝尔经济学奖得主）。 通过实验和研究，证明了实现智能行为的主要手段在于知识，在多数实际情况下是特定领域的知识。 他有句名言：”知识中蕴藏着力量”（In the Knowledge lies the power）。这句话和培根的名言”知识就是力量”意义相近，但似乎更确切些：知识只有被人所发掘和掌握时，才能生成力量。 中文一般译作”拉吉·瑞迪”，1937年出生于印度中南部安得拉邦。是获得图灵奖的亚洲第一人。(亚洲第一位获诺贝尔奖，第一位获诺贝尔科学奖的也都是印度人…) 现任卡内基·梅隆大学计算机学院院长 在斯坦福大学攻读博士学位时，导师是有”人工智能之父”之称的J.McCarthy。另一位人工智能大师M.Minsky当时也在斯坦福，Raj曾聆听过其教导。学成后来到卡内基梅隆大学工作，有幸与艾伦·纽厄尔（A.Newell）和赫伯特·西蒙（H.A.Simon）这样一些知名学者一起共事。 1966年，ACM在洛杉矶举行仪式，向艾伦·佩利（A.Perlis）授予首届图灵奖。Raj作为斯坦福大学研究生参与了该仪式并十分激动。暗下决心，也要在发展计算机科学技术上做出贡献。28年后，当年的这位研究生也走上了图灵奖的颁奖台。 人工智能会给我们带来什么|人民日报 Manuel Blum 1995年图灵奖得主贡献领域: 计算复杂度理论，及其在密码学和程序校验上的应用 中文一般译作”曼纽尔·布卢姆”，1938年4月26日出生于委内瑞拉首都加拉加斯。其父母在20世纪30年代逃离欧洲后定居在那里。20世纪50年代中期来到美国，在麻省理工学院完成了本硕博，导师是 马文·明斯基 计算复杂性理论的主要奠基人之一，密码系统和程序检验领域的先驱 在其之前，已有5位学者因在计算复杂性理论方面的贡献而获图灵奖殊荣：拉宾（1976年）、库克（1982年）、卡普（1985年）、哈特马尼斯和（1993年）。在图灵奖34年历史上，这是获奖科学家最多的一个分支领域，由此可见计算复杂性作为基础性分支在计算机科学中的突出地位及其重要性 计算复杂性的研究始于20世纪50年代末60年代初，当时在美国有两个并行的中心:一个是通用电气公司设立于纽约州斯克内克塔迪（Schenectady）的研究实验室，核心人物是哈特马尼斯（J．Hartmanis）和斯特恩斯（R．Stearns）另一个中心是麻省理工学院，布卢姆与前述两人互相独立地进行着相关问题的研究，并完成了其博士论文：Amachiceindependenttheoryofthecomplexityofrecursivefunctions(与机器无关的递归函数复杂性的理论)，该论文的详细摘要1967年发表于J．ACM14（2），322～336页实际上布卢姆是受以色列学者拉宾（M.O.Rabin）的启发而开始这方面的研究。拉宾是希伯莱大学教授，是研究计算复杂性问题的先驱，并在1976年荣获图灵奖。拉宾在1959－1960年间就发表过一些关于计算复杂性方面的论文，可惜流传面较小影响不大。但MIT“ 慧眼识珠”，邀请他前来讲学。布卢姆当时正苦于没有适当的课题作博士论文，听了拉宾的讲座极感兴趣，当即决定沿此方向进行研究，其结果就是完成了上述博士论文。布卢姆的论文不但提出了有关计算复杂性的一些分理，而且在对复杂性类的归纳上也比其他学者有更高的抽象度。因此学术界公认，布、哈、斯三人是计算复杂性理论的主要奠基人。 布卢姆除了在计算复杂性理论方面作出了开创性贡献以外，还致力于将这一理论应用于对计算机系统的安全性和通信的安全性有十分重要意义的“密码学”以及在“软件工程”中十分重要而又十分困难的程序正确性验证方面，并且取得了令人瞩目的成就。 一家人和卡内基梅隆大学渊源颇深，Blum夫妇被誉为计算机领域的“居里夫妇 曼纽尔·布卢姆及其《迈向有意识的人工智能》的演讲 Amir Pnueli 1996年图灵奖得主贡献领域: 时序逻辑，程序与系统验证 中文一般译作”阿米尔·伯努利”，1941年4月22日－2009年11月2日。出生于以色列 研究领域主要是时间逻辑和模型检查，尤其是并发系统的公平性 例如Golang GPM调度模型中，M的作用就是执行G中包装的并发任务。Go运行时系统中的调度器的主要职责就是将G公平合理的安排到多个M上去执行 Go语言的并发模型 Douglas Engelbart 1997年图灵奖得主贡献领域: 互动计算，鼠标之父、图形用户界面的先驱 中文一般译作”道格拉斯·恩格尔巴特”，1925年1月30日－2013年7月2日。生于美国俄勒冈州的波特兰，瑞典人和挪威人后裔。 人机交互的先驱。其成立的小组发明了鼠标，开发了超文本系统、网络计算机及图形用户界面 James Nicholas Gray 1998年图灵奖得主贡献领域: 数据库与事务处理(ACID) 中文一般译作”詹姆斯·尼古拉·格雷”，1944年1月12－2007年1月28日。生于美国俄勒冈州的波特兰，瑞典人和挪威人后裔。 因对数据库和事务处理研究的开创性贡献以及系统实现中的技术领导地位而获图灵奖 (事务处理技术虽然诞生于数据库研究，但对于分布式系统，C/S架构中的数据管理与通信，对于容错和高可靠系统，同样有重要意义) 也是继 查尔斯·巴赫曼和埃德加·科德后，数据库领域第三位图灵奖得主。 在IBM期间，他参与和主持过IMS、System R、SQL／DS、DB2等项目的开发；在 Microsoft 工作期间，协助开发了 Virtual Earth 1983 年，ACID 一词首次出现。基于格雷的工作，安德烈亚斯·罗伊特（Andreas Reuter）和西奥·哈德尔（Theo Härder）第一次使用 ACID 来描述事务的特性，其中 A 代表 Atomicity（原子性），C 代表 Consistency（一致性），I 代表 Isolation（隔离性），D 代表 Durability（持久性）。ACID 是可靠事务系统必须具备的四个特性，而格雷在定义事务概念时，列了 ACD，但没有提到 I。格雷一生为几个主要的数据库和事务处理系统作出了贡献，他协助开发的 IBM System R 是 SQL 关系数据库的先驱，如今已成为全世界的标准。 格雷生性好水，是一位经验丰富的水手，拥有一艘 40 英尺的帆船。2007年，独自航向法拉隆群岛，打算撒散其母亲骨灰，1月28日，他的船失踪。2012年，在法律意义上被认定已经死亡 2008 年微软在威斯康星州麦迪逊开设了一个以吉姆·格雷命名的研究中心；每年，微软研究院都会向在数据密集型计算领域作出杰出贡献的研究人员颁发以格雷命名的 Jim Gray eScience 奖 Jim Gray在他的著名的论文“Why do computers stop and what can be done about it?”中首次提出了程序bug的类型，比如玻尔bug(Bohrbug)、 海森堡bug(Heisenbugs)等用著名科学家名称命名的bug。后来又出现了更多的bug类型你知道几个？ Bug 的类型大全与历史获图灵奖的三位数据库专家介绍.pptx Frederick Phillips 1999年图灵奖得主贡献领域: 计算机体系结构，操作系统，软件工程 中文一般译作”佛瑞德·布鲁克斯”，1931年4月19日出生于美国美国北卡罗来纳州德罕。 60年初在IBM主持开发过OS/360系统，被认为是IBM 360系统之父。 1965年，离开IBM，进入学界，任教于北卡罗莱纳大学教堂山分校，在此创立计算机工程学系。 同时著书立说，很多软件工程领域的黑话，如没有银弹，焦油坑 等就出自其作品，耳熟能详的包括： 《人月神话》 （The Mythical Man-Month: Essays on Software Engineering），著作，出版于1975年，被誉为软件项目管理领域的圣经 《没有银弹》（No Silver Bullet: Essence and Accidents of Software Engineering），论文，发表于1986年 《再论人月神话》 （The Mythical Man-Month: Revised Essays on Software Engineering），1995年重新发行《人月神话》纪念版，其中新增对《没有银弹》一文的评论和回应，以及4个额外的新章节。 人月（man-month）指的是“一个人要花几个月”才能完成软件开发的单位，通常用来评估一件软件项目的大小。但这个概念容易误把工作量和项目进度混为一谈，人月是个危险并很容易就遭到误解的迷思（myth），因为其假设人力和工时可以互换的。但系统不是单独的零件，生产零件可以计件，生产系统则不能计件。 他有很多经典语录，如： “无论多少个女人，孕育一个生命也需要九个月。”（人力和时间并不呈现线性关系（正比或反比关系），指出以大量人员的投入并不能缩短软件的开发的进度。一窝蜂的作业方式无助于软件生产，且会制造麻烦，产生出更差的软件） “布鲁克斯定律”：从人月神话更进一步，其又引出著名的“布鲁克斯定律”：“向一个延误滞后的IT项目追加人力，只会使进度更加落后，导致更严重的延误。” 10x（10倍效率）程序员：在普通设计师（程序员）和优秀设计师（程序员）之间，有着10倍多的差异 项目经理的主要日常工作是沟通，而不是做出决定。 提纲挈领的前提，在堆积如山的文件资料中，少数文档是关键枢纽，每一件项目管理的工作都围绕着他们运转。这些文档是项目经理最重要的个人工具 会议管理之中的“人月神话” 码农翻身–干掉软件开发的超级怪兽：狼人！ 只有喜欢研究编程的人才能成为10x程序员 姚期智 2000年图灵奖得主贡献领域: 计算理论，包括伪随机数生成，密码学与通信复杂度 唯一获图灵奖的华人。生于上海，长于台湾，台大物理学学士，哈佛物理学博士，师从后来获诺贝尔奖的Glashow。后放弃物理研究计算机。17年放弃美国国籍(杨振宁也是同年放弃美国国籍)，成为中国公民。(估计大概率也“争取”过丘成桐，丁肇中和崔琦) 以20年为期，我们看看，这些大师究竟能不能培育出新的大师。到2030年，中国的诺贝尔理化生/菲尔兹/图灵奖，能不能有新的突破。到我离世时，能不能超过10位。 Ole-Johan Dahl &amp; Kristen Nygaard 2001年图灵奖得主贡献领域: 面向对象编程 中文一般译作”奥利-约翰·达尔”(1931年10月12日－2002年1月29日), “克利斯登·奈加特”(1926年8月27日－2002年8月10日) 二人共同创造了Simula，首次引入了面向对象程序设计语言的基本概念：对象、类、继承，被认为是面向对象之父。 二人均为挪威人，均在获奖的次年去世。 使挪威在信息科学领域闻名世界 Simula，一种编译式的编程语言，于1960年代诞生于奥斯陆的挪威计算中心，主要设计者为奥利-约翰·达尔与克利斯登·奈加特。开发出了Simula I与Simula 67两代，它承继了ALGOL 60的基础，被认为是第一个面向对象编程的编程语言。Simula 67引入了对象、类、继承和子类、虚过程，还有协程、离散事件模拟和垃圾收集特征。Simula影响了Smalltalk以及接下来所有的面向对象编程编程语言，如设计C++语言的比雅尼·斯特劳斯特鲁普，和设计Java语言的詹姆斯·高斯林，都认可自己受到了Simula的重要影响 二人在创造面向对象思想方面的成功部分显然是由于他们非凡的才能，但部分原因也是由于他们的背景非常不同。有一个故事说，1967年春天，一位新员工震惊地告诉总机操作员：”两个人在楼上走廊的黑板前激烈战斗。我们该怎么办？接线员走出办公室，听了几秒钟，然后说：”放松。只有达尔和奈加特在讨论SIMULA。 奥利-约翰·达尔后来故意停止进一步发展SIMULA，并去奥斯陆大学任教，研究编程方法，并与Tony Hoare一起制作了一章，名为”分层程序结构”，成为著名著作《结构化程序设计》的一部分。2002年因淋巴癌病逝。 (这本书共三个作者，另外一位为Dijkstra) 奈加特毕业后进入挪威国防研究院，在计算挪威第一座核反应堆的铀棒直径时，因为需要，而开始设计模拟语言。 除此他还是一位积极的社会活动家，活跃于挪威政坛。“一生获得无数荣誉，深受挪威人民爱戴。” Ronald Linn Rivest &amp; Adi Shamir &amp; Leonard Max Adleman 2002年图灵奖得主贡献领域: 公钥密码学（RSA加密算法） 中文一般译作”罗纳德·李维斯特”,”阿迪·萨莫尔”,”伦纳德·阿德曼” Ronald L. Rivest,生于1947年,毕业于耶鲁大学、斯坦福大学，发明RSA加密算法，RSA数据安全公司的联合创始人 Adi Shami，以色列魏兹曼科学研究所教授、美国外籍科学院院士、现代密码学奠基人之一 Leonard M. Adleman，1945年12月31日于美国加州旧金山，分别于1968年和1976年从加州大学伯克利分校（UC Berkeley）获得数学学士学位和计算机/电机工程（EECS）博士学位。除此还在研究DNA Alan Kay 2003年图灵奖得主贡献领域: 面向对象编程，Smalltalk语言之父 中文一般译作”艾伦·凯” 1940年5月17日生于美国麻省，童年在澳大利亚度过。 Smalltalk吸取了Simula中class的概念，并发展出图形使用界面（GUI），即苹果麦金塔电脑的原型。Smalltalk是一种动态类型、反射式的面向对象编程语言。由艾伦·凯、Dan Ingalls、Ted Kaehler、Adele Goldberg等于1970年代初在施乐帕罗奥多研究中心开始开发。Smalltalk对其它众多的程序设计语言的产生起到了极大推动作用，如 Objective-C、Java、Python和Ruby等。1990年代的许多软件开发思想得利于Smalltalk，例如设计模式、敏捷编程和代码重构 是施乐PARC研究中心第一位雇员，1972年，PARC发布了Smalltalk第一个版本。1979年，凯邀请乔布斯、Teff Raskin来到PARC参观，乔布斯对视窗图形用户界面印象深刻。 (施乐PARC还发明了复制粘贴功能) 而后曾加入苹果，惠普。 Vinton Cerf &amp; Robert Kahn 2004年图灵奖得主贡献领域: TCP/IP协议 中文一般译作”文特·瑟夫”,”罗伯特·卡恩” 二人一起发明了传输控制协议（TCP）和互联网协议（IP,也称 网际协议），这两个协议成为互联网核心通信协议的基础,二人均被公认为“互联网之父”之一 (还有一位是HTTP协议的设计者蒂姆·伯纳斯-李) 二人没有申请专利，没有将TCP/IP视为私有财产。还花了整整十年的时间推广这项新技术，用各种方式说服人们去尝试使用它 (蒂姆·伯纳斯-李 同样放弃了HTTP协议的专利) 1943年6月23日出生于康涅狄格州纽黑文(New Haven)，当上学主要在西海岸的加州。家境优渥，酷爱科幻小说。但作为早产儿，落下听觉缺陷。“这也使得他对于世界的沟通方式与众不同，当1971年电子邮件发明，这种无需提供声音的沟通方式无疑受到他格外的青睐” (还写过一篇论文：“一位有听觉缺陷的工程师的自白”) 其妻子是插图画家，3岁时耳朵全聋。二人的第一次见面是ta们的助听器推销商精心策划，让二人不期而遇，一见钟情。饭后二人去艺术博物馆。瑟夫从未受过艺术方面的训练，但也表现出浓厚兴趣。在康定斯基的大型作品前，他伫立良久，最后冒出一句：“这画真像一只巨大的新鲜汉堡包”。 由于听力缺陷，两口子说悄悄话都像吼叫 1965年，在斯坦福大学获得数学学士学位 后来考取加州大学洛杉矶分校，先后取得计算机科学硕士和博士学位 1972年至1976年，任教斯坦福大学。其间与 鲍勃·卡恩（Robert E. Kahn）一起领导TCP/IP协议的研发小组，为阿帕网（ARPANET） 成功开发了主机协议， 使ARPANET成为第一个大规模的数据包网络。 现为Google副总裁兼首席互联网顾问，IPv6论坛的名誉主席 协议(Protocol),网关(Gateway),这些新术语皆由ta们创造。 在署名问题上，两人决定让上帝作主，掷硬币决定。结果瑟夫受到了垂青 坚持反对OSI，认为划分过细，十分复杂，而且仅仅设计，从未试验过。“OSI的一切都是非常抽象的，学究气十足。他们所用的语言浮夸到不可思议的程度，简直读不下去”。而TCP／IP是实践的结晶，也是合作研究的产物，不是像OSI那样在一大堆委员会里产生出来的“大骆驼”。 （1983年，瑟夫曾劝说让IBM、DEC、HP支持TCP／IP，但都遭拒绝，而采用了OSI。他们认为TCP／IP只是一项研究试验。不过最关键的是，国防部选择了TCP／IP。） “编程让人体味到一种奇妙无比的感觉。你创造了一个你自己的世界，你就是这个世界的主人。不管编了什么，计算机总会照办。它就像一只沙匣，里边每一粒沙子都在你把握之中” “我希望人们能够时刻提醒自己，网络的另一端有着和你一样的人，千万不要把互联网当成是一个虚幻的网络。” “你应该清楚这个头衔很不公平。互联网至少有两个父亲，更确切地讲，它有数千个父亲。我只是在最初10年做了些早期工作。” “互联网的确有遗憾之处，但我从不后悔发明了它。” 个人电脑不是一个人的发明，互联网更是集体的力量。戴得上“互联网之父”这顶帽子的人不只瑟夫一人，起码，雷纳德·克兰罗克（Leonard Kleinrock）（设计出了名为包交换(packet switching)的关键互联网技术，1969年该技术发送了第一封有记载的电子邮件）、拉里·罗伯茨（Lawrence Roberts）（是他整合了美国高等专案研究署的ARPANet网络，在过去25年中的大部分时间里，这就是互联网）。以及发明了互联网标准通讯协议TCP/IP的文顿·瑟夫和罗伯特·卡恩（Robert Kahn），四位杰出的科学家为催生互联网分别做出了关键性努力，都曾被媒体称作“互联网之父”。鉴于他们四人对互联网建设与发展的重大项献，1997年12月，时任总统克林顿为他们颁发了“美国国家技术奖”。 文顿·瑟夫：把互联网送上“天堂” 三访互联网之父文顿·瑟夫 “互联网之父”文顿·瑟夫：我从没后悔改变世界 《互联网时代》：“互联网之父”首度齐聚荧屏 1938年12月23日生于纽约布鲁克林，1960年纽约城市大学获得电机工程学士学位，1962和1964年在普林斯顿大学获得硕士和博士学位。毕业在贝尔实验室工作，后在麻省理工学院做助教 “信息高速公路”概念创立人 “老实说，我并不喜欢被人称为‘互联网之父,我只是一个科学家，一个喜欢与别人分享技术的人，我希望别人更加关注我所做的事情。” 世界互联网大会，大佬们都说了啥？ TCP/IP的故事 Presidential Medal of Freedom Peter Naur 2005年图灵奖得主贡献领域: Algol 60语言, BNF范式 中文一般译作”彼得·诺尔” 1928年10月25日生于丹麦腓特烈斯贝 天文学博士，毕业后研究方向转向计算机科学。 目前唯一一位丹麦籍图灵奖得主 他在ALGOL 60中，导入巴科斯范式（Backus Normal Form），进一步发展它，并根据其发明者约翰·巴科斯来命名。高德纳认为，彼得·诺尔在这个记号法中也具有很大贡献，主张应称为巴科斯-诺尔范式（Backus-Naur Form），但彼得·诺尔本人不愿居功，他本人仍然称呼其为巴科斯范式。 2016年1月3日去世 彼得·诺尔(Peter Naur）完善了BNF范式(Bcakus-Naur-Form)，中文叫做巴斯克语言公式。实际上他著名的成果就是Algol 60报告，Algol 60是一个算法语言编译器。在他之前，计算机语言是通过说明性的使用手册和编译代码本身而非正式的定义。他通过使用BNF来定义语法，并用精心选择的说明文字定义语义，简洁而准确。现在全世界所有的、各种算法语言都是基于这个巴斯克语言公式的，所以他的贡献是很大的，这个东西是原创计算机技术突飞猛进，计算机科学发展并不快 调查了72名图灵奖得主背景，却发现计算机专业很难得奖！ BNF for Go Frances Allen 2006年图灵奖得主贡献领域: 并行计算，编译器优化 中文一般译作”法兰(西斯)·艾伦”(1933年8月4日－2020年8月4日),出生于纽约北部的农场。 最早想当一名教师，从纽约州立师范学院 (现 纽约州立大学奥尔巴尼分校)毕业，获得数学学士学位，并在当地学校开始教学。两年后进入密歇根大学，并获得数学硕士学位，“为还读书时贷款，我跟他们(IBM)签约了。” 原本计划只待到债务还清，然而之后，其的整个职业生涯都在 IBM 度过 在 IBM 的第一个任务是教研究社区 FORTRAN 语言(IBM 三个月前刚刚推出的一种复杂的语言)。这是其专注于高性能计算编译器的职业生涯的开始。 爱好是爬山和研究环境问题，退休后致力于鼓励女性从事计算机科学研究的教育培训项目 并行计算技术、编译器优化领域先驱, 成就主要包括编译器的基本原理、代码优化和并行编译等 第一位获图灵奖的女性 全球首位图灵奖女性得主去世，她的研究影响了计算机发展历程 巾帼不让须眉：程序媛秘史 Edmund Clarke &amp; Ernest Emerson &amp; Joseph Sifakis 2007年图灵奖得主贡献领域: 开发自动化方法检测计算机硬件和软件中的设计错误 中文一般译作”小爱德蒙·克拉克”(1945年7月27日 - 2020年12月22日)，生于弗吉尼亚州纽波特纽斯，因感染“新冠”逝世 弗吉尼亚大学数学学士学位，杜克大学数学硕士学位，康奈尔大学计算机博士学位。 之后，杜克大学，哈佛大学，卡内基梅隆大学任教 证明在一些程序语言的控制逻辑中没有一个完善的Hoare理论证明系统，1981年，和自己的博士生Allen Emerson 首次提出了模型检测的想法并用在自动机并发系统的验证研究上。成为形式逻辑研究方面模型检查的开创者之一 中文一般译作”艾伦·爱默生”(1954年6月2日－)，是Edmund Clarke在哈佛大学的博士生。 著名的“模型检测”的论文就是Emerson与导师Clarke合作的。 Emerson是从德州奥斯丁分校获得的其数学本科学位，并从哈佛大学应用数学系获得其博士学位。 之所以走上形式化验证的道路，是受1970年代图灵奖得主Tony Hoare的一篇CACM 论文”Proof of Program: Find”的启发。他位列CiteSeer引用次数最多的前1%计算机科学家。 中文一般译作”约瑟夫·斯发基斯”(1946年12月26日－)，1946年出生于希腊Heraklion（克里特岛第一大城市） 青年时分别在希腊 雅典国立科技大学的电子工程系和法国的University of Grenoble计算机系学习。拥有法国国籍，因此成为第一位荣获图灵奖的法国研究人员。 广泛应用于工业界的“模型检查”技术的发明者。该技术是用数学算法来验证一个软件或硬件系统设计是否满足预设的需求（例如在安全性或可靠性方面），其理论基础是1981年由Sifakis在法国、Clarke和 Emerson在美国分别独立提出的 专访 | 图灵奖得主约瑟夫·斯法基斯：人工智能在设计复杂性上还功力不足 图灵奖获得者：我为何要给无人驾驶前景泼冷水？ Barbara Liskov 2008年图灵奖得主贡献领域: 编程语言和系统设计的实践与理论,里氏替换原则 中文一般译作”芭芭拉·利斯科夫”,1944年出生于洛杉矶 1961年在加州大学伯克利分校获得数学学士学位. 1968年在斯坦福大学获得博士学位,是美国第一个计算机科学女博士,导师为1971年图灵奖得主约翰·麦卡锡 和美国华人计算机科学家周以真提出著名的 里氏替换原则, 是面向对象程序设计中最重要的几大原则之一 她改变了编程 Barbara Liskov：CLU与Argus语言发明人 计算机领域中的女性 Charles Thacker2009年图灵奖得主贡献领域: 帮助设计、制造第一款现代PC 中文一般译作”查尔斯·萨克尔” (1943年2月26日－2017年6月12日）,生于美国加州帕萨迪纳 加盟施乐公司Palo Alto研究中心，先后担任MAXC时分操作系统的项目负责人，Alto个人计算系统的首席设计师等职务 设计与实现了第一台现代个人电脑Xerox Alto。（其主持或者参与设计的产品基本上没有在商业上取得很大成功，图灵奖看重的是技术的创新，而非商业上的成功） 1997年，加入微软，帮助创建了微软在英国剑桥的研究院 Leslie Valiant2010年图灵奖得主贡献领域: 对众多计算理论所做出变革性贡献 中文一般译作”莱斯利·瓦利安特” ，1949年3月28日出生于匈牙利布达佩斯。英国皇家学会会员 在英国剑桥大学国王学院、伦敦帝国学院和华威大学接受教育，曾在卡内基梅隆大学、利兹大学、爱丁堡大学任教，现任教于哈佛大学工程和应用科学学院 成就主要有: 可能近似正确（PAC）学习理论，枚举和代数计算的复杂性，以及并行和分布式计算理论” 对复杂性理论的许多贡献中，引入了 P- 完整性（P-completeness）概念来解释枚举和可靠性问题是难以处理的。 还介绍了机器学习的“可能近似正确”即PAC 模型，有助于计算学习理论领域和全息算法概念的发展。 还以引入批量同步的并行处理模型在计算机系统领域中闻名。 早期在自动机理论方面的工作中还包括一种无上下文解析的算法，直到2010年， 该算法仍然是渐近最快的。 还从事着计算机神经科学的研究，专注于理解记忆和学习。 计算机科学家莱斯利 瓦利安特,人工智能的边界在哪里？ Judea Pearl“贝叶斯网络之父” 2011年图灵奖得主贡献领域: 通过概率论和因果推理对人工智能领域作出的根本性贡献 中文一般译作”朱迪亚·珀尔”，1936年9月4日出生于以色列特拉维夫。以色列裔美国籍计算机科学家和哲学家，以人工智能概率方法的杰出成绩和贝氏网络的研发而知名。现任教于加州大学洛杉矶分校 2002年，其作为记者的儿子，因为美国人和犹太人身份，在巴基斯坦被基地组织和国际伊斯兰阵线涉嫌的武装部队所劫持和杀害 上世纪 80 年代，带头推动机器进行概率推理 --- 而现在他是这个领域最尖锐的批评者之一。其在最新著作《The Book of Why：The New Science of Cause and Effect》中指出，由于未能完全理解智能真正的含义，人工智能的发展已经受到阻碍。（中文译名 为什么）在他看来，人工智能领域已经陷入了概率关联（probabilistic association）的泥潭。近来，新闻头条吹捧机器学习和神经网络的最新突破，比如计算机可以下围棋和驾驶汽车。但 Pearl 对此感到腻味。在他看来，当今人工智能领域的最新技术仅仅是上一代机器所做事情的强化版：在大量数据中找到隐藏的规律。其最近称：「所有令人印象深刻的深度学习成果都只是曲线拟合。他在新书中阐述了一个关于真正智能的机器如何思考的愿景。他认为，关键是用因果推理来代替关联推理。机器不能只有把发烧和疟疾联系起来的能力，还要有推理「疟疾引起发烧」的能力。一旦这种因果框架到位，机器就有可能提出反事实的问题——询问在某种干预下因果关系将如何变化，Pearl 认为这是科学思考的基础。他还提出了一种使这种思维成为可能的正式语言——21 世纪版的贝叶斯框架，允许机器进行概率思维。 “贝叶斯网络”之父重磅力作《为什么》中文版来啦！ 图灵奖得主、“贝叶斯网络之父”朱迪亚·珀尔：不透明机器学习的局限性 Shafrira Goldwasser &amp; Silvio Micali2012年图灵奖得主贡献领域: 在密码学领域 于复杂理论基础之上做出变革性工作；并发展出新的具有数学可证明性的有效验证机制； “零知识证明” 中文一般译作”莎弗莉拉·“莎菲”·戈德瓦塞尔”，1958年11月14日出生于美国纽约，以色列裔美国人。毕业于CMU和UCB，任教于MIT 现代加密技术依靠计算机完成某些数学任务（例如分解非常大的数字）的难度来维持安全性。最复杂的计算机将花费数年甚至数十年才能解码的代码基本上是坚不可摧的。Goldwasser结合了随机性和复杂性领域，以拓宽对计算的可能性和不可能的数学理解。Goldwasser和她的合作者Silvio Micali帮助定义了对任何代码的各种可能的攻击，并设计了新的工具对其进行保护。除零知识证明外，她还开发了测试数字是否为质数的新方法，并且广泛研究了为什么即使在人们仅寻求近似值的情况下，计算机也无法轻易解决现实生活中出现的某些数学问题。 零知识证明 零知识证明-视频介绍 中文一般译作”希尔维奥·米卡利”，1954年10月13日出生于意大利帕勒莫，毕业于罗马大学和UCB，现任职于麻省理工学院计算机科学和人工智能实验室，主要研究密码学，零知识证明，伪随机数生成，安全协议和机制设计。和 Goldwasser是同事关系 同时还是区块链平台阿尔戈兰德的创始人 图灵奖得主Sivio Micali的Algorand区块链协议简介 Algorand-图灵or涂灵，“不可能三角”已破？ Leslie Lamport2013年图灵奖得主贡献领域: 对于分布式及并形系统的理论与实践具有基础性贡献，尤其是诸如因果逻辑时序（causality and logical clocks）、安全性与存活度（safety and liveness）、复制状态机（replicated state machines）及循序一致性（sequential consistency）等理论概念的发明 中文一般译作”莱斯利·兰波特”，1941年2月7日出生于美国纽约，其父是欧洲移民。 MIT获学士学位，之后到布兰戴斯大学攻读数学博士。 曾在学校教授数学课程，现为微软首席计算机科学家。 LaTeX排版系统的开发者 (La即Lamport的前两个字母) Paxos算法 (问世于1990年) 拜占庭将军问题 Sequential consistency Atomic Register Hierarchy Lamport面包店算法 认为自己是一个数学家，其次才算是计算机科学家，强调对于证明的重视 兰伯特的研究为分布式系统理论奠定了基础。他最著名的论文是《分布式系统中的时间、时钟和事件顺序》，该论文在2000年获得了PODC影响力论文奖。同时，他也是允许计算机系统合作、避免错误和解决混淆的协议开发的核心人物。兰伯特的另一篇论文《如何制造一台能正确执行多进程程序的多处理器计算机》，主要定义了顺序一致性的概念，在分布式计算系统看似混乱的行为中增加了清晰的一致性，在系统中，几台自主计算机通过传递消息相互通信，兰伯特设计了重要的算法，并开发了正式的建模和验证协议，以提高真实分布式系统的质量。这些贡献提高了计算机系统的正确性、性能和可靠性。随后，他还撰写了《拜占庭将军的问题》、《分布式快照：确定分布式系统的全局状态》和《兼职议会》等论文。这些论文涉及到逻辑时钟（和前发生的关系）和拜占庭式的失败的概念，在计算机科学领域，它们被数次引用。之后，兰伯特还奖延伸了帕克斯共识算法、面包店算法，和用于计算机系统中同时需要相同资源的多个线程互斥的Chandy – Lamport算法等。其中，面包店算法在他的《Dijkstra并发编程问题的新解决方案》中有所描述，该算法旨在解决相互排斥的问题，它证明了数据损坏的原因不是由多个线程写入同一内存的位置，之后，还解决了在当前程序未完成前另一个程序读取该位置的漏洞。20世纪80年代早期，唐纳德·克努特（Donald Knuth）发布了TeX的早期版本，兰伯特在它的基础上开发一套宏。这套宏后来成为标准版宏包，被称之为LaTeX 。1983年，Addison – Wesley的编辑彼得·戈登（Peter Gordon）向兰伯特提出建议，希望他将其用户手册编汇成一本书。次年9月，兰伯特发布了LaTeX 宏的2.06 a版本，一年后，La TeX 2.09—— Lamport LaTex 的最后版本上线。与此同时， Addison – Wesley也发布了兰伯特此前编写的LaTeX用户手册，名叫《LaTe X ：文件编制系统》，该手册在1986年一共卖掉几十万份。1989年8月21日，斯坦福大学举行TeX用户组会议，兰伯特在会议上同意了将LaTeX的维护和开发工作转交给弗兰克·米特尔·巴赫（Frank Mittel bach）的决策 ，具体后续工作由他与克里斯·罗利（Chris Rowley）和里纳·施普夫（Rainer Schpf）组成 LaTeX3 团队共同完成。随后，在1994年，他们共同发布了LaTe X2e。兰伯特除了在编程方面极富天赋之外，他也因在时态逻辑方面的工作而闻名。早年间，他介绍了动作的时态逻辑（TLA）。最近，他研究出了TLA +，这是一种用于指定并发和反应系统来进行推理的“语言”。对于这种“语言”，兰伯特在《指定系统》一书中进行了详尽解释，它是一种面向软硬件工程师的工具，并将其定义为“克服工程师对数学反感的堂吉诃德式尝试”。 莱斯利·兰伯特——分布式系统中的开创者 图灵奖得主莱斯利·兰伯特：思考比编码重要 遇见令人惊叹的莱斯利·B·兰伯特 一些轶事 Paxos算法的历史： 共识算法的前生今世 Michael Stonebraker2014年图灵奖得主贡献领域: 对现代数据库的概念和实践作出的根本性贡献 中文一般译作”迈克尔·斯通布雷克”，1943年10月11日出生于新罕布什尔州米尔顿. 普林斯顿大学取得学士学位，而后转至密歇根大学分别获得硕士学位和博士学位。其博士论文为《大型马尔科夫随机链的压缩》。 1971年博士毕业，当时科德的关系模型论文发表不久，引起了其极大兴趣。这篇论文引发了传统数据库学者和关系数据库学者之间的一场激烈争论。传统数据库阵营认为，全新的关系数据库不可能被构建出来，即使建起来，也没有人能理解。关系数据库派则反唇相讥，认为这是一项有趣而重要的工作。作为加州大学伯克利分校的小助教，其坚定地站在了关系数据库一派。 研究领域为数据库，通过一系列学术原型及初步商业化，在关系数据库方面的研究结果对现今市场上的产品有很深影响。同时也是以下数据库公司的创始人：Ingres, Illustra, Cohera, StreamBase Systems, Vertica，以及VoltDB。（其中Postgres是Ingres的后续项目，引入了平衡多分数–B树） 数据库领域的布道者，SQL Server/Sysbase的奠基人 冲浪在数据潮头的实干家——数据库界的四位图灵奖得主（4） 数据库大师访谈 - 迈克尔·斯通布雷克Michael Stonebraker访谈录 （数据库实现，Ingres Whitfield Diffie &amp; Martin Hellman 2015年图灵奖得主贡献领域: 公开密钥加密技术,迪菲-赫尔曼密钥交换 中文一般译作”惠特菲尔德·迪菲”,1944年出生于华盛顿 在华盛顿特区出生,在纽约市长大,从10岁开始就对密码学有兴趣. 大学进入麻省理工,主修数学. 中文一般译作”马丁·赫尔曼”,1945年出生于纽约 在大学主修主修电机工程。1966年，在纽约大学取得学士学位。1967年，在斯坦福大学取得硕士学位，1969年取得电机工程博士。曾在在IBM华生研究中心（Thomas J. Watson Research Center）工作 迪菲-赫尔曼密钥交换发表于1976年 迪菲-赫尔曼密钥交换（Diffie–Hellman key exchange，缩写为D-H）发表于1976年,可以让双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。 这个方法被发明后不久出现了RSA，另一个进行公钥交换的算法，其使用了非对称加密算法 不论是SSL还是TLS, 其核心都是利用 迪菲-赫尔曼密钥交换（D-H）, 或者其他类似的算法进行加密 (默认用的是RSA，但用D-H算法更安全，可参考 阮一峰-图解SSL/TLS协议) 马丁·赫尔曼：那个带给我们“安全感“的男人 Tim Berners-Lee 2016年图灵奖得主贡献领域: HTTP 中文一般译作”蒂姆·伯纳斯-李” John Hennessy &amp; David Patterson) 2017年图灵奖得主贡献领域: 计算机体系结构，微处理器 中文一般译作”约翰·轩尼诗”,”大卫·帕特森”。 二人开发了RISC微处理器 并且让这一概念流行起来。 二人还有一本合著 《计算机体系结构：量化研究方法》 约翰·轩尼诗（1953年9月22日 - ）, MIPS公司创办人，第十任斯坦福大学校长, 2018年担任Alphabet董事会主席 马克·安德森称其为 “硅谷教父” 大卫·帕特森(1947年11月16日 － ), 加州大学伯克利分校教授(2016年从UCB退休，作为杰出工程师加入谷歌)，曾任ACM主席一职。主要成就包括 精简指令集，RAID(磁盘阵列的三位主要研发者之一)与计算机集群 MIPS，路在何方？ 解读两大精简指令集：RISC-V和MIPS 两人平分由谷歌提供的100万美元奖金。而轩尼诗恰好是谷歌母公司Alphabet的执行主席，帕特森则是Google Brain团队的成员，故而有2017年图灵奖得主花落谁家？GOOGLE竟把图灵奖奖金发给自己的员工 Yoshua Bengio &amp; Geoffrey Hinton &amp; Yann LeCun 2018年图灵奖得主贡献领域: 深度学习 约书亚·本希奥（法语：Yoshua Bengio，1964年3月5日－），加拿大计算机科学家，因人工神经网络和深度学习领域的研究而闻名 杰弗里·辛顿（英语：Geoffrey Hinton，1947年12月6日－），英国出生的加拿大计算机学家和心理学家，多伦多大学教授。以其在类神经网络方面的贡献闻名。辛顿是反向传播算法和对比散度算法的发明人之一，也是深度学习的积极推动者，被誉为“深度学习之父” （同时还是乔治·布尔的曾曾孙；布尔值即出自其名） 杨立昆（法语：Yann Le Cun，英语：Yann LeCun，原中文译名扬·勒丘恩，1960年7月8日－），法国籍计算机科学家，2018年图灵奖得主，其在机器学习、计算机视觉、移动机器人和计算神经科学等领域都有很多贡献。最著名的工作是在光学字符识别和计算机视觉上使用卷积神经网络 (CNN)，因而也被称为卷积网络之父。他同Léon Bottou和Patrick Haffner等人创建了DjVu图像压缩技术，同Léon Bottou开发了Lush语言。 Facebook人工智能研究院的第一任主任 诺奖季说诺奖：一家 9 次 15 人获诺贝尔奖的公司，它是怎样兴衰的? Yoshua Bengio、 Yann LeCun、Geoffrey Hinton 获 2018 年图灵奖 Deep Learning Pioneers: Yoshua Bengio, Yann LeCun &amp; Geoffrey Hinton 图灵奖揭晓：授予深度学习三巨头 Edwin Catmull &amp; Patrick Hanrahan 2019年图灵奖得主贡献领域: 计算机图形学及其应用 是自 1988年图灵奖得主Ivan Edward Sutherland后，时隔31年，计算机图形学再获图灵奖 艾德文·卡特姆（1945年3月31日－），迪士尼动画工作室和皮克斯动画工作室现任总裁，皮克斯的创始人之一 帕特里克·汉拉恩（1955年－），斯坦福大学计算机图形实验室计算机科学与电机工程学教授，主要研究渲染算法、图形处理器及科学插画与可视化,因渲染和计算机图形研究获得三个奥斯卡金像奖。 Tableau创办者 2019图灵奖得主10年前的对话 Alfred Aho &amp; Jeffrey Ullman 2020年图灵奖得主贡献领域: 编译原理 阿尔佛雷德·艾侯（1941年8月9日－），生于加拿大安大略省提明斯（Timmins）。在哥伦比亚大学任教，贝尔实验室计算机科学研究中心的会长。研究领域为量子计算、编程语言、编译器和算法 AWK中的A就是其姓氏“Aho ”的缩写 同时也与杰弗瑞·乌尔曼和约翰·霍普克洛夫特著作大量计算机科学领域的参考书，包括算法、数据结构以及计算机科学基础。其中最著名的是与 Ravi Sethi及杰弗瑞·乌尔曼合著《编译器：原理、技术、工具》,即著名的龙书 也写了Unix下egrep和fgrep工具的最初版本 杰弗瑞·乌尔曼（1942年11月22日－），斯坦福大学名誉教授。其合作编写的编译器教材（也称龙书）、计算理论（也称灰姑娘书，中文一般译作「自动机理论、语言和计算导论」）、数据结构、数据库教材，被认为是所在领域的标准 图灵奖出炉，“龙书” 作者、编程语言大佬 Alfred Aho 和 Jeffrey Ullman 获奖 2020图灵奖颁给编程的回忆——Jeff Dean的编译启蒙 红宝书与绿宝书与书：哪些经典计算机书籍的诨名和它们背后的故事 原文地址不少诨名得自原书封面，比如“灰姑娘书”，说的就是图灵得主Hopcroft等人的名作《自动机理论、语言和计算导论》（Addison－Wesley，1979，清华大学出版社2002年影印了第2版）。本来书名实在拗口，要不是内容了不起，恐怕会拒不少读者于千里之外；但聪明的读者们不仅没有被这个原名吓倒，反而从封面上找到了解决之道：该书初版的封面也确实吸引人——画的是一个小女孩儿，拼命地从一个古怪装置上拉一条绳子（那个恶魔般的装置上赫然写着“NP完全问题”）。对，就叫它“灰姑娘书”吧！这个名字在读者中不胫而走，每个人刚拿到这本书，看着那小女孩儿的认真样儿（封底上画着她把那个劳什子弄得一团糟），都不禁对“灰姑娘”这个称呼会心一笑。该书甫一问世就成了这个领域最权威的教材，20多年的工业发展都未能撼动灰姑娘的地位。但经过时代变迁，“自动机理论”逐渐从研究生科目落到了本科生的课程表里。为了让学生们好过一些，作者们推出了难度降低、涉及面减小的第二版。不想读者们根本不领情——老师和学生都说还是第一版内容充实，说第二版删掉了一些关键内容，还说作者们为了显得“易懂”，有些地方竟改得口罗嗦了。在我看来，这些抱怨都有道理，但很可能大家的腹诽更多地是为了封面：灰姑娘不见了，取而代之的是蓝黑过渡的底色上的状态机图案。这不能不让念旧的老读者沮丧。抱怨在所难免，而对所有人来说，无论封面怎样，这本书还是“灰姑娘书”。另一部因封面得名的书是“龙书”，也就是Aho等人所著的《编译原理技术与工具》（Addison－Wesley，1986，人民邮电出版社2002年影印版）。Aho是ACM会员奖得主，还与上述Hopcroft合著过《数据结构与算法》等名作，但他最了不起的著作恐怕还是这一部。所谓“龙书”，说全了应该是“屠龙宝书”，因为封面上画着一条红龙和一位骑士。西方人眼里，龙都是恶龙，是妖邪之物，而这条龙身上却写着“编译器设计复杂度”的字样！那么骑士又会用何种法宝迎战呢？只见他披着“数据流分析”铠甲，挟着“LALR分析器生成器”长剑，正忙着在一台终端前输入呢，敢情是个高科技武士！这部“龙书”，人人谈起都要皱眉，列出一堆牢骚（概念定义不清晰呀，多位作者分工不明确呀），但没人能绕过它谈编译原理：毕竟“编译器设计”这条恶龙太歹毒，而此书还是屠龙的最佳指南。有意思的是，该书3位作者中的两位此前还合作过另一本《编译器设计原则》，封面上同样是对峙的恶龙和勇士，只不过那时他们还没开打，仅仅怒目相向而已。为了区别，人们把早先的这本称为“绿龙书”，而后来名声更大的还是“红龙书”。从绿龙到红龙，从怒视到交手，也许封面上的冲突程度也体现了编译器领域的研究进展吧。如果在编程语言课上有人说到了“旧约”、“新约”，大家用不着以为这是在讨论信仰问题。这里的“圣经隐喻”，指的无非是编程语言的圣书，Kernighan和Ritchie写的《C程序语言》（也被按作者称为“K＆R”），而所谓旧、新约，不过是该书的初版（Prentice－Hall，1978）和第二版（Prentice－Hall，1988，清华大学出版社2000年影印版）。Kernighan是上述Aho在贝尔实验室的同事，甚至还共同发明了另一门语言AWK（他们俩分别是其中的A和K），但谈到对C语言的贡献，Kernighan却连忙撇清自己：“Ritchie发明了C语言，没我什么事，句号。”那么这部圣经呢？它的雏形是Kernighan给贝尔的同事们写的一份教程。后来，Kernighan索性“拧着Ritchie的胳膊”，和这个原创者一起完成了全书。ANSIC标准形成后，两位作者又把该书更新到第二版。虽然Kernighan总在称赞Ritchie这位合作者和图灵奖得主（“Ritchie的文章绝了，我们俩写的段落放在一起高下立判”），但其实他本人在C语言发展中的作用也难以抹煞——我们知道，“旧约”出版的几年后，实验室里他负责的那个部门来了一个叫Stroustrup的年轻人；我们还知道，这个年轻人后来发明了C＋＋语言。既然在计算机课上“圣经”未必有宗教含义，那么“四人帮（GoF）”也往往另有所指。这说的是划时代的软件开发专著《设计模式》（Addison－Wesley，1995，机械工业出版社2002年影印版）。GoF指的是四位作者Gamma、Helm、Johnson和Vlissides。当年他们还是声名未彰的软件开发者，而本书一炮打响后，这四位都成了名重天下的大师。说起他们能结成“帮派”，并最终成书，简直近乎不可思议：在写作该书时，四人分散在北美大陆的不同角落：魁北克、伊利诺斯、纽约、加州，Vlissides甚至愿意用“3个时区”强调他们地理分布上的跨度。未来的大师们主要通过当时刚刚时兴的电子邮件交换意见，有时候，他们发现距离对这样复杂的写作可能也是一种优势：大家要考虑成熟再发表想法；而当东部的同事早已丢下问题蒙头大睡时，西部的某个同事还能拾起难题，从他止步的地方重新开始。“设计模式”对软件行业的影响无法低估，很多幼稚的开发者甚至言必称“模式”或“GoF”，殊不知这四位老友现在比当时更加天各一方（Gamma、Helm分别回了瑞士、澳大利亚老家），大家至今也只是在会议上碰过几次面而已。谈到这里，如果您是一位雄心勃勃的作者，也许您已经大致明白了构成名著的要素：最好是有奇特的封面，要不就得找到有趣的合作者，再不，还可以在版次方面下功夫——这样八成能够促成一个响亮的外号，作品的知名也指日可待。可是，如果“巴巴雷里”先生画不好画儿，恐怕个头儿再高也没法成为艺术史上的乔尔乔内；同样，要是您的大作里没有“干货”，再响亮的诨名怕也只是个玩笑吧。 Jack Dongarra 2021年图灵奖得主贡献领域: 高性能计算 杰克·唐加拉(1950年7月18日－), 生于芝加哥，1972年在芝加哥州立大学获得数学学士学位(类似于地方性师范学校，本想当高中老师)，1973年在伊利诺伊理工学院获得计算机科学硕士学位，1980年在新墨西哥大学获得应用数学的博士学位(师从Matlab创始人、美国国家工程院院士Cleve Moler) 对数值算法和库的开创性贡献，使高性能计算软件在40多年来跟上了指数级硬件改进的步伐 专注于线性代数、并行计算、高级计算机体系结构的使用、编程方法，和并行计算机工具的数值算法。同时研究包括开发，测试和记录高质量的数学软件，很多被整合到了MATLAB、R语言、SciPy等软件中. 我眼中一切都是线性代数 此外还是 超级计算机排名 TOP500 发起人之一 图灵奖公布！高性能计算先驱、为超算铺平道路的Jack Dongarra获奖 图灵奖颁给超算跑分开创者！Matlab&amp;SciPy都跟他有关：“我眼中一切都是线性代数 更多参考： 图灵奖获得者 看了 72 位图灵奖得主成就，才发现我对计算机一无所知 “沧海遗珠” &amp; 图灵奖之外被遗漏的天才 约翰·冯·诺伊曼（德语：John von Neumann，1903年12月28日－1957年2月8日），出生于匈牙利的美国籍犹太人数学家，理论计算机科学与博弈论的奠基者，在泛函分析、遍历理论、几何学、拓扑学和数值分析等众多数学领域及计算机科学、量子力学和经济学中都有重大贡献。 图灵奖给任何人都是无上的荣耀，给他却像是侮辱---大概类似颁发给莱布尼兹一座“牛顿数学奖” 丘奇","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"git:亲测体验rebase与merge","date":"2020-04-30T11:55:26.000Z","path":"2020/04/30/git-亲测体验rebase与merge/","text":"rebase与merge异同与最佳使用场景 这个dev-cui分支从devlop分支切出后,一直都只有我一个人在开发&amp;维护. 假如还有一位同事张三, 在devlop分支切出的分支dev-zhangsan上进行开发,他添加了一个glossary.md,而后进行了add &amp; commit 此时项目开发完成,需要将两个分支合并到devlop分支上: develop分支先合并了dev-cui,(即切到develop分支, 执行git merge命令) git merge接着去合并dev-zhangsan,如果使用git merge, 绿色表示dev-cui分支,紫色表示dev-zhangsan,每一个点代表一次提交. 可见出现了分叉,且merge操作会自动有一次commit(此处为快进式提交,参看文首链接),见下图: gir rebase先回退到7f8ccb37fdcced4bd4766c8192a6e27fc5f02730, 接着切换到dev-zhangsan分支, 执行git rebase develop, 此刻对于dev-zhangsan分支,已经有了develop分支的其他提交 而后切回develop分支,执行git merge dev-zhangsan 此时的develop分支的提交log为: git rebase一般称为变基或换基, 这篇blog 将其称为衍合,区别于git merge的合并 其实git rebase后,还是要执行一次git merge. 即有个主干分支A,有个次分支B,二者切分后,都有许多次提交. 这时想再合并到一起,且希望commit log是一条直线, 那切到次分支B上,执行git rebase A, 这时就基于A,然后把B的改动”拔掉”,然后放到最前面.(B的提交历史此时是一条直线) 而后需要切回主干分支A,执行git merge B,一定是一个”快进式提交”. 此时对于A,它的commit log就也是一条支线了 呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"DataGrip常用快捷键","date":"2020-04-29T14:58:03.000Z","path":"2020/04/29/DataGrip常用快捷键/","text":"\b 写代码一直使用JetBrains全家桶, 但数据库GUI工具多用Navicat. 最近Navicat好几次出现卡顿, 下载下来吃灰多时的DataGrip,就此转正上位. 但刚开始用,实在是太蹩脚了…比如Navicat上有一个筛选功能,在DataGrip上没有找到.. 找了些介绍资料,掌握一些快捷键后,体验并不差. (Notice:该资料为全英文,无字幕) 选择展示”行过滤器” 可以书写简单的sql,按Enter执行 Command+F 模糊搜索全局,比Navicat强大 Control+Shift+A 输入transpose并选择, 则行列将倒换, 当列数比较多时,行列切换进行视图,简直是一种神操作 Enter/Space 回车键&amp;空格键 提交&amp;清空 Command+Z 及其他一些小tips 撤销操作,如果选了”Auto-commit”,则改名了无效.. 如果没选,Enter为提交的快捷键 选中某个字段,点击删除,则整行都会被删,快捷删除键为Delete(Win/Linux为Ctrl+Y) Command+N,快速增加一行 打开一个操作台 Option : cyclic expand word cyclic expand word: “循环往上/下选择单词” 参考: IDEA 快捷键拆解系列（六 Option+Enter 展示潜在的可能行为 选择后,这样就能替换成所有的字段. 之前一直有个问题,当一张20个字段的表,只需要取出其中19个字段,有一个不需要,这条sql要怎样快速地写? 在这里有了答案 Command+Enter 执行sql语句 可以选择以csv或tsv或其他格式导出查出的数据 另: csv: 以逗号(comma)为分隔符 tsv: 以Tab键为分隔符 可以设置只执行选中的sql; 可以快速查看执行计划 以检验性能 Shift+F6 :重命名 重命名某张表,及修改sql中用到这张表的部分 可以对查询出的多个结果进行比较(点击图标) 灵活易用的 导入/导出 竖直操作 展示历史记录选中, 右键-&gt;show history 好用且强大的导航 所见即所得的sql语句 直观的图表功能Command + Option + Shift + U 可以快速查看各张表之间的关系! Shift+Shift : 强大的搜索 可以键入任何关键词搜索 如突发奇想,想看看有没有insert语句的模板: 我在开往机场的最后一班地铁里, 将这段只有10几分钟视频提到的tips &amp; tricks, 一一操作并记录. 当敲下最后一个句点,车厢里传来的到站提醒, 正好隔着耳机缓缓传来. 我快步出站,旋即混散在夜色茫茫中. 此番如李元芳”弃刀用剑”,只是工具的改变,本无大碍. 但翻看了下朋友圈”Navicat”关键词相关状态,还是有些小小感叹. 这几年来,虽然曾更换语言,从PhpStorm/PyCharm到Goland,中间还有Sublime/Atom/VS Code, 但作为服务端研发, MySQL自始至终一直相伴. 正是在导航猫这个数据库GUI上, 我亲手实现了 mysql数据库主从同步,实现读写分离 实测了关系型数据库事务的四种隔离级别, 体验了幻读, 并设置隔离级别,体验了脏读与不可重复读 体验了联合索引的失效,当然还有共享锁与排它锁 总结了一些写sql时的一些tips, 也遇到过被盗库勒索比特币 还曾细致思考过Year 2038 problem … 潮落夜江斜月里, 两三星火是瓜州,这一路从小白茕茕而来,一路失去,一路获得, 虽仍为菜鸟但心向大神. 下一个五年, 正是我们这些人今生止此一次的机遇期. 就此告别吧 身后的灯火逐渐暗淡每个恋家的孩子 都要扬起远行的帆说声再见吧 美好的梦境不会消散你的爱枕在臂弯 心脏将毕生柔软 亲爱的旅人 没有一条路无风无浪会有孤独 会有悲伤 也会有无尽的希望亲爱的旅人 这一程会短暂却又漫长而一切终将 汇聚成最充盈的景象","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Rust常用加密算法","date":"2020-04-28T11:35:11.000Z","path":"2020/04/28/Rust常用加密算法/","text":"哈希运算(以Sha256为例) main.rs: 1234567891011use crypto::digest::Digest;use crypto::sha2::Sha256;fn main() &#123; let input = \"dashen\"; let mut sha = Sha256::new(); sha.input_str(input); println!(\"&#123;&#125;\", sha.result_str());&#125; Cargo.toml:1234567891011[package]name = \"crypto_test\"version = \"0.1.0\"edition = \"2021\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rustc-serialize = \"0.3.24\"rust-crypto = \"0.2.36\"rand = \"0.8.5\" 输出为： 6d65924d8e0580b9ac04d13da91c74c3ae28b08b4be4634ae06e647f42a88913 可以在线比对验证一下 验证数据完整性(使用HMAC) MAC（Message Authentication Code，消息认证码算法）是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。HMAC算法首先它是基于信息摘要算法的。目前主要集合了MD和SHA两大系列消息摘要算法。其中MD系列的算法有HmacMD2、HmacMD4、HmacMD5三种算法；SHA系列的算法有HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA512五种算法。HMAC算法除了需要信息摘要算法外，还需要一个密钥。HMAC的密钥可以是任何长度，如果密钥的长度超过了摘要算法信息分组的长度，则首先使用摘要算法计算密钥的摘要作为新的密钥。一般不建议使用太短的密钥，因为密钥的长度与安全强度是相关的。通常选取密钥长度不小于所选用摘要算法输出的信息摘要的长度。 12345678910111213141516171819202122232425use std::iter::repeat;use crypto::hmac::Hmac;use crypto::mac::Mac;use crypto::sha2::Sha256;use rand::&#123;RngCore, rngs::OsRng&#125;;use rustc_serialize::base64::&#123;STANDARD, ToBase64&#125;;use rustc_serialize::hex::ToHex;use crypto::aes::&#123;self,KeySize&#125;;fn main() &#123; let mut key: Vec&lt;u8&gt; = repeat(0u8).take(32).collect(); println!(\"key1: &#123;:?&#125;\", key); OsRng.fill_bytes(&amp;mut key); println!(\"key2: &#123;:?&#125;\", key); println!(\"key: &#123;&#125;\", key.to_base64(STANDARD)); let message = \"dashen.tech\"; let mut hmac = Hmac::new(Sha256::new(), &amp;key); hmac.input(message.as_bytes()); println!(\"HMAC digest: &#123;&#125;\", hmac.result().code().to_hex());&#125; 输出： 1234key1: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]key2: [222, 156, 238, 1, 219, 222, 104, 217, 162, 90, 44, 240, 252, 125, 103, 47, 217, 104, 37, 81, 138, 15, 191, 43, 204, 182, 103, 51, 123, 148, 92, 255]key: 3pzuAdveaNmiWizw/H1nL9loJVGKD78rzLZnM3uUXP8=HMAC digest: 33f440b743d37078d428796c028f47237400f91bb638cc843508224f224f4407 可以在线比对验证一下: 发现不一致… 用Go实现一下: 123456789101112131415161718192021package mainimport ( \"crypto/hmac\" \"crypto/sha256\" \"encoding/hex\" \"fmt\")func main() &#123; rs := hmacSha256(\"dashen.tech\", \"3pzuAdveaNmiWizw/H1nL9loJVGKD78rzLZnM3uUXP8=\") fmt.Println(\"结果为:\", rs)&#125;func hmacSha256(data string, secret string) string &#123; h := hmac.New(sha256.New, []byte(secret)) h.Write([]byte(data)) return hex.EncodeToString(h.Sum(nil))&#125; 结果为: 019cb6bd005949a61eca8bd8900b03bb481803348a497340b65bfe9c3e4816e5 和在线工具计算出的结果一致，说明rust版的实现有问题…以后再研究下原因 加密内容(以AES为例) 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES加密原理:采用对称分组密码体制，密钥的长度最少支持为128、192、256位；加密分组长度128位，如果数据块及密钥长度不足时，会补齐进行加密。 aes加密中的iv是什么 关于AES加解密中CBC模式的IV初始化向量的安全性问题 12345678910111213141516171819202122232425262728use std::iter::repeat;use rand::&#123;RngCore, rngs::OsRng&#125;;use rustc_serialize::base64::&#123;STANDARD, ToBase64&#125;;use crypto::aes::&#123;self, KeySize&#125;;use crypto::symmetriccipher::SynchronousStreamCipher;fn main() &#123; let mut key: Vec&lt;u8&gt; = repeat(0u8).take(16).collect(); println!(\"key1: &#123;:?&#125;\", key); OsRng.fill_bytes(&amp;mut key); println!(\"key2: &#123;:?&#125;\", key); println!(\"key: &#123;&#125;\", key.to_base64(STANDARD)); let mut iv: Vec&lt;u8&gt; = repeat(0u8).take(16).collect(); println!(\"iv1:&#123;:?&#125;\", iv); OsRng.fill_bytes(&amp;mut iv); println!(\"iv2:&#123;:?&#125;\", iv); println!(\"iv: &#123;&#125;\", iv.to_base64(STANDARD)); let mut cipher = aes::ctr(KeySize::KeySize128, &amp;key, &amp;iv); let secret = \"dashen.tech\"; let mut output: Vec&lt;u8&gt; = repeat(0u8).take(secret.len()).collect(); cipher.process(secret.as_bytes(), &amp;mut output[..]); println!(\"最终结果为：&#123;&#125;\", output.to_base64(STANDARD));&#125; 输出： 1234567key1: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]key2: [199, 203, 0, 244, 50, 50, 159, 132, 73, 176, 74, 56, 85, 31, 15, 218]key: x8sA9DIyn4RJsEo4VR8P2g==iv1:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]iv2:[74, 79, 85, 77, 17, 214, 64, 71, 35, 240, 34, 105, 42, 80, 40, 226]iv: Sk9VTRHWQEcj8CJpKlAo4g==最终结果为：b4NBF3CKKLfYuLg=","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"缓存一致性问题","date":"2020-04-22T13:26:58.000Z","path":"2020/04/22/缓存一致性问题/","text":"先删缓存,还是先改数据库? 缓存更新的套路 美团二面：Redis与MySQL双写一致性如何保证？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"go env -w GOSUMDB=off ","date":"2020-04-18T13:58:45.000Z","path":"2020/04/18/go-env-w-GOSUMDB-off/","text":"如果go get时啥的出问题, 一定记得关闭GOSUMDB, 命令为 go env -w GOSUMDB=off 几乎所有和go mod有关的疑难杂症,都是没执行这个命令! 私有笔记","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Linux的I/O调度算法","date":"2020-04-16T15:56:16.000Z","path":"2020/04/16/Linux的I-O调度算法/","text":"Linux IO Scheduler即 Linux IO 调度器,其基本目的是将请求按照它们对应在块设备上的扇区号进行排列，以减少磁头的移动，提高效率 一、I/O调度的4种算法 CFQ (完全公平队列 Completely Fair Queueing)完全公平队列（Completely Fair Queueing） 特点: 在最新的内核版本和发行版中,都选择CFQ做为默认的I/O调度器,对于通用的服务器也是最好的选择.CFQ试图均匀地分布对I/O带宽的访问,避免进程被饿死并实现较低的延迟,是deadline和as调度器的折中.CFQ对于多媒体应用(video,audio)和桌面系统是最好的选择.CFQ赋予I/O请求一个优先级,而I/O优先级请求独立于进程优先级,高优先级的进程的读写不能自动地继承高的I/O优先级. 工作原理:CFQ为每个进程/线程,单独创建一个队列来管理该进程所产生的请求,也就是说每个进程一个队列,各队列之间的调度使用时间片来调度,以此来保证每个进程都能被很好的分配到I/O带宽.I/O调度器每次执行一个进程的4次请求. NOOP(电梯式调度程序)特点: 在Linux2.4或更早的版本的调度程序,那时只有这一种I/O调度算法.NOOP实现了一个简单的FIFO队列,它像电梯的工作主法一样对I/O请求进行组织,当有一个新的请求到来时,它将请求合并到最近的请求之后,以此来保证请求同一介质.NOOP倾向饿死读而利于写.NOOP对于闪存设备,RAM,嵌入式系统是最好的选择.电梯算法饿死读请求的解释:因为写请求比读请求更容易.写请求通过文件系统cache,不需要等一次写完成,就可以开始下一次写操作,写请求通过合并,堆积到I/O队列中.读请求需要等到它前面所有的读操作完成,才能进行下一次读操作.在读操作之间有几毫秒时间,而写请求在这之间就到来,饿死了后面的读请求. Deadline(截止时间调度程序)特点: 通过时间以及硬盘区域进行分类,这个分类和合并要求类似于noop的调度程序.Deadline确保了在一个截止时间内服务请求,这个截止时间是可调整的,而默认读期限短于写期限.这样就防止了写操作因为不能被读取而饿死的现象.Deadline对数据库环境(ORACLE RAC,MYSQL等)是最好的选择. AS(预料I/O调度程序)特点:本质上与Deadline一样,但在最后一次读操作后,要等待6ms,才能继续进行对其它I/O请求进行调度.可以从应用程序中预订一个新的读请求,改进读操作的执行,但以一些写操作为代价.它会在每个6ms中插入新的I/O操作,而会将一些小写入流合并成一个大写入流,用写入延时换取最大的写入吞吐量.AS适合于写入较多的环境,比如文件服务器AS对数据库环境表现很差. 查看系统配置 1.查看当前系统支持的IO调度算法dmesg | grep -i scheduler 2.查看当前系统的I/O调度方法cat /sys/block/sda/queue/scheduler 该命令对ubuntu无效.. ubuntu wiki-IOSchedulers 3.临时及永久更改I/O调度方法临地更改I/O调度方法:例如:想更改到noop电梯调度算法:echo noop &gt; /sys/block/sda/queue/scheduler 永久更改: 修改内核引导参数,加入elevator=调度程序名vi /boot/grub/menu.lst更改到如下内容:kernel /boot/vmlinuz-2.6.18-8.el5 ro root=LABEL=/ elevator=deadline rhgb quiet 参考: Linux I/O 调度算法 Linux IO Scheduler（Linux IO 调度器） Zorro’s Linux Book-Linux的IO调度 linux之 修改磁盘调度算法 如何更改 Linux I/O 调度器来调整性能 linux内核调度器进化史:O(n)-&gt;O(1)-&gt;O(log(n)) Linux进程调度之 大O(1)调度算法","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"不用任何比较运算符找出两个整数中的较大的值","date":"2020-04-16T13:33:44.000Z","path":"2020/04/16/不用任何比较运算符找出两个整数中的较大的值/","text":"这是 牛客网的一道面试题 给定两个32位整数a和b，返回a和b中较大的，要求不能用任何比较判断运算符。 如果可以用标注库, 那首先想到可以用sort包进行排序： 12345678910111213141516171819package mainimport ( \"fmt\" \"sort\")func main() &#123; var a, b = 123, 126 sli := make([]int, 0) sli = append(sli, a, b) sort.Ints(sli) fmt.Println(\"其中较大的数为：\", sli[1])&#125; 但一般情况下，不会让使用sort包。 另一种思路： a和b做差，如果能得知差的正负号，则也可以得出a，b谁大谁小 (未考虑a-b可能溢出的情况) 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var a, b = 123, 126 c := a - b scA := sign(c) scB := flip(scA) fmt.Println(\"较大的数为：\", a*scA+b*scB)&#125;// 取反操作。即异或操作 (位取反也称位异或，一般用~或者^。Go用后者); 当两数不同时,结果为1;两数相同时,结果为0func flip(n int) int &#123; return n ^ 1&#125;func sign(n int) int &#123; return flip((n &gt;&gt; 31) &amp; 1)&#125; 原码、反码、补码与位运算 不用任何比较判断找出两个数中较大的","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"那些有简称的计算机书籍","date":"2020-04-10T13:39:10.000Z","path":"2020/04/10/那些有简称的计算机书籍/","text":"2022.03.22补记，稍作整理后，参加了Go夜读四周年活动 在线预览 参见 同名豆列","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"MySQL长文本字段的选取","date":"2020-04-08T13:39:38.000Z","path":"2020/04/08/MySQL长文本字段的选取/","text":"某个字段需要存储 长文本类型的数据,长度可变,范围不清. varchar最多能存储多大长度呢? 何种情况下用text更好? 以下内容就为探究这个问题: .先将content字段设为varchar(255),则此字段只能最多存储255个字符数 1234567891011121314151617package mainimport \"fmt\"func main() &#123; var str string for i := 1; i &lt;= 255; i++ &#123; str += \"a\" &#125; fmt.Println(str) fmt.Println(len(str))&#125; 1234输出为:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa255 将生成的255位的str,写入content字段,成功保存. 且与文本是 数字,英文 还是中文,全角还是半角无关.(自MySQL 5.0之后) 但如果写入更长的数据,则会从第255位开始,之后的都舍弃. 即 baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (还是255位,舍弃最后一个a) 可以写入, 而 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac (256位),无法写入 .varchar类型的上限是 最多能存储65535个字节的数据(而不是字符; 即64KB),因而其上限和字符集有关,如果是latin1,则可以表示65532长度的字符数 (变长字段额外使用1或2个字节来记录实际数据长度、以及是否为NULL标识位,如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte) 字符集为utf-8时,则最多存 $65532/3=21844$个字符数, 尝试将content自动改为varchar(21844),报错如下: 1ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. You have to change some columns to TEXT or BLOBs。 这是因为不仅受 存储限制,编码长度限制,还受到mysql单行长度限制,mysql一行记录所有长度不得超过65535。若定义的表中各字段长度超过这个值，则提示如上错误. 因为这张表还有一个int(11)类型的id,故而达不到21844这个长度. 将id字段删掉,只保留content这一个字段,在utf-8下,可成功设置为 varchar(21844), 如改为varchar(21845),则会继续报如上错误. .如果继续以较大幅度提供后面的值,如 varchar(70000),则不会报错而将自动转为mediumtext类型. 如将该字段字符集(及其相应的排序规则)改为latin1,则可成功设置为varchar(65532) 如再提高至varchar(65533),则会报上面行大小太大的错误. 在latin1字符集下,存储英文大小写,数字,都没有问题,但用来存储汉字,则会因为不能识别而被记录为? &lt;4.&gt;在在utf-8下, 且只有这一个字段,可成功设置为varchar(21844)情况下,经实际亲测,可以容纳21844个字符,超出部分将会被舍弃. 即一般情况下,如果长度小于2万,可用varchar,否则就要用text 参考 &amp; 强烈推荐阅读 MySQL中varchar最大长度是多少？ MySQL性能优化之char、varchar、text的区别","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"当以有涯之生，多行未做之事","date":"2020-04-07T11:16:34.000Z","path":"2020/04/07/当以有涯之生，多行未做之事/","text":"造的轮子各种“抛锚”，心无旁骛“查案”自得其乐，日志一行行输出，紧盯屏幕唯恐遗漏任何细节。最后水落石出真相大白，揉搓酸痛睡眼，见有斑点血块。 明明心羡老庄，骑青牛西去，驾鲲鹏高飞---却只能在愈发稀少的酣眠中。身在凡尘结庐人境，无时不向往桃花源，又常自作五柳生，而被时代洪流，为资本巨手，被社会车轮惯性，夹持裹挟牢牢吞噬，活成了杰克伦敦及其马丁伊登。恐怖的是还打了鸡血般歆享，只能在夜深人静偶尔发现。 12年前那个闷热暑假，我读塞林格『麦田里的守望者』，不解其意味如嚼蜡。更对『Beat Generation』模糊朦胧，缺乏真切感知。多年后，似乎有一些懂了，却亦成为局中人。 再过100年，此刻的绝大多数生物体都将归为齑粉。而过后1000年，能将名姓遗物留存下的，能有几个？恐多不过一二。不惭自认好铁，不甘宰鸡屠狗，却也找不好方位，目不见睫皓首穷经。 每当这般忖夺，实觉人生之趣不过如此，牵绊者，唯父母亲友，连兴趣爱好。正是亲戚情话，琴书消忧。转念又想，更当以有涯之生，多行未做之事。这消弭了对挫折的痛楚，也减弱了于成功的喜悦，更在不仄足中，一直在奔跑，不太敢停歇。 “我们生活在一个不值得大师用文字记录的时代”，回溯展望，看似日新月异实则千篇一律。结婚生子，困于奶粉尿布，便无暇无心“胡思乱想”。子又生孙，孙又生子，总会有某些瞬间，踏进同一条河流。我想到了故事里，黄土坡的那个放羊娃。当略带讥嘻看完，心有庆幸，却无意识到，都大抵如此。… 幸甚是凡夫俗子，惦念着天亮的一顿饕餮，就能暂歇扫去千般愁绪。 2020.04.07 凌晨1:54","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"钓台的春昼","date":"2020-04-03T13:53:28.000Z","path":"2020/04/03/钓台的春昼/","text":"作者： 郁达夫 因为近在咫尺，以为什么时候要去就可以去，我们对于本乡本土的名区胜景，反而往往没有机会去玩，或不容易下一个决心去玩的。 正唯其是如此，我对于富春江上的严陵，二十年来，心里虽每在记着，但脚却从没有向这一方面走过。一九三一，岁在辛未，暮春三月，春服未成，而中央党帝，似乎又想玩一个秦始皇所玩过的把戏了，我接到了警告，就仓皇离去了寓居。 先在江浙附近的穷乡里，游息了几天，偶尔看见了一家扫墓的行舟，乡愁一动，就定下了归计。绕了一个大弯，赶到故乡，却正好还在清明寒食的节前。 和家人等去上了几处坟，与许久不曾见过面的亲戚朋友，来往热闹了几天，一种乡居的倦怠，忽而袭上心来了，于是乎我就决心上钓台去访一访严子陵的幽居。 钓台去桐庐县城二十余里，桐庐去富阳县治九十里不足，自富阳溯江而上，坐小火轮三小时可达桐庐，再上则须坐帆船了。 我去的那一天，记得是阴晴欲雨的养花天，并且系坐晚班轮去的，船到桐庐，已经是灯火微明的黄昏时候了，不得已就只得在码头近边的一家旅馆的高楼上借了一宵宿。 养花天:暮春牡丹开花时节,因天多轻云微雨，适宜养花，故称五代·郑文宝《送曹纬刘鼎二秀才》诗：“小舟闻笛夜，微雨养花天。”明·杨慎《丹铅总录·时序·养花天》：“《花木谱》云：越中牡丹开时，赏者不问疏亲，谓之看花局。泽国此月多有轻阴微雨，谓之养花天。” 桐庐县城，大约有三里路长，三千多烟灶，一二万居民，地在富春江西北岸，从前是皖浙交通的要道，现在杭江铁路一开，似乎没有一二十年前的繁华热闹了。尤其要使旅客感到萧条的，却是桐君山脚下的那一队花船的失去了踪影。 说起桐君山，原是桐庐县的一个接近城市的灵山胜地，山虽不高，但因有仙，自然是灵了。以形势来论，这桐君山，也的确是可以产生出许多口音生硬，别具风韵的桐严嫂来的生龙活脉，地处在桐溪东岸，正当桐溪和富春江合流之所，依依一水，西岸便瞰视着桐庐县市的人家烟树。 南面对江，便是十里长州；唐诗人方干的故居，就在这十里桐洲九里花的花田深处。向西越过桐庐县城，更遥遥对着一排高低不定的青峦，这就是富春山的山子山孙了。 东北面山下，是一片桑麻沃地，有一条长蛇似的官道，隐而复现，出没盘曲在桃花杨柳洋槐榆树的中间，绕过一支小岭，便是富阳县的境界，大约去程明道的墓地程坟，总也不过一二十里地的间隔，我的去拜谒桐君，瞻仰道观，就在那一天到桐庐的晚上，是淡云微月，正在作雨的时候。 鱼梁渡头，因为夜渡无人，渡船停在东岸的桐君山下。我从旅馆踱了出来，先在离轮埠不远的渡口停立了几分钟，后来问一位来渡口洗夜饭米的年轻少妇，弓身请问了一回，才得到了渡江的秘诀。 她说：“你只须高喊两三声，船自会来的。” 先谢了她教我的好意，然后以两手围成了播音的喇叭，“喂，喂，渡船请摇过来！”地纵声一喊，果然在半江的黑影当中，船身摇动了。渐摇渐近，五分钟后，我在渡口，却终于听出了咿呀柔橹的声音。 时间似乎已经入了酉时的下刻，小市里的群动，这时候都已经静息，自从渡口的那位少妇，在微茫的夜色里，藏去了她那张白团团的面影之后，我独立在江边，不知不觉心里头却兀自感到了一种他乡日暮的悲哀。 渡船到岸，船头上起了几声微微的水浪清音，又铜东的一响，我早已跳上了船，渡船也已经掉过头来了。坐在黑沉沉的舱里，我起先只在静听着柔橹划水的声音，然后却在黑影里看出了一星船家在吸着的长烟管头上的烟火，最后因为沉默压迫不过，我只好开口说话了：“船家！你这样的渡我过去，该给你几个船钱？”我问。 “随你先生把几个就是。”船家说话冗慢幽长，似乎已经带着些睡意了，我就向袋里摸出了两角钱来。“这两角钱，就算是我的渡船钱，请你候我一会，上去烧一次夜香，我是依旧要渡过江来的。” 船家的回答，只是恩恩乌乌，幽幽同牛叫似的一种鼻音，然而从继这鼻音而起的两三声轻快的喀声听来，他却已经在感到满足了，因为我也知道，乡间的义渡，船钱最多也不过是两三枚铜子而已。 到了桐君山下，在山影和树影交掩着的崎岖道上，我上岸走不上几步，就被一块乱石绊倒，滑跌了一次。船家似乎也动了恻隐之心了。一句话也不发，跑将上来，他却突然交给了我一盒火柴。 我于感谢了一番他的盛意之后，重整步武，再摸上山去，先是必须点一枝火柴走三五步路的，但到得半山，路既就了规律，而微云堆里的半规月色，也朦胧地现出一痕银线来了，所以手里还存着的半盒火柴，就被我藏入了袋里。 路是从山的西北，盘曲而上，渐走渐高，半山一到，天也开朗了一点，桐庐县市上的灯光，也星星可数了。更纵目向江心望去，富春江两岸的船上和桐溪合流口停泊着的船尾船头，也看得出一点一点的火来。 走过半山，桐君观里的晚祷钟鼓，似乎还没有息尽，耳朵里仿佛听见了几丝木鱼钲钹的残声。走上山顶，先在半途遇着了一道道观外围的女墙，这女墙的栅门，却已经掩上了。 在栅门外徘徊了一刻，觉得已经到了此门而不进去，终于是不能满足我这一次暗夜冒险的好奇怪癖的。所以细想了几次，还是决心进去，非进去不可，轻轻用手往里面一推，栅门却呀的一声，早已退向了后方开开了，这门原来是虚掩在那里的。 进了栅门，踏着为淡月所映照的石砌平路，向东向南的前走了五六十步，居然走到了道观的大门之外，这两扇朱红漆的大门，不消说是紧闭在那里的。 到了此地，我却不想再破门进去了，因为这大门是朝南向着大江开的，门外头是一条一丈来宽的石砌步道，步道的一旁是道观的墙，一旁便是山坡，靠山坡的一面，并且还有一道二尺来高的石墙筑在那里， 大约是代替栏杆，防人倾趺下山去的用意，石墙之上，铺的是二三尺宽的青石，在这似石栏又似石凳的墙上，尽可以坐卧游息，饱看桐江和对岸的风景，就是在这里坐它一晚，也很可以，我又何必去打开门来，惊起那些老道的恶梦呢？ 空旷的天空里，流涨着的只是些灰白的云，云层缺处，原也看得出半角的天，和一点两点的星，但看起来最饶风趣的，却仍是欲藏还露，将见仍无的那半规月影。 这时候江面上似乎起了风，云脚的迁移，更来得迅速了，而低头向江心一看，几多散乱着的船里的灯光，也忽明忽灭地变换了一变换位置。 这道观大门外的景色，真神奇极了。 我当十几年前，在放浪的游程里，曾向瓜州京口一带，消磨过不少的时日，那时觉得果然名不虚传的，确是甘露寺外的江山，而现在到了桐庐，昏夜上这桐君山来一看，又觉得这江山的秀而且静，风景的整而不散，却非那天下第一江山的北固山所可与比拟的了。 真也难怪得严子陵，难怪得戴徵士，倘使我若能在这样的地方结屋读书，颐养天年，那还要什么的高官厚禄，还要什么的浮名虚誉哩？ 一个人在这桐君观前的石凳上，看看山，看看水，看看城中的灯火和天上的星云，更做做浩无边际的无聊的幻梦，我竟忘记了时刻，忘记了自身，直等到隔江的击柝声传来，向西一看，忽而觉得城中的灯影微茫地灭了，才跑也似地走下了山来，渡江奔回了客舍。 第二日侵晨，觉得昨天在桐君观前做过的残梦正还没有续完的时候，窗外面忽而传来了一阵吹角的声音。 好梦虽被打破，但因这同吹筚篥似的商音哀咽，却很含着些荒凉的古意，并且晓风残月，杨柳岸边，也正好候船待发，上严陵去；所以心里纵怀着了些儿怨恨，但脸上却只现出了一痕微笑，起来梳洗更衣，叫茶房去雇船去。 雇好了一只双桨的渔舟，买就了些酒菜鱼米，就在旅馆前面的码头上上了船。轻轻向江心摇出去的时候，东方的云幕中间，已现出了几丝红韵，有八点多钟了，舟师急得厉害，只在埋怨旅馆的茶房，为什么昨晚不预先告诉，好早一点出发。 因为此去就是七里滩头，无风七里，有风七十里，上钓台去玩一趟回来，路程虽则有限，但这几日风雨无常，说不定要走夜路，才回来得了的。过了桐庐，江心狭窄，浅滩果然多起来了。 路上遇着的来往的行舟，数目也是很少，因为早晨吹的角，就是往建德去的快班船的信号，快班船一开，来往于两埠之间的船就不十分多了。两岸全是青青的山，中间是一条清浅的水，有时候过一个沙洲，洲上的桃花菜花，还有许多不晓得名字的白色的花，正在喧闹着春暮，吸引着蜂蝶。 我在船头上一口一口的喝着严东关的药酒，指东话西地问着船家，这是什么山？那是什么港？惊叹了半天，称颂了半天，人也觉得倦了，不晓得什么时候，身子却走上了一家水边的酒楼，在和数年不见的几位已经做了党官的朋友高谈阔论。谈论之余，还背诵了一首两三年前曾在同一的情形之下做成的歪诗。 不是尊前爱惜身，佯狂难免假成真， 曾因酒醉鞭名马，生怕情多累美人。 劫数东南天作孽，鸡鸣风雨海扬尘， 悲歌痛哭终何补，义士纷纷说帝秦。 直到盛筵将散，我酒也不想再喝了，和几位朋友闹得心里各自难堪，连对旁边坐着的两位陪酒的名花都不愿意开口。正在这上下不得的苦闷关头，船家却大声的叫了起来说：“先生，罗芷过了，钓台就在前面，你醒醒吧，好上山去烧饭吃去。” 擦擦眼睛，整了一整衣服，抬起头来一看，四面的水光山色又忽而变了样子了。清清的一条浅水，比前又窄了几分，四围的山包得格外的紧了，仿佛是前无去路的样子。并且山容峻削，看去觉得格外的瘦格外的高。 向天上地下四围看看，只寂寂的看不见一个人类。双桨的摇响，到此似乎也不敢放肆了，钩的一声过后，要好半天才来一个幽幽的回响，静，静，静，身边水上，山下岩头，只沉浸着太古的静，死灭的静，山峡里连飞鸟的影子也看不见半只。 前面的所谓钓台山上，只看得见两个大石垒，一间歪斜的亭子，许多纵横芜杂的草木。山腰里的那座祠堂，也只露着些废垣残瓦，屋上面连炊烟都没有一丝半缕，像是好久好久没有人住了的样子。 并且天气又来得阴森，早晨曾经露一露脸过的太阳，这时候早已深藏在云堆里了，余下来的只是时有时无从侧面吹来的阴飕飕的半箭儿山风。 船靠了山脚，跟着前面背着酒菜鱼米的船夫走上严先生祠堂去的时候，我心里真有点害怕，怕在这荒山里要遇见一个干枯苍老得同丝瓜筋似的严先生的鬼魂。 在祠堂西院的客厅里坐定，和严先生的不知第几代的裔孙谈了几句关于年岁水旱的话后，我的心跳也渐渐儿的镇静下去了，嘱托了他以煮饭烧菜的杂务，我和船家就从断碑乱石中间爬上了钓台。 东西两石垒，高各有二三百尺，离江面约两里来远，东西台相去，只有一二百步，但其间却夹着一条深谷，立在东台，可以看得出罗芷的人家，回头展望来路，风景似乎散漫一点，而一上谢氏的西台，向西望去，则幽谷里的清景，却绝对的不像是在人间了。 我虽则没有到过瑞士，但到了西台，朝西一看，立时就想起了曾在照片上看见过的威廉退儿的祠堂。这四山的幽静，这江水的青蓝，简直同在画片上的珂罗版色彩，一色也没有两样，所不同的，就是在这儿的变化更多一点，周围的环境更芜杂不整齐一点而已，但这却是好处，这正是足以代表东方民族性的颓废荒凉的美。 从钓台下来，回到严先生的祠堂——记得这是洪杨以后严州知府戴重建的祠堂——西院里饱啖了一顿酒肉，我觉得有点酩酊微醉了。手拿着以火柴柄制成的牙签，走到东面供着严先生神像的龛前， 向四面的破壁上一看，翠墨淋漓，题在那里的，竟多是些俗而不雅的过路高官的手笔。最后到了南面的一块白墙头上，在离屋檐不远的一角高处，却看到了我们的一位新近去世的同乡夏灵峰先生的四句似邵尧夫而又略带感慨的诗句。 夏灵峰先生虽则只知崇古，不善处今，但是五十年来，像他那样的顽固自尊的亡清遗老，也的确是没有第二个人。比较起现在的那些官迷财迷的南满尚书和东洋宦婢来，他的经术言行，姑且不必去论它，就是以骨头来秤秤，我想也要比什么罗三郎郑太郎辈，重到好几百倍。 慕贤的心一动，醺人的臭技自然是难熬了，堆起了几张桌椅，借得了一枝破笔，我也在高墙上在夏灵峰先生的脚后放上了一个陈屁，就是在船舱的梦里，也曾微吟过的那一首歪诗。 从墙头上跳将下来，又向龛前天井去走了一圈，觉得酒后的喉咙，有点渴痒了，所以就又走回到了西院，静坐着喝了两碗清茶。 在这四大无声，只听见我自己的啾啾喝水的舌音冲击到那座破院的败壁上去的寂静中间，同惊雷似地一响，院后的竹园里却忽而飞出了一声闲长而又有节奏似的鸡啼的声来。 同时在门外面歇着的船家，也走进了院门，高声的对我说：“先生，我们回去吧，已经是吃点心的时候了，你不听见那只公鸡在后山啼么？我们回去吧！” 1932年8月在上海写","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"栈和队列问题汇集","date":"2020-03-31T14:35:26.000Z","path":"2020/03/31/栈和队列问题汇集/","text":"leetcode-20 有效的括号 leetcode-150 逆波兰表达式求值 leetcode-71 简化路径 栈和递归有紧密的关系 二叉树的前序/中序/后序遍历 leetcode-341 扁平化嵌套列表迭代器 队列Queue: 队列的基本应用---广度优先遍历 树: 层序遍历 图: 无权图的最短路径 leetcode-102 二叉树的层序遍历 leetcode-107 二叉树的层次遍历II leetcode-103 二叉树的锯齿形层次遍历 leetcode-199 二叉树的右视图 BFS和图的最短路径: leetcode-279 完全平方数 leetcode-127 单词接龙 leetcode-126 单词接龙II 优先队列也是队列 优先队列的底层实现: 堆 对于堆的底层实现,要达到可以白板编程的程度 leetcode-347 前K个高频元素 维护前k大个元素,或前k小个元素,这样的需求是优先队列使用的典型场景 leetcode-23 合并K个排序链表 使用k分的归并排序~","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"查找问题汇集","date":"2020-03-31T13:41:06.000Z","path":"2020/03/31/查找问题汇集/","text":"两类查找问题: 查找有无: 元素a是否存在? — 使用set(集合) 查找对应关系(键值对应): 元素a出现了几次? — 使用map(字典) leetcode-349 两个数组的交集 leetcode-350 两个数组的交集II 哈希表的缺点是 失去了数据的顺序性 C++,map和set的底层实现为平衡二叉树, unordered_map和unordered_set的底层实现为哈希表 leetcode-242 有效的字母异位词 leetcode-202 快乐数 leetcode-290 单词规律 leetcode-205 同构字符串 leetcode-451 根据字符出现频率排序 leetcode-1 两数之和 leetcode-15 三数之和 leetcode-16 最接近的三数之和 leetcode-454 四数相加II leetcode-49 字母异位词分组 leetcode-447 回旋镖的数量 leetcode-149 直线上最多的点数 滑动窗口+查找表 leetcode-219 存在重复元素II leetcode-217 存在重复元素 leetcode-220 存在重复元素III","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"数组问题汇集","date":"2020-03-31T01:35:50.000Z","path":"2020/03/31/数组问题汇集/","text":"数组中的问题其实最常见, 排序: 选择排序,插入排序,归并排序,快速排序 查找: 二分查找法(该思想在1946年提出,直至1962年,才出现第一个没有bug的二分查找法) 数据结构: 栈,队列,堆. 都(可)用数组实现 leetcode-283 移动零 leetcode-27 移除元素 leetcode-26 删除排序数组中的重复项 leetcode-80 删除排序数组中的重复项II leetcode-75 颜色分类 leetcode-88 合并两个有序数组 leetcode-215 数组中的第K个最大元素 leetcode-125 验证回文串 leetcode-344 反转字符串 leetcode-345 反转字符串中的元音字母 leetcode-11 盛最多水的容器 双索引技术,一种表现形式是xxx,另外一种是滑动窗口 leetcode-209 长度最小的子数组 leetcode-3 最大字符子串 leetcode-438 找到字符串中所有字母异位词 leetcode-76 最小覆盖子串","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"链表问题汇集","date":"2020-03-31T01:35:43.000Z","path":"2020/03/31/链表问题汇集/","text":"一般链表的问题,都是操作链表的next指针,像一根针线一样,连接着下一个节点. 很多链表的问题,就像”穿针引线”一样,其实就是操纵next指针指向哪里~ leetcode-206 反转链表 leetcode-92 反转链表II leetcode-83 删除排序链表中的重复元素 leetcode-86 分隔链表 leetcode-328 奇偶链表 leetcode-2 两数相加 leetcode-445 两数相加II 设立链表的虚拟头结点 leetcode-203 移除链表元素 leetcode-82 删除排序链表中的重复元素II leetcode-21 合并两个有序链表 leetcode-24 两两交换链表中的节点 leetcode-25 K个一组翻转链表 leetcode-147 对链表进行插入排序 leetcode-148 排序链表 不仅仅是穿针引线 双指针技术 (或称”双索引技术) leetcode-237 删除链表中的节点 leetcode-19 删除链表的倒数第N个节点 leetcode-61 旋转链表 leetcode-143 重排链表 leetcode-234 回文链表","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"流水线相关问题","date":"2020-03-27T11:51:27.000Z","path":"2020/03/27/流水线相关问题/","text":"概念 计算 流水线的周期和全部执行需要的时间 首先，流水线周期是指在（取指、分析、执行）三个阶段中时间最长的一段，对应上面的例题，最长的一段时间为2ns，所以流水线周期为2ns。 100条指令全部执行完毕需要的时间为：理论公式：（2+2+1）+（100-1）*2=203ns。 100条指令全部执行完毕需要的时间为：实践公式：（3+100-1）*2=204ns。（公式中的k表示指令被分成了几段） 流水线吞吐率的计算 流水线加速比的计算计算机组成与体系结构","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"Golang中select的四大用法 ","date":"2020-03-15T10:14:27.000Z","path":"2020/03/15/Golang中select的四大用法/","text":"姊妹篇: golang之channel入门 golang之channel并发访问 Select vs Switch 二者有个共同特性就是都通过case的方式来处理, 但除此之外几乎完全不同; switch..case 可以处理各种类型，常用来做 接口 interface{} 的判断 (通过variable.(type)). 重点是会依照 case 的顺序依序执行。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"func convert(val interface&#123;&#125;) &#123; switch t := val.(type) &#123; case int: fmt.Println(\"val为int类型\", t) case string: fmt.Println(\"val为string类型\", t) case float64: fmt.Println(\"val为float64类型\", t) case float32: fmt.Println(\"val为float32类型\", t) case []string: fmt.Println(\"val为字符串类型的切片\", t) default: fmt.Println(\"val不是上列类型之一\") &#125;&#125;func main() &#123; var i interface&#123;&#125; i = float32(3.1415926) convert(i) i = \"dashen\" convert(i) i = 100 convert(i) i = []string&#123;\"欧拉\", \"高斯\"&#125; convert(i)&#125; 输出为: 1234val为float32类型 3.1415925val为string类型 dashenval为int类型 100val为字符串类型的切片 [欧拉 高斯] 而select..case则只能处理 channel类型 即每个 case 必须是一个通信操作, 要么是发送要么是接收 select 将随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 如果有多个 case 都可以执行，Select 会随机公平地选出一个执行。其他不会执行。否则：如果有 default 子句，则执行该语句。如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 Select的四大基本用法 随机选择 Random Select 123456789101112131415161718192021222324252627package mainimport \"fmt\"func main() &#123; var ch1, ch2, ch3 chan int var i1, i2 int select &#123; case i1 = &lt;-ch1: fmt.Println(\"接收到了管道1的一条数据:\", i1) case ch2 &lt;- i2: fmt.Println(\"向管道2发送了一条数据:\", i2) case i3, ok := &lt;-ch3: if ok &#123; fmt.Println(\"收到了管道3的数据:\", i3) &#125; else &#123; fmt.Println(\"管道3已被关闭\") &#125; default: fmt.Println(\"以上case皆不可运行,即没有进行通信\") &#125;&#125; 输出为:1以上case皆不可运行,即没有进行通信 如果把上述代码中的default语句块去掉,则会报123456fatal error: all goroutines are asleep - deadlock!goroutine 1 [select]:main.main() /Users/shuangcui/go/note/select/2.go:9 +0x108exit status 2 而如果将如上代码中的channel改成有缓存,如: 12345678910111213141516171819202122232425262728293031323334353637package mainimport \"fmt\"func main() &#123; ch1 := make(chan int,1) ch2 := make(chan int,1) ch3 := make(chan int,1) ch6 := make(chan int,1) var i1, i2 int select &#123; case i1 = &lt;-ch1: fmt.Println(\"接收到了管道1的一条数据:\", i1) case ch2 &lt;- i2: fmt.Println(\"向管道2发送了一条数据:\", i2) case i3, ok := &lt;-ch3: if ok &#123; fmt.Println(\"收到了管道3的数据:\", i3) &#125; else &#123; fmt.Println(\"管道3已被关闭\") &#125; case ch6 &lt;- 271828: fmt.Println(\"向管道6发送了一条数据:\", 271828) default: fmt.Println(\"以上case皆不可运行,即没有进行通信\") &#125;&#125; 第二个case和第四个case是可以执行的,所以不会走default语句.输出为: 1向管道2发送了一条数据: 0 或 1向管道6发送了一条数据: 271828 二者都满足条件,被select选中执行的概率完全一样 超时控制 假设业务中需调用某接口A，要求超时时间为x秒，那么如何优雅、简洁的实现呢？ 利用 select+time.After 参考 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"time\")func main() &#123; ch := make(chan string) go func() &#123; time.Sleep(time.Second * 2) ch &lt;- \"写入某个值\" &#125;() select &#123; case rs := &lt;-ch: fmt.Println(\"结果是:\", rs) case &lt;-time.After(time.Second * 1): fmt.Println(\"超时!\") &#125;&#125; 输出为: 1超时! 参考: Go 采用 time.After 实现超时控制 如何用 go 实现超时控制 Go语言并发模型：使用 select 关于time.After: 123456789// After waits for the duration to elapse and then sends the current time// on the returned channel.// It is equivalent to NewTimer(d).C.// The underlying Timer is not recovered by the garbage collector// until the timer fires. If efficiency is a concern, use NewTimer// instead and call Timer.Stop if the timer is no longer needed.func After(d Duration) &lt;-chan Time &#123; return NewTimer(d).C&#125; 接收一个int64类型的值,返回一个Time类型的单向channel 检查channel是否已满 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; ch := make(chan int, 1) ch &lt;- 271828 select &#123; case ch &lt;- 31415926: fmt.Println(\"通道的值为:\", &lt;-ch) fmt.Println(\"channel vaule is:\",&lt;-ch) default: fmt.Println(\"通道已经被阻塞,即已经满了\") &#125;&#125; 输出为: 1通道已经被阻塞,即已经满了 将如上ch这个int类型通道的缓存值从1改称10,则 1ch := make(chan int, 10) 则执行结果为: 12通道的值为: 271828channel vaule is: 31415926 在循环中使用select 如果有多个 channel 需要读取, 且读取是不间断的, 就必须使用 for + select 机制来实现 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\" \"time\")func main() &#123; i := 0 ch := make(chan string, 0) defer func() &#123; close(ch) &#125;() go func() &#123; CuiStartLoop: //不加也可以,与后面break后的 CuiStartLoop相呼应,作为循环体的标识 for &#123; time.Sleep(time.Second * 1) fmt.Println(time.Now().Unix()) fmt.Println(\"当前i的值为:\",i) i++ select &#123; case m := &lt;-ch: fmt.Println(\"输出为:\",m) break CuiStartLoop default: fmt.Println(\"执行了default代码块\") &#125; &#125; &#125;() time.Sleep(time.Second * 4) ch &lt;- \"stop\"&#125; 输出: 1234567891011121584289065当前i的值为: 0执行了default代码块1584289066当前i的值为: 1执行了default代码块1584289067当前i的值为: 2执行了default代码块1584289068当前i的值为: 3输出为: stop 当没有值传送进来时, 就会一直停在 select 区段, 所以即便没有 default代码块 也是可以正常运作的. 而要结束 for 或 select 都需要通过 break 来结束, 但是要在 select 区间直接结束掉 for 循环, 只能使用 break. 参考: 一文掌握 Go 语言 Select 的四大用法 更底层(操作系统层面)地进行理解: select实现原理 Go netpoll I/O 多路复用构建原生网络模型之源码深度解析 一个EOF引发的探索之路之四（理解golang的NetFD之I/O多路复用篇）","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"银行家算法","date":"2020-03-10T12:51:42.000Z","path":"2020/03/10/银行家算法/","text":"银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行 在并发编程中,当多个进程或线程对某个不可抢占资源进行争夺时会引起死锁的问题。 使用银行家算法主要的目的是为了避免系统产生死锁(对于死锁可以将其理解为坏账) 银行家算法原本是为银行系统设计的,确保银行在发放现金贷款时,不会发生不能满足所有客户需要的情况 https://mp.weixin.qq.com/s/ZrLTC3IFLQfD7eeyIaINvg 操作系统——“银行家算法” golang简单实现银行家算法","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"哲学家就餐问题","date":"2020-03-10T12:51:22.000Z","path":"2020/03/10/哲学家就餐问题/","text":"经典死锁问题–哲学家就餐问题","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"天地都在我心中","date":"2020-03-09T13:32:56.000Z","path":"2020/03/09/天地都在我心中/","text":"这日，令狐冲参透『易筋锻骨篇』诀窍，喜不自胜，听着曲儿，孤身一人径直东行。 其时正是初春，夜间冷雨来袭，更是寒气料峭。此时令狐冲内力虽不臻化境，却也已有些修为。只一炷香功夫，听着天竺梵文(经济学人)，沿川杨河，不觉已奔出20余里，来到入海口。 那数月正闹疫病，商户闭市，居民早歇，住宅区每个门口，村镇每条通路，皆有人把守昼夜不停。即便身后繁喧的过往远东第一大城，也不及同期热闹，更况是这郊野海边，原生态的渔村。 就这般至一孤岛，川杨河不复涛涛，平静归流入海。起眼处，一望无垠的太平洋，只有零星几点微弱灯火，从漆黑一片的浩瀚中穿透而来——那许是邮轮，也或是出海的渔家。而再行几步，是官兵屯驻之所，却也不见守备，与周遭一般侘寂。 华亭一马平川，无有名山高岳，不及其家齐鲁。令狐冲独立洲头，想往来诸事，似陈公子昂登幽州台，感岁月无痕，若湘潭毛公临橘子洲。杜工部于岱岳之巅，俯瞰众生，生孔夫子众山皆小，大致若此。王之涣于鹳雀楼，见九曲黄河东去，魏国故往山河，登楼穷目，亦非能外。 雨点密集，战场鼓点一般。生完浩叹，令狐冲摸摸湿透的衣衫，开始琢磨，这可咋回去 天地都在我心中","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"爽读数据2020","date":"2020-02-26T14:30:55.000Z","path":"2020/02/26/爽读数据2020/","text":"2019年『离结比』连续几年走高，登记结婚926万对，离婚404万对，离结比为44%——这意味着每有两对鸳鸯聚首，便有将近一对分手。 除西部三个省域，大陆地区各省份结婚人数均下降;除黑龙江，各省份离婚人数均上升。离结比最高的是四大直辖市和东三省，每两对人登记结婚，就有超过一对人离婚(京沪可能有 为买房假离婚现象)。 看过了太多未来预言，很多次提到，“婚姻”，这种人类社会最基础的组织形式，正在瓦解消亡。从数据看是有这种趋向。纵然过去几代人那种黏糊和凑合的婚姻，令崇尚自由的新一代人难以接受。但作为一件人生大事，“婚姻”如此快速得被解构，让内心相对保守的我有些慌，有话可聊，相携到老，竟成许多人奢望。 2018年出生人口1523万，连续三年下降，没有出现放开二胎，想象中的“婴儿潮”。预计2019年，新出生人口或锐减至1100万。 2018年死亡人口993万，其中有一半逝者为火葬。2019年，火化遗体数量最多的省为山东，67万具🙏。该年度山东省死亡人口为71.99万。 人口规模与山东相近的河南，2019年火化遗体数为12.9万具。河南省2018年死亡人口74万🙏。 江西省2019年遗体火化数增加71%。2018年，江西省死亡人口28万🙏。 2018年，中国男性人口7.1亿，女性6.8亿——这亦是“3000万光棍”推论的理论依据。实际上分摊到年龄段所占比例(如女性更长寿)，情况不至如此焦灼。但无可否认，许多地方，依然有性别鉴定，非法流产，买卖女婴状况。扭转这一根深蒂固观念非一代人之功，除去地产商，还得有其他方式加以遏制调节。","tags":[{"name":"区域经济","slug":"区域经济","permalink":"http://www.dashen.tech/tags/区域经济/"}]},{"title":"常见的垃圾回收算法","date":"2020-02-19T12:27:36.000Z","path":"2020/02/19/常见的垃圾回收算法/","text":"关于垃圾回收垃圾回收(Garbage Collection，简称GC)是编程语言中提供的内存管理功能。在传统的系统级编程语言（主要指C/C++）中，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。由于内存是有限的，所以当程序不再需要使用某个变量的时候，就需要销毁该对象并释放其所占用的内存资源，好重新利用这段空间。在C/C++中，释放无用变量内存空间的事情需要由程序员自己来处理(malloc分配内存,free释放内存)。就是说当程序员认为变量没用了，就手动地释放其占用的内存。但是这样显然非常繁琐，如果有所遗漏，就可能造成资源浪费甚至”内存泄露”。当软件系统比较复杂，变量多的时候程序员往往就忘记释放内存或者在不该释放的时候释放内存了。这对于程序开发人员是一个比较头痛的问题。为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的功能就被称为垃圾回收。 内存泄漏(memory leak) 由于疏忽或错误造成程序未能释放已经不再使用的内存。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak） 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费; 一次内存泄露危害可以忽略,但内存泄露堆积后果很严重,无论多少内存,迟早会被占光。 内存溢出(out of memory) 简称OOM,指应用系统中存在无法回收的内存或使用的内存过多, 最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了, 系统会提示内存溢出,有时候会自动关闭软件, 重启电脑或者软件后释放掉一部分内存又可以正常运行该软件; (从微观层面, 是指程序在申请内存时, 没有足够的内存空间供其使用, 出现out of memory；比如申请了一个int32,但给它存了int64才能存下的数，那就是内存溢出。) 内存泄露是造成内存溢出的其中一个原因，但是内存泄露不一定会造成内存溢出。简单来说，内存溢出就是占用内存太大，超过了系统可以承受的范围；而内存泄露则是由于对程序运行分配的对象回收不及时甚至于脆没有被回收，久而久之，则在系统分配的堆空间里面产生了很多无用的引用 常见方法 各种编程语言的实现都采用了哪些垃圾回收算法？这些算法都有哪些优点和缺点？ 引用计数法(reference counting) 基本思路是为每个对象加一个计数器，记录指向这个对象的引用数量。每次有一个新的引用指向这个对象，计数器加一；反之每次有一个指向这个对象引用被置空或者指向其他对象，计数器减一。当计数器变为 0 的时候，自动删除这个对象。 引用计数的优点是: 1）相对简单，不需要太多运行时（run-time）的支持，可以在原生不支持 GC 的语言里实现。(如C/C++?) 2）对象会在成为垃圾的瞬间被释放，不会给正常程序的执行带来额外中断。 引用计数的死穴是循环引用: 对象 A 包含一个引用指向对象 B ，同时对象 B 包含一个引用指向对象 A，计数器就抓瞎了。另外，引用计数对正常程序的执行性能有影响（每次引用赋值都要改计数器），特别是在多线程环境下（改计数器要加锁同步）。 PHP 5.3之前的GC,Python部分GC机制, 采用了该方法 Python中GC的垃圾回收算法分析 标记清除法(mark-sweep) 垃圾回收（GC） 的基本算法 基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 标记-清扫没有无法处理循环引用的问题，不触发 GC 时也不影响正常程序的执行性能。标记-清扫的问题是当内存耗尽触发 GC 时，需要中断正常程序一段时间来清扫内存，在内存大对象多的时候这个中断可能很长。 采用或者部分采用标记-清扫的例子,或采用该方法变种的例子非常多。实际应用中基于该算法的垃圾回收机制使用最广, Golang的三色标记法,便是基于此 复制收集法(copying) 基本思路是把整个内存空间一分为二，不妨记为 A 和 B。所有对象的内存在 A 中分配，当 A 塞满的时候，同样从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象复制到 B 去，然后对调 A 和 B 的角色。 相对于标记-清扫，节点复制的主要缺点是总有一半空间空闲着无法利用，另一个比较隐晦的缺点是它使用内存的方式与现有的内存换页、Cache 换入换出机制有潜在的冲突。但有个很大的优点： 所有的对象在内存中永远都是紧密排列的，所以分配内存的任务变得极为简单，只要移动一个指针即可。对于内存分配频繁的环境来说，性能优势相当大。另外，由于不需要清扫整个内存空间，所以如果内存中存活对象很少而垃圾对象很多的话（有些语言有这个倾向），触发 GC 造成的中断会小于标记-清扫法。 引用计数法和标记清除法两种方法都是在对象本身上操作的，也就是说清除和释放都是操作对象本身所在的位置，但是，GC 复制算法 就稍微复杂一些了 — 最原始的做法是将内存一分为二，每次只使用其他一半，当要 GC 的时候就将使用着的一半中的活动对象复制到另外一半中，然后清理掉这一半中的所有对象，直接使用另外一半即可，重复这个操作。 好处非常明显: 首先是速度快，没有额外的标记-清理操作，就是直接的复制，高吞吐；分配对象直接分配，不需要考虑碎片化问题；还可以保持与 OS 的缓存兼容。 弊端也很突出: 即空间的利用率不高;且不兼容保守式的 GC 算法;对于递归调用还会有栈溢出的风险。 所以为了更好的完善这个算法，还有有很多改进思路被提出，例如不是将空间划分为两部分，而是划分为多个部分，从而提升空间的利用率, 就是其中的一个思路。 Go中GC的实现及测验 Go垃圾回收 1：历史和原理 GO GC 垃圾回收机制 Proposal: Eliminate STW stack re-scanning 垃圾回收,主要是语言的虚拟机,或者运行时即runtime去做 1.3以前版本 STW（Stop The World） 100ms数量级 Golang的垃圾回收算法都非常简陋，其性能也广为诟病:go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后再启动所有任务的执行。 在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直无法忍受！这个时期国内外很多在生产环境实践go语言的团队, 都或多或少踩过gc的坑。当时解决这个问题比较常用的方法, 是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。 1.3 Mark STW, Sweep 并行 1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行, 并启动mark. mark完成后马上就重新启动被暂停的任务(之前是等sweep完之后再执行普通协程任务)，让sweep任务和普通协程任务一样并行地和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。 go team自己的说法是减少了50%-70%的暂停时间。 在这个版本后,Go语言在GC的sweep阶段,和程序员写的程序可以同时执行了(mark阶段程序员的程序还是处在停滞等待的)1.3之前,在进行垃圾回收时的sweep阶段时,程序员写的go func是处于等待状态的 1.5 三色标记法 10ms数量级 go 1.5 实现的垃圾回收器是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。 三色标记法 的mark操作是可以渐进执行的, 而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升，但是相对成熟的垃圾回收系统（如java jvm和javascript v8），go需要优化的路径还很长。 三色标记算法是对”标记清除法”标记阶段的改进，原理如下： 起初所有对象都是白色。 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。 重复 上一步，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。 三色标记的一个明显好处是能够让用户程序和 mark 并发的进行，具体可以参考论文：《On-the-fly garbage collection: an exercise in cooperation.》。这个版本Golang 的 GC 实现也是基于这篇论文. 在这个版本后,Go语言在GC的makr &amp; sweep阶段,和程序员写的程序可以同时执行了. 即GC运行时,程序员的程序可以不必等待了. 从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。 GC 的认识 1.8 混合写屏障（hybrid write barrier） 1ms数量级 这个版本的 GC 代码相比之前改动较大，采用一种混合的 write barrier 方式 （Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]）来避免 堆栈重新扫描。 Write Barrier是为了记录mark阶段新产生的对象。Golang 1.7 之前的 write barrier 使用的经典的 Dijkstra-style insertion write barrier [Dijkstra ‘78]， STW 的主要耗时就在 stack re-scan 的过程。自 1.8 之后采用一种混合的 write barrier 方式 （Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]）来避免 re-scan。具体的可以参考 17503-eliminate-rescan。 混合屏障的优势在于它允许堆栈扫描永久地使堆栈变黑（没有STW并且没有写入堆栈的障碍），这完全消除了堆栈重新扫描的需要，从而消除了对堆栈屏障的需求。重新扫描列表, 特别是堆栈障碍在整个运行时引入了显着的复杂性，并且干扰了来自外部工具（如GDB和基于内核的分析器）的堆栈遍历。 此外，与Dijkstra风格的写屏障一样，混合屏障不需要读屏障，因此指针读取是常规的内存读取; 它确保了进步，因为物体单调地从白色到灰色再到黑色。 混合屏障的缺点很小: 它可能会导致更多的浮动垃圾，因为它会在标记阶段的任何时刻保留从根（堆栈除外）可到达的所有内容。 golang 1.8 gc的演进 更多参考: Java虚拟机垃圾回收算法 深入理解java垃圾回收机制 JavaScript内存管理","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"善用搜索","date":"2020-02-17T03:32:38.000Z","path":"2020/02/17/善用搜索/","text":"快速搜索浏览器收藏夹中的内容 安装Vimium插件, 而后键入shift+b, 即可搜索 shift+/ 可以查看Vimium的全部命令 配置快捷操作 在地址栏输入g,而后敲击Tab键, 即可在github中进行搜索 同理,根据配置, 键入b而后Tab,则可使用B站搜索 键入w而后Tab,则可使用微信搜索 键入z而后Tab,则可使用知乎搜索 键入cn而后Tab,则可将中文翻译为英文 谷歌tips 必须包含或不能包含某关键字 在标题中必须要出现xxxx这个关键字: intext: xxxx 排除掉某个网站的内容: A -B 搜索包含A但不包含B的结果 如 xxxx -csdn.net,搜索xxxx关键字,但排除点csdn.net的内容 如 天涯明月刀 -游戏, 那就是只搜索电视剧或小说,不搜索游戏 filetype:指定搜索的文件类型 可以指定搜索的文件类型,如 filetype:pdf go语言, 其他搜索引擎也支持. 借鉴一下同行简历: filetype:pdf 简历 go开发 如果点击后发现是404,可在地址栏加一个cache:, 谷歌可能会有缓存 site:xxx网站 站内搜索 只从 .edu 结尾的网站上找寻要的内容 inurl:edu 电气电子 inurl指令用于搜索查询词出现在url 中的页面. 百度和谷歌都支持该指令。 其他匹配符 &quot;&quot;为完全匹配 *为模糊匹配 参考: 搜索技巧1 搜索技巧2","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"四种常用的磁盘调度算法","date":"2020-02-15T12:16:55.000Z","path":"2020/02/15/四种常用的磁盘调度算法/","text":"磁盘调度在多道程序设计的计算机系统中，各个进程可能会不断提出不同的对磁盘进行读/写操作的请求。由于有时候这些进程的发送请求的速度比磁盘响应的还要快，因此我们有必要为每个磁盘设备建立一个等待队列，常用的磁盘调度算法有以下四种： 先来先服务算法（FCFS）， 最短寻道时间优先算法（SSTF）， 扫描算法（SCAN）， 循环扫描算法（CSCAN） 例:假定某磁盘共有200个柱面，编号为0-199，如果在为访问143号柱面的请求者服务后，当前正在为访问125号柱面的请求服务，同时有若干请求者在等待服务，它们每次要访问的柱面号为 86，147，91，177，94，150，102，175，130 1、先来先服务算法（FCFS）First Come First Service 这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。 先来先服务 （125）86.147.91.177.94.150.102.175.130 2、最短寻道时间优先算法（SSTF） Shortest Seek Time First 该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。 最短寻道时间优先（125）130.147.150.175.177.102.94.91.86 3、扫描算法（SCAN）电梯调度 扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。 电梯调度（125）102.94.91.86.130.147.150.175.177 4、循环扫描算法（CSCAN） 循环扫描算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。 循环扫描 （125）130.147.150.175.177.86.91.94.102","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"perf使用浅析","date":"2020-02-06T08:43:49.000Z","path":"2020/02/06/perf使用浅析/","text":"http://walkerdu.com/2018/09/13/perf-event/ https://www.cnblogs.com/ber619/p/13431817.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"有关内存对齐","date":"2020-02-03T10:14:42.000Z","path":"2020/02/03/有关内存对齐/","text":"在内存分配时,是以8 Byte为单位的. 故而任何变量的内存大小都肯定是8的倍数 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"reflect\")type X struct &#123; a int b int8 c int8&#125;type Y struct &#123; a int8 b int c int8&#125;func main() &#123; var s1 X var s2 Y fmt.Printf(\"struct size:%d,%d\\n\", reflect.TypeOf(s1).Size(), reflect.TypeOf(s2).Size())&#125; 1struct size:16,24 为何会出现这样的差异? int类型占8个Byte (和机器是32位还是64位,以及go版本有关. 64位机器int一般占8字节即64位) 而int8 只占1个字节即8个位 12345678type X struct &#123; // 第0~7个byte 被分配 a int // 第8个byte 被分配 b int8 // 第9个byte 被分配 c int8&#125; 因为内存分配时都是以 8 Byte为最小单位,故而s1占16个Byte 而对于 123456789type Y struct &#123; // 第0个byte 被分配 a int8 // 之后的第1~7这7个byte,盛不下需要8个byte的int, 由于内存对齐规则,b需要单独占用第8~15这块空间 // 第8~15个byte 被分配 b int // 第16个byte 被分配(此时共占了17个byte,因为内存分配时都是以 `8 Byte`为最小单位,故而s2占24个Byte) c int8&#125; 一个设计良好的结构体,可以节省很多的内存空间 参考: 私有笔记 在 Go 中恰到好处的内存对齐 Go的内存对齐和指针运算详解和实践 《Go语言实战》笔记(二十六) | Go unsafe 包之内存布局golang内存对齐 聊一聊字节对齐 找工作知识储备(1)—内存对齐 #84 图解 Go 内存对齐 第 84 期图解 Go 之内存对齐","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"内存屏障","date":"2020-02-03T06:04:08.000Z","path":"2020/02/03/内存屏障/","text":"内存屏障，也称内存栅栏，内存栅障，屏障指令等， 是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后…","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"亲测体验mysql联合索引的失效","date":"2020-02-01T16:19:20.000Z","path":"2020/02/02/亲测体验mysql联合索引的失效/","text":"前文说到,可以通过联合索引,解决Innodb二级索引的回表问题, 如何解决Innodb二级索引的二次查询问题(回表) — 建立联合索引 联合索引 也称 复合索引,覆盖索引,多列索引,组合索引, 与之对应的是单列索引 只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。 123一个包含查询所需字段的索引称为“覆盖索引”MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提高了效率 常见的方法是：将被查询的字段，建立到联合索引里去。 亲测体验 123456create table user ( id int primary key, name varchar(20), sex varchar(5), index(name))engine=innodb; 注: 当select *且where或order by的字段为主键索引id时,自然也无需回表即可查到所有内容 联合索引的创建原则 对于联合索引(abc), 基于最左匹配原则, 匹配条件为 a,ab,abc,acb时,均可以用上该索引,而b,c,bc则使用不到索引 最可能被单独使用的排在最前面. where或order by的顺序不需要按照联合索引的顺序 当有&gt;或&lt;操作,该字段还可以使用索引,但该列之后将出现断点,无法再用索引 最左匹配原则: mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 更多可参考","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"time_wait和close_wait","date":"2020-02-01T15:23:23.000Z","path":"2020/02/01/time-wait和close-wait/","text":"➜ ~ netstat -nat |grep TIME_WAIT tcp4 0 0 127.0.0.1.64158 127.0.0.1.64157 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64161 TIME_WAIT tcp4 0 0 127.0.0.1.64163 127.0.0.1.64162 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64166 TIME_WAIT tcp4 0 0 127.0.0.1.64168 127.0.0.1.64167 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64170 TIME_WAIT tcp4 0 0 127.0.0.1.64172 127.0.0.1.64171 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64173 TIME_WAIT tcp4 0 0 127.0.0.1.64175 127.0.0.1.64174 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64176 TIME_WAIT tcp4 0 0 127.0.0.1.64178 127.0.0.1.64177 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64181 TIME_WAIT tcp4 0 0 127.0.0.1.64183 127.0.0.1.64182 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64185 TIME_WAIT tcp4 0 0 127.0.0.1.64187 127.0.0.1.64186 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64190 TIME_WAIT tcp4 0 0 127.0.0.1.64192 127.0.0.1.64191 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64194 TIME_WAIT tcp4 0 0 127.0.0.1.64196 127.0.0.1.64195 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64197 TIME_WAIT tcp4 0 0 127.0.0.1.64199 127.0.0.1.64198 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64200 TIME_WAIT tcp4 0 0 127.0.0.1.64202 127.0.0.1.64201 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64203 TIME_WAIT tcp4 0 0 127.0.0.1.64205 127.0.0.1.64204 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64206 TIME_WAIT tcp4 0 0 127.0.0.1.64208 127.0.0.1.64207 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64211 TIME_WAIT tcp4 0 0 127.0.0.1.64213 127.0.0.1.64212 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64214 TIME_WAIT tcp4 0 0 127.0.0.1.64216 127.0.0.1.64215 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64217 TIME_WAIT tcp4 0 0 127.0.0.1.7890 127.0.0.1.64220 TIME_WAIT tcp4 0 0 172.16.13.74.64221 220.181.76.250.80 TIME_WAIT tcp4 0 0 127.0.0.1.64219 127.0.0.1.64218 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64223 TIME_WAIT tcp4 0 0 127.0.0.1.64225 127.0.0.1.64224 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64229 TIME_WAIT tcp4 0 0 172.16.13.74.64232 61.151.165.102.80 TIME_WAIT tcp4 0 0 172.16.13.74.64233 61.151.165.102.80 TIME_WAIT tcp4 0 0 127.0.0.1.64231 127.0.0.1.64230 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64236 TIME_WAIT tcp4 0 0 127.0.0.1.64238 127.0.0.1.64237 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64240 TIME_WAIT tcp4 0 0 127.0.0.1.64242 127.0.0.1.64241 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64243 TIME_WAIT tcp4 0 0 127.0.0.1.64245 127.0.0.1.64244 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64248 TIME_WAIT tcp4 0 0 127.0.0.1.64250 127.0.0.1.64249 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64251 TIME_WAIT tcp4 0 0 127.0.0.1.64253 127.0.0.1.64252 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64254 TIME_WAIT tcp4 0 0 127.0.0.1.64256 127.0.0.1.64255 TIME_WAIT tcp4 0 0 127.0.0.1.54530 127.0.0.1.64257 TIME_WAIT netstat -a | grep TIME_WAIT | wc -l TIME_WAIT的出现，是为了解决网络的丢包和网络不稳定所带来的其他问题： 防止前一个连接(五元组) 上延迟的数据包或者丢失重传的数据包，(恰巧)被后面复用的连接错误的接收 确保连接方能在时间范围内，关闭自己的连接。（其实，也是因为丢包造成的） 如果没有time_wait，会有几率，造成数据错乱，或 短暂性的连接失败 dmesg | grep “TCP established hash table” [ 0.525614] TCP established hash table entries: 16384 (order: 5, 131072 bytes) dmesg | grep “TCP bind hash table” [ 0.527224] TCP bind hash table entries: 16384 (order: 6, 262144 bytes) TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。 查看TIME_WAIT状态的连接数量： netstat -nat | grep : 端口号 | grep TIME_WAIT | wc -l TIME_WAIT状态多，简单的说就是服务端主动关闭了TCP连接。 TCP频繁的建立连接，会有一些问题： 三次握手建立连接、四次握手断开连接都会对性能有损耗； 断开的连接断开不会立刻释放，会等待2MSL的时间，据我观察是1分钟； 大量TIME_WAIT会占用内存，一个连接实测是3.155KB。而且占用太多，有可能会占满端口，一台服务器最多只能有6万多个端口； Golang 优化之路——HTTP长连接 MSL:最长报文段寿命(Maximum segment lifetime, MSL) Linux性能优化–怎样解决恼人的TIME_WAIT问题 TCP TIME-WAIT 笔记 ss命令：用来显示套接字信息的，类似于netstat，可以显示更多的信息，用于替代netstat","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"黄冈新建小竹楼记","date":"2020-01-28T13:51:39.000Z","path":"2020/01/28/黄冈新建小竹楼记/","text":"提及北宋初年的直臣，第一印象可能有寇准，包拯，范仲淹，恐很难有人想到王禹偁。尽管也有诗作，且这位老乡最推崇杜工部白乐天，但我是被他幽趣盎然的『黄冈新建小竹楼记』圈粉。同写自贬谪期间，历代多有文学评论家，认为该作比之前柳宗元的“得意诸记”，和小他半个世纪的小拥趸欧阳修的&lt;醉翁亭记&gt;，“雅素隽洁”，更胜一筹。诸人多以第二段为精妙，“远吞山光，急雨密雪，瀑声碎玉，丁丁铮铮”。然余独喜末二:听闻竹子做屋瓦，只能用十年。如覆盖两层，则可用二十年。我四年之中，奔走不停，还不知明年又去往何方，还怕竹楼年久朽坏？五年里四处流窜打过六份工的人，默默点赞，示作认同。果然，两年后又被贬至蕲州，未过一个月即亡，年四十八岁。蕲州即今日黄冈下辖蕲春县，至明代，这里出过一位顶了不起的中医，有巨作『本草纲目』。此后又数百年，有一位籍贯于此的“二愣子”，曾自号互联网时代的李时珍，有公司“250+110”。王禹偁死后整100年，又有一位因太过耿直而屡遭贬谪的文人，客死于从边鄙流放之地的琼岛，一路北归途中。虽生前不算腾达，但在同代达官显贵都早作齑粉灰烬时，其人对黄冈，甚于对中国文学史乃至文化史，都还有无可忽视的巨大影响。又近千年，黄州生疫疾，有主任名唐，据公文，“夙兴夜寐，抛家舍幼”。然钦差问讯，不知何言唯以沉默对，俄而即贬。亦有人道: 其非不知，难言矣。(略..) 黄冈之地多竹，大者如椽，竹工破之，刳去其节，用代陶瓦。比屋皆然，以其价廉而工省也。 子城西北隅，雉堞圮毁，蓁莽荒秽，因作小楼二间，与月波楼通。远吞山光，平挹江濑，幽阒辽夐，不可具状。夏宜急雨，有瀑布声；冬宜密雪，有碎玉声；宜鼓琴，琴调和畅；宜咏诗，诗韵清绝；宜围棋，子声丁丁然；宜投壶，矢声铮铮然；皆竹楼之所助也。 公退之暇，被鹤氅衣，戴华阳巾，手执《周易》一卷，焚香默坐，消遣世虑。江山之外，第见风帆沙鸟，烟云竹树而已。待其酒力醒，茶烟歇，送夕阳，迎素月，亦谪居之胜概也。 彼齐云、落星，高则高矣；井干、丽谯，华则华矣；止于贮妓女，藏歌舞，非骚人之事，吾所不取。 吾闻竹工云，竹之为瓦，仅十稔。若重覆之，得二十稔。噫，吾以至道乙未岁，自翰林出滁上，丙申移广陵；丁酉又入西掖，戊戌岁除日有齐安之命，己亥闰三月到郡。四年之间，奔走不暇，未知明年又在何处，岂惧竹楼之易朽乎！后之人与我同志，嗣而葺之，庶斯楼之不朽也！ 咸平二年八月十五日记。 扩展阅读: 黄州新建小竹楼记 / 黄州竹楼记 大宋朋友圈 | 王禹偁 一只会写诗的啄木鸟","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"盛唐之殇--观<长安十二时辰>记","date":"2020-01-24T15:47:58.000Z","path":"2020/01/24/盛唐之殇-观-长安十二时辰-记/","text":"追完了『长安十二时辰』，一部为过审，改的支离破碎面貌全非的历史悬疑剧。大概是想强行凑够“十二时辰”，更是为增加集数收回成本，后期太过拖沓烂尾明显。 细细想来，“出道即巅峰”，却最终“狗尾续貂”的作品实在不少，从白先勇『台北人』，到『三国杀』桌游。而影视剧中，&lt;大染坊2&gt;，&lt;神医喜来乐2&gt;，&lt;大宋提刑官2&gt;，&lt;闯关东2&gt;，无一不是前作可称经典，续作难堪优秀。欧美剧如&lt;神探夏洛克&gt;，&lt;生活大爆炸&gt;，亦有此症结。这般比较，更能领会随剧而终的&lt;大侦探波罗&gt;，几十年来水准一直在线，殊是难得。 按天宝三载计，为公元745年。 实际上，作为有唐一代福禄寿考之典范，归宿最好的诗人&amp;政客，这时贺知章可能已经去世(约659-约744年)。 剧中曾假”何执正”之口说“十年内，长安必乱”。10年后的755年，安史之乱爆发，成为划开盛唐与中晚唐之泾渭。 后来写出『安禄山事迹』的姚汝能，在狱中奉劝27岁的岑参: “给你指条明路，去西域发展，长安，你混不了”。 当年度，岑参考中进士，两度从军边塞。但出场吟诵的“忽如一夜春风来，千树万树梨花开”，实际写于9年后的天宝十三载。 当年按兵不援，导致烽燧堡惨剧的盖嘉运，历史上颇有建树。最知名的吹捧诗作，即出自岑参之手---『玉门关盖将军』，最后四句“我来塞在按边储，为君取醉酒剩沽。醉争酒盏相喧呼，忽忆咸阳旧酒徒”。联系此剧，会觉违和。 后来依靠裙带关系，杨国忠逐渐掌权，口蜜腹剑的李林甫渐渐边缘，8年后病死，随后按谋反清算，子孙多被流放岭南黔中。 而外番安禄山与朝堂杨国忠矛盾激化，又过两年，以“诛国忠 清君侧”为由发动叛乱。自此天旋地转，一年后，玄宗败撤蜀中避难，专权误国，败坏朝纲的祸首，在马嵬坡，被失去小拇指的前弓弩手张小敬射杀，记录于姚汝能『安禄山事迹』中，(除了这名这事，别的都为编纂)。时年71岁的李三郎痛失所爱，羁旅夜雨，想念“严羽幻”，作『雨霖铃』。后宋人柳三变，将此词牌发扬光大。 “二月春风似剪刀”政治讽喻诗的解释，不身临其境当真get不到。 相比之下，作为“为人不识陈近南，纵使英雄也枉然”的原版，李太白“生不用封万户侯，但愿一识韩荆州”，享谪仙这般盛誉的韩朝宗，首先顾及的，不是留名千古的欣喜，更多为眼下的坐立不安。 大将军王忠嗣，奏言安禄山必反，又与李林甫不睦，被安以“欲奉太子即位”而遭贬，并在4年后郁郁而终(以剧情发生的745年为时间基准)。 剧中的士人领袖，宁王之孙，当为与李白，贺知章，焦遂，张旭，李适之，崔宗之同位列『饮中八仙歌』的汝阳王李琎。 吉州永新县(今吉安永新)百姓温饱未及，而舍命供奉打点，希冀其村姑许合子，能得圣人恩宠，成杨太真第二，以免税赋徭役。历史上许合子为著名歌唱家，可以和春秋时期留下成语“余音绕梁”的韩娥，及西汉武帝时谱下『佳人曲』的李延年齐名。安史乱后，流落风尘。…但不常见于诗词经传，后人所知，有唐最知名歌唱家是李龟年。 见风使舵善于逢迎的元载，时年32岁。后来果真平步青云，深得宠信，官至宰相。其独揽朝政专横跋扈，但也提拔任用刘晏进行财税体系改革，为乱后残缺的大唐又续命百载。 太子李亨，后来在灵武登基，即为肃宗。在郭子仪等人帷幄拼杀下，平定了叛乱。但他算不得一位好皇帝，在玄宗病逝后十多天，为权宦政变惊惧而死。 与李亨本幼年交好的永王李璘，无奈生于皇家，成年后与兄长反目。八年战乱期间，也起兵自立。一把年纪，本在天柱山避难，顺道炼丹修仙的李白，政治觉悟极低站错了队。而后永王兵败身死江西赣州，李白也被刺配。行至白帝城遇大赦，遂有“朝辞白帝彩云间，千里江陵一日还”。 少年英杰李泌，时年23岁，北周太师李弼之后，七岁能文，被称神童。一生几起几落，为国为民，内修外联，颇有建树。 宦官在古代，几乎不曾能有好名声，蔡伦郑和可算作寥寥例外。而皇帝的贴身太监，基本脸谱是专横跋扈，贪财弄权。因“力士脱靴，贵妃捧砚”留名的高力士，亦难逃此印象。剧集里他有贪财瑕疵，却是极为关键的正派人物。历史上对其评价亦高，一生对玄宗忠心耿耿，不离不弃。被誉“千古贤宦第一”，死后陪葬于泰陵。 姊妹篇: 起承转合–由陈子昂&lt;国殇&gt; 姊妹篇: 渔阳鞞鼓","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"围炉夜话","date":"2020-01-19T12:47:54.000Z","path":"2020/01/19/围炉夜话/","text":"我再也难忘“可导一定连续，连续不一定可导”，还真就是那副狂风吹倒一片自行车的图----像多米诺骨牌，会“倒”下，说明一定连续；但连续却不意味着一定可“倒”——比如有的自行车支撑系统贼拉好，就是扛住了冲击。 现在，对矩阵的秩,“相似必合同，合同必等价”，也有了耳目一新的全新认知😂","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"math/rand包源码剖析","date":"2020-01-19T02:16:56.000Z","path":"2020/01/19/math-rand包源码剖析/","text":"关于伪随机数生成算法 伪随机数生成器（pseudo random number generator，PRNG），又被称为确定性随机比特生成器（deterministic random bit generator，DRBG），是一个生成数字序列的算法，其特性近似于随机数序列的特性。PRNG生成的序列并不是真随机，因此它完全由一个初始值决定，这个初始值被称为PRNG的随机种子（seed，但这个种子可能包含真随机数）。尽管接近于真随机的序列可以通过硬件随机数生成器生成，但伪随机数生成器因为其生成速度和可再现的优势，在实践中也很重要 伪随机数生成器 线性同余发生器与伪随机数 如何评价一个伪随机数生成算法的优劣？ 计算机取随机数是什么原理，是真正的随机数吗？ 5 均匀分布随机数生成 浅谈随机数发生器","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"归并排序","date":"2020-01-15T11:11:35.000Z","path":"2020/01/15/归并排序/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"柳子厚墓志铭","date":"2020-01-08T14:58:26.000Z","path":"2020/01/08/柳子厚墓志铭/","text":"子厚，讳宗元。七世祖庆，为拓跋魏侍中，封济阴公。曾伯祖奭，为唐宰相，与褚遂良、韩瑗俱得罪武后，死高宗朝。皇考讳镇，以事母弃太常博士，求为县令江南。其后以不能媚权贵，失御史。权贵人死，乃复拜侍御史。号为刚直，所与游皆当世名人。 子厚少精敏，无不通达。逮其父时，虽少年，已自成人，能取进士第，崭然见头角。众谓柳氏有子矣。其后以博学宏词，授集贤殿正字。俊杰廉悍，议论证据今古，出入经史百子，踔厉风发，率常屈其座人。名声大振，一时皆慕与之交。诸公要人，争欲令出我门下，交口荐誉之。 贞元十九年，由蓝田尉拜监察御史。顺宗即位，拜礼部员外郎。遇用事者得罪，例出为刺史。未至，又例贬永州司马。居闲，益自刻苦，务记览，为词章，泛滥停蓄，为深博无涯涘。而自肆于山水间。 元和中，尝例召至京师；又偕出为刺史，而子厚得柳州。既至，叹曰：“是岂不足为政邪？”因其土俗，为设教禁，州人顺赖。其俗以男女质钱，约不时赎，子本相侔，则没为奴婢。子厚与设方计，悉令赎归。其尤贫力不能者，令书其佣，足相当，则使归其质。观察使下其法于他州，比一岁，免而归者且千人。衡湘以南为进士者，皆以子厚为师，其经承子厚口讲指画为文词者，悉有法度可观。 其召至京师而复为刺史也，中山刘梦得禹锡亦在遣中，当诣播州。子厚泣曰：“播州非人所居，而梦得亲在堂，吾不忍梦得之穷，无辞以白其大人；且万无母子俱往理。”请于朝，将拜疏，愿以柳易播，虽重得罪，死不恨。遇有以梦得事白上者，梦得于是改刺连州。呜呼！士穷乃见节义。今夫平居里巷相慕悦，酒食游戏相征逐，诩诩强笑语以相取下，握手出肺肝相示，指天日涕泣，誓生死不相背负，真若可信；一旦临小利害，仅如毛发比，反眼若不相识。落陷穽，不一引手救，反挤之，又下石焉者，皆是也。此宜禽兽夷狄所不忍为，而其人自视以为得计。闻子厚之风，亦可以少愧矣。 子厚前时少年，勇于为人，不自贵重顾籍，谓功业可立就，故坐废退。既退，又无相知有气力得位者推挽，故卒死于穷裔。材不为世用，道不行于时也。使子厚在台省时，自持其身，已能如司马刺史时，亦自不斥；斥时，有人力能举之，且必复用不穷。然子厚斥不久，穷不极，虽有出于人，其文学辞章，必不能自力，以致必传于后如今，无疑也。虽使子厚得所愿，为将相于一时，以彼易此，孰得孰失，必有能辨之者。 子厚以元和十四年十一月八日卒，年四十七。以十五年七月十日，归葬万年先人墓侧。子厚有子男二人：长曰周六，始四岁；季曰周七，子厚卒乃生。女子二人，皆幼。其得归葬也，费皆出观察使河东裴君行立。行立有节概，重然诺，与子厚结交，子厚亦为之尽，竟赖其力。葬子厚于万年之墓者，舅弟卢遵。遵，涿人，性谨慎，学问不厌。自子厚之斥，遵从而家焉，逮其死不去。既往葬子厚，又将经纪其家，庶几有始终者。铭曰：“是惟子厚之室，既固既安，以利其嗣人。” 子厚，名叫宗元。七世祖柳庆，做过北魏的侍中，被封为济阴公。高伯祖柳奭，做过唐朝的宰相，同褚遂良、韩瑗都得罪了武后，在高宗时被处死。父亲叫柳镇，为了侍奉母亲，放弃了太常博士的官位，请求到江南做县令。后来因为他不肯向权贵献媚，丢了御史的官职。直到那位权贵死了，才又被任命为侍御史。人们都说他刚毅正直，与他交往的都是当时名人。 子厚少年时就很精明聪敏，没有不明白通晓的事。赶上他父亲在世时，他虽然很年轻，但已经成才，能够考取为进士，突出地显露出才华，大家都说柳家有能扬名显姓的后人了。后来又通过博学宏词科的考试，被授为集贤殿的官职。他才能出众，方正勇敢，发表议论时能引证今古事例为依据，精通经史诸子典籍，议论时才华横溢，滔滔不绝，常常使在座的人折服。因此名声轰动，一时之间人们都敬慕而希望与他交往。那些公卿贵人争着想让他成为自己的门生，异口同声的推荐赞誉他。 贞元十九年，子厚由蓝田县尉调任监察御史。顺宗即位，又升为礼部员外郎。逢遇当权人获罪，他也被按例贬出京城当刺史，还未到任，又被依例贬为永州司马。身处清闲之地，自己更加刻苦为学，专心诵读，写作文，文笔汪洋恣肆，雄厚凝练，像无边的海水那样精深博大。而他自己则纵情于山水之间。 元和年间，他曾经与同案人一起奉召回到京师，又一起被遣出做刺史，子厚分在柳州。到任之后，他慨叹道：“这里难道不值得做出政绩吗？”于是按照当地的风俗，为柳州制订了教谕和禁令，全州百姓都顺从并信赖他。当地习惯于用儿女做抵押向人借钱，约定如果不能按时赎回，等到利息与本金相等时，债主就把人质没收做奴婢。子厚为此替借债人想方设法，都让他们把子女赎了回来；那些特别穷困没有能力赎回的，就让债主记下子女当佣工的工钱，到应得的工钱足够抵消债务时，就让债主归还被抵押的人质。观察使把这个办法推广到别的州县，到一年后，免除奴婢身份回家的将近一千人。衡山、湘水以南准备考进士的人，就把子厚当做老师，那些经过子厚亲自讲授和指点的人所写的文章，全都可以看得出是合乎规范的。 他被召回京师又再次被遣出做刺史时，中山人刘梦得禹锡也在被遣之列，应当去播州。子厚流着泪说：“播州不是一般人能住的地方，况且梦得有老母在堂，我不忍心看到梦得处境困窘，他没有办法把这事告诉他的老母；况且绝没有母子一同前往的道理。”向朝廷请求，并准备呈递奏章，情愿拿柳州换播州，表示即使因此再度获罪，死也无憾。正遇上有人把梦得的情况告知了皇上，梦得因此改任连州刺史。呜呼！士人到了穷境时，才看得出他的节操和义气！一些人，平日街坊居处互相仰慕讨好，一些吃喝玩乐来往频繁，夸夸其谈，强作笑脸，互相表示愿居对方之下，手握手作出掏肝挖肺之状给对方看，指着天日流泪，发誓不论生死谁都不背弃朋友，简直像真的一样可信。一旦遇到小小的利害冲突，仅仅象头发丝般细小，便翻脸不认人，朋友落入陷阱，也不伸一下手去救，反而借机推挤他，再往下扔石头，到处都是这样的人啊！这应该是连那些禽兽和野蛮人都不忍心干的，而那些人却自以为得计。他们听到子厚的高尚风节，也应该觉得有点惭愧了！ 子厚从前年轻时，勇于帮助别人，自己不看重和爱惜自己，认为功名事业可以一蹴而就，所以受到牵连而被贬斥。贬谪后，又没有熟识而有力量有地位的人推荐与引进，所以最后死在荒僻的边远之地，才干不能为世间所用，抱负不能在当时施展。如果子厚当时在御史台、尚书省做官时，能谨慎约束自己，已像在司马时、刺史时那样，也自然不会被贬官了；贬官后，如果有人能够推举他，将一定会再次被任用，不至穷困潦倒。然而若是子厚被贬斥的时间不久，穷困的处境未达到极点，虽然能够在官场中出人投地，但他的文学辞章一定不能这样地下功夫，以致于象今天这样一定流传后世，这是毫无疑问的。即使让子厚实现他的愿望，一度官至将相，拿那个换这个，何者为得，何者为失？一定能有辨别它的人。 子厚在元和十四年十一月初八去世，终年四十七岁；在十五年七月初十安葬在万年县他祖先墓地的旁边。子厚有两个儿子：大的叫周六，才四岁；小的叫周七，是子厚去世后才出生的。两个女儿，都还小。他的灵柩能够回乡安葬，费用都是观察使河东人裴行立先生付出的。行立先生为人有气节，重信用，与子厚是朋友，子厚对他也很尽心尽力，最后竟仰赖他的力量办理了后事。把子厚安葬到万年县墓地的，是他的表弟卢遵。卢遵是涿州人，性情谨慎，做学问永不满足；自从子厚被贬斥之后，卢遵就跟随他和他家住在一起，直到他去世也没有离开；既送子厚归葬，又准备安排料理子厚的家属，可以称得上是有始有终的人了。 铭文说：“这是子厚的幽室，既牢固又安适，对子厚的子孙会有好处。”","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"McCabe度量法","date":"2020-01-05T13:14:08.000Z","path":"2020/01/05/McCabe度量法/","text":"概论: McCabe度量法是由 托马斯·麦克凯 提出的一种基于程序控制流的复杂性度量方法。又称环路度量，循环复杂度（Cyclomatic complexity）， 也称为条件复杂度或圈复杂度，是一种软件度量。它认为程序的复杂性很大程度上取决于程序图的复杂性。单一的顺序结构最为简单，循环和选择所构成的环路越多，程序就越复杂。 McCabe度量法以图论为工具，先画出程序图，然后用该图的环路数作为程序复杂性的度量值。程序图是退化的程序流程图。也就是说，把程序流程图的每一个处理符号都退化成一个结点，原来连接不同处理符号的流线变成连接不同结点的有向弧，这样得到的有向图就叫做程序图。 根据图论，在一个强连通的有向图G中，环的个数V(G)由以下公式给出： $$V(G)=m-n+2$$ 其中，V(G)是有向图G中环路数，m是图G中弧数，n是图G中结点数，p是图G中强连通分量个数。在一个程序中，从程序图的入口点总能到达图中任何一个结点，因此，程序总是连通的，但不是强连通的。为了使图成为强连通图，从图的出口点到入口点加一条用虚线表示的有向边，使图成为强连通图。这样就可以使用上式计算环路复杂性了。 有的也有用E来代表图G中弧数,即 $$V(G)=E-N+2$$ 例题: 例1 采用McCabe度量法计算下图所示程序的环路复杂性为（ ） A.1 &nbsp;B.2 &nbsp;C.3 &nbsp;D.4 &nbsp; 解: 环形复杂度 $V（G）=M-N+2$，其中，E是流图中边的条数，M是结点数。 即 V(G) = 11-10+2 = 3 例2 下图用 白盒测试 方法进行测试，图中有（ ）条路径。采用McCabe度量计算该程序图的环路复杂性为（ ） 问题1 选项 A.3 &nbsp; B.4 &nbsp; C.5 &nbsp; D.6 &nbsp; 问题2 选项 A.3 &nbsp; B.4 &nbsp; C.5 &nbsp; D.6 &nbsp; 解: 将所有结点标注序号，根据图示，可以找到不同的路径共4条： 1-2-3-11；1-2-3-4-5-6-10-11；1-2-3-4-5-7-9-10-11；1-2-3-4-5-7-8-9-10-11。 第一空选择B选项。 根据环路复杂度计算公式 $V（G）=M-N+2=13-11+2=4$，第二空选择B选项。 例3 对下图所示的程序流程图进行判定 覆盖测试，则至少需要（ ）个测试用例。采用 McCabe度量法计算其环路复杂度为（ ）。 问题1选项 A.2 &nbsp; B.3 &nbsp; C.4 &nbsp; D.5 &nbsp; 问题2选项 A.2 &nbsp; B.3 &nbsp; C.4 &nbsp; D.5 &nbsp; 解: 判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。根据题意，只需2个测试用例即可； 根据环路复杂度的计算公式 $V（G）=m-n+2=11-10+2=3$ 判定覆盖（分支覆盖） 判定覆盖与条件覆盖的区别 软件测试中条件覆盖，路径覆盖，语句覆盖，分支覆盖的区别 例4 对下图所示流程图采用白盒测试方法进行测试，若要满足路径覆盖，则至少需要（ ）个测试用例。采用McCabe度量法计算该程序的环路复杂性为（ ） 问题1选项 A.3&nbsp; B.4&nbsp; C.6&nbsp; D.8&nbsp; 问题2选项A.1&nbsp;B.2&nbsp;C.3&nbsp;D.4&nbsp; 解: 问题1考查白盒测试路径覆盖：覆盖所有可能的路径。 根据流程图，若要覆盖所有可能路径，对于a的取值需要a=0，a&lt;0，a&gt;0三种用例，而对于i的取值需要i&gt;0和i&lt;=0两种用例，排列组合，共需要6组用测才能覆盖所有可能的路径。 问题2对于环形复杂度计算，根据公式 $V（G）=E-N+2$，其中，E是流图中边的条数，N是结点数。 $V（G）=E-N+2=10-8+2=4$。 例5 采用McCabe度量法计算下列程序图的环路复杂性为（ ） 问题1选项 A.2&nbsp; B.3&nbsp; C.4&nbsp; D.5&nbsp; 解: McCabe度量法先画出程序图，然后采用公式V（G）=m-n+2计算环路复杂度，其中m是有向弧的数量，n是结点的数量。 10-8+2=4。 例6 对以下的程序伪代码（用缩进表示程序块）进行路径覆盖测试，至少需要（ ）个测试用例。采用McCabe度量法计算其环路复杂度为（ ）。 问题1选项 A.2&nbsp;B.4&nbsp;C.6&nbsp;D.8&nbsp; 问题2选项A.2&nbsp;B.3&nbsp;C.4&nbsp;D.5&nbsp; 对于本题，用例（x，y，z）分别为（1，1，0）（1，-1，0）（-1，0，1）（-1，0，-1），这4个测试用例可以走完所有可能路径。因为在伪代码中，我们可以看到，当x&gt;0时，只需要对Y分别取大于0和不大于0的值即可，z不参与比较；当x不大于0时，只需要对z分别取大于0和不大于0的值即可，y不参与比较，只需要4个用例即可。 对于第二空，转换为结点图如下： &nbsp;根据$V（G）=m-n+2$，其中m是有向图的弧，为15，n为有向图的节点数，为13，15-13+2=4，即环路复杂的为4。 例7 下图所示的程序流程图中有（ &nbsp;）条不同的简单路径。采用McCabe度量法计算该程序图的环路复杂性为（ &nbsp;） 问题1选项 A.3&nbsp;B.4&nbsp;C.5&nbsp;D.6&nbsp; 问题2选项 A.3&nbsp;B.4&nbsp;C.5&nbsp;D.6&nbsp; 解: 环形复杂度定量度量程序的逻辑复杂度。描绘程序控制流的流图之后，可以用下述3种方法中的任何一种来计算环形复杂度。 （1）流图中的区域数等于环形复杂度。 （2）流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是结点数。 （3）流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。 这种环路度量法，计算的思路是这样的：它是考虑控制的复杂程度，即条件选择的分支繁杂程度。 图中有3次简单的判断。故3条简单路径，形成3块环形区域，区域复杂度为3 例8 软件的复杂性主要体现在程序的复杂性。（ &nbsp;）是度量软件复杂性的一个主要参数。若采用McCabe度量法计算环路复杂性，则对于下图所示的程序图，其环路复杂度为（ &nbsp;）。 问题1选项 A.代码行数&nbsp;B.常量的数量&nbsp;C.变量的数量&nbsp;D.调用的库函数的数量&nbsp; 问题2选项 A.2&nbsp;B.3&nbsp;C.4&nbsp;D.5&nbsp; 解: 代码行数度量法以程序的总代码行数作为程序复杂性的度量值。 McCabe度量法先画出程序图，然后采用公式 $V(G)=m-n+2$ 计算环路复杂度，其中m是有向弧的数量，n是结点的数量。在本题中，结点数为9，弧为11，所以环路复杂度为11-9+2=4。 参考: McCabe度量方法计算程序复杂度 希赛题库","tags":[{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"Go expvar包","date":"2020-01-03T11:59:01.000Z","path":"2020/01/03/Go-expvar包/","text":"介绍与使用 expvar 是 exposed variable的简写 expvar包是 Golang 官方为暴露Go应用内部指标数据所提供的标准对外接口，可以辅助获取和调试全局变量。 其通过init函数将内置的expvarHandler(一个标准http HandlerFunc)注册到http包ListenAndServe创建的默认Server上 如以下案例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package mainimport ( \"encoding/json\" \"expvar\" \"fmt\" \"github.com/gin-gonic/gin\" \"net/http\" \"runtime\" \"time\")func main() &#123; router := gin.Default() //初始化一个gin实例 router.GET(\"/debug/vars\", GetCurrentRunningStats) //接口路由，如果url不是/debug/vars，则用metricBeat去获取会出问题 s := &amp;http.Server&#123; Addr: \":\" + \"6666\", Handler: router, ReadTimeout: 5 * time.Second, WriteTimeout: 5 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, &#125; s.ListenAndServe() //开始监听&#125;var CuMemoryPtr *map[string]stringvar BTCMemoryPtr *map[string]interface&#123;&#125;// 开始时间var start = time.Now()// calculateUptime 计算运行时间func calculateUptime() interface&#123;&#125; &#123; return time.Since(start).String()&#125;// currentGoVersion 当前 Golang 版本func currentGoVersion() interface&#123;&#125; &#123; return runtime.Version()&#125;// getNumCPUs 获取 CPU 核心数量func getNumCPUs() interface&#123;&#125; &#123; return runtime.NumCPU()&#125;// getGoOS 当前系统类型func getGoOS() interface&#123;&#125; &#123; return runtime.GOOS&#125;// getNumGoroutins 当前 goroutine 数量func getNumGoroutins() interface&#123;&#125; &#123; return runtime.NumGoroutine()&#125;// getNumCgoCall CGo 调用次数func getNumCgoCall() interface&#123;&#125; &#123; return runtime.NumCgoCall()&#125;// 业务特定的内存数据func getCuMemoryMap() interface&#123;&#125; &#123; if CuMemoryPtr == nil &#123; return 0 &#125; else &#123; return len(*CuMemoryPtr) &#125;&#125;// 业务特定的内存数据func getBTCMemoryMap() interface&#123;&#125; &#123; if BTCMemoryPtr == nil &#123; return 0 &#125; else &#123; return len(*BTCMemoryPtr) &#125;&#125;var lastPause uint32// getLastGCPauseTime 获取上次 GC 的暂停时间func getLastGCPauseTime() interface&#123;&#125; &#123; var gcPause uint64 ms := new(runtime.MemStats) statString := expvar.Get(\"memstats\").String() if statString != \"\" &#123; json.Unmarshal([]byte(statString), ms) if lastPause == 0 || lastPause != ms.NumGC &#123; gcPause = ms.PauseNs[(ms.NumGC+255)%256] lastPause = ms.NumGC &#125; &#125; return gcPause&#125;// GetCurrentRunningStats 返回当前运行信息func GetCurrentRunningStats(c *gin.Context) &#123; c.Writer.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\") first := true report := func(key string, value interface&#123;&#125;) &#123; if !first &#123; fmt.Fprintf(c.Writer, \",\\n\") &#125; first = false if str, ok := value.(string); ok &#123; fmt.Fprintf(c.Writer, \"%q: %q\", key, str) &#125; else &#123; fmt.Fprintf(c.Writer, \"%q: %v\", key, value) &#125; &#125; fmt.Fprintf(c.Writer, \"&#123;\\n\") expvar.Do(func(kv expvar.KeyValue) &#123; report(kv.Key, kv.Value) &#125;) fmt.Fprintf(c.Writer, \"\\n&#125;\\n\") c.String(http.StatusOK, \"\")&#125;func init() &#123; //这些都是自定义变量，发布到expvar中，每次请求接口，expvar会自动去获取这些变量，并返回 expvar.Publish(\"运行时间\", expvar.Func(calculateUptime)) expvar.Publish(\"version\", expvar.Func(currentGoVersion)) expvar.Publish(\"cores\", expvar.Func(getNumCPUs)) expvar.Publish(\"os\", expvar.Func(getGoOS)) expvar.Publish(\"cgo\", expvar.Func(getNumCgoCall)) expvar.Publish(\"goroutine\", expvar.Func(getNumGoroutins)) expvar.Publish(\"gcpause\", expvar.Func(getLastGCPauseTime)) expvar.Publish(\"CuMemory\", expvar.Func(getCuMemoryMap)) expvar.Publish(\"BTCMemory\", expvar.Func(getBTCMemoryMap))&#125; 运行程序，并请求127.0.0.1:6666/debug/vars 结果如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868&#123; \"BTCMemory\": 0, \"CuMemory\": 0, \"cgo\": 1, \"cmdline\": [ \"/var/folders/9t/839s3jmj73bcgyp5x_xh3gw00000gn/T/go-build1753052226/b001/exe/1\" ], \"cores\": 8, \"gcpause\": 0, \"goroutine\": 3, \"memstats\": &#123; \"Alloc\": 1516104, \"TotalAlloc\": 1516104, \"Sys\": 71961616, \"Lookups\": 0, \"Mallocs\": 12075, \"Frees\": 1237, \"HeapAlloc\": 1516104, \"HeapSys\": 66650112, \"HeapIdle\": 63930368, \"HeapInuse\": 2719744, \"HeapReleased\": 63930368, \"HeapObjects\": 10838, \"StackInuse\": 458752, \"StackSys\": 458752, \"MSpanInuse\": 46376, \"MSpanSys\": 49152, \"MCacheInuse\": 9600, \"MCacheSys\": 16384, \"BuckHashSys\": 4156, \"GCSys\": 4227128, \"OtherSys\": 555932, \"NextGC\": 4473924, \"LastGC\": 0, \"PauseTotalNs\": 0, \"PauseNs\": [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], \"PauseEnd\": [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], \"NumGC\": 0, \"NumForcedGC\": 0, \"GCCPUFraction\": 0, \"EnableGC\": true, \"DebugGC\": false, \"BySize\": [ &#123; \"Size\": 0, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 8, \"Mallocs\": 251, \"Frees\": 0 &#125;, &#123; \"Size\": 16, \"Mallocs\": 4258, \"Frees\": 0 &#125;, &#123; \"Size\": 24, \"Mallocs\": 490, \"Frees\": 0 &#125;, &#123; \"Size\": 32, \"Mallocs\": 1194, \"Frees\": 0 &#125;, &#123; \"Size\": 48, \"Mallocs\": 745, \"Frees\": 0 &#125;, &#123; \"Size\": 64, \"Mallocs\": 572, \"Frees\": 0 &#125;, &#123; \"Size\": 80, \"Mallocs\": 72, \"Frees\": 0 &#125;, &#123; \"Size\": 96, \"Mallocs\": 84, \"Frees\": 0 &#125;, &#123; \"Size\": 112, \"Mallocs\": 2268, \"Frees\": 0 &#125;, &#123; \"Size\": 128, \"Mallocs\": 79, \"Frees\": 0 &#125;, &#123; \"Size\": 144, \"Mallocs\": 19, \"Frees\": 0 &#125;, &#123; \"Size\": 160, \"Mallocs\": 164, \"Frees\": 0 &#125;, &#123; \"Size\": 176, \"Mallocs\": 11, \"Frees\": 0 &#125;, &#123; \"Size\": 192, \"Mallocs\": 16, \"Frees\": 0 &#125;, &#123; \"Size\": 208, \"Mallocs\": 73, \"Frees\": 0 &#125;, &#123; \"Size\": 224, \"Mallocs\": 5, \"Frees\": 0 &#125;, &#123; \"Size\": 240, \"Mallocs\": 4, \"Frees\": 0 &#125;, &#123; \"Size\": 256, \"Mallocs\": 30, \"Frees\": 0 &#125;, &#123; \"Size\": 288, \"Mallocs\": 28, \"Frees\": 0 &#125;, &#123; \"Size\": 320, \"Mallocs\": 50, \"Frees\": 0 &#125;, &#123; \"Size\": 352, \"Mallocs\": 11, \"Frees\": 0 &#125;, &#123; \"Size\": 384, \"Mallocs\": 30, \"Frees\": 0 &#125;, &#123; \"Size\": 416, \"Mallocs\": 25, \"Frees\": 0 &#125;, &#123; \"Size\": 448, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 480, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 512, \"Mallocs\": 9, \"Frees\": 0 &#125;, &#123; \"Size\": 576, \"Mallocs\": 18, \"Frees\": 0 &#125;, &#123; \"Size\": 640, \"Mallocs\": 57, \"Frees\": 0 &#125;, &#123; \"Size\": 704, \"Mallocs\": 8, \"Frees\": 0 &#125;, &#123; \"Size\": 768, \"Mallocs\": 1, \"Frees\": 0 &#125;, &#123; \"Size\": 896, \"Mallocs\": 19, \"Frees\": 0 &#125;, &#123; \"Size\": 1024, \"Mallocs\": 26, \"Frees\": 0 &#125;, &#123; \"Size\": 1152, \"Mallocs\": 23, \"Frees\": 0 &#125;, &#123; \"Size\": 1280, \"Mallocs\": 36, \"Frees\": 0 &#125;, &#123; \"Size\": 1408, \"Mallocs\": 1, \"Frees\": 0 &#125;, &#123; \"Size\": 1536, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 1792, \"Mallocs\": 22, \"Frees\": 0 &#125;, &#123; \"Size\": 2048, \"Mallocs\": 7, \"Frees\": 0 &#125;, &#123; \"Size\": 2304, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 2688, \"Mallocs\": 38, \"Frees\": 0 &#125;, &#123; \"Size\": 3072, \"Mallocs\": 6, \"Frees\": 0 &#125;, &#123; \"Size\": 3200, \"Mallocs\": 2, \"Frees\": 0 &#125;, &#123; \"Size\": 3456, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 4096, \"Mallocs\": 20, \"Frees\": 0 &#125;, &#123; \"Size\": 4864, \"Mallocs\": 2, \"Frees\": 0 &#125;, &#123; \"Size\": 5376, \"Mallocs\": 15, \"Frees\": 0 &#125;, &#123; \"Size\": 6144, \"Mallocs\": 6, \"Frees\": 0 &#125;, &#123; \"Size\": 6528, \"Mallocs\": 1, \"Frees\": 0 &#125;, &#123; \"Size\": 6784, \"Mallocs\": 2, \"Frees\": 0 &#125;, &#123; \"Size\": 6912, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 8192, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 9472, \"Mallocs\": 2, \"Frees\": 0 &#125;, &#123; \"Size\": 9728, \"Mallocs\": 3, \"Frees\": 0 &#125;, &#123; \"Size\": 10240, \"Mallocs\": 8, \"Frees\": 0 &#125;, &#123; \"Size\": 10880, \"Mallocs\": 8, \"Frees\": 0 &#125;, &#123; \"Size\": 12288, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 13568, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 14336, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 16384, \"Mallocs\": 0, \"Frees\": 0 &#125;, &#123; \"Size\": 18432, \"Mallocs\": 1, \"Frees\": 0 &#125; ] &#125;, \"os\": \"darwin\", \"version\": \"go1.16.7\", \"运行时间\": \"30.037286084s\"&#125; 其中，expvar包会默认携带memstats，该字段内含 各种内存堆栈以及GC的一些信息，具体可见源码注释 src/runtime/mstats.gosrc/runtime/mstats.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272// A MemStats records statistics about the memory allocator.type MemStats struct &#123; // General statistics. // Alloc is bytes of allocated heap objects. // // This is the same as HeapAlloc (see below). Alloc uint64 // TotalAlloc is cumulative bytes allocated for heap objects. // // TotalAlloc increases as heap objects are allocated, but // unlike Alloc and HeapAlloc, it does not decrease when // objects are freed. TotalAlloc uint64 // Sys is the total bytes of memory obtained from the OS. // // Sys is the sum of the XSys fields below. Sys measures the // virtual address space reserved by the Go runtime for the // heap, stacks, and other internal data structures. It's // likely that not all of the virtual address space is backed // by physical memory at any given moment, though in general // it all was at some point. Sys uint64 // Lookups is the number of pointer lookups performed by the // runtime. // // This is primarily useful for debugging runtime internals. Lookups uint64 // Mallocs is the cumulative count of heap objects allocated. // The number of live objects is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed. Frees uint64 // Heap memory statistics. // // Interpreting the heap statistics requires some knowledge of // how Go organizes memory. Go divides the virtual address // space of the heap into \"spans\", which are contiguous // regions of memory 8K or larger. A span may be in one of // three states: // // An \"idle\" span contains no objects or other data. The // physical memory backing an idle span can be released back // to the OS (but the virtual address space never is), or it // can be converted into an \"in use\" or \"stack\" span. // // An \"in use\" span contains at least one heap object and may // have free space available to allocate more heap objects. // // A \"stack\" span is used for goroutine stacks. Stack spans // are not considered part of the heap. A span can change // between heap and stack memory; it is never used for both // simultaneously. // HeapAlloc is bytes of allocated heap objects. // // \"Allocated\" heap objects include all reachable objects, as // well as unreachable objects that the garbage collector has // not yet freed. Specifically, HeapAlloc increases as heap // objects are allocated and decreases as the heap is swept // and unreachable objects are freed. Sweeping occurs // incrementally between GC cycles, so these two processes // occur simultaneously, and as a result HeapAlloc tends to // change smoothly (in contrast with the sawtooth that is // typical of stop-the-world garbage collectors). HeapAlloc uint64 // HeapSys is bytes of heap memory obtained from the OS. // // HeapSys measures the amount of virtual address space // reserved for the heap. This includes virtual address space // that has been reserved but not yet used, which consumes no // physical memory, but tends to be small, as well as virtual // address space for which the physical memory has been // returned to the OS after it became unused (see HeapReleased // for a measure of the latter). // // HeapSys estimates the largest size the heap has had. HeapSys uint64 // HeapIdle is bytes in idle (unused) spans. // // Idle spans have no objects in them. These spans could be // (and may already have been) returned to the OS, or they can // be reused for heap allocations, or they can be reused as // stack memory. // // HeapIdle minus HeapReleased estimates the amount of memory // that could be returned to the OS, but is being retained by // the runtime so it can grow the heap without requesting more // memory from the OS. If this difference is significantly // larger than the heap size, it indicates there was a recent // transient spike in live heap size. HeapIdle uint64 // HeapInuse is bytes in in-use spans. // // In-use spans have at least one object in them. These spans // can only be used for other objects of roughly the same // size. // // HeapInuse minus HeapAlloc estimates the amount of memory // that has been dedicated to particular size classes, but is // not currently being used. This is an upper bound on // fragmentation, but in general this memory can be reused // efficiently. HeapInuse uint64 // HeapReleased is bytes of physical memory returned to the OS. // // This counts heap memory from idle spans that was returned // to the OS and has not yet been reacquired for the heap. HeapReleased uint64 // HeapObjects is the number of allocated heap objects. // // Like HeapAlloc, this increases as objects are allocated and // decreases as the heap is swept and unreachable objects are // freed. HeapObjects uint64 // Stack memory statistics. // // Stacks are not considered part of the heap, but the runtime // can reuse a span of heap memory for stack memory, and // vice-versa. // StackInuse is bytes in stack spans. // // In-use stack spans have at least one stack in them. These // spans can only be used for other stacks of the same size. // // There is no StackIdle because unused stack spans are // returned to the heap (and hence counted toward HeapIdle). StackInuse uint64 // StackSys is bytes of stack memory obtained from the OS. // // StackSys is StackInuse, plus any memory obtained directly // from the OS for OS thread stacks (which should be minimal). StackSys uint64 // Off-heap memory statistics. // // The following statistics measure runtime-internal // structures that are not allocated from heap memory (usually // because they are part of implementing the heap). Unlike // heap or stack memory, any memory allocated to these // structures is dedicated to these structures. // // These are primarily useful for debugging runtime memory // overheads. // MSpanInuse is bytes of allocated mspan structures. MSpanInuse uint64 // MSpanSys is bytes of memory obtained from the OS for mspan // structures. MSpanSys uint64 // MCacheInuse is bytes of allocated mcache structures. MCacheInuse uint64 // MCacheSys is bytes of memory obtained from the OS for // mcache structures. MCacheSys uint64 // BuckHashSys is bytes of memory in profiling bucket hash tables. BuckHashSys uint64 // GCSys is bytes of memory in garbage collection metadata. GCSys uint64 // OtherSys is bytes of memory in miscellaneous off-heap // runtime allocations. OtherSys uint64 // Garbage collector statistics. // NextGC is the target heap size of the next GC cycle. // // The garbage collector's goal is to keep HeapAlloc ≤ NextGC. // At the end of each GC cycle, the target for the next cycle // is computed based on the amount of reachable data and the // value of GOGC. NextGC uint64 // LastGC is the time the last garbage collection finished, as // nanoseconds since 1970 (the UNIX epoch). LastGC uint64 // PauseTotalNs is the cumulative nanoseconds in GC // stop-the-world pauses since the program started. // // During a stop-the-world pause, all goroutines are paused // and only the garbage collector can run. PauseTotalNs uint64 // PauseNs is a circular buffer of recent GC stop-the-world // pause times in nanoseconds. // // The most recent pause is at PauseNs[(NumGC+255)%256]. In // general, PauseNs[N%256] records the time paused in the most // recent N%256th GC cycle. There may be multiple pauses per // GC cycle; this is the sum of all pauses during a cycle. PauseNs [256]uint64 // PauseEnd is a circular buffer of recent GC pause end times, // as nanoseconds since 1970 (the UNIX epoch). // // This buffer is filled the same way as PauseNs. There may be // multiple pauses per GC cycle; this records the end of the // last pause in a cycle. PauseEnd [256]uint64 // NumGC is the number of completed GC cycles. NumGC uint32 // NumForcedGC is the number of GC cycles that were forced by // the application calling the GC function. NumForcedGC uint32 // GCCPUFraction is the fraction of this program's available // CPU time used by the GC since the program started. // // GCCPUFraction is expressed as a number between 0 and 1, // where 0 means GC has consumed none of this program's CPU. A // program's available CPU time is defined as the integral of // GOMAXPROCS since the program started. That is, if // GOMAXPROCS is 2 and a program has been running for 10 // seconds, its \"available CPU\" is 20 seconds. GCCPUFraction // does not include CPU time used for write barrier activity. // // This is the same as the fraction of CPU reported by // GODEBUG=gctrace=1. GCCPUFraction float64 // EnableGC indicates that GC is enabled. It is always true, // even if GOGC=off. EnableGC bool // DebugGC is currently unused. DebugGC bool // BySize reports per-size class allocation statistics. // // BySize[N] gives statistics for allocations of size S where // BySize[N-1].Size &lt; S ≤ BySize[N].Size. // // This does not report allocations larger than BySize[60].Size. BySize [61]struct &#123; // Size is the maximum byte size of an object in this // size class. Size uint32 // Mallocs is the cumulative count of heap objects // allocated in this size class. The cumulative bytes // of allocation is Size*Mallocs. The number of live // objects in this size class is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed // in this size class. Frees uint64 &#125;&#125; 对于各个字段的意义 可参考： 12345678910111213141516171819202122232425262728291、Alloc uint64 //Go语言框架 堆空间分配的字节数2、TotalAlloc uint64 //从服务开始运行至今分配器为分配的堆空间总和，只增加，释放时不减少3、Sys uint64 //服务现在使用的系统内存4、Lookups uint64 //被runtime监视的指针数5、Mallocs uint64 //服务malloc的次数6、Frees uint64 //服务回收的heap objects的字节数7、HeapAlloc uint64 //服务分配的堆内存字节数8、HeapSys uint64 //系统分配的作为运行栈的内存9、HeapIdle uint64 //申请但未分配的堆内存或者回收了的堆内存（空闲）字节数10、HeapInuse uint64 //正在使用的堆内存字节数10、HeapReleased uint64 //返回给OS的堆内存，类似C/C++中的free11、HeapObjects uint64 //堆内存块申请的量12、StackInuse uint64 //正在使用的栈字节数13、StackSys uint64 //系统分配的作为运行栈的内存14、MSpanInuse uint64 //用于测试用的结构体使用的字节数15、MSpanSys uint64 //系统为测试用的结构体分配的字节数16、MCacheInuse uint64 //mcache结构体申请的字节数(不会被视为垃圾回收)17、MCacheSys uint64 //操作系统申请的堆空间用于mcache的字节数18、BuckHashSys uint64 //用于剖析桶散列表的堆空间19、GCSys uint64 //垃圾回收标记元信息使用的内存20、OtherSys uint64 //golang系统架构占用的额外空间21、NextGC uint64 //垃圾回收器检视的内存大小22、LastGC uint64 // 垃圾回收器最后一次执行时间。23、PauseTotalNs uint64 // 垃圾回收或者其他信息收集导致服务暂停的次数。24、PauseNs [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间25、PauseEnd [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间开始点。26、NumForcedGC uint32 //服务调用runtime.GC()强制使用垃圾回收的次数。27、GCCPUFraction float64 //垃圾回收占用服务CPU工作的时间总和。如果有100个goroutine，垃圾回收的时间为1S,那么就占用了100S。28、BySize //内存分配器使用情况 以上参考golang程序的监控神器—-expvar 社区同行开发的expvarmon工具，可以在命令行终端以图形化的方式实时展示特定的指标数据的变化，（expvarmon 即expvar monitor） go get github.com/divan/expvarmon 启动刚才的程序，然后执行如下命令，可实时查看应用指标变化 （期间可以进行不同qps的请求） expvarmon -ports=&quot;http://localhost:6666/debug/vars&quot; -i 1s 参考 给expvarmon插上数据持久化的“翅膀” 源码分析 expvar包代码只有300多行 详细分析可参考 Golang 公共变量包——expvar Go语言学习之expvar包 官方库或知名项目中的使用 src/net/http/triv.go 中使用了这个包 另外golang.org/x/tools@v0.1.6/cmd/godoc/main.go golang.org/x/tools@v0.1.6/go/internal/gccgoimporter/gccgoinstallation_test.go go/test/bench/garbage/parser.go 也有使用 以及前面提到的expvarmon","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"压缩算法---以golang/snappy为例","date":"2020-01-02T12:05:50.000Z","path":"2020/01/02/压缩算法-以golang-snappy为例/","text":"阮一峰-数据压缩与信息熵 压缩，典型的时间换空间 用到LRU，首选hashicorp/golang-lru，不过不知道啥时候，Go官方悄不溜整了一个groupcache，也提供了lru的实现…顺道瞟了一眼，发现github.com/golang下除去有go，还有一整套配套的常用组件。比如vscode/sublime的插件，有性能测试工具perf，有错误处理库xerrors，有日志库glog，有用于单测的mock…甚至连压缩都提供了snappy，数据库有leveldb。。。这简直是想“自举”包圆整个产业链 golang/snappy snappy是Google研发的压缩算法，优点是有非常高的速度和合理的压缩率(压缩率比gzip 小) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"github.com/golang/snappy\" \"io/ioutil\")var ( textMap = map[string]string&#123; \"a\": `1234567890-=qwertyuiop[]\\';lkjhgfdsazxcvbnm,./`, // a重复4次 \"b\": `1234567890-=qwertyuiop[]\\';lkjhgfdsazxcvbnm,./1234567890-=qwertyuiop[]\\';lkjhgfdsazxcvbnm,./1234567890-=qwertyuiop[]\\';lkjhgfdsazxcvbnm,./1234567890-=qwertyuiop[]\\';lkjhgfdsazxcvbnm,./`, \"c\": `浕浉浄浀浂洉洡洣浐洘泚浌洼洽派洿浃浇浈浊测浍济浏浑浒浓浔泿洱涏洀洁洂洃洄洅洆洇洈洊洋洌洎洏洐洑洒洓洔洕洗洠洙洚洛洝洞洟洢洤津洦洧洨洩洪洫洬洭洮洲洳洴洵洶洷洸洹洺活涎`, // c重复3次 \"d\": `浕浉浄浀浂洉洡洣浐洘泚浌洼洽派洿浃浇浈浊测浍济浏浑浒浓浔泿洱涏洀洁洂洃洄洅洆洇洈洊洋洌洎洏洐洑洒洓洔洕洗洠洙洚洛洝洞洟洢洤津洦洧洨洩洪洫洬洭洮洲洳洴洵洶洷洸洹洺活涎浕浉浄浀浂洉洡洣浐洘泚浌洼洽派洿浃浇浈浊测浍济浏浑浒浓浔泿洱涏洀洁洂洃洄洅洆洇洈洊洋洌洎洏洐洑洒洓洔洕洗洠洙洚洛洝洞洟洢洤津洦洧洨洩洪洫洬洭洮洲洳洴洵洶洷洸洹洺活涎浕浉浄浀浂洉洡洣浐洘泚浌洼洽派洿浃浇浈浊测浍济浏浑浒浓浔泿洱涏洀洁洂洃洄洅洆洇洈洊洋洌洎洏洐洑洒洓洔洕洗洠洙洚洛洝洞洟洢洤津洦洧洨洩洪洫洬洭洮洲洳洴洵洶洷洸洹洺活涎`, &#125; imgSrc = []string&#123; \"john.jpg\", \"Dijkstra.jpg\", \"tony.jpg\", \"tony1.jpg\", &#125;)/* k: a len: 46 48 k: b len: 184 58 k: c len: 246 250 k: d len: 738 274 snappy jpg*/func main() &#123; for k, v := range textMap &#123; got := snappy.Encode(nil, []byte(v)) //fmt.Println(\"原始信息为:\",v, \"压缩后的信息为:\",string(got)) fmt.Println(\"k:\", k, \", 原长度:\", len(v), \", 压缩后的长度:\", len(got)) &#125; fmt.Println(\"snappy压缩 jpg：\") for _, v := range imgSrc &#123; buf, err := ioutil.ReadFile(v) if err == nil &#123; got := snappy.Encode(nil, buf) fmt.Println(\"k:\", v, \", 原长度:\", len(buf), \", 压缩后的长度:\", len(got)) &#125; &#125;&#125; 执行结果： 123456789k: a , 原长度: 46 , 压缩后的长度: 48k: b , 原长度: 184 , 压缩后的长度: 58k: c , 原长度: 246 , 压缩后的长度: 250k: d , 原长度: 738 , 压缩后的长度: 274snappy压缩 jpg：k: john.jpg , 原长度: 172909 , 压缩后的长度: 172921k: Dijkstra.jpg , 原长度: 199459 , 压缩后的长度: 196799k: tony.jpg , 原长度: 169282 , 压缩后的长度: 169026k: tony1.jpg , 原长度: 52923 , 压缩后的长度: 52565 字符串包含较多的重复字符,压缩才有较大效果 对jpg 图片的压缩率不大，甚至还会使体积变大… 压缩 就是找出那些重复出现的字符串，然后用更短的符号代替。 如AAABBBBCC可以记为3A4B2C （只要保证对应关系，可以用任意字符代替那些重复出现的字符串） 所以对于没有重复的数据，无法再进一步压缩。 而文件需要加校验字段，所以对于没有重复信息的数据会越压越大 .jpg本身又已经经过了压缩(有损压缩)，故而… 图片格式jpg、png、gif、RAW、TIFF有啥区别，图片受损没法打开，能修复吗？ 4张图片的原始信息如下： golang中snappy的使用场合实例详解 其他的压缩算法 lz4：综合来看效率最高的压缩算法，更侧重压缩/解压速度，压缩比并不是第一。当前Android和iOS操作系统，内存压缩就使用的是lz4算法，及时压缩内存以节省出更多的内存空间。 使用C编写. 更多 深入浅出lz4压缩算法 zstd: 由Facebook研发的快速数据压缩算法,具有更好的压缩比。使用C编写. 更多 zstd - 一种由Facebook使用的快速数据压缩算法 zip：作者菲尔·卡茨,不愿意为一个压缩软件付钱，索性自己写了一个更好的算法ZIP，然后无偿公开。2000年4月14日，饮酒过量导致急性脾出血,死于一家汽车旅馆，年仅37岁，死时手中握着一个空酒瓶 更多ZIP,一个没落天才的故事","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"<大话设计模式>书摘","date":"2019-12-28T12:35:48.000Z","path":"2019/12/28/大话设计模式-书摘/","text":"https://refactoringguru.cn/design-patterns 1.简单工厂模式 2.策略模式 3.单一职责原则 4.开放-封闭原则 可以扩展,不可修改 简单工厂模式是不满足开放-封闭原则 5.依赖倒转原则 面向对象设计的标志 针对抽象编程,而不是针对细节编程. 里式替换原则: 6.装饰模式 装饰器模式 Decorator Pattern 7.代理模式 8.工厂方法模式 9.原型模式 浅拷贝和深拷贝 10.模板方法模式 11.迪米特拉法则(最少知识原则) 强调类之间的松耦合 12.外观模式 13.建造者模式 比较难以理解 14.观察者模式 接触耦合 一般通过接口来实现 15.抽象工厂模式 16.状态模式 17.适配器模式 18.备忘录 模式 19.组合模式 20.迭代器模式 21.单例模式 22.桥接模式 比较复杂 23.命令模式 24.职责链模式 25.中介者模式 26.享元模式 27.解释器模式 不太好理解的一个 28.访问者模式 也是比较难的一个模式","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"Go interface{}转struct","date":"2019-12-21T13:29:20.000Z","path":"2019/12/21/Go-interface-转struct/","text":"写一个通用的方法，更具type字段区分不同类型，入参不同，返回值也不同 POST方式，type=8带在路径中，其他业务相关的参数放在body里 如果用gin框架，可以用c.GetQuery(key)获取type类型 12//解析query typstr, ok := c.GetQuery(\"type\") 因为入参不同，返回值也不同，所以req和res都需要用interface{}类型，而不能是某个特定的struct 具体的方法格式如下： functionName(ctx context.Context, typ int, req interface{}) (res interface{}, err error) 通过switch case，不同类型进行不同处理： 1234567891011121314151617switch typ &#123; case 1: var newReq protocol.XXXXXReq reqByte, reqByteErr := json.Marshal(req) if reqByteErr != nil &#123; return nil, reqByteErr &#125; jsonRes := json.Unmarshal(reqByte, &amp;newReq) if jsonRes != nil &#123; return nil, jsonRes &#125; return func1type(newReq) // 处理type=1这种类型 default: return &#125; 可见，func1type的入参是一个结构体，而原始的req是一个interface{} 如上采用了JSON序列化的方式，先将interface类型的入参json.Marshal，再将得到的byte类型的变量reqByte进行 json.Unmarshal(reqByte,&amp;定义的结构体) 这样就实现了从interface到struct的转换。 还有一种方式，是 使用断言，做强制转换 可参考 Golang interface{}转struct的两种方法","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"写一个线程安全的有界阻塞队列","date":"2019-12-19T11:57:39.000Z","path":"2019/12/19/写一个线程安全的有界阻塞队列/","text":"2小时20分钟的面试 问了OPA的各种信息，这是之前在HP用到的东西，后面再未使用，早忘干净了，比如Bundler是咋回事(服务端？)，多个部署还是单个？ （不过这玩意儿好像用户越来越多了，据我所知蚂蚁也在用） 写了一道算法题，实现一个线程安全的有界的阻塞队列。。。不加阻塞这个条件其实问题不大，但加了之后感到困惑：要用channel吗？ 后来告知要用sync.Cond --- 我博客里有涉及(sync.Cond-让一系列Goroutine在满足特定条件时被唤醒)，但写go这好几年，就从来没在项目里使用过 之后问了Go生态下微服务的注册与发现。 而后让写了一个sql，获取重复数据，性能尽可能高。写了一版只实现了功能，性能一般。 1select * from test as a where ((SELECT COUNT(*) from test where id = a.id)&gt;1) 允许Google，从StackOverflow上找到了更好的写法。 1SELECT id,COUNT(id) FROM test GROUP BY id HAVING COUNT(id)&gt; 1 最后交流了框架中orm在model层和dao层的自动生成 写一个线程安全的有界阻塞队列: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// write a thread safe bounded blocking queuepackage mainimport ( \"sync\")type BBQ struct &#123; data []interface&#123;&#125; capability int mutex sync.Mutex cond sync.Cond&#125;func NewBBQ(c int) *BBQ &#123; q := new(BBQ) q.capability = c q.cond = sync.Cond&#123;L: &amp;q.mutex&#125; return q&#125;func (q *BBQ) Push(value interface&#123;&#125;) &#123; q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == q.capability &#123; q.cond.Wait() &#125; q.data = append(q.data, value) q.cond.Signal() return&#125;func (q *BBQ) Pop() interface&#123;&#125; &#123; q.cond.L.Lock() defer q.cond.L.Unlock() for len(q.data) == 0 &#123; q.cond.Wait() &#125; first := q.data[0] q.data = q.data[1:] q.cond.Signal() return first&#125; 其他语言版本的 write a thread safe bounded blocking queue","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"爽读数据2019","date":"2019-12-10T14:31:00.000Z","path":"2019/12/10/爽读数据2019/","text":"2018年世界各国人均GDP 1.一个错觉，一直以为美国人均GDP在20名左右，落后英法德加澳，实则不然。人均GDP排在美国之前的7个国家及中国澳门地区，无一人口超过1000万。 2.北欧四国全在前15，芬兰人口竟不及丹麦。 3.新加坡与美国人均GDP相当，约为中国大陆地区6-7倍。日本人均GDP约为大陆地区4倍，韩国约为3倍;中国台湾省约为大陆地区2.6倍(与上海与海南人均GDP差距相当)，中国xx地区约为大陆5倍(大陆地区各省人均GDP最高的北京与甘肃相差4.5倍)，中国澳门地区约为大陆8.5倍。 4.中国人均GDP为印度4.75倍。这个数据指标此后二十年要务必关注。 5.中亚五个内陆“斯坦”，最北最西的哈萨克斯坦与土库曼斯坦人均GDP相对较好。与中国搭界的吉尔吉斯斯坦，及世界两个双重内陆国之一的乌兹别克斯坦，人均GDP仅为中国大陆地区13%。最靠后的塔吉克斯坦，不足大陆地区9%。 6.排名倒数前十的悉数为非洲国家，其中包括莫桑比克和马达加斯加。非洲地区只有三个小国人均GDP在中国大陆地区之上:塞舌尔，毛球，赤道几内亚。 7.阿联酋人均GDP高过日本，文莱人均GDP高于韩国。科威特，巴林，沙特，阿曼，马尔代夫，马来西亚，人均GDP高过大陆地区。 8.有四个人口过亿国家人均GDP排在中国大陆地区之前:美国，日本，俄罗斯，墨西哥。巴西人口突破2亿，印度尼西亚人口超过2.5亿，菲律宾人口超过1亿。尼日利亚人口即将突破2亿。孟加拉国人口1.6亿。印度人口与中国相去不大。巴基斯坦人口突破2亿。埃及，越南，刚果民主共和国人口即将过亿。 多年前，确切说我还在学校未下车间时，世界人口过亿国家共10个，最末为西非强国尼日利亚。现在这个数量是12，如无错误，新上榜的是墨西哥与菲律宾。","tags":[{"name":"区域经济","slug":"区域经济","permalink":"http://www.dashen.tech/tags/区域经济/"}]},{"title":"分析IMDb电影信息","date":"2019-12-07T10:43:20.000Z","path":"2019/12/07/分析IMDb电影信息/","text":"姊妹篇,爬取豆瓣电影信息 IMDb，全称Internet Movie Database，即互联网电影资料库。 不过我还是更喜欢像MySql那样把IM理解为“我” 起因是看王兴的一个专访，他表示&lt;美国往事&gt;比&lt;教父&gt;更厉害一点。 都曾看过，但与我直觉有异。&lt;The Godfather&gt; 三部曲分别排在豆瓣top250第21，50，151位，&lt;Once Upon a Time in America&gt; 则列第73位。 有时候，地域习俗 文化背景 会对同一事物观感与评价有巨大影响。于是想看看国际版“豆瓣电影”---IMDb上评分如何。 经过对其Top250影片分析，果不其然，二者差异十分巨大，两个榜单重合度大概只有1/3，相当多数在IMDb250的影片，会让国内观众感到生僻---- 一圈下来，我标注了132部“待看”。 几点结论如下: 两份榜单差异巨大 1.很显然，从国外用户评价看，&lt;教父&gt;前两部占据榜单第二、三名，强于排名第72的&lt;美国往事&gt;。但&lt;教父&gt;第三部没有上榜。 事实上，一个系列能够全部上榜，而不成狗尾续貂真心不易。豆瓣top250中，除去教父，还有此殊荣的只有理查德·林克莱特的“Before”三部曲。其中，问世于1995年的&lt;Before Sunrise&gt;(爱在黎明破晓前)位列第110位，9年后续拍的&lt;Before Sunset&gt;(爱在日落黄昏时)排名第125，而又过9年后拍摄的&lt;Before Midnight&gt;(爱在午夜降临前)“下滑”至第214位。IMDb上该系列同样呈递减趋势，前两部排名第196和237，第三部未入围top250。 榜首头名不约而同 2.两份排名虽迥如云泥，但榜首却是高度一致。也许『教父』和『美国往事』，『罗生门』和『七武士』孰更胜一筹还将见仁见智继续争论，但至于1994年获奥斯卡的『阿甘正传』与那年落败的『肖申克的救赎』，时间已给以最佳裁决。 两者曾你来我往，交替排在豆瓣top250榜首。现今，&lt;阿甘正传&gt;被&lt;霸王别姬&gt;挤下，排名第三。IMDb上更“靠后”排名第12。 如果参考当年，遴选自巴赫，莫扎特，贝多芬及斯特拉文斯基的7首古典音乐，送入太空，作为和地外生命第一次见面交流的“自我介绍”，&lt;阿甘正传&gt;显然远不及&lt;肖申克的救赎&gt;。前者是身残志坚，是努力奋斗，是不气馁不放弃，还有穿插其间看似讨巧的乒乓外交、水门事件等。从时间维度，过后一百年，对这些美国历史的陈仓旧事没多少兴趣;从空间广度，阿甘这样的残障者毕竟只占少数，观众很难联及自身，只觉是在看别人事迹。而肖申克这样的遭遇，却可能保不齐哪天发生于你我，观众更具共情和代入感。 简而言之，阿甘靠“美国梦”征服了奥斯卡评委，肖申克则用“希望”，战胜了岁月。 IMDb时间跨度更大 3.入围IMDb top250的作品时间跨度更大:最早可追溯至1921年卓别林的『The Kid』(寻子遇仙记)，另外还有5部20世纪20年代的默片电影上榜，分别是1924年的『福尔摩斯二世』，同样由卓别林主演的上映于1925年的『淘金记』，1926年的『将军号』，1927年的『大都会』，及1928年的『圣女贞德蒙难记』;如图示，最早上榜豆瓣top 250的作品，是喜剧大师拍摄于30年代的『城市之光』和『摩登时代』。 因为算法原因，很难有当年度上映的电影，能登上豆瓣top 250。而IMDb则不然，已有5部2019年影片入选，分别是『小丑』，『寄生虫』，『复仇者联盟4』，『爱尔兰人』，『极速之王』(有个杀马特名字，叫“福特对战法拉利”)。而入围豆瓣的最新作品，是去年上映的『何以为家』，『我不是药神』和『头号玩家』。换言之，IMDb榜流动性更快，更大一些。 另外，IMDb上榜作品时间分布更为均匀，而豆瓣榜单，绝大多数影片是1990年之后拍摄。 中外观众口味有别 4.从其间差异，能明显反应出中外观众电影之外的不同。“外国人”对诺兰，对『星际穿越』，对各种奇幻和外太空探险，对超级英雄，有种狂热的迷恋。而在国内备受赞誉，豆瓣排名第11的文艺片『海上钢琴师』，则在IMDb位列最后一位，行将被挤出榜单。 上榜IMDb top250，而不在豆瓣top 250的作品，在豆瓣也大多评分不差，绝大多数超过8分。但也有两部是不足7分的例外--- 土耳其电影&lt;强盗&gt;和印度电影&lt;瓦塞浦黑帮&gt;。这或许两国历史高度相干，国内观众难有共鸣可以理解。但作为2007年奥斯卡最佳影片的『无间道风云』，剧情中国观众应当似曾相识，更有两位知名主演，评分竟只有7.2。 另则，『寻梦环游记』在榜，而我认为更佳的&lt;疯狂动物城&gt;未能入围。二者在豆瓣排名第37和22。 同时“发掘”一位不太曾关注的神级老戏骨——罗伯特·德罗尼。 『两代教父同框! 罗伯特·德尼罗与阿尔·帕西诺』 韩片入围不及豆瓣 5.一向以“政治尺度大”著称的韩国电影，上榜作品不多，&lt;辩护人&gt;和&lt;熔炉&gt;皆不在列。可能“外国人”对这很难有共鸣。『老男孩』，『小姐』，『杀人回忆』，『寄生虫』，是入围top250的四部作品。其中宋康昊主演两部，是货真价实的“高丽国一级演员”。 日本作品上榜更多 6.相形之下，日本作品入围颇多。因为年代分布更均匀，使以黑泽明为代表的半个多世纪前“黄金时代”的黑白影片，大量上榜top250。除去必定在列的『罗生门』『七武士』，同属黑泽明的『生之欲』『用心棒』，及其后期作品『乱』，小津安二郎的『东京物语』，小林正树的『切腹』，同样榜上有名。 而在豆瓣top250中，与诺兰同样7部作品并列榜首的宫崎骏，则在IMDb榜上稍有逊色:『千与千寻』，『幽灵公主』，『哈尔的移动城堡』，『龙猫』，『风之谷』，『天空之城』。其中『天空之城』在豆瓣排名第36，IMDb排名第249。 除去宫崎骏，高畑勋的『萤火虫之墓』和3年前上映的新海诚『你的名字』，两部动漫电影同样入围。 阿米尔·汗 印度国宝当之无愧 7.作为官方语言为英语的印度，有理由相信其庞大的人口可以很大程度“影响”IMDb。共有『巴萨提的颜色』，『三傻』，『地球上的星星』，『我的个神啊』，『摔跤吧！』，『穆那大哥做医生』，『较量』，『瓦塞浦黑帮』等多部作品入围。其中『较量』即『瞒天误杀记』原版，后者增加预算更换演员重新翻拍。 但这些作品大多排名不高。最靠前的『三傻』，豆瓣排名第12，IMDb第79。这可能也是国情使然，使中国观众在观看时更有同感。 我是在2011年10月，刚刚结束繁重索然的高中，观看了这部少数后来会重新再看的影片 --- 因实在太有共鸣 --- 片中“病毒”教授摔下的鸟蛋和说教，与国内绝不在少数的中小学老师和家长的“谆谆教诲”别无二致。在那前后，乔布斯逝世，来自世人如雪片般纷至沓来的缅怀，让高中时代曾将其『Stay hungry，Stay foolish』作为格言的我还是有些惊讶。于是想要找寻这个没上过大学的家伙，究竟对人类有何贡献，也开始思索许些在高中时代没有时间考虑的更深层次问题。 促使我做这期IMDb数据分析的王兴，曾被问到比尔·盖茨是否为其偶像。他说不是，乔布斯对他影响更大一些，主要是审美和品味。去年美团上市，成中国互联网市值仅次于二马的第三大公司，在敲锣前夕，他再次致意乔布斯:是他用iPhone开启了移动互联网，才使包括美团在内的公司有存在的可能。 同样让我印象深刻的，还有主演阿米尔·汗。其上提到的8部电影，有5部是他主演 --- 印度国宝级演员当之无愧。更令人肃然起敬之处，出身上游社会的他，利用自己巨大影响，以极大魄力拍摄了&lt;真相访谈&gt;。”印度良心”必将留名21世纪南亚古国历史。 在『摔跤吧!』之前，我一直以为其戏路和角色塑造较有局限，如陈道明或陈宝国，而不是演啥像啥，如梁家辉，金士杰，张译以及范伟——无论『三傻』还是『我的个神啊』，或是『地球上的星星』&lt;神秘巨星&gt;，以及口碑不佳的&lt;印度暴徒&gt;，多是饰演那种机灵搞怪似的人物。『摔跤吧』一改刻板印象，更用5个月减重54斤的惊人毅力，完美诠释了”敬业”的含义。 大陆优秀电影作品 任重道远 8.华语电影方面，竟无一部大陆作品上榜。中国xx地区上榜两部，分别是排名241的『花样年华』和247的『无间道』。","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"A sharing about Open Policy Agent2","date":"2019-12-05T15:05:13.000Z","path":"2019/12/05/A-sharing-about-Open-Policy-Agent/","text":"Introduction The Open Policy Agent (OPA, pronounced “oh-pa”) is an open source, general-purpose policy engine that unifies policy enforcement across the stack. OPA provides a high-level declarative language that let’s you specify policy as code and simple APIs to offload policy decision-making from your software. You can use OPA to enforce policies in microservices, Kubernetes, CI/CD pipelines, API gateways, and more. You can get more information by the official website. Download &amp; RunOn macOS (64-bit): -L -o opalink12345On Linux (64-bit):```curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64 On Windows:1Windows users can obtain the OPA executable from [GitHub Releases](https://github.com/open-policy-agent/opa/releases). The steps below are the same for Windows users except the executable name will be different. On Docker: The most convenient way to use OPA is by the docker. 1docker run -p 8181:8181 openpolicyagent/opa run --server --log-level debug more information RegoBasic Type整型,浮点型,布尔型,统称为标量类型(Scalar values) Composite Typearrayobjectsetset是一组无序的,唯一值的集合;h和array/object相比,set不可以被索引.元素值的顺序,也不影响其是否相等,即{1,2,3} == {3,1,2}结果为true Rego’s Modules: Package,Import,RuleIn Rego, policies are defined inside modules. Modules consist of: Exactly one Package declaration. Zero or more Import statements. Zero or more Rule definitions. Some tips and syntax sugar[_]Package如package名称为 xxx.yyy.zzz 可通过请求 localhost:8181/v1/data/xxx/yyy/zzz 获得结果 Import要以data或input开头,可以用as自定义名称 KeywordSomeWithDefaultElseOperatorsAssignment :=Comparison ==Unification =Best Practices for the three operators aboveComparison Operators","tags":[]},{"title":"A sharing about Open Policy Agent","date":"2019-12-05T15:05:13.000Z","path":"2019/12/05/A-sharing-about-Open-Policy-Agent_bak/","text":"package play default hello = falsedefault v = false default t2 = false hello { pi := 3.14159 #pi = 2.71828 rect := {&quot;width&quot;: 2, &quot;height&quot;: 4} #rect.width=21 rect == {&quot;height&quot;: 4, &quot;width&quot;: 2} cui := {&quot;hometown&quot;:&quot;zp&quot;, &quot;age&quot;:26} # =和==效果等效,都是判等而不是赋值 # cui = {&quot;age&quot;:27, &quot;hometown&quot;:&quot;zp&quot;} # cui == {&quot;age&quot;:27,&quot;hometown&quot;:&quot;zp&quot;} m := input.message m == &quot;world&quot; } #右边的input,可以传参进来,根据参数来进行判断,也可以不传 v { “hello” == “hello” } 可以用;来分割多个”表达式”,或者新起一行,以省略;几个表达式之间是and的关系 t { x := 42; y := 41; x &gt; y } 也可以直接返回true/false,但是不能返回空body,否则会报错: found empty body tt {true} t2 { x := 42 y := 41 x &gt; y #3 &gt; 5 } ———-这里面表达式的顺序不影响结果s { x &gt; y y = 41 x = 42} s2 { #43 &gt; y # 在一个值出现后又被:=赋值,则会报错 y := 42 y := 42 #这样会报错:rego_compile_error: var y assigned above} 在一个值出现后又被:=赋值,则会报错;即在这个值出现过后,不能再出现:=的操作s3 { y := 42 43 &gt; y} ———-sli { #sites = [{&quot;name&quot;: &quot;prod&quot;}, {&quot;name&quot;: &quot;smoke1&quot;}, {&quot;name&quot;: &quot;dev&quot;}] # there exists (at least) one document within sites where the name attribute equals &quot;smoke1&quot;., # 即[_]的作用就是遍历这个东西,然后如果有其中一个元素,和已知的元素相等,则返回true,类似Inslice方法或者in_array方法 input.site[_].name = &quot;smoke1&quot; } We can generalize the example above with a rule that defines a set document instead of a boolean document,可以用这种方式,来返回一个”set”,而不是bool值sli6[environment]{ #environment := input.site[_].name environment = input.site[_].name #:=和=两种写法都可以. } is_sli6_contain_sth { sli6[“prod”] sli6[“23sd”]} ———————————————————greeting := “Hello”max_height := 42location := null scalar{ [greeting, max_height] = [&quot;Hello&quot;,42] location = null } #default composite1 = true composite1[cube] { cube := {&quot;width&quot;: 3, &quot;height&quot;: 4, &quot;depth&quot;: 5} } composite1[cube2] { cube2 := {&quot;width&quot;: 13, &quot;height&quot;: 4111, &quot;depth&quot;: 2225} } composite6 { cube := {&quot;width&quot;: 13, &quot;height&quot;: 4111, &quot;depth&quot;: 2225} cube.height #返回13 } composite8 { a := 42 b := false c := null d := {“a”: a, “x”: [b, c]} d.a = 44 } —–set类型是unordered的,unique的;{}即是集合set5[cube] { cube := {“width”: 666, “height”: 777,”time”: 666, “depth”: 888,”depth”: 999} } set6[s] { cube := {“width”: 666, “height”: 777,”time”: 6667, “depth”: 888,”depth”: 999} s := {cube.width, cube.height, cube.depth,cube.time}} set8 { {1,2,3} == {3,1,2} x = 1 {1,2,3} == {3,x,2}} 因为集合与对象都是用{}大括号语法来定义; 用{}定义一个空对象，所以必须使用不同的语法来创建一个空集合：count(set())#———Variables—————– #———References—————– r[ u[0].servers[1].hostname] { u := input.university } #用dot-access或者类似python的方式都可以 r2[ u[0][“servers”][2][“name”]] { u := input.university } 两种形式均有效，但是，点访问样式通常更具可读性。但在四种情况下必须使用方括号：—————Variable Keys—————–i和j,类似冒泡排序,把每个都过一遍,但凡有一个值等于给定的值,则返回true下划线可以被视为特殊的迭代器。就是一种语法糖: 在幕后，OPA将_字符转换为唯一的变量名称，该名称与范围内的变量和规则不冲突。vk { input.university[].servers[].hostname = “sdu.edu.cn” } ——————Composite Keys—————————s := {[1, 2], [1, 4], [2, 6]} s[[1, 2]] ——————Comprehensions————————这部分的input{ “message”: “world”, “site”:[{“name”: “prod”}, {“name”: “smoke1”}, {“name”: “dev”}], &quot;university&quot;:[ { &quot;region&quot;: &quot;north&quot;, &quot;name&quot;: &quot;Beijing&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;tsinghua&quot;, &quot;hostname&quot;: &quot;tsinghua.edu.cn&quot; }, { &quot;name&quot;: &quot;pku&quot;, &quot;hostname&quot;: &quot;pku.edu.cn&quot; }, { &quot;name&quot;: &quot;ruc&quot;, &quot;hostname&quot;: &quot;ruc.edu.cn&quot; } ] }, { &quot;region&quot;: &quot;east&quot;, &quot;name&quot;: &quot;Shanghai&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;sjtu&quot;, &quot;hostname&quot;: &quot;sjtu.edu.cn&quot; }, { &quot;name&quot;: &quot;fudan&quot;, &quot;hostname&quot;: &quot;fudan.edu.cn&quot; }, { &quot;name&quot;: &quot;tongji&quot;, &quot;hostname&quot;: &quot;tongji.edu.cn&quot; } ] }, { &quot;region&quot;: &quot;south&quot;, &quot;name&quot;: &quot;Guangzhou&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;sysu&quot;, &quot;hostname&quot;: &quot;sysu.edu.cn&quot; }, { &quot;name&quot;: &quot;scut&quot;, &quot;hostname&quot;: &quot;scut.edu.cn&quot; } ] } ] } 2package play sites := [ {“name”: “prod”}, {“name”: “smoke1”}, {“name”: “dev”}] q[name1] {name1 := input.sites[_].name}v { 1 = 1 input.site[_].name = “dev”}{ 2=22} 2的input{ “message”: “world”, “site”:[{“name”: “prod”}, {“name”: “smoke1”}, {“name”: “dev”}]} 3package play Composite Keyss = {[1, 2], [1, 4], [2, 6]} rs[s[[1, x]]]{ s[[1,x]] == [1,2] #true } 4package play Comprehensions ,类似python中的语法Python equivalent of Rego comprehension shown above.names = [site.name for site in sites if site.region == “west”]region := “west” #names := [name | sites[i].region == region; name := sites[i].name] names := [name | input.site[i].region == region; name := input.site[i].name] input是: { “message”: “world”, “site”:[ { “region”: “east”, “name”: “prod”, “servers”: [ { “name”: “web-0”, “hostname”: “hydrogen” }, { “name”: “web-1”, “hostname”: “helium” }, { “name”: “db-0”, “hostname”: “lithium” } ] }, { “region”: “west”, “name”: “smoke”, “servers”: [ { “name”: “web-1000”, “hostname”: “beryllium” }, { “name”: “web-1001”, “hostname”: “boron” }, { “name”: “db-1000”, “hostname”: “carbon” } ] }, { “region”: “west”, “name”: “dev”, “servers”: [ { “name”: “web-dev”, “hostname”: “nitrogen” }, { “name”: “db-dev”, “hostname”: “oxygen” } ] }]} 5package play default hello = false Array Comprehensionsapp_to_hostnames[app_name] = hostnames { app := input.apps[_] app_name := app.name hostnames := [hostname | name := app.servers[] s := input.sites[].servers[_] s.name == name hostname := s.hostname]} input是: { “message”: “world”, “apps”: [ { “name”: “web”, “servers”: [“web-0”, “web-1”, “web-1000”, “web-1001”, “web-dev”] }, { “name”: “mysql”, “servers”: [“db-0”, “db-1000”] }, { “name”: “mongodb”, “servers”: [“db-dev”] } ], &quot;sites&quot; : [ { &quot;region&quot;: &quot;east&quot;, &quot;name&quot;: &quot;prod&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-0&quot;, &quot;hostname&quot;: &quot;hydrogen&quot; }, { &quot;name&quot;: &quot;web-1&quot;, &quot;hostname&quot;: &quot;helium&quot; }, { &quot;name&quot;: &quot;db-0&quot;, &quot;hostname&quot;: &quot;lithium&quot; } ] }, { &quot;region&quot;: &quot;west&quot;, &quot;name&quot;: &quot;smoke&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-1000&quot;, &quot;hostname&quot;: &quot;beryllium&quot; }, { &quot;name&quot;: &quot;web-1001&quot;, &quot;hostname&quot;: &quot;boron&quot; }, { &quot;name&quot;: &quot;db-1000&quot;, &quot;hostname&quot;: &quot;carbon&quot; } ] }, { &quot;region&quot;: &quot;west&quot;, &quot;name&quot;: &quot;dev&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-dev&quot;, &quot;hostname&quot;: &quot;nitrogen&quot; }, { &quot;name&quot;: &quot;db-dev&quot;, &quot;hostname&quot;: &quot;oxygen&quot; } ] } ] } 6package play default hello = false Object Comprehensionsapp_to_hostnames := {app.name: hostnames | app := input.apps[] hostnames := [hostname | name := app.servers[] s := input.sites[].servers[] s.name == name hostname := s.hostname]} input: { “message”: “world”, “apps”: [ { “name”: “web”, “servers”: [“web-0”, “web-1”, “web-1000”, “web-1001”, “web-dev”] }, { “name”: “mysql”, “servers”: [“db-0”, “db-1000”] }, { “name”: “mongodb”, “servers”: [“db-dev”] }], &quot;sites&quot;:[ { &quot;region&quot;: &quot;east&quot;, &quot;name&quot;: &quot;prod&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-0&quot;, &quot;hostname&quot;: &quot;hydrogen&quot; }, { &quot;name&quot;: &quot;web-1&quot;, &quot;hostname&quot;: &quot;helium&quot; }, { &quot;name&quot;: &quot;db-0&quot;, &quot;hostname&quot;: &quot;lithium&quot; } ] }, { &quot;region&quot;: &quot;west&quot;, &quot;name&quot;: &quot;smoke&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-1000&quot;, &quot;hostname&quot;: &quot;beryllium&quot; }, { &quot;name&quot;: &quot;web-1001&quot;, &quot;hostname&quot;: &quot;boron&quot; }, { &quot;name&quot;: &quot;db-1000&quot;, &quot;hostname&quot;: &quot;carbon&quot; } ] }, { &quot;region&quot;: &quot;west&quot;, &quot;name&quot;: &quot;dev&quot;, &quot;servers&quot;: [ { &quot;name&quot;: &quot;web-dev&quot;, &quot;hostname&quot;: &quot;nitrogen&quot; }, { &quot;name&quot;: &quot;db-dev&quot;, &quot;hostname&quot;: &quot;oxygen&quot; } ] } ] } ####","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Unix后记&寻找Shen Lin","date":"2019-12-03T13:16:10.000Z","path":"2019/12/03/Unix后记-寻找Shen-Lin/","text":"看『左耳朵耗子』这篇UNIX 50 年：KEN THOMPSON 的密码，意外获知KEN，DMR，RMS之外，能够拥有三位字母简称，且在极客圈中得到广泛认可的另一位大神——BWK。同样是贝尔实验室出来的研究员，当初跟着K&amp;R开发unix。另外，awk中的“k”，那本C语言经典&lt;C程序设计语言&gt;作者K&amp;R中的“k”，均指此人 --- 所以，K&amp;R在分指Unix和C时，“K”竟然有不同涵义… 有关BWK的资料明明整整十分详细，但他的两项研究成果， graph partitioning 和 travelling salesman problem——都有一位疑似华人的『Shen Lin』参与，但却无有这么一位重要人物的词条，知之者怕更是鲜有。 这位Shen Lin，我能搜到的资料，是被诺基亚收购后的贝尔实验室研究员。遍查全网，只有一位同名研究戏剧的学者，与之匹配度最高，但又显然不是。 两个理论中，前者在当下机器学习中提供重要理论支撑，后者则是运筹学图论中必学，我更习惯翻译为“流动商贩问题”，结果搜索结果全是城管如何如何… Ken的这个回复，及Unix这个社区的“极简风格”，让我想起Linus在Ted上的“rant”:如果被困孤岛，做个页面就能获救，那他选择死在岛上 KEN的github 追忆者为DMR建的github","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"Golang中的常用转换","date":"2019-12-02T13:23:14.000Z","path":"2019/12/02/Golang中的常用转换/","text":"int/string互转12345str := strconv.Itoa(19930217) // \"19930217\"i,err := strconv.Atoi(\"19930217\") //19930217 int64/string直接互转123str := strconv.FormatInt(9223372036854775808,10) //\"9223372036854775808\"i64, err := strconv.ParseInt(\"9223372036854775808\", 10, 64) //9223372036854775808 string和float32/64 互转12f64,err := strconv.ParseFloat(\"3.12345678\",64) //3.12345678f32,err := strconv.ParseFloat(\"3.12345678\",32) //3.1234567165374756 12345 s1 := strconv.FormatFloat(3.12345678, 'f', -1, 32)//float32,3.1234567s2 := strconv.FormatFloat(3.12345678, 'f', -1, 64)//float64,3.12345678s3 := strconv.FormatFloat(3.1234567, 'f', -1, 32)//float32,3.1234567 s4 := strconv.FormatFloat(3.1234567, 'f', -1, 64)//float64,3.1234567","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Year 2038 problem","date":"2019-12-02T11:34:37.000Z","path":"2019/12/02/Year-2038-problem/","text":"前情回顾 已经知道,对于int了tinyint了这些MySql类型,后面那个4或者11没啥实际意义,只是说(当位数不足时)前面填充多少个0,然后使之变为4位或者11位,对这个类型的字段实际能存的长度没啥影响. 即占据1个Byte的tinyint类型,最多就能表征256个不同值. 可以表征无符号的连续数字0-255,或者有符号的数字-128到127. char类型括号里的数字和tinyint/int差不多; 而varchar不同,括号里的这个数字确实有实际意义,可以指定其最大能存多少,其所谓”可变”,也就是在这里.即varchar这个类型能存的最大长度,根据后面括号里的这个数值而变. 且自MySql 5.0后,这个数字指”字符”,而不再是”字节”,即对一个varchar(6),存”张三李四王五”没问题,但”1234567”或”abcdefg”,则会溢出. timestamp类型 占4Byte即32个Bit，也即最多能表征2的32次方个不同值。如果考虑正负，可存纳从0到2的32次方-1的数;若考虑符号，则可容纳-2的31次方到2的31次方-1多的数。…也即如果存时间戳类型，最多在从格林尼治时间1970-01-01 00:00:00开始，过后2的32次方-1秒后，将会出现溢出问题。 但问题是，实际是过2的31次方-1秒，(即2147483647秒,巧合的是，这个数竟然是个梅森素数！)也就是格林尼治时间2038-01-19 03:14:07，就会因达到边界而出现问题。 那这里为何要用有符号的整型而白白浪费一个比特位？丝毫没有必要。而不这样做的好处却很显然，可以表示2的32次方-1秒，即4294967295，这样可以直接使可用时间到格林尼治时间2106-06-07 14:28:15。 孜孜以求 为这问题可真是上穷碧落下尘埃，没写过C++的我，甚至硬着头皮看了总共有2.2GB的MySql源码……数据库时间戳字段其实会读取系统时间(如根据当前时间戳更新功能)，这也就牵扯到了unix早期开发时，K&amp;R两位天神的设计。 几经寻索,我在这里找到了与我相同的疑问: 一种说法是，当时还没有无符号的整数这种类型(uint)，也没有考虑到脱胎于贝尔实验室，Ken用来打游戏的unix，能够存活那么久，并作为信息时代最最重要基础设施，深刻改变了整个世界的面貌----失败的MULTICS启发了Ken和Dmr，于是有了Unix(和C语言)，又在逾20年后，使芬兰人Linus一举成名，取代RMS，成为geek新一代精神领袖。今天，全世界90%以上的服务，包括MacOS，iOS，Android，以及几乎所有App和web网站的服务端代码，和unix/linux有最直接联系。 实际上，在这个一日千里的时代和行业，人类并不会使『Year 2038 Problem』有机会真实发生，但这个探索的过程和过程中形成的一套方法论，却是特别具有意义。 附录小记 另:Dmr于2011年10月，在西海岸硅谷叱咤风云的乔布斯去世后不久，被人发现默默死于东海岸寓所中，对这位Unix和C语言之父，图灵奖得主，祭奠者屈指可数。 另一位Unix之父和图灵奖得主Ken(一种说法是Unix主要是Ken开发，但Dmr做了大量优秀设计，因而业界肯排里奇前面，学界则恰好相反)，同时亦是B语言之父，utf-8设计者。后来。他加入Google，和另外几位同僚一道(包括当年贝尔实验室的小弟Rob Pike)，设计了一种叫做Golang的全新语言。 1999年肯·汤普逊(左)和丹尼斯·里奇因开发C语言和 Unix 操作系统一起获得了美国国家技术奖。 拓展: 『梅森素数是由梅森数而来。所谓梅森数，是指形如2的p次方－1的一类数，其中指数p是素数，常记为Mp 。如果梅森数是素数，就称为梅森素数。 用因式分解法可以证明，若2n－1是素数，则指数n也是素数；反之，当n是素数时，2n－1（即Mp）却未必是素数。前几个较小的梅森数大都是素数，然而梅森数越大，梅森素数也就越难出现。目前仅发现51个梅森素数，最大的是M82589933（即2的82589933次方减1），有24862048位数。 真真是15年前便曾听过,但也仅限于此』 时间函数在MySql中: # 获取当前时间戳1select UNIX_TIMESTAMP() 1575379809 # 获取当前时间1select now() 2019-12-03 21:31:32 # 2147483647时间戳(2的31次方-1)对应的当地时间1select FROM_UNIXTIME(2147483647,\"%Y-%m-%d %H:%i:%S\") 2038-01-19 11:14:07 # 从格林尼治时间1970-01-01 00:00:00 过后9999999999秒后对应的当地时间(越界..) 1select FROM_UNIXTIME(9999999999) Null # 1938-01-20 00:00:00 对应的”时间戳”(并不是负数) 1select UNIX_TIMESTAMP(\"1938-01-20 00:00:00\") 0","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"避坑,sed命令在Mac和Linux下有不同","date":"2019-11-21T10:51:34.000Z","path":"2019/11/21/避坑-sed命令在Mac和Linux下有不同/","text":"问题 （1）Windows系统里，文件每行结尾是’&lt;回车&gt;&lt;换行&gt;’, ‘\\r\\n’ （2）Mac系统里， 文件每行结尾是’&lt;回车&gt;’，即’\\r’ （3）Unix系统里， 文件每行结尾是’&lt;换行&gt;’，即’\\n’ 所以，用’\\n’作为作为换行符的文件，用Windows的记事本打开时 会没有换行； 而用’\\r\\n’作为换行符的文件（windows文件），用Linux或mac的vim打开时 会将\\r显示成^M。 echo &quot;a,b,c,d&quot; 在Mac或Linux系统下,以上结果皆为a,b,c,d 现用sed,将”,”替换为换行,&nbsp;&nbsp;Linux系统下执行echo &quot;a,b,c,d&quot; |sed &#39;s/,/\\n/g&#39;,结果为: 相同命令,在Mac下执行结果则为: 解决通过安装gsed来解决, brew install gnu-sed 然后使用gsed, 在bash_profile中加一条alias,用gsed替换掉sed 更多相关问题,可参考","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"'步履不停'特别项目--'62761232快递展览'档案","date":"2019-11-17T13:46:29.000Z","path":"2019/11/17/步履不停-特别项目-62761232快递展览-档案/","text":"p{ text-indent:2em;} (一) 当年15年前，一群荷尔蒙旺盛的艺术家，和这座正值艺术青春期的城市，发生激烈碰撞，有了一场现在来看依然不失先锋前卫的“62761232 当代艺术快递展”:观众拨打这个电话，经过培训的快递员，带着装有展品的箱子上门讲解展示，全程免费。那是个互联网刚从泡沫寒冬中走出的年代，纸媒依然是传播渠道的主体，快递业亦处草创阶段。ta们联系多家媒体，最终只有刚创办一年的&lt;东方早报&gt;，愿意给以版面宣传;因要对快递员占用工作时间培训，几经拉锯，上海本土一家叫“羚羊快递”的公司，承接下这特殊的“订单”。除去“快递展”，同期还有地点位于商场的“超市展”，凌晨0:30开始的“十二点半”，双份展品镜像呈现的“双胞胎展”。15年间，当初组织者光顾进行策划的咖啡馆，均已倒闭歇业无一例外，那家羚羊快递，也被更大型和集团化的公司击败退出市场。即便背后是“文汇/新民”报业集团的&lt;东方早报&gt;，也在互联网席卷，纸媒日渐式微之际，于前几年停刊，专注做线上的“澎湃新闻”。城市步履匆匆，时代呼啸而过，对这样一场远在15年前,持续只有10天,由42名艺术家和15名快递员,及上百位观众共同构成的”遥远往事”,就更显如此:当初的展品多已找寻不见，参展者和观展者，也多消散于人海，甚有撒手人寰。一切都在时光面前，透说着流离失所的无奈。恰逢“1995-2019 中国当代艺术的城市叙事”展览期间，多伦现代美术馆策划了这场特别项目，邀当年几位当事者亲临，有了这场异彩纷呈的“回忆杀”。(二) 再叙活动方联系到了15年前几位策划者和参与者。当时J在&lt;东方早报&gt;负责文化艺术板块，亦以参展者身份参与。同时几经努力,联系到当初15名快递员中的一位，但他自觉与艺术无甚关联，让其回忆职业生涯中这与众不同的短短一瞬，有些强人所难。当时的受众并没有太多，而今能找到的就只有J的同事，当时毕业不多久，同样供职于&lt;东方早报&gt;的一位女士。她像现在点外卖一样，每到中午都打电话，其中一“展品”，会留下一只拖鞋，待到整个活动结束时，已经堆了好几双。回忆中同样感慨15年变化，用她话说，“原来是抽烟喝酒，谁也看不惯的桀骜少女，现在朋友形容她 是母仪天下”。说起受众数量，徐震说，其实ta们只管表达出自己的想法，至于观众多少反响如何，实话说不是太在意。我想，这大概是”艺术”与”商业”，艺术品与商品的不同。观众水平参差，经闻见解有异，艺术不会去迎合受众，也不能去在意曲高和寡。试问，当面对&lt;向日葵&gt;和&lt;格尔尼卡&gt;，观众当真都能get到作者意图，分析出“好在哪里”？疑问办这样一场没有收益的活动，动力源何？又为何如阿波罗登月，在条件看似更充足完备的15年后，反而再少有类似“展览”？当事者回答，当初某个艺术组织给了两万，几位策划者又凑了些，主要用来付快递费用，以及购买箱子。参展者没有回报反还要交费，还要将展品自行寄至主办方处。动机和动力大概就是年轻，热血，想做点与众不同的事。而今年届中年，算是换了一种形式，细水长流。(三) 嬗变没有人能永远年轻，但总有人正年轻。而当下那些”正年轻着的艺术家”，在做些什么呢？此前在xxxxx的工作经历，让我认识几位“艺术家”朋友。ta们散落居住在杭州南面群山中的村落，对该群体的生活状态大致了然。我认为，是互联网让封闭的世界愈发稀少以至绝迹——封闭不一定全然是坏事，至少在保持多样性避免同质化方面，封闭不可或缺。已经没有人能完全不吸纳汹涌而来的外部讯息，在小圈子里漫不经心地自顾自过着活着。我们平时很难准确领略到技术的力量。实际上，一切的变化，一切摧枯拉朽或润物无声地演进，最底层都源自技术的突破，动摇了上层原本稳固的一切。活动结束，走在被法国梧桐枯叶覆盖的山阴路，路过内山完造旧居，想着ta们慨叹的“青春”“青春”。也生出一声叹息:何用十五年，此刻心绪，与自以为永远不会被锤倒的三年前比，已是老气横秋。踩在簌簌枯叶上，这段话模糊出现在心头:“我早先岂不知我的青春已经逝去？但以为身外的青春固在：星，月光，僵坠的蝴蝶，暗中的花，猫头鹰的不祥之言，杜鹃的啼血，笑的渺茫，爱的翔舞。……虽然是悲凉漂渺的青春罢，然而究竟是青春。” 参考: 费大为：艺术一定要快递 寻人启事 | 寻找十五年前的快递员和观众 &lt;美术文献&gt; 第36期 虹口多伦现代美术馆——快递一个展览给你：对话“62761232快递展”艺术家 “步履不停：1995-2019年中国当代艺术的城市叙事”将于2019年10月18日至12月15日在上海多伦现代美术馆展出。本次展览由上海多伦现代美术馆主办，吴蔚担任策展人，以公共空间和当代艺术实践的交叉点为研究对象，聚焦20世纪90年代中期以来以城市街头为主题的中国当代艺术实践。展览期间，在美术馆内部空间和多伦路街区，同时展出十七位艺术家创作的当代艺术作品，涵盖绘画、摄影、影像、雕塑、装置等不同艺术形式。本次展览将免费向公众开放。 展览以“步履不停”为主题，关注艺术家在城市街头行走、漫游、渐进的持续旅程。他们的作品表现了艺术家对于社会环境、城市空间及人群的批判性思考，呈现了个人和集体的记忆与经验，并将变革带到日常生活中。 20世纪90年代，随着中国城市化进程的加快，当代艺术家开始主动关注并探索城市公共空间，他们改变了以往对公共空间的认知和介入方式，进一步扩大了文化和美学表达的范围。当艺术进入人们日常生活中熟悉的场所和领地，“街道”不仅记录了艺术观念和实践变化的轨迹，也见证了城市发展和公共文化的历史，突显了其中社群生活的特性与意义。本次展览尝试让艺术成为连接美术馆与社区、艺术家与大众之间的桥梁。 本次展览还将展出特别项目“‘62761232快递展’档案”，这是“62761232快递展”的文献档案首次在国内美术馆与公众见面。2004年9月，由上海比翼艺术中心发起，四十二位艺术家和十五位快递员参与了一次特别的“外卖”展览。“快递展”期间，上海市民可以通过拨打快递公司的电话，让快递员将浓缩在一个行李箱里的展览带到面前。十五年后，我们将通过当年展览的文献档案，回顾这个具有启发性的艺术项目，展现艺术家在大变局时代的独特视野与前瞻性，重新定义艺术、公众和城市之间的关系。此次特别项目得到香格纳画廊文献库的大力协助。 本次展览将同时参与2019上海城市空间艺术季联合展，以及2019年“1+16”美术馆市民共享计划，以“艺术美育再升级”为目的，使市民和美术馆的距离更近，参与更多，体验更佳，从而不断提升市民的内在审美和人文素养。 通过本次活动展示的不同门类的艺术作品，希望吸引更多的市民参与互动，为整个多伦路街区的发展拓展思考空间。在此，观众和艺术家都是现代都市的行者，共同感知当代城市的肌理，挖掘现代生活的细节，激发创造性思维，使重塑城市空间和公共生活成为可能。 步履不停：1995-2019年中国当代艺术的城市叙事","tags":[]},{"title":"关于time.Duration()的注释","date":"2019-11-15T13:16:31.000Z","path":"2019/11/15/关于time-Duration-的注释/","text":"A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years. Duration 将两个瞬间之间经过的时间表示为 int64 纳秒计数。 该表示将最大可表示持续时间限制为大约 290 年。 src/time/time.go1234567891011121314151617181920212223242526272829// A Duration represents the elapsed time between two instants// as an int64 nanosecond count. The representation limits the// largest representable duration to approximately 290 years.type Duration int64const ( minDuration Duration = -1 &lt;&lt; 63 maxDuration Duration = 1&lt;&lt;63 - 1)// Common durations. There is no definition for units of Day or larger// to avoid confusion across daylight savings time zone transitions.//// To count the number of units in a Duration, divide:// second := time.Second// fmt.Print(int64(second/time.Millisecond)) // prints 1000//// To convert an integer number of units to a Duration, multiply:// seconds := 10// fmt.Print(time.Duration(seconds)*time.Second) // prints 10s//const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute) 12345678func main()&#123; minDuration := -1 &lt;&lt; 63 maxDuration := 1&lt;&lt;63 - 1 fmt.Println(\"minDuration:\",minDuration) fmt.Println(\"maxDuration:\",maxDuration)&#125; 输出为： 12minDuration: -9223372036854775808maxDuration: 9223372036854775807 即可以表征从Unix时间零点，即北京时间1970-01-01 08：00：00，到过后9223372036854775807纳秒之后，这之间的时间间隔 1s= 1e9 ns 即约为9223372036秒 转化为北京时间，约为 2262-04-12 07:47:16,中间相隔292年零4个多月","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"GORM 中的Hook和Callbacks","date":"2019-11-14T07:46:55.000Z","path":"2019/11/14/GORM-中的Hook和Callbacks/","text":"V2： https://gorm.io/zh_CN/docs/v2_release_note.html https://gorm.io/zh_CN/docs/session.html https://gorm.io/zh_CN/docs/write_plugins.html https://gorm.io/zh_CN/docs/hooks.html https://www.zhangshengrong.com/p/q0XpVee6aK/ https://jiajunhuang.com/articles/2019_03_19-gorm.md.html https://github.com/go-gorm/gorm/blob/master/prepare_stmt.go https://juejin.cn/post/6844903843969368072 https://segmentfault.com/a/1190000039097157 https://xie.infoq.cn/article/f061726cf5611637a77e026ae https://gorm.io/zh_CN/docs/write_plugins.html https://3ks.dev/2020/07/28/gorm-faq/ V1： https://learnku.com/docs/gorm/v1/write_plugins/3803#965348 https://cloud.tencent.com/developer/article/1830811 https://blog.csdn.net/weixin_39769183/article/details/112609741 https://jasperxu.com/gorm-zh/advanced.html mysql使用ROW_COUNT()返回插入、更新、删除操作影响行数。即gorm中的RowsAffected字段 而读取的行数， **github.com/jinzhu/gorm@v1.9.16/scope.go:** **github.com/jinzhu/gorm@v1.9.16/callback_query.go:** 核心的步骤在于 scope.prepareQuerySQL() 构建 SQL 语句.然后通过 rows, err := scope.SQLDB().Query(scope.SQL, scope.SQLVars…), 执行了数据库查询. 那么查询到的结果是如何传递的, 传递给谁呢? 函数的开头定义了 results = scope.IndirectValue(), 这就是最终查询结果的归属地. https://segmentfault.com/a/1190000022987438","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"搭建Jaeger","date":"2019-11-13T13:23:35.000Z","path":"2019/11/13/搭建Jaeger/","text":"姊妹篇: prometheus入门 本篇是对 Golang 上手GORM V2 + Opentracing链路追踪优化CRUD体验（源码阅读） 阅读与实践 该篇相关代码 GORM V2版本开始支持Context上下文传递，支持插件Plugins(有了插件，callback和hook的代码就能更优雅一点) ORM利用反射，以牺牲一定的性能为代价，快速构建项目 使用Docker搭建Opentracing + jaeger 平台 docker run -d --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p 5775:5775/udp -p 6831:6831/udp -p 6832:6832/udp -p 5778:5778 -p 16686:16686 -p 14268:14268 -p 14250:14250 -p 9411:9411 jaegertracing/all-in-one:1.18 访问 http://localhost:16686/ 如下： 编写CallBacks插件 CallBacks和Hook不同,前者将伴随GORM的DB对象的整个生命周期,利用CallBacks对GORM框架进行侵入,实现自定义的一些功能 1. 在每次SQL操作前,从context上下文生成子span gormTracing.go: 12345678910111213141516171819package gormTracingimport ( \"github.com/opentracing/opentracing-go\" \"gorm.io/gorm\")const gormSpanKey = \"__gorm_spqn\"func before(db *gorm.DB) &#123; //生成子span。 名字可以自定义 span, _ := opentracing.StartSpanFromContext(db.Statement.Context, \"shuang_gorm_jaeger\") // 利用db实例去传递span // gorm v1.x版本没有InstanceSet，有scope.Set db.InstanceSet(gormSpanKey, span)&#125; 2. 在每次SQL操作后 从DB实例拿到Span并记录数据 gormTracing.go: 123456789101112131415161718192021222324func after(db *gorm.DB) &#123; _span, isExist := db.InstanceGet(gormSpanKey) if !isExist &#123; // 不存在则直接抛弃掉 return &#125; // 断言 进行类型转换 span, ok := _span.(opentracing.Span) if !ok &#123; return &#125; // 一定要Finish掉 defer span.Finish() // 记录error if db.Error != nil &#123; span.LogFields(tracerLog.Error(db.Error)) &#125; span.LogFields(tracerLog.String(\"sql\", db.Dialector.Explain(db.Statement.SQL.String(), db.Statement.Vars...)))&#125; 同样可以非常简单就可以从DB的Setting中，拿到用于处理GORM操作的子Span。 只需要调用span的LogFields方法就能记录下想要的信息 3. 创建结构体，实现gorm.Plugin接口 gormTracing.go:1234567891011121314151617181920212223242526272829303132const ( callBackBeforeName = \"opentracing:before\" callBackAfterName = \"opentracing:after\")type OpentracingPlugin struct&#123;&#125;func (op *OpentracingPlugin) Name() string &#123; return \"opentracingPlugin\"&#125;func (op *OpentracingPlugin) Initialize(db *gorm.DB) (err error) &#123; // 开始前 - 并不是都用相同的方法，可自定义 db.Callback().Create().Before(\"gorm:before_create\").Register(callBackBeforeName, before) db.Callback().Query().Before(\"gorm:query\").Register(callBackBeforeName, before) db.Callback().Delete().Before(\"gorm:before_delete\").Register(callBackBeforeName, before) db.Callback().Update().Before(\"gorm:setup_reflect_value\").Register(callBackBeforeName, before) db.Callback().Row().Before(\"gorm:row\").Register(callBackBeforeName, before) db.Callback().Raw().Before(\"gorm:raw\").Register(callBackBeforeName, before) // 结束后 - 并不是都用相同的方法，可自定义 db.Callback().Create().After(\"gorm:after_create\").Register(callBackAfterName, after) db.Callback().Query().After(\"gorm:after_query\").Register(callBackAfterName, after) db.Callback().Delete().After(\"gorm:after_delete\").Register(callBackAfterName, after) db.Callback().Update().After(\"gorm:after_update\").Register(callBackAfterName, after) db.Callback().Row().After(\"gorm:row\").Register(callBackAfterName, after) db.Callback().Raw().After(\"gorm:raw\").Register(callBackAfterName, after) return&#125;// 告诉编译器这个结构体实现了gorm.Plugin接口var _ gorm.Plugin = &amp;OpentracingPlugin&#123;&#125; 需要给GORM所有的最终操作（Create、Query、Delete、Update、Row、Raw等）, 注册上刚刚编写的两个方法 before和after （即在sql执行前要做的操作，和sql执行后要做的操作） GORM的Plugin接口源码如下： 12345// Plugin GORM plugin interfacetype Plugin interface &#123; Name() string Initialize(*DB) error&#125; 只需如上面代码，实现Name和Initialize这两个方法，即实现了这个接口 单元测试 1. 初始化Jeager gormTracing_test.go: 1234567891011121314151617181920212223242526272829303132333435package gormTracingimport ( \"github.com/opentracing/opentracing-go\" \"github.com/uber/jaeger-client-go\" \"github.com/uber/jaeger-client-go/config\" \"io\")func initJaeger() (closer io.Closer, err error) &#123; // 根据配置初始化Tracer， 返回Closer tracer, closer, err := (&amp;config.Configuration&#123; ServiceName: \"gormTracing\", Disabled: false, Sampler: &amp;config.SamplerConfig&#123; Type: jaeger.SamplerTypeConst, // param的值在0到1之间，设置为1则将所有的Operation输出到Reporter Param: 1, &#125;, Reporter: &amp;config.ReporterConfig&#123; LogSpans: true, LocalAgentHostPort: \"localhost:6831\", &#125;, &#125;).NewTracer() if err != nil &#123; return &#125; // 设置全局Tracer - 如果不设置将会导致上下文无法生成正确的Span opentracing.SetGlobalTracer(tracer) return&#125; 2. 实现GORM官方范例 GORM V2文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package gormTracingimport ( \"context\" \"github.com/opentracing/opentracing-go\" \"github.com/uber/jaeger-client-go\" \"github.com/uber/jaeger-client-go/config\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" \"io\" \"testing\")func initJaeger() (closer io.Closer, err error) &#123; // 根据配置初始化Tracer， 返回Closer tracer, closer, err := (&amp;config.Configuration&#123; ServiceName: \"gormTracing\", Disabled: false, Sampler: &amp;config.SamplerConfig&#123; Type: jaeger.SamplerTypeConst, // param的值在0到1之间，设置为1则将所有的Operation输出到Reporter Param: 1, &#125;, Reporter: &amp;config.ReporterConfig&#123; LogSpans: true, LocalAgentHostPort: \"localhost:6831\", &#125;, &#125;).NewTracer() if err != nil &#123; return &#125; // 设置全局Tracer - 如果不设置将会导致上下文无法生成正确的Span opentracing.SetGlobalTracer(tracer) return&#125;type Product struct &#123; gorm.Model Code string Price uint&#125;type User struct &#123; gorm.Model Id int Name string gender string&#125;// V2需要利用Driver来连接MySQL数据库func Test_GormTracing(t *testing.T) &#123; // 1. 初始化Jaeger closer, err := initJaeger() if err != nil &#123; t.Fatal(err) &#125; defer closer.Close() // 2. 连接数据库 // \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local\" dsn := \"root:12345678@tcp(localhost:3306)/shuang?charset=utf8mb4&amp;parseTime=True&amp;loc=Local\" db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;) if err != nil &#123; t.Fatal(err) &#125; // 3. 最重要的一步，使用之前自定义的插件 _ = db.Use(&amp;OpentracingPlugin&#123;&#125;) // 迁移 schema ---&gt; 生成对应的数据表 //_ = db.AutoMigrate(&amp;Product&#123;&#125;) // 4. 生成新的Span - 注意将span结束掉，不然无法发送对应的结果 span := opentracing.StartSpan(\"gormTracing unit test\") defer span.Finish() // 5. 把生成的Root Span写入到Context上下文，获取一个子Context // 通常在Web项目中，Root Span由中间件生成 ctx := opentracing.ContextWithSpan(context.Background(), span) // 6. 将上下文传入DB实例，生成Session会话 // 这样子就能把这个会话的全部信息反馈给Jaeger session := db.WithContext(ctx) // ---&gt; 下面是官方文档GORM的范例 // Create //session.Create(&amp;Product&#123;Code: \"D42\", Price: 100&#125;) // //// Read //var product Product //session.First(&amp;product, 1) // 根据整形主键查找 //session.First(&amp;product, \"code = ?\", \"D42\") // 查找 code 字段值为 D42 的记录 // //// Update - 将 product 的 price 更新为 200 //session.Model(&amp;product).Update(\"Price\", 200) //// Update - 更新多个字段 //session.Model(&amp;product).Updates(Product&#123;Price: 200, Code: \"F42\"&#125;) // 仅更新非零值字段 //session.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;\"Price\": 200, \"Code\": \"F42\"&#125;) // //// Delete - 删除 product //session.Delete(&amp;product, 1) var user User //db.Table(\"user\").Where(\"id=?\", 1).First(&amp;user) session.Table(\"user\").Where(\"id=?\", 1).First(&amp;user)&#125; 3. 执行并查看结果 访问Jaeger控制台（localhost:16686），可发现有一条新的记录： 点击进入查看详情，可以非常清楚看到整个单元测试从开始到结束的SQL执行情况： 总共执行了2条SQL命令，整个过程耗时3.76ms（因为连接的本地库，所以比较快） 点开对应的Span，可以看到每次GORM操作所执行的SQL命令： 至此使用OpenTracing对GORM执行过程进行链路追踪已成功实现，从此摆脱需要检索庞大日志查找慢查询、异常和错误的情况，直接一目了然 4. 并发情况下链路追踪的效果 1234567891011121314151617181920212223242526272829303132333435363738394041func Test_GormTracing2(t *testing.T) &#123; closer, err := initJaeger() if err != nil &#123; t.Fatal(err) &#125; defer closer.Close() db, err := gorm.Open(mysql.Open(\"root:12345678@tcp(localhost:3306)/shuang?charset=utf8mb4&amp;parseTime=True&amp;loc=Local\"), &amp;gorm.Config&#123;&#125;) if err != nil &#123; t.Fatal(err) &#125; _ = db.Use(&amp;OpentracingPlugin&#123;&#125;) rand.Seed(time.Now().UnixNano()) num, wg := 1&lt;&lt;10, &amp;sync.WaitGroup&#123;&#125; wg.Add(num) for i := 0; i &lt; num; i++ &#123; go func(t int) &#123; span := opentracing.StartSpan(fmt.Sprintf(\"gormTracing unit test %d\", t)) defer span.Finish() ctx := opentracing.ContextWithSpan(context.Background(), span) session := db.WithContext(ctx) p := &amp;Product&#123;Code: strconv.Itoa(t), Price: uint(rand.Intn(1 &lt;&lt; 10))&#125; session.Create(p) session.First(p, p.ID) session.Delete(p, p.ID) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 番外：GORM V2 部分源码阅读 GORM V2 部分源码阅读 更多参考: Jaeger V1.18文档 分布式链路追踪：OpenTracing SDK 与 Jaeger 的对接方法 gRPC与分布式链路追踪 全链路监控Jaeger搭建实战","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"runtime.Caller的性能问题","date":"2019-11-11T15:32:07.000Z","path":"2019/11/11/runtime-Caller的性能问题/","text":"前置篇 golang获取调用者的方法名及所在行数 123456789101112131415// Caller reports file and line number information about function invocations on// the calling goroutine's stack. The argument skip is the number of stack frames// to ascend, with 0 identifying the caller of Caller. (For historical reasons the// meaning of skip differs between Caller and Callers.) The return values report the// program counter, file name, and line number within the file of the corresponding// call. The boolean ok is false if it was not possible to recover the information.func Caller(skip int) (pc uintptr, file string, line int, ok bool) &#123; rpc := make([]uintptr, 1) n := callers(skip+1, rpc[:]) if n &lt; 1 &#123; return &#125; frame, _ := CallersFrames(rpc).Next() return frame.PC, frame.File, frame.Line, frame.PC != 0&#125; Caller报告有关函数调用的文件和行号信息调用 goroutine 的堆栈。 参数 skip 是堆栈帧的数量上升，0 标识呼叫者的caller。 （由于历史原因 跳过的含义在调用者和调用者之间有所不同。）返回值报告 相应的文件中的程序计数器、文件名和行号称呼。 如果无法恢复信息，则布尔值 ok 为 false。 skip： 堆栈帧数，0 为当前函数，1为上一层函数 pcuintptr这个返回的是函数指针 file是函数所在文件名目录 line所在行号 ok 是否可以获取到信息 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"runtime\")func main() &#123; test()&#125;func test() &#123; fmt.Printf(\"当前函数的文件/行号等信息：\") fmt.Println(runtime.Caller(0)) fmt.Printf(\"上一层函数的文件/行号等信息：\") fmt.Println(runtime.Caller(1)) fmt.Printf(\"上两层函数的文件/行号等信息：\") fmt.Println(runtime.Caller(2)) fmt.Printf(\"上三层函数的文件/行号等信息：\") fmt.Println(runtime.Caller(3)) fmt.Printf(\"上四层函数的文件/行号等信息：\") fmt.Println(runtime.Caller(4))&#125; 执行结果： 12345当前函数的文件/行号等信息：4297144295 /Users/fliter/go/src/shuang/runtimee/call.go 15 true上一层函数的文件/行号等信息：4297144159 /Users/fliter/go/src/shuang/runtimee/call.go 9 true上两层函数的文件/行号等信息：4296724555 /usr/local/go/src/runtime/proc.go 225 true上三层函数的文件/行号等信息：4296909139 /usr/local/go/src/runtime/asm_arm64.s 1130 true上四层函数的文件/行号等信息：0 0 false Next在不停地迭代 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// Next returns frame information for the next caller.// If more is false, there are no more callers (the Frame value is valid).func (ci *Frames) Next() (frame Frame, more bool) &#123; for len(ci.frames) &lt; 2 &#123; // Find the next frame. // We need to look for 2 frames so we know what // to return for the \"more\" result. if len(ci.callers) == 0 &#123; break &#125; pc := ci.callers[0] ci.callers = ci.callers[1:] funcInfo := findfunc(pc) if !funcInfo.valid() &#123; if cgoSymbolizer != nil &#123; // Pre-expand cgo frames. We could do this // incrementally, too, but there's no way to // avoid allocation in this case anyway. ci.frames = append(ci.frames, expandCgoFrames(pc)...) &#125; continue &#125; f := funcInfo._Func() entry := f.Entry() if pc &gt; entry &#123; // We store the pc of the start of the instruction following // the instruction in question (the call or the inline mark). // This is done for historical reasons, and to make FuncForPC // work correctly for entries in the result of runtime.Callers. pc-- &#125; name := funcname(funcInfo) if inldata := funcdata(funcInfo, _FUNCDATA_InlTree); inldata != nil &#123; inltree := (*[1 &lt;&lt; 20]inlinedCall)(inldata) // Non-strict as cgoTraceback may have added bogus PCs // with a valid funcInfo but invalid PCDATA. ix := pcdatavalue1(funcInfo, _PCDATA_InlTreeIndex, pc, nil, false) if ix &gt;= 0 &#123; // Note: entry is not modified. It always refers to a real frame, not an inlined one. f = nil name = funcnameFromNameoff(funcInfo, inltree[ix].func_) // File/line is already correct. // TODO: remove file/line from InlinedCall? &#125; &#125; ci.frames = append(ci.frames, Frame&#123; PC: pc, Func: f, Function: name, Entry: entry, funcInfo: funcInfo, // Note: File,Line set below &#125;) &#125; // Pop one frame from the frame list. Keep the rest. // Avoid allocation in the common case, which is 1 or 2 frames. switch len(ci.frames) &#123; case 0: // In the rare case when there are no frames at all, we return Frame&#123;&#125;. return case 1: frame = ci.frames[0] ci.frames = ci.frameStore[:0] case 2: frame = ci.frames[0] ci.frameStore[0] = ci.frames[1] ci.frames = ci.frameStore[:1] default: frame = ci.frames[0] ci.frames = ci.frames[1:] &#125; more = len(ci.frames) &gt; 0 if frame.funcInfo.valid() &#123; // Compute file/line just before we need to return it, // as it can be expensive. This avoids computing file/line // for the Frame we find but don't return. See issue 32093. file, line := funcline1(frame.funcInfo, frame.PC, false) frame.File, frame.Line = file, int(line) &#125; return&#125; 使用runtime.Caller能够拿到当前执行的文件名和行号，这个方法几乎在所有的日志组件里都有使用 单次消耗的时间可以忽略不计，但对于日志量巨大的服务而言影响还是很大的 比较好的做法是，不是所有日志都调用该方法，而是分级别，或让用户使用hook来决定哪条日志需要打印出文件名和行号信息 参考： golang日志组件使用runtime.Caller性能问题分析 鸟窝-如何在Go的函数中得到调用者函数名?","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"英文简记","date":"2019-11-07T02:09:05.000Z","path":"2019/11/07/英文简记/","text":"philosophy &amp;&amp; psychology &amp;&amp; physiology philosophy英[fəˈlɒsəfi]美[fəˈlɑːsəfi]n. 哲学; 哲学体系; 思想体系; 人生哲学; 生活的信条(或态度); psychology英[saɪˈkɒlədʒi]美[saɪˈkɑːlədʒi]n. 心理学; 心理; 心理特征; 心理影响; physiology英[ˌfɪziˈɒlədʒi]美[ˌfɪziˈɑːlədʒi]n. 生理学; 生理机能; Authentication &amp;&amp; Authorization 即AuthN和AuthZ 前者为认证,判断是不是自己人,让不让进外面的大门;authn，即authentication的简写 后者为授权,已经得知是自己人,进了大门.但不是每个楼层和房间都能去,控制和管理其权限;authz，即authorization的简写 Electrical &amp;&amp; Electronicelectrical 英[ɪˈlektrɪkl]美[ɪˈlektrɪkl]adj. 电的; 用电的; 发电的; electronic英[ɪˌlekˈtrɒnɪk]美[ɪˌlekˈtrɑːnɪk]adj. 电子的; 电子器件的; 电子设备的; IEEE: Institute of Electrical and Electronics Engineers 全世界有N多 电气与电子工程学院 introduction &amp;&amp; instruction &amp;&amp; specification introduction 介绍,引见,引论,引言 例如：Mary was shy at her introduction to the company. instruction 命令,指示；讲授,指导,教学；使用说明书,操作指南 例如：They had received instructions to watch him.他们收到了监视他的命令The instructions for assembling the toy are very clear.如何装配玩具的说明非常清楚明了. “说明”多用instruction 如 The final step is to make sure that the vault binary is available on the PATH. See this page for instructions on setting the PATH on Linux and Mac. This page contains instructions for setting the PATH on Windows. https://learn.hashicorp.com/vault/getting-started/install Coarse &amp;&amp; Coursecoarse英[kɔːs]美[kɔːrs]adj. 粗糙的; 粗织的; 粗的; 大颗粒的; 粗鲁无礼的，粗俗的(尤指涉及性的);[例句]The soldiers did not bother to moderate their coarse humour in her presence.她在的时候，士兵们还是照样说粗俗的笑话，都懒得收敛。 course英[kɔːs]美[kɔːrs]n. (有关某学科的系列) 课程，讲座; (大学中要进行考试或取得资格的) 课程; (船或飞机的) 航向，航线;v. 快速地流动; 奔流;[例句]Aircraft can avoid each other by going up and down, as well as by altering course to left or right飞机可以通过上下升降和左右移动改变航线来避免相撞。 Command Completion指命令行的命令补全 On the bash command-line, command completion shortens the typing needed for everyday tasks. 在bash命令行上，命令补全特性可以减少日常任务所需的输入量。 sealn. 密封；印章；海豹；封条；标志vt. 密封；盖章 unseal vt. 开封；开启；使解除束缚 reverse proxy 反向代理 subtitle有字幕的意思 n. (电影或电视上的) 字幕; 副标题; 小标题;v. 给…加副标题; 给(电影等)加字幕; tendencyswelled [sweld]基本翻译v. 膨胀；隆起；增大（swell的过去分词）adj. 骄傲自大；自负的 plentiful 英[ˈplentɪfl]美[ˈplentɪfl] adj. 大量的; 众多的; 充足的; 丰富的; [例句]Fish are plentiful in the lake.这个湖里鱼很多。 painstaking 英[ˈpeɪnzteɪkɪŋ]美[ˈpeɪnzteɪkɪŋ] adj. 需细心的; 辛苦的; 需专注的; [例句]Forensic experts carried out a painstaking search of the debris.法医专家对残骸进行了极其仔细的搜索。 As discerned如所见 whereas [ˌweərˈæz] conj. 然而；鉴于n. 序言，开场白；条件语句 whereas: 然而Whereas Clauses: 鉴于条款Whereas You: 而你 stagnant 英[ˈstæɡnənt]美[ˈstæɡnənt] adj. (水或空气) 不流动而污浊的; 停滞的; 不发展的; 无变化的; [例句]He is seeking advice on how to revive the stagnant economy他正在就如何振兴低迷的经济征求意见。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"Google Authenticator实现原理","date":"2019-11-06T13:18:38.000Z","path":"2019/11/06/Google-Authenticator实现原理/","text":"曾就职的公司好几家都使用谷歌认证器(Google Authenticator,俗称谷歌令牌),作为二次校验的工具.相比于短信这样的并不算安全的OTP(One Time Password),使用令牌可以增强安全性, 同时还节省了短信的费用. 类似产品还有阿里巴巴的身份宝,默认的时间是60秒;腾讯的Token,时间是60秒 客户端(可以是Google Authenticator的APP,也可以是浏览器插件,或者集成进钉钉/企业微信等IM的类似插件等)绑定证书后, 会隔一段时间(如30s)产生一串随机数字(一般为6位). 服务端和客户端始终保持产生的数字相同,这样客户端在发起请求时,就多了一层校验. 问题是,如何保证两边的验证码一致? (实际上,客户端绑定完证书,从此之后断网,依然能和服务端生成一致的验证码) 本质上说,其实非常简单: 双方约定好使用的哈希函数,约定好一个秘钥,而后对(当前的时间戳/时间间隔)和秘钥做哈希运算,这样双方在时间戳相同的情况下,就能得到相同的一个哈希值. 123456789101112131415161718import pyotpimport base64import timesecretKey = base64.b32encode('the_key_of_shuang'.encode())totp = pyotp.TOTP(secretKey)code = totp.now()print(code)# OTP verified for current timea = totp.verify(code)print(a) # =&gt; Truetime.sleep(30)b = totp.verify(code)print(b) # =&gt; False 输出为: 123652804TrueFalse Golang可参阅gotp实现 有个疑惑: 客户端和服务端是同一个秘钥吗? 这不就成了对称加密,如果客户端的秘钥泄露,不是很容易伪造吗? 更多参考: 双因子认证(2FA) OTP,HOTP,TOTP基本原理 谷歌身份验证器后面的实现原理","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"密码学","slug":"密码学","permalink":"http://www.dashen.tech/tags/密码学/"}]},{"title":"有关'全局唯一id'","date":"2019-11-05T13:09:41.000Z","path":"2019/11/05/有关-全局唯一id/","text":"UUID/GUID通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID） UUID是由开放软件基金会（OSF）定义的一种标准,而GUID是微软对UUID这个标准的实现,目前被广泛采用。UUID还有其它各种实现，不止GUID一种。 生成的uuid是由一组 32位数 的16进制数字所构成，故uuid理论上的总数为16的32次方, 即2的128次方，约等于3.4 x 10的38次方。也就是说若每纳秒(ns)产生1兆个UUID，要花100亿年才会将所有uuid用完。 UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例： 550e8400-e29b-41d4-a716-446655440000 UUID的版本 uuid现在共有5个版本,版本1不够安全,版本4有可能发生重复,但概率极低.现在大多使用uuid4 参见: UUID 不同版本的区别及选择 生成规则参考: 图解各路分布式ID生成算法 比较知名的有Twitter的Snowflake算法 UUID4发生碰撞的概率: 更多参见私有笔记 参考: 面试总被问分布式ID？ 美团（Leaf）了解一下 美团技术分享：深度解密美团的分布式ID生成算法 面试总被问分布式ID怎么办？ 滴滴（Tinyid）甩给他","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"gdb/lldb调试工具","date":"2019-10-30T09:15:33.000Z","path":"2019/10/30/神器gdb/","text":"What is GDB? GDB, the GNU Project debugger, allows you to see what is going on `inside’ another program while it executes – or what another program was doing at the moment it crashed. GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act: Start your program, specifying anything that might affect its behavior. Make your program stop on specified conditions. Examine what has happened, when your program has stopped. Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another. 但因为Mac上GDB支持不好,故而多用功能类似的LLDB 关于二者关系：gdb像是个“年迈而经验丰富的老人”，lldb像是个“与时俱进的活力青年”。就像它们的创造者一样，一个是自由软件的灵魂人物 Richard Stallman，一个是扛起了Apple Swift大旗（及llvm）的Chris Lattner.初识LLDB 调试 MySQL编译器漫谈 入门指南 GDB调试入门指南 Linux工具集快查 初探LLDB调试MYSQL，一条最简单的SELECT语句是如何执行的？ [译]使用 LLDB 调试 Go 程序 Delve调试器 使用案例 验证InnoDB自增row_id的上限 最开始执行时可能出现如下问题: 123Unable to find Mach task port for process-id 42060: (os/kern) failure (0x5). (please check gdb is codesigned - see taskgated(8))No symbol table is loaded. Use the &quot;file&quot; command. 按照此步骤安装证书即可. MySQL表自增id用完了该怎么办？ MySQL只学有用的–你知道自增ID会用完吗？ 45 | 自增id用完怎么办？ LLDB 调试mysql 探究Go程序启动过程(即确定真正的入口函数) 以下内容是对 雨痕Go语言学习笔记.下卷 和 qcraoGo 语言问题集(Go Questions)–Go 程序启动过程是怎样的 实践与记录： test.go: 12345package mainfunc main() &#123; println(\"hello shuang!\")&#125; go build -gcflags &quot;-N -l&quot; -o dashen test.go 查看/usr/local/go/src/runtime/rt0_linux_amd64.s 1234567891011// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.#include \"textflag.h\"TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB)TEXT _rt0_amd64_linux_lib(SB),NOSPLIT,$0 JMP _rt0_amd64_lib(SB) runtime目录下，有很多不同平台的入口文件，均由汇编实现： 用gdb设置断点，查看_rt0_amd64在哪里 src/runtime/asm_amd64.s 这段汇编就是要找的真正目标~其完成了初始化和运行时的启动: 12345678910111213141516171819202122232425TEXT runtime·rt0_go(SB),NOSPLIT,$0 // 省略很多 CPU 相关的特性标志位检查的代码 // 基本看不懂 // ……………………………… // 下面是最后调用的一些函数，比较重要 // 初始化执行文件的绝对路径 CALL runtime·args(SB) // 初始化 CPU 个数和内存页大小 CALL runtime·osinit(SB) // 初始化命令行参数、环境变量、gc、栈空间、内存管理、所有 P 实例、HASH算法等 CALL runtime·schedinit(SB) // 要在 main goroutine 上运行的函数 MOVQ $runtime·mainPC(SB), AX // entry PUSHQ AX PUSHQ $0 // arg size // 新建一个 goroutine，该 goroutine 绑定 runtime.main，放在 P 的本地队列，等待调度 CALL runtime·newproc(SB) POPQ AX POPQ AX // 启动M，开始调度goroutine CALL runtime·mstart(SB) MOVL $0xf1, 0xf1 // crash RETDATA runtime·mainPC+0(SB)/8,$runtime·main(SB)GLOBL runtime·mainPC(SB),RODATA,$8 完整文件参考:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.#include \"go_asm.h\"#include \"go_tls.h\"#include \"funcdata.h\"#include \"textflag.h\"// _rt0_amd64 is common startup code for most amd64 systems when using// internal linking. This is the entry point for the program from the// kernel for an ordinary -buildmode=exe program. The stack holds the// number of arguments and the C-style argv.TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ 0(SP), DI // argc LEAQ 8(SP), SI // argv JMP runtime·rt0_go(SB)// main is common startup code for most amd64 systems when using// external linking. The C startup code will call the symbol \"main\"// passing argc and argv in the usual C ABI registers DI and SI.TEXT main(SB),NOSPLIT,$-8 JMP runtime·rt0_go(SB)// _rt0_amd64_lib is common startup code for most amd64 systems when// using -buildmode=c-archive or -buildmode=c-shared. The linker will// arrange to invoke this function as a global constructor (for// c-archive) or when the shared library is loaded (for c-shared).// We expect argc and argv to be passed in the usual C ABI registers// DI and SI.TEXT _rt0_amd64_lib(SB),NOSPLIT,$0x50 // Align stack per ELF ABI requirements. MOVQ SP, AX ANDQ $~15, SP // Save C ABI callee-saved registers, as caller may need them. MOVQ BX, 0x10(SP) MOVQ BP, 0x18(SP) MOVQ R12, 0x20(SP) MOVQ R13, 0x28(SP) MOVQ R14, 0x30(SP) MOVQ R15, 0x38(SP) MOVQ AX, 0x40(SP) MOVQ DI, _rt0_amd64_lib_argc&lt;&gt;(SB) MOVQ SI, _rt0_amd64_lib_argv&lt;&gt;(SB) // Synchronous initialization. CALL runtime·libpreinit(SB) // Create a new thread to finish Go runtime initialization. MOVQ _cgo_sys_thread_create(SB), AX TESTQ AX, AX JZ nocgo MOVQ $_rt0_amd64_lib_go(SB), DI MOVQ $0, SI CALL AX JMP restorenocgo: MOVQ $0x800000, 0(SP) // stacksize MOVQ $_rt0_amd64_lib_go(SB), AX MOVQ AX, 8(SP) // fn CALL runtime·newosproc0(SB)restore: MOVQ 0x10(SP), BX MOVQ 0x18(SP), BP MOVQ 0x20(SP), R12 MOVQ 0x28(SP), R13 MOVQ 0x30(SP), R14 MOVQ 0x38(SP), R15 MOVQ 0x40(SP), SP RET// _rt0_amd64_lib_go initializes the Go runtime.// This is started in a separate thread by _rt0_amd64_lib.TEXT _rt0_amd64_lib_go(SB),NOSPLIT,$0 MOVQ _rt0_amd64_lib_argc&lt;&gt;(SB), DI MOVQ _rt0_amd64_lib_argv&lt;&gt;(SB), SI JMP runtime·rt0_go(SB)DATA _rt0_amd64_lib_argc&lt;&gt;(SB)/8, $0GLOBL _rt0_amd64_lib_argc&lt;&gt;(SB),NOPTR, $8DATA _rt0_amd64_lib_argv&lt;&gt;(SB)/8, $0GLOBL _rt0_amd64_lib_argv&lt;&gt;(SB),NOPTR, $8TEXT runtime·rt0_go(SB),NOSPLIT,$0 // copy arguments forward on an even stack MOVQ DI, AX // argc MOVQ SI, BX // argv SUBQ $(4*8+7), SP // 2args 2auto ANDQ $~15, SP MOVQ AX, 16(SP) MOVQ BX, 24(SP) // create istack out of the given (operating system) stack. // _cgo_init may update stackguard. MOVQ $runtime·g0(SB), DI LEAQ (-64*1024+104)(SP), BX MOVQ BX, g_stackguard0(DI) MOVQ BX, g_stackguard1(DI) MOVQ BX, (g_stack+stack_lo)(DI) MOVQ SP, (g_stack+stack_hi)(DI) // find out information about the processor we're on MOVL $0, AX CPUID MOVL AX, SI CMPL AX, $0 JE nocpuinfo // Figure out how to serialize RDTSC. // On Intel processors LFENCE is enough. AMD requires MFENCE. // Don't know about the rest, so let's do MFENCE. CMPL BX, $0x756E6547 // \"Genu\" JNE notintel CMPL DX, $0x49656E69 // \"ineI\" JNE notintel CMPL CX, $0x6C65746E // \"ntel\" JNE notintel MOVB $1, runtime·isIntel(SB) MOVB $1, runtime·lfenceBeforeRdtsc(SB)notintel: // Load EAX=1 cpuid flags MOVL $1, AX CPUID MOVL AX, runtime·processorVersionInfo(SB)nocpuinfo: // if there is an _cgo_init, call it. MOVQ _cgo_init(SB), AX TESTQ AX, AX JZ needtls // g0 already in DI MOVQ DI, CX // Win64 uses CX for first parameter MOVQ $setg_gcc&lt;&gt;(SB), SI CALL AX // update stackguard after _cgo_init MOVQ $runtime·g0(SB), CX MOVQ (g_stack+stack_lo)(CX), AX ADDQ $const__StackGuard, AX MOVQ AX, g_stackguard0(CX) MOVQ AX, g_stackguard1(CX)#ifndef GOOS_windows JMP ok#endifneedtls:#ifdef GOOS_plan9 // skip TLS setup on Plan 9 JMP ok#endif#ifdef GOOS_solaris // skip TLS setup on Solaris JMP ok#endif#ifdef GOOS_darwin // skip TLS setup on Darwin JMP ok#endif LEAQ runtime·m0+m_tls(SB), DI CALL runtime·settls(SB) // store through it, to make sure it works get_tls(BX) MOVQ $0x123, g(BX) MOVQ runtime·m0+m_tls(SB), AX CMPQ AX, $0x123 JEQ 2(PC) CALL runtime·abort(SB)ok: // set the per-goroutine and per-mach \"registers\" get_tls(BX) LEAQ runtime·g0(SB), CX MOVQ CX, g(BX) LEAQ runtime·m0(SB), AX // save m-&gt;g0 = g0 MOVQ CX, m_g0(AX) // save m0 to g0-&gt;m MOVQ AX, g_m(CX) CLD // convention is D is always left cleared CALL runtime·check(SB) MOVL 16(SP), AX // copy argc MOVL AX, 0(SP) MOVQ 24(SP), AX // copy argv MOVQ AX, 8(SP) CALL runtime·args(SB) CALL runtime·osinit(SB) CALL runtime·schedinit(SB) // create a new goroutine to start program MOVQ $runtime·mainPC(SB), AX // entry PUSHQ AX PUSHQ $0 // arg size CALL runtime·newproc(SB) POPQ AX POPQ AX // start this M CALL runtime·mstart(SB) CALL runtime·abort(SB) // mstart should never return RET // Prevent dead-code elimination of debugCallV1, which is // intended to be called by debuggers. MOVQ $runtime·debugCallV1(SB), AX RETDATA runtime·mainPC+0(SB)/8,$runtime·main(SB)GLOBL runtime·mainPC(SB),RODATA,$8TEXT runtime·breakpoint(SB),NOSPLIT,$0-0 BYTE $0xcc RETTEXT runtime·asminit(SB),NOSPLIT,$0-0 // No per-thread init. RET/* * go-routine */// void gosave(Gobuf*)// save state in Gobuf; setjmpTEXT runtime·gosave(SB), NOSPLIT, $0-8 MOVQ buf+0(FP), AX // gobuf LEAQ buf+0(FP), BX // caller's SP MOVQ BX, gobuf_sp(AX) MOVQ 0(SP), BX // caller's PC MOVQ BX, gobuf_pc(AX) MOVQ $0, gobuf_ret(AX) MOVQ BP, gobuf_bp(AX) // Assert ctxt is zero. See func save. MOVQ gobuf_ctxt(AX), BX TESTQ BX, BX JZ 2(PC) CALL runtime·badctxt(SB) get_tls(CX) MOVQ g(CX), BX MOVQ BX, gobuf_g(AX) RET// void gogo(Gobuf*)// restore state from Gobuf; longjmpTEXT runtime·gogo(SB), NOSPLIT, $16-8 MOVQ buf+0(FP), BX // gobuf MOVQ gobuf_g(BX), DX MOVQ 0(DX), CX // make sure g != nil get_tls(CX) MOVQ DX, g(CX) MOVQ gobuf_sp(BX), SP // restore SP MOVQ gobuf_ret(BX), AX MOVQ gobuf_ctxt(BX), DX MOVQ gobuf_bp(BX), BP MOVQ $0, gobuf_sp(BX) // clear to help garbage collector MOVQ $0, gobuf_ret(BX) MOVQ $0, gobuf_ctxt(BX) MOVQ $0, gobuf_bp(BX) MOVQ gobuf_pc(BX), BX JMP BX// func mcall(fn func(*g))// Switch to m-&gt;g0's stack, call fn(g).// Fn must never return. It should gogo(&amp;g-&gt;sched)// to keep running g.TEXT runtime·mcall(SB), NOSPLIT, $0-8 MOVQ fn+0(FP), DI get_tls(CX) MOVQ g(CX), AX // save state in g-&gt;sched MOVQ 0(SP), BX // caller's PC MOVQ BX, (g_sched+gobuf_pc)(AX) LEAQ fn+0(FP), BX // caller's SP MOVQ BX, (g_sched+gobuf_sp)(AX) MOVQ AX, (g_sched+gobuf_g)(AX) MOVQ BP, (g_sched+gobuf_bp)(AX) // switch to m-&gt;g0 &amp; its stack, call fn MOVQ g(CX), BX MOVQ g_m(BX), BX MOVQ m_g0(BX), SI CMPQ SI, AX // if g == m-&gt;g0 call badmcall JNE 3(PC) MOVQ $runtime·badmcall(SB), AX JMP AX MOVQ SI, g(CX) // g = m-&gt;g0 MOVQ (g_sched+gobuf_sp)(SI), SP // sp = m-&gt;g0-&gt;sched.sp PUSHQ AX MOVQ DI, DX MOVQ 0(DI), DI CALL DI POPQ AX MOVQ $runtime·badmcall2(SB), AX JMP AX RET// systemstack_switch is a dummy routine that systemstack leaves at the bottom// of the G stack. We need to distinguish the routine that// lives at the bottom of the G stack from the one that lives// at the top of the system stack because the one at the top of// the system stack terminates the stack walk (see topofstack()).TEXT runtime·systemstack_switch(SB), NOSPLIT, $0-0 RET// func systemstack(fn func())TEXT runtime·systemstack(SB), NOSPLIT, $0-8 MOVQ fn+0(FP), DI // DI = fn get_tls(CX) MOVQ g(CX), AX // AX = g MOVQ g_m(AX), BX // BX = m CMPQ AX, m_gsignal(BX) JEQ noswitch MOVQ m_g0(BX), DX // DX = g0 CMPQ AX, DX JEQ noswitch CMPQ AX, m_curg(BX) JNE bad // switch stacks // save our state in g-&gt;sched. Pretend to // be systemstack_switch if the G stack is scanned. MOVQ $runtime·systemstack_switch(SB), SI MOVQ SI, (g_sched+gobuf_pc)(AX) MOVQ SP, (g_sched+gobuf_sp)(AX) MOVQ AX, (g_sched+gobuf_g)(AX) MOVQ BP, (g_sched+gobuf_bp)(AX) // switch to g0 MOVQ DX, g(CX) MOVQ (g_sched+gobuf_sp)(DX), BX // make it look like mstart called systemstack on g0, to stop traceback SUBQ $8, BX MOVQ $runtime·mstart(SB), DX MOVQ DX, 0(BX) MOVQ BX, SP // call target function MOVQ DI, DX MOVQ 0(DI), DI CALL DI // switch back to g get_tls(CX) MOVQ g(CX), AX MOVQ g_m(AX), BX MOVQ m_curg(BX), AX MOVQ AX, g(CX) MOVQ (g_sched+gobuf_sp)(AX), SP MOVQ $0, (g_sched+gobuf_sp)(AX) RETnoswitch: // already on m stack; tail call the function // Using a tail call here cleans up tracebacks since we won't stop // at an intermediate systemstack. MOVQ DI, DX MOVQ 0(DI), DI JMP DIbad: // Bad: g is not gsignal, not g0, not curg. What is it? MOVQ $runtime·badsystemstack(SB), AX CALL AX INT $3/* * support for morestack */// Called during function prolog when more stack is needed.//// The traceback routines see morestack on a g0 as being// the top of a stack (for example, morestack calling newstack// calling the scheduler calling newm calling gc), so we must// record an argument size. For that purpose, it has no arguments.TEXT runtime·morestack(SB),NOSPLIT,$0-0 // Cannot grow scheduler stack (m-&gt;g0). get_tls(CX) MOVQ g(CX), BX MOVQ g_m(BX), BX MOVQ m_g0(BX), SI CMPQ g(CX), SI JNE 3(PC) CALL runtime·badmorestackg0(SB) CALL runtime·abort(SB) // Cannot grow signal stack (m-&gt;gsignal). MOVQ m_gsignal(BX), SI CMPQ g(CX), SI JNE 3(PC) CALL runtime·badmorestackgsignal(SB) CALL runtime·abort(SB) // Called from f. // Set m-&gt;morebuf to f's caller. MOVQ 8(SP), AX // f's caller's PC MOVQ AX, (m_morebuf+gobuf_pc)(BX) LEAQ 16(SP), AX // f's caller's SP MOVQ AX, (m_morebuf+gobuf_sp)(BX) get_tls(CX) MOVQ g(CX), SI MOVQ SI, (m_morebuf+gobuf_g)(BX) // Set g-&gt;sched to context in f. MOVQ 0(SP), AX // f's PC MOVQ AX, (g_sched+gobuf_pc)(SI) MOVQ SI, (g_sched+gobuf_g)(SI) LEAQ 8(SP), AX // f's SP MOVQ AX, (g_sched+gobuf_sp)(SI) MOVQ BP, (g_sched+gobuf_bp)(SI) MOVQ DX, (g_sched+gobuf_ctxt)(SI) // Call newstack on m-&gt;g0's stack. MOVQ m_g0(BX), BX MOVQ BX, g(CX) MOVQ (g_sched+gobuf_sp)(BX), SP CALL runtime·newstack(SB) CALL runtime·abort(SB) // crash if newstack returns RET// morestack but not preserving ctxt.TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0 MOVL $0, DX JMP runtime·morestack(SB)// reflectcall: call a function with the given argument list// func call(argtype *_type, f *FuncVal, arg *byte, argsize, retoffset uint32).// we don't have variable-sized frames, so we use a small number// of constant-sized-frame functions to encode a few bits of size in the pc.// Caution: ugly multiline assembly macros in your future!#define DISPATCH(NAME,MAXSIZE) \\ CMPQ CX, $MAXSIZE; \\ JA 3(PC); \\ MOVQ $NAME(SB), AX; \\ JMP AX// Note: can't just \"JMP NAME(SB)\" - bad inlining results.TEXT reflect·call(SB), NOSPLIT, $0-0 JMP ·reflectcall(SB)TEXT ·reflectcall(SB), NOSPLIT, $0-32 MOVLQZX argsize+24(FP), CX DISPATCH(runtime·call32, 32) DISPATCH(runtime·call64, 64) DISPATCH(runtime·call128, 128) DISPATCH(runtime·call256, 256) DISPATCH(runtime·call512, 512) DISPATCH(runtime·call1024, 1024) DISPATCH(runtime·call2048, 2048) DISPATCH(runtime·call4096, 4096) DISPATCH(runtime·call8192, 8192) DISPATCH(runtime·call16384, 16384) DISPATCH(runtime·call32768, 32768) DISPATCH(runtime·call65536, 65536) DISPATCH(runtime·call131072, 131072) DISPATCH(runtime·call262144, 262144) DISPATCH(runtime·call524288, 524288) DISPATCH(runtime·call1048576, 1048576) DISPATCH(runtime·call2097152, 2097152) DISPATCH(runtime·call4194304, 4194304) DISPATCH(runtime·call8388608, 8388608) DISPATCH(runtime·call16777216, 16777216) DISPATCH(runtime·call33554432, 33554432) DISPATCH(runtime·call67108864, 67108864) DISPATCH(runtime·call134217728, 134217728) DISPATCH(runtime·call268435456, 268435456) DISPATCH(runtime·call536870912, 536870912) DISPATCH(runtime·call1073741824, 1073741824) MOVQ $runtime·badreflectcall(SB), AX JMP AX#define CALLFN(NAME,MAXSIZE) \\TEXT NAME(SB), WRAPPER, $MAXSIZE-32; \\ NO_LOCAL_POINTERS; \\ /* copy arguments to stack */ \\ MOVQ argptr+16(FP), SI; \\ MOVLQZX argsize+24(FP), CX; \\ MOVQ SP, DI; \\ REP;MOVSB; \\ /* call function */ \\ MOVQ f+8(FP), DX; \\ PCDATA $PCDATA_StackMapIndex, $0; \\ CALL (DX); \\ /* copy return values back */ \\ MOVQ argtype+0(FP), DX; \\ MOVQ argptr+16(FP), DI; \\ MOVLQZX argsize+24(FP), CX; \\ MOVLQZX retoffset+28(FP), BX; \\ MOVQ SP, SI; \\ ADDQ BX, DI; \\ ADDQ BX, SI; \\ SUBQ BX, CX; \\ CALL callRet&lt;&gt;(SB); \\ RET// callRet copies return values back at the end of call*. This is a// separate function so it can allocate stack space for the arguments// to reflectcallmove. It does not follow the Go ABI; it expects its// arguments in registers.TEXT callRet&lt;&gt;(SB), NOSPLIT, $32-0 NO_LOCAL_POINTERS MOVQ DX, 0(SP) MOVQ DI, 8(SP) MOVQ SI, 16(SP) MOVQ CX, 24(SP) CALL runtime·reflectcallmove(SB) RETCALLFN(·call32, 32)CALLFN(·call64, 64)CALLFN(·call128, 128)CALLFN(·call256, 256)CALLFN(·call512, 512)CALLFN(·call1024, 1024)CALLFN(·call2048, 2048)CALLFN(·call4096, 4096)CALLFN(·call8192, 8192)CALLFN(·call16384, 16384)CALLFN(·call32768, 32768)CALLFN(·call65536, 65536)CALLFN(·call131072, 131072)CALLFN(·call262144, 262144)CALLFN(·call524288, 524288)CALLFN(·call1048576, 1048576)CALLFN(·call2097152, 2097152)CALLFN(·call4194304, 4194304)CALLFN(·call8388608, 8388608)CALLFN(·call16777216, 16777216)CALLFN(·call33554432, 33554432)CALLFN(·call67108864, 67108864)CALLFN(·call134217728, 134217728)CALLFN(·call268435456, 268435456)CALLFN(·call536870912, 536870912)CALLFN(·call1073741824, 1073741824)TEXT runtime·procyield(SB),NOSPLIT,$0-0 MOVL cycles+0(FP), AXagain: PAUSE SUBL $1, AX JNZ again RETTEXT ·publicationBarrier(SB),NOSPLIT,$0-0 // Stores are already ordered on x86, so this is just a // compile barrier. RET// void jmpdefer(fn, sp);// called from deferreturn.// 1. pop the caller// 2. sub 5 bytes from the callers return// 3. jmp to the argumentTEXT runtime·jmpdefer(SB), NOSPLIT, $0-16 MOVQ fv+0(FP), DX // fn MOVQ argp+8(FP), BX // caller sp LEAQ -8(BX), SP // caller sp after CALL MOVQ -8(SP), BP // restore BP as if deferreturn returned (harmless if framepointers not in use) SUBQ $5, (SP) // return to CALL again MOVQ 0(DX), BX JMP BX // but first run the deferred function// Save state of caller into g-&gt;sched. Smashes R8, R9.TEXT gosave&lt;&gt;(SB),NOSPLIT,$0 get_tls(R8) MOVQ g(R8), R8 MOVQ 0(SP), R9 MOVQ R9, (g_sched+gobuf_pc)(R8) LEAQ 8(SP), R9 MOVQ R9, (g_sched+gobuf_sp)(R8) MOVQ $0, (g_sched+gobuf_ret)(R8) MOVQ BP, (g_sched+gobuf_bp)(R8) // Assert ctxt is zero. See func save. MOVQ (g_sched+gobuf_ctxt)(R8), R9 TESTQ R9, R9 JZ 2(PC) CALL runtime·badctxt(SB) RET// func asmcgocall(fn, arg unsafe.Pointer) int32// Call fn(arg) on the scheduler stack,// aligned appropriately for the gcc ABI.// See cgocall.go for more details.TEXT ·asmcgocall(SB),NOSPLIT,$0-20 MOVQ fn+0(FP), AX MOVQ arg+8(FP), BX MOVQ SP, DX // Figure out if we need to switch to m-&gt;g0 stack. // We get called to create new OS threads too, and those // come in on the m-&gt;g0 stack already. get_tls(CX) MOVQ g(CX), R8 CMPQ R8, $0 JEQ nosave MOVQ g_m(R8), R8 MOVQ m_g0(R8), SI MOVQ g(CX), DI CMPQ SI, DI JEQ nosave MOVQ m_gsignal(R8), SI CMPQ SI, DI JEQ nosave // Switch to system stack. MOVQ m_g0(R8), SI CALL gosave&lt;&gt;(SB) MOVQ SI, g(CX) MOVQ (g_sched+gobuf_sp)(SI), SP // Now on a scheduling stack (a pthread-created stack). // Make sure we have enough room for 4 stack-backed fast-call // registers as per windows amd64 calling convention. SUBQ $64, SP ANDQ $~15, SP // alignment for gcc ABI MOVQ DI, 48(SP) // save g MOVQ (g_stack+stack_hi)(DI), DI SUBQ DX, DI MOVQ DI, 40(SP) // save depth in stack (can't just save SP, as stack might be copied during a callback) MOVQ BX, DI // DI = first argument in AMD64 ABI MOVQ BX, CX // CX = first argument in Win64 CALL AX // Restore registers, g, stack pointer. get_tls(CX) MOVQ 48(SP), DI MOVQ (g_stack+stack_hi)(DI), SI SUBQ 40(SP), SI MOVQ DI, g(CX) MOVQ SI, SP MOVL AX, ret+16(FP) RETnosave: // Running on a system stack, perhaps even without a g. // Having no g can happen during thread creation or thread teardown // (see needm/dropm on Solaris, for example). // This code is like the above sequence but without saving/restoring g // and without worrying about the stack moving out from under us // (because we're on a system stack, not a goroutine stack). // The above code could be used directly if already on a system stack, // but then the only path through this code would be a rare case on Solaris. // Using this code for all \"already on system stack\" calls exercises it more, // which should help keep it correct. SUBQ $64, SP ANDQ $~15, SP MOVQ $0, 48(SP) // where above code stores g, in case someone looks during debugging MOVQ DX, 40(SP) // save original stack pointer MOVQ BX, DI // DI = first argument in AMD64 ABI MOVQ BX, CX // CX = first argument in Win64 CALL AX MOVQ 40(SP), SI // restore original stack pointer MOVQ SI, SP MOVL AX, ret+16(FP) RET// cgocallback(void (*fn)(void*), void *frame, uintptr framesize, uintptr ctxt)// Turn the fn into a Go func (by taking its address) and call// cgocallback_gofunc.TEXT runtime·cgocallback(SB),NOSPLIT,$32-32 LEAQ fn+0(FP), AX MOVQ AX, 0(SP) MOVQ frame+8(FP), AX MOVQ AX, 8(SP) MOVQ framesize+16(FP), AX MOVQ AX, 16(SP) MOVQ ctxt+24(FP), AX MOVQ AX, 24(SP) MOVQ $runtime·cgocallback_gofunc(SB), AX CALL AX RET// cgocallback_gofunc(FuncVal*, void *frame, uintptr framesize, uintptr ctxt)// See cgocall.go for more details.TEXT ·cgocallback_gofunc(SB),NOSPLIT,$16-32 NO_LOCAL_POINTERS // If g is nil, Go did not create the current thread. // Call needm to obtain one m for temporary use. // In this case, we're running on the thread stack, so there's // lots of space, but the linker doesn't know. Hide the call from // the linker analysis by using an indirect call through AX. get_tls(CX)#ifdef GOOS_windows MOVL $0, BX CMPQ CX, $0 JEQ 2(PC)#endif MOVQ g(CX), BX CMPQ BX, $0 JEQ needm MOVQ g_m(BX), BX MOVQ BX, R8 // holds oldm until end of function JMP havemneedm: MOVQ $0, 0(SP) MOVQ $runtime·needm(SB), AX CALL AX MOVQ 0(SP), R8 get_tls(CX) MOVQ g(CX), BX MOVQ g_m(BX), BX // Set m-&gt;sched.sp = SP, so that if a panic happens // during the function we are about to execute, it will // have a valid SP to run on the g0 stack. // The next few lines (after the havem label) // will save this SP onto the stack and then write // the same SP back to m-&gt;sched.sp. That seems redundant, // but if an unrecovered panic happens, unwindm will // restore the g-&gt;sched.sp from the stack location // and then systemstack will try to use it. If we don't set it here, // that restored SP will be uninitialized (typically 0) and // will not be usable. MOVQ m_g0(BX), SI MOVQ SP, (g_sched+gobuf_sp)(SI)havem: // Now there's a valid m, and we're running on its m-&gt;g0. // Save current m-&gt;g0-&gt;sched.sp on stack and then set it to SP. // Save current sp in m-&gt;g0-&gt;sched.sp in preparation for // switch back to m-&gt;curg stack. // NOTE: unwindm knows that the saved g-&gt;sched.sp is at 0(SP). MOVQ m_g0(BX), SI MOVQ (g_sched+gobuf_sp)(SI), AX MOVQ AX, 0(SP) MOVQ SP, (g_sched+gobuf_sp)(SI) // Switch to m-&gt;curg stack and call runtime.cgocallbackg. // Because we are taking over the execution of m-&gt;curg // but *not* resuming what had been running, we need to // save that information (m-&gt;curg-&gt;sched) so we can restore it. // We can restore m-&gt;curg-&gt;sched.sp easily, because calling // runtime.cgocallbackg leaves SP unchanged upon return. // To save m-&gt;curg-&gt;sched.pc, we push it onto the stack. // This has the added benefit that it looks to the traceback // routine like cgocallbackg is going to return to that // PC (because the frame we allocate below has the same // size as cgocallback_gofunc's frame declared above) // so that the traceback will seamlessly trace back into // the earlier calls. // // In the new goroutine, 8(SP) holds the saved R8. MOVQ m_curg(BX), SI MOVQ SI, g(CX) MOVQ (g_sched+gobuf_sp)(SI), DI // prepare stack as DI MOVQ (g_sched+gobuf_pc)(SI), BX MOVQ BX, -8(DI) // Compute the size of the frame, including return PC and, if // GOEXPERIMENT=framepointer, the saved base pointer MOVQ ctxt+24(FP), BX LEAQ fv+0(FP), AX SUBQ SP, AX SUBQ AX, DI MOVQ DI, SP MOVQ R8, 8(SP) MOVQ BX, 0(SP) CALL runtime·cgocallbackg(SB) MOVQ 8(SP), R8 // Compute the size of the frame again. FP and SP have // completely different values here than they did above, // but only their difference matters. LEAQ fv+0(FP), AX SUBQ SP, AX // Restore g-&gt;sched (== m-&gt;curg-&gt;sched) from saved values. get_tls(CX) MOVQ g(CX), SI MOVQ SP, DI ADDQ AX, DI MOVQ -8(DI), BX MOVQ BX, (g_sched+gobuf_pc)(SI) MOVQ DI, (g_sched+gobuf_sp)(SI) // Switch back to m-&gt;g0's stack and restore m-&gt;g0-&gt;sched.sp. // (Unlike m-&gt;curg, the g0 goroutine never uses sched.pc, // so we do not have to restore it.) MOVQ g(CX), BX MOVQ g_m(BX), BX MOVQ m_g0(BX), SI MOVQ SI, g(CX) MOVQ (g_sched+gobuf_sp)(SI), SP MOVQ 0(SP), AX MOVQ AX, (g_sched+gobuf_sp)(SI) // If the m on entry was nil, we called needm above to borrow an m // for the duration of the call. Since the call is over, return it with dropm. CMPQ R8, $0 JNE 3(PC) MOVQ $runtime·dropm(SB), AX CALL AX // Done! RET// void setg(G*); set g. for use by needm.TEXT runtime·setg(SB), NOSPLIT, $0-8 MOVQ gg+0(FP), BX#ifdef GOOS_windows CMPQ BX, $0 JNE settls MOVQ $0, 0x28(GS) RETsettls: MOVQ g_m(BX), AX LEAQ m_tls(AX), AX MOVQ AX, 0x28(GS)#endif get_tls(CX) MOVQ BX, g(CX) RET// void setg_gcc(G*); set g called from gcc.TEXT setg_gcc&lt;&gt;(SB),NOSPLIT,$0 get_tls(AX) MOVQ DI, g(AX) RETTEXT runtime·abort(SB),NOSPLIT,$0-0 INT $3loop: JMP loop// check that SP is in range [g-&gt;stack.lo, g-&gt;stack.hi)TEXT runtime·stackcheck(SB), NOSPLIT, $0-0 get_tls(CX) MOVQ g(CX), AX CMPQ (g_stack+stack_hi)(AX), SP JHI 2(PC) CALL runtime·abort(SB) CMPQ SP, (g_stack+stack_lo)(AX) JHI 2(PC) CALL runtime·abort(SB) RET// func cputicks() int64TEXT runtime·cputicks(SB),NOSPLIT,$0-0 CMPB runtime·lfenceBeforeRdtsc(SB), $1 JNE mfence LFENCE JMP donemfence: MFENCEdone: RDTSC SHLQ $32, DX ADDQ DX, AX MOVQ AX, ret+0(FP) RET// hash function using AES hardware instructionsTEXT runtime·aeshash(SB),NOSPLIT,$0-32 MOVQ p+0(FP), AX // ptr to data MOVQ s+16(FP), CX // size LEAQ ret+24(FP), DX JMP runtime·aeshashbody(SB)TEXT runtime·aeshashstr(SB),NOSPLIT,$0-24 MOVQ p+0(FP), AX // ptr to string struct MOVQ 8(AX), CX // length of string MOVQ (AX), AX // string data LEAQ ret+16(FP), DX JMP runtime·aeshashbody(SB)// AX: data// CX: length// DX: address to put return valueTEXT runtime·aeshashbody(SB),NOSPLIT,$0-0 // Fill an SSE register with our seeds. MOVQ h+8(FP), X0 // 64 bits of per-table hash seed PINSRW $4, CX, X0 // 16 bits of length PSHUFHW $0, X0, X0 // repeat length 4 times total MOVO X0, X1 // save unscrambled seed PXOR runtime·aeskeysched(SB), X0 // xor in per-process seed AESENC X0, X0 // scramble seed CMPQ CX, $16 JB aes0to15 JE aes16 CMPQ CX, $32 JBE aes17to32 CMPQ CX, $64 JBE aes33to64 CMPQ CX, $128 JBE aes65to128 JMP aes129plusaes0to15: TESTQ CX, CX JE aes0 ADDQ $16, AX TESTW $0xff0, AX JE endofpage // 16 bytes loaded at this address won't cross // a page boundary, so we can load it directly. MOVOU -16(AX), X1 ADDQ CX, CX MOVQ $masks&lt;&gt;(SB), AX PAND (AX)(CX*8), X1final1: PXOR X0, X1 // xor data with seed AESENC X1, X1 // scramble combo 3 times AESENC X1, X1 AESENC X1, X1 MOVQ X1, (DX) RETendofpage: // address ends in 1111xxxx. Might be up against // a page boundary, so load ending at last byte. // Then shift bytes down using pshufb. MOVOU -32(AX)(CX*1), X1 ADDQ CX, CX MOVQ $shifts&lt;&gt;(SB), AX PSHUFB (AX)(CX*8), X1 JMP final1aes0: // Return scrambled input seed AESENC X0, X0 MOVQ X0, (DX) RETaes16: MOVOU (AX), X1 JMP final1aes17to32: // make second starting seed PXOR runtime·aeskeysched+16(SB), X1 AESENC X1, X1 // load data to be hashed MOVOU (AX), X2 MOVOU -16(AX)(CX*1), X3 // xor with seed PXOR X0, X2 PXOR X1, X3 // scramble 3 times AESENC X2, X2 AESENC X3, X3 AESENC X2, X2 AESENC X3, X3 AESENC X2, X2 AESENC X3, X3 // combine results PXOR X3, X2 MOVQ X2, (DX) RETaes33to64: // make 3 more starting seeds MOVO X1, X2 MOVO X1, X3 PXOR runtime·aeskeysched+16(SB), X1 PXOR runtime·aeskeysched+32(SB), X2 PXOR runtime·aeskeysched+48(SB), X3 AESENC X1, X1 AESENC X2, X2 AESENC X3, X3 MOVOU (AX), X4 MOVOU 16(AX), X5 MOVOU -32(AX)(CX*1), X6 MOVOU -16(AX)(CX*1), X7 PXOR X0, X4 PXOR X1, X5 PXOR X2, X6 PXOR X3, X7 AESENC X4, X4 AESENC X5, X5 AESENC X6, X6 AESENC X7, X7 AESENC X4, X4 AESENC X5, X5 AESENC X6, X6 AESENC X7, X7 AESENC X4, X4 AESENC X5, X5 AESENC X6, X6 AESENC X7, X7 PXOR X6, X4 PXOR X7, X5 PXOR X5, X4 MOVQ X4, (DX) RETaes65to128: // make 7 more starting seeds MOVO X1, X2 MOVO X1, X3 MOVO X1, X4 MOVO X1, X5 MOVO X1, X6 MOVO X1, X7 PXOR runtime·aeskeysched+16(SB), X1 PXOR runtime·aeskeysched+32(SB), X2 PXOR runtime·aeskeysched+48(SB), X3 PXOR runtime·aeskeysched+64(SB), X4 PXOR runtime·aeskeysched+80(SB), X5 PXOR runtime·aeskeysched+96(SB), X6 PXOR runtime·aeskeysched+112(SB), X7 AESENC X1, X1 AESENC X2, X2 AESENC X3, X3 AESENC X4, X4 AESENC X5, X5 AESENC X6, X6 AESENC X7, X7 // load data MOVOU (AX), X8 MOVOU 16(AX), X9 MOVOU 32(AX), X10 MOVOU 48(AX), X11 MOVOU -64(AX)(CX*1), X12 MOVOU -48(AX)(CX*1), X13 MOVOU -32(AX)(CX*1), X14 MOVOU -16(AX)(CX*1), X15 // xor with seed PXOR X0, X8 PXOR X1, X9 PXOR X2, X10 PXOR X3, X11 PXOR X4, X12 PXOR X5, X13 PXOR X6, X14 PXOR X7, X15 // scramble 3 times AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 // combine results PXOR X12, X8 PXOR X13, X9 PXOR X14, X10 PXOR X15, X11 PXOR X10, X8 PXOR X11, X9 PXOR X9, X8 MOVQ X8, (DX) RETaes129plus: // make 7 more starting seeds MOVO X1, X2 MOVO X1, X3 MOVO X1, X4 MOVO X1, X5 MOVO X1, X6 MOVO X1, X7 PXOR runtime·aeskeysched+16(SB), X1 PXOR runtime·aeskeysched+32(SB), X2 PXOR runtime·aeskeysched+48(SB), X3 PXOR runtime·aeskeysched+64(SB), X4 PXOR runtime·aeskeysched+80(SB), X5 PXOR runtime·aeskeysched+96(SB), X6 PXOR runtime·aeskeysched+112(SB), X7 AESENC X1, X1 AESENC X2, X2 AESENC X3, X3 AESENC X4, X4 AESENC X5, X5 AESENC X6, X6 AESENC X7, X7 // start with last (possibly overlapping) block MOVOU -128(AX)(CX*1), X8 MOVOU -112(AX)(CX*1), X9 MOVOU -96(AX)(CX*1), X10 MOVOU -80(AX)(CX*1), X11 MOVOU -64(AX)(CX*1), X12 MOVOU -48(AX)(CX*1), X13 MOVOU -32(AX)(CX*1), X14 MOVOU -16(AX)(CX*1), X15 // xor in seed PXOR X0, X8 PXOR X1, X9 PXOR X2, X10 PXOR X3, X11 PXOR X4, X12 PXOR X5, X13 PXOR X6, X14 PXOR X7, X15 // compute number of remaining 128-byte blocks DECQ CX SHRQ $7, CX aesloop: // scramble state AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 // scramble state, xor in a block MOVOU (AX), X0 MOVOU 16(AX), X1 MOVOU 32(AX), X2 MOVOU 48(AX), X3 AESENC X0, X8 AESENC X1, X9 AESENC X2, X10 AESENC X3, X11 MOVOU 64(AX), X4 MOVOU 80(AX), X5 MOVOU 96(AX), X6 MOVOU 112(AX), X7 AESENC X4, X12 AESENC X5, X13 AESENC X6, X14 AESENC X7, X15 ADDQ $128, AX DECQ CX JNE aesloop // 3 more scrambles to finish AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 AESENC X8, X8 AESENC X9, X9 AESENC X10, X10 AESENC X11, X11 AESENC X12, X12 AESENC X13, X13 AESENC X14, X14 AESENC X15, X15 PXOR X12, X8 PXOR X13, X9 PXOR X14, X10 PXOR X15, X11 PXOR X10, X8 PXOR X11, X9 PXOR X9, X8 MOVQ X8, (DX) RET TEXT runtime·aeshash32(SB),NOSPLIT,$0-24 MOVQ p+0(FP), AX // ptr to data MOVQ h+8(FP), X0 // seed PINSRD $2, (AX), X0 // data AESENC runtime·aeskeysched+0(SB), X0 AESENC runtime·aeskeysched+16(SB), X0 AESENC runtime·aeskeysched+32(SB), X0 MOVQ X0, ret+16(FP) RETTEXT runtime·aeshash64(SB),NOSPLIT,$0-24 MOVQ p+0(FP), AX // ptr to data MOVQ h+8(FP), X0 // seed PINSRQ $1, (AX), X0 // data AESENC runtime·aeskeysched+0(SB), X0 AESENC runtime·aeskeysched+16(SB), X0 AESENC runtime·aeskeysched+32(SB), X0 MOVQ X0, ret+16(FP) RET// simple mask to get rid of data in the high part of the register.DATA masks&lt;&gt;+0x00(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x08(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x10(SB)/8, $0x00000000000000ffDATA masks&lt;&gt;+0x18(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x20(SB)/8, $0x000000000000ffffDATA masks&lt;&gt;+0x28(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x30(SB)/8, $0x0000000000ffffffDATA masks&lt;&gt;+0x38(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x40(SB)/8, $0x00000000ffffffffDATA masks&lt;&gt;+0x48(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x50(SB)/8, $0x000000ffffffffffDATA masks&lt;&gt;+0x58(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x60(SB)/8, $0x0000ffffffffffffDATA masks&lt;&gt;+0x68(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x70(SB)/8, $0x00ffffffffffffffDATA masks&lt;&gt;+0x78(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x80(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0x88(SB)/8, $0x0000000000000000DATA masks&lt;&gt;+0x90(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0x98(SB)/8, $0x00000000000000ffDATA masks&lt;&gt;+0xa0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xa8(SB)/8, $0x000000000000ffffDATA masks&lt;&gt;+0xb0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xb8(SB)/8, $0x0000000000ffffffDATA masks&lt;&gt;+0xc0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xc8(SB)/8, $0x00000000ffffffffDATA masks&lt;&gt;+0xd0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xd8(SB)/8, $0x000000ffffffffffDATA masks&lt;&gt;+0xe0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xe8(SB)/8, $0x0000ffffffffffffDATA masks&lt;&gt;+0xf0(SB)/8, $0xffffffffffffffffDATA masks&lt;&gt;+0xf8(SB)/8, $0x00ffffffffffffffGLOBL masks&lt;&gt;(SB),RODATA,$256TEXT ·checkASM(SB),NOSPLIT,$0-1 // check that masks&lt;&gt;(SB) and shifts&lt;&gt;(SB) are aligned to 16-byte MOVQ $masks&lt;&gt;(SB), AX MOVQ $shifts&lt;&gt;(SB), BX ORQ BX, AX TESTQ $15, AX SETEQ ret+0(FP) RET// these are arguments to pshufb. They move data down from// the high bytes of the register to the low bytes of the register.// index is how many bytes to move.DATA shifts&lt;&gt;+0x00(SB)/8, $0x0000000000000000DATA shifts&lt;&gt;+0x08(SB)/8, $0x0000000000000000DATA shifts&lt;&gt;+0x10(SB)/8, $0xffffffffffffff0fDATA shifts&lt;&gt;+0x18(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x20(SB)/8, $0xffffffffffff0f0eDATA shifts&lt;&gt;+0x28(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x30(SB)/8, $0xffffffffff0f0e0dDATA shifts&lt;&gt;+0x38(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x40(SB)/8, $0xffffffff0f0e0d0cDATA shifts&lt;&gt;+0x48(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x50(SB)/8, $0xffffff0f0e0d0c0bDATA shifts&lt;&gt;+0x58(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x60(SB)/8, $0xffff0f0e0d0c0b0aDATA shifts&lt;&gt;+0x68(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x70(SB)/8, $0xff0f0e0d0c0b0a09DATA shifts&lt;&gt;+0x78(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x80(SB)/8, $0x0f0e0d0c0b0a0908DATA shifts&lt;&gt;+0x88(SB)/8, $0xffffffffffffffffDATA shifts&lt;&gt;+0x90(SB)/8, $0x0e0d0c0b0a090807DATA shifts&lt;&gt;+0x98(SB)/8, $0xffffffffffffff0fDATA shifts&lt;&gt;+0xa0(SB)/8, $0x0d0c0b0a09080706DATA shifts&lt;&gt;+0xa8(SB)/8, $0xffffffffffff0f0eDATA shifts&lt;&gt;+0xb0(SB)/8, $0x0c0b0a0908070605DATA shifts&lt;&gt;+0xb8(SB)/8, $0xffffffffff0f0e0dDATA shifts&lt;&gt;+0xc0(SB)/8, $0x0b0a090807060504DATA shifts&lt;&gt;+0xc8(SB)/8, $0xffffffff0f0e0d0cDATA shifts&lt;&gt;+0xd0(SB)/8, $0x0a09080706050403DATA shifts&lt;&gt;+0xd8(SB)/8, $0xffffff0f0e0d0c0bDATA shifts&lt;&gt;+0xe0(SB)/8, $0x0908070605040302DATA shifts&lt;&gt;+0xe8(SB)/8, $0xffff0f0e0d0c0b0aDATA shifts&lt;&gt;+0xf0(SB)/8, $0x0807060504030201DATA shifts&lt;&gt;+0xf8(SB)/8, $0xff0f0e0d0c0b0a09GLOBL shifts&lt;&gt;(SB),RODATA,$256TEXT runtime·return0(SB), NOSPLIT, $0 MOVL $0, AX RET// Called from cgo wrappers, this function returns g-&gt;m-&gt;curg.stack.hi.// Must obey the gcc calling convention.TEXT _cgo_topofstack(SB),NOSPLIT,$0 get_tls(CX) MOVQ g(CX), AX MOVQ g_m(AX), AX MOVQ m_curg(AX), AX MOVQ (g_stack+stack_hi)(AX), AX RET// The top-most function running on a goroutine// returns to goexit+PCQuantum.TEXT runtime·goexit(SB),NOSPLIT,$0-0 BYTE $0x90 // NOP CALL runtime·goexit1(SB) // does not return // traceback from goexit1 must hit code range of goexit BYTE $0x90 // NOP// This is called from .init_array and follows the platform, not Go, ABI.TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0 PUSHQ R15 // The access to global variables below implicitly uses R15, which is callee-save MOVQ runtime·lastmoduledatap(SB), AX MOVQ DI, moduledata_next(AX) MOVQ DI, runtime·lastmoduledatap(SB) POPQ R15 RET// gcWriteBarrier performs a heap pointer write and informs the GC.//// gcWriteBarrier does NOT follow the Go ABI. It takes two arguments:// - DI is the destination of the write// - AX is the value being written at DI// It clobbers FLAGS. It does not clobber any general-purpose registers,// but may clobber others (e.g., SSE registers).TEXT runtime·gcWriteBarrier(SB),NOSPLIT,$120 // Save the registers clobbered by the fast path. This is slightly // faster than having the caller spill these. MOVQ R14, 104(SP) MOVQ R13, 112(SP) // TODO: Consider passing g.m.p in as an argument so they can be shared // across a sequence of write barriers. get_tls(R13) MOVQ g(R13), R13 MOVQ g_m(R13), R13 MOVQ m_p(R13), R13 MOVQ (p_wbBuf+wbBuf_next)(R13), R14 // Increment wbBuf.next position. LEAQ 16(R14), R14 MOVQ R14, (p_wbBuf+wbBuf_next)(R13) CMPQ R14, (p_wbBuf+wbBuf_end)(R13) // Record the write. MOVQ AX, -16(R14) // Record value // Note: This turns bad pointer writes into bad // pointer reads, which could be confusing. We could avoid // reading from obviously bad pointers, which would // take care of the vast majority of these. We could // patch this up in the signal handler, or use XCHG to // combine the read and the write. MOVQ (DI), R13 MOVQ R13, -8(R14) // Record *slot // Is the buffer full? (flags set in CMPQ above) JEQ flushret: MOVQ 104(SP), R14 MOVQ 112(SP), R13 // Do the write. MOVQ AX, (DI) RETflush: // Save all general purpose registers since these could be // clobbered by wbBufFlush and were not saved by the caller. // It is possible for wbBufFlush to clobber other registers // (e.g., SSE registers), but the compiler takes care of saving // those in the caller if necessary. This strikes a balance // with registers that are likely to be used. // // We don't have type information for these, but all code under // here is NOSPLIT, so nothing will observe these. // // TODO: We could strike a different balance; e.g., saving X0 // and not saving GP registers that are less likely to be used. MOVQ DI, 0(SP) // Also first argument to wbBufFlush MOVQ AX, 8(SP) // Also second argument to wbBufFlush MOVQ BX, 16(SP) MOVQ CX, 24(SP) MOVQ DX, 32(SP) // DI already saved MOVQ SI, 40(SP) MOVQ BP, 48(SP) MOVQ R8, 56(SP) MOVQ R9, 64(SP) MOVQ R10, 72(SP) MOVQ R11, 80(SP) MOVQ R12, 88(SP) // R13 already saved // R14 already saved MOVQ R15, 96(SP) // This takes arguments DI and AX CALL runtime·wbBufFlush(SB) MOVQ 0(SP), DI MOVQ 8(SP), AX MOVQ 16(SP), BX MOVQ 24(SP), CX MOVQ 32(SP), DX MOVQ 40(SP), SI MOVQ 48(SP), BP MOVQ 56(SP), R8 MOVQ 64(SP), R9 MOVQ 72(SP), R10 MOVQ 80(SP), R11 MOVQ 88(SP), R12 MOVQ 96(SP), R15 JMP retDATA debugCallFrameTooLarge&lt;&gt;+0x00(SB)/8, $\"call fra\"DATA debugCallFrameTooLarge&lt;&gt;+0x08(SB)/8, $\"me too l\"DATA debugCallFrameTooLarge&lt;&gt;+0x10(SB)/4, $\"arge\"GLOBL debugCallFrameTooLarge&lt;&gt;(SB), RODATA, $0x14 // Size duplicated below// debugCallV1 is the entry point for debugger-injected function// calls on running goroutines. It informs the runtime that a// debug call has been injected and creates a call frame for the// debugger to fill in.//// To inject a function call, a debugger should:// 1. Check that the goroutine is in state _Grunning and that// there are at least 256 bytes free on the stack.// 2. Push the current PC on the stack (updating SP).// 3. Write the desired argument frame size at SP-16 (using the SP// after step 2).// 4. Save all machine registers (including flags and XMM reigsters)// so they can be restored later by the debugger.// 5. Set the PC to debugCallV1 and resume execution.//// If the goroutine is in state _Grunnable, then it's not generally// safe to inject a call because it may return out via other runtime// operations. Instead, the debugger should unwind the stack to find// the return to non-runtime code, add a temporary breakpoint there,// and inject the call once that breakpoint is hit.//// If the goroutine is in any other state, it's not safe to inject a call.//// This function communicates back to the debugger by setting RAX and// invoking INT3 to raise a breakpoint signal. See the comments in the// implementation for the protocol the debugger is expected to// follow. InjectDebugCall in the runtime tests demonstrates this protocol.//// The debugger must ensure that any pointers passed to the function// obey escape analysis requirements. Specifically, it must not pass// a stack pointer to an escaping argument. debugCallV1 cannot check// this invariant.TEXT runtime·debugCallV1(SB),NOSPLIT,$152-0 // Save all registers that may contain pointers in GC register // map order (see ssa.registersAMD64). This makes it possible // to copy the stack while updating pointers currently held in // registers, and for the GC to find roots in registers. // // We can't do anything that might clobber any of these // registers before this. MOVQ R15, r15-(14*8+8)(SP) MOVQ R14, r14-(13*8+8)(SP) MOVQ R13, r13-(12*8+8)(SP) MOVQ R12, r12-(11*8+8)(SP) MOVQ R11, r11-(10*8+8)(SP) MOVQ R10, r10-(9*8+8)(SP) MOVQ R9, r9-(8*8+8)(SP) MOVQ R8, r8-(7*8+8)(SP) MOVQ DI, di-(6*8+8)(SP) MOVQ SI, si-(5*8+8)(SP) MOVQ BP, bp-(4*8+8)(SP) MOVQ BX, bx-(3*8+8)(SP) MOVQ DX, dx-(2*8+8)(SP) // Save the frame size before we clobber it. Either of the last // saves could clobber this depending on whether there's a saved BP. MOVQ frameSize-24(FP), DX // aka -16(RSP) before prologue MOVQ CX, cx-(1*8+8)(SP) MOVQ AX, ax-(0*8+8)(SP) // Save the argument frame size. MOVQ DX, frameSize-128(SP) // Perform a safe-point check. MOVQ retpc-8(FP), AX // Caller's PC MOVQ AX, 0(SP) CALL runtime·debugCallCheck(SB) MOVQ 8(SP), AX TESTQ AX, AX JZ good // The safety check failed. Put the reason string at the top // of the stack. MOVQ AX, 0(SP) MOVQ 16(SP), AX MOVQ AX, 8(SP) // Set AX to 8 and invoke INT3. The debugger should get the // reason a call can't be injected from the top of the stack // and resume execution. MOVQ $8, AX BYTE $0xcc JMP restoregood: // Registers are saved and it's safe to make a call. // Open up a call frame, moving the stack if necessary. // // Once the frame is allocated, this will set AX to 0 and // invoke INT3. The debugger should write the argument // frame for the call at SP, push the trapping PC on the // stack, set the PC to the function to call, set RCX to point // to the closure (if a closure call), and resume execution. // // If the function returns, this will set AX to 1 and invoke // INT3. The debugger can then inspect any return value saved // on the stack at SP and resume execution again. // // If the function panics, this will set AX to 2 and invoke INT3. // The interface&#123;&#125; value of the panic will be at SP. The debugger // can inspect the panic value and resume execution again.#define DEBUG_CALL_DISPATCH(NAME,MAXSIZE) \\ CMPQ AX, $MAXSIZE; \\ JA 5(PC); \\ MOVQ $NAME(SB), AX; \\ MOVQ AX, 0(SP); \\ CALL runtime·debugCallWrap(SB); \\ JMP restore MOVQ frameSize-128(SP), AX DEBUG_CALL_DISPATCH(debugCall32&lt;&gt;, 32) DEBUG_CALL_DISPATCH(debugCall64&lt;&gt;, 64) DEBUG_CALL_DISPATCH(debugCall128&lt;&gt;, 128) DEBUG_CALL_DISPATCH(debugCall256&lt;&gt;, 256) DEBUG_CALL_DISPATCH(debugCall512&lt;&gt;, 512) DEBUG_CALL_DISPATCH(debugCall1024&lt;&gt;, 1024) DEBUG_CALL_DISPATCH(debugCall2048&lt;&gt;, 2048) DEBUG_CALL_DISPATCH(debugCall4096&lt;&gt;, 4096) DEBUG_CALL_DISPATCH(debugCall8192&lt;&gt;, 8192) DEBUG_CALL_DISPATCH(debugCall16384&lt;&gt;, 16384) DEBUG_CALL_DISPATCH(debugCall32768&lt;&gt;, 32768) DEBUG_CALL_DISPATCH(debugCall65536&lt;&gt;, 65536) // The frame size is too large. Report the error. MOVQ $debugCallFrameTooLarge&lt;&gt;(SB), AX MOVQ AX, 0(SP) MOVQ $0x14, 8(SP) MOVQ $8, AX BYTE $0xcc JMP restorerestore: // Calls and failures resume here. // // Set AX to 16 and invoke INT3. The debugger should restore // all registers except RIP and RSP and resume execution. MOVQ $16, AX BYTE $0xcc // We must not modify flags after this point. // Restore pointer-containing registers, which may have been // modified from the debugger's copy by stack copying. MOVQ ax-(0*8+8)(SP), AX MOVQ cx-(1*8+8)(SP), CX MOVQ dx-(2*8+8)(SP), DX MOVQ bx-(3*8+8)(SP), BX MOVQ bp-(4*8+8)(SP), BP MOVQ si-(5*8+8)(SP), SI MOVQ di-(6*8+8)(SP), DI MOVQ r8-(7*8+8)(SP), R8 MOVQ r9-(8*8+8)(SP), R9 MOVQ r10-(9*8+8)(SP), R10 MOVQ r11-(10*8+8)(SP), R11 MOVQ r12-(11*8+8)(SP), R12 MOVQ r13-(12*8+8)(SP), R13 MOVQ r14-(13*8+8)(SP), R14 MOVQ r15-(14*8+8)(SP), R15 RET#define DEBUG_CALL_FN(NAME,MAXSIZE) \\TEXT NAME(SB),WRAPPER,$MAXSIZE-0; \\ NO_LOCAL_POINTERS; \\ MOVQ $0, AX; \\ BYTE $0xcc; \\ MOVQ $1, AX; \\ BYTE $0xcc; \\ RETDEBUG_CALL_FN(debugCall32&lt;&gt;, 32)DEBUG_CALL_FN(debugCall64&lt;&gt;, 64)DEBUG_CALL_FN(debugCall128&lt;&gt;, 128)DEBUG_CALL_FN(debugCall256&lt;&gt;, 256)DEBUG_CALL_FN(debugCall512&lt;&gt;, 512)DEBUG_CALL_FN(debugCall1024&lt;&gt;, 1024)DEBUG_CALL_FN(debugCall2048&lt;&gt;, 2048)DEBUG_CALL_FN(debugCall4096&lt;&gt;, 4096)DEBUG_CALL_FN(debugCall8192&lt;&gt;, 8192)DEBUG_CALL_FN(debugCall16384&lt;&gt;, 16384)DEBUG_CALL_FN(debugCall32768&lt;&gt;, 32768)DEBUG_CALL_FN(debugCall65536&lt;&gt;, 65536)TEXT runtime·debugCallPanicked(SB),NOSPLIT,$16-16 // Copy the panic value to the top of stack. MOVQ val_type+0(FP), AX MOVQ AX, 0(SP) MOVQ val_data+8(FP), AX MOVQ AX, 8(SP) MOVQ $2, AX BYTE $0xcc RET Go程序启动过程: 检查运行平台的CPU，设置好程序运行需要相关标志。 TLS的初始化。 runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。 runtime.newproc创建新的goroutine用于绑定用户写的main方法。 runtime.mstart开始goroutine的调度。 main 函数里执行的一些重要的操作包括： 新建一个线程执行 sysmon 函数，定期垃圾回收和调度抢占； 启动 gc； 执行所有的 init 函数等等 更多： Go语言goroutine调度器初始化","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"两个生僻小命令---go mod why和go mod graph","date":"2019-10-29T10:57:58.000Z","path":"2019/10/29/两个生僻小命令-go-mod-why和go-mod-graph/","text":"Go Module的基本使用 自新版本引入Go Module,改变了以往所有项目及依赖全部堆砌在$GOPATH/src下,时间一长项目一多变得臃肿混乱的局面,同时也解决了依赖包的版本控制问题. 现在我们可以在任意位置十分方便地新建项目. 执行 go mod init dashen,可以发现项目多了一个go.mod文件. (可以切换到文件夹后就执行go mod init xxx,也可在编码过程中再执行) 以最近调研和使用的几个log包为例,main.go代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"flag\" \"fmt\" \"github.com/golang/glog\" \"github.com/op/go-logging\" \"github.com/sirupsen/logrus\")func main() &#123; fmt.Println(\"\\n----glog----\") logFunc1() fmt.Println(\"\\n----logging----\") logFunc2() fmt.Println(\"\\n----logrus----\") logFunc3() fmt.Println(\"\\n\")&#125;func logFunc1() &#123; flag.Parse() defer glog.Flush() glog.Infof(\"This is info message: %v by glog\", 12345)&#125;func logFunc2() &#123; var log = logging.MustGetLogger(\"example\") log.Debugf(\"This is info message: %d by logging\", 12345)&#125;func logFunc3() &#123; logrus.Infof(\"This is info message:%d by logrus\", 12345)&#125; 执行go run main.go -v=4 -alsologtostderr, 如下图: 注: 可以手动执行go mod download或go mod tidy,也可以直接go run,这时会寻找需要的包自动进行下载并引用. 下载的包存放在$GOPATH/pkg/mod路径下,如果想更直观查看该项目用到的依赖包,可在项目目录下执行go mod vendor,之后项目目录下就会多一个vendor文件夹,且会将$GOPATH/pkg/mod下该项目用到的依赖copy到vendor中..(经亲测,两份依赖包完全独立,修改其中一处不会影响另外一处,那问题来了: 这样设计是否合理?再执行时实际引用的是哪一份?) 另: (除go.mod外,go命令还维护一个名为go.sum的文件,其中包含特定模块版本内容的预期加密哈希值,以确保项目所依赖的模块不会出现意外更改.go.mod和go.sum都应检入版本控制,但go.sum不需要手工维护,所以可以不用太关注) 关于几个日志包的一点解释: go run main.go后面的-v=4 -alsologtostderr为glog包需要的参数; 关于这三种常用的日至包—glog,go-logging和logrus,简而言之,glog为k8s采用的日志方案,代码量较少,但貌似不支持多色,及可定制化较低;go-logging和logrus都可支持彩色输出. 在此不做更多记述.更多高阶用法及参考: glog glog 使用及实现分析 go-logging github地址 go-logging的使用 logrus github地址 Logrus的使用 几个生僻小命令 go mod 常用命令见下: go mod why go mod why + [go.mod文件里某一个包名,如A],会告诉你在哪里使用了A这个包 但如果是A这个包还使用了B,那如果go mod why B,则会提示: go mod graph go graph命令后面不能带参数, 会显示出go.mod里需要的每个包,都依赖了哪些包. 对go.mod里的任何一个包,和go mod graph的结果都是一个一对多的关系. go.sum中不仅有项目需依赖的包的相关信息(如版本),还有这些依赖包所依赖的package的版本等信息,以及保证版本等信息无误的相关校验..这些都是go自己完成,开发者无需关心. 私有链接1 私有链接2","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"聊斋自志","date":"2019-10-28T12:07:00.000Z","path":"2019/10/28/聊斋自志/","text":"除去正文中提到的屈原，李贺，干宝，苏轼，几尊在中国文学史俱有一席之地的“上古大神”，这个一生未仕，自认“冷淡萧条”“落溷之花”的大户人家私塾先生，也曾致意八百年前几十里外的一位段姓老前辈。段成式的出生地，今天有近80万人口，而知之者多不逾千。他离世一两百年后，苏州人范仲淹随母改嫁，到此处一户朱姓人家。过后近1000年，这位诗文政绩俱佳的文正公，被身不由己稀里糊涂安排成了当地名人，此地也自号“范公故里”——不仅俗套，显然也违背当事人意愿。…看过英文版『出师表』，『浮生六记』，『阿Q正传』，也尝试去欣赏英译的唐诗宋词。和苏曼殊之于拜伦作品，那种升华一般的琅琅雅致相比，中文作品被翻译为英语后，大多数直白，缺韵，张力和想象力不足，如龙失目 少了魂魄。 《聊斋自志》 &lt;My Preface Of Story Room&gt; preface [ˈprefəs]n. 前言；引语vt. 为…加序言；以…开始vi. 作序 披萝带荔，三闾氏感而为《骚》；牛鬼蛇神，长爪郎吟而成癖。 The Mountain Ghosts who wore the vanillas, touched Qu Yuan and he wrote the ; although monsters and divinities are strange,Li He loved to sing for them with addiction. vanilla [vəˈnɪlə]n. 香子兰，香草adj. 香草味的divinity [dɪˈvɪnəti]n. 神；神性；神学addiction [əˈdɪkʃn]n. 上瘾，沉溺；癖嗜 自鸣天籁，不择好音，有由然矣。 Creatures sing from themselves naturally and beautifully, they use all the wonderful voices,have their own reasons. 松，落落秋萤之火，魑魅争光；逐逐野马之尘，罔两见笑。 I am insignificant like the autumn firefly’s light, but want to shine by ghostly stories; I am uncoventional like the wild horse’s dust,and can be laughed by monster tales. unconventional 英[ˌʌnkənˈvenʃənl] 美[ˌʌnkənˈvenʃənl] adj.不因循守旧的; 不因袭的; 新奇的; [例句]Linus Pauling is an unconventional genius莱纳斯·鲍林是个标新立异的天才人物。 才非干宝，雅爱搜神；情类黄州，喜人谈鬼。 My ability can’t match the Gan Bao,but I love to collect the Divine Stories;My hobby is like the Su Shi,and I like to hear the Ghostly Tales. 闻则命笔，遂以成编。久之，四方同人，又以邮筒相寄，因而物以好聚，所积益夥。 I write the stories if I heard about them,then make them become a book. As the time passes,the friends from each directions,send the stories with the postal tubes,so that I gather the good stories greatly,the amount is very large. 甚者，人非化外，事或奇于断发之乡；睫在目前，怪有过于飞头之国。 Even,the people aren’t the foreigners,the affairs are more strange than the savage area; the things before the eyes,the affairs are more odd than the Utopia country. 眼前所发生的怪事，竟比飞头国的事更为离奇。飞头之国，古代传说中的怪异地方。唐段成式《酉阳杂俎·异境》：“岭南溪洞中，往往有飞头者，故有飞头獠子之号。”(爽哥注: 段成式,今山东邹平人氏,与蒲松龄出生地相距几十公里, 相差800多年) savage [ˈsævɪdʒ] n. 未开化的人；粗鲁的人；残暴成性的人adj. 野蛮的；残酷的；狂怒的；荒凉的vt. 乱咬；粗暴的对待n. (Savage)人名；(西)萨瓦赫；(英、德)萨维奇 遄飞逸兴，狂固难辞；永托旷怀，痴且不讳。 My good interest is intense,it’s difficult that I avoid crazy; my vast mindedness is eternal, it’s needless that I evade the obsession. intense [ɪnˈtens]adj. 强烈的；紧张的；非常的；热情的eternal [ɪˈtɜːnl]adj. 永恒的；不朽的evade [ɪˈveɪd] 详细Xvt. 逃避；规避；逃脱vi. 逃避；规避；逃脱evade: 逃避evade obligations: 规避义务obsession [əbˈseʃn]n. 痴迷；困扰；[内科][心理] 强迫观念 展如之人，得毋向我胡卢耶？ The honest people, can’t they laugh at me? 然五父衢头，或涉滥听；而三生石上，颇悟前因。 However the stories which I heard in Wufu Road, could be unfounded statements; and the tales that happened on Sansheng Stone,make me realize the previous causes greatly. 五父衢是一路名，位于山东曲阜县东南。古道路名。《礼记·檀弓》：“孔子少孤，不知其墓，殡于五父之衢。”《左传》襄公十一年（公元前562年）：季武子将作三军，“诅诸五父之衢”。孔子少孤，不知父亲葬在哪儿。母亲去世，无法合葬。于是把母亲的灵柩殡（停放）于五父衢头，也就是街上。果然有知道的人告诉孔子，他父亲的墓的位置。孔子才能使父母合葬。蒲自序是说自己故事的来源是道听途说unfounded [ʌnˈfaʊndɪd]adj. 未建立的；没有理由的；没有事实根据的网络释义Unfounded: 多虑Unfounded viewpoint: 无根据的看法unfounded rumor: 讹传 放纵之言，或有未可概以人废者。 The fantastic words,people shouldn’t reject them because of the speakers. fantastic,除去”极好的”,还有:n. 古怪的人adj. 奇异的；空想的；异想天开的；古怪的；极好的，极出色的；不可思议的；不切实际的 松悬弧时，先大人梦一病瘠瞿昙，偏袒入室，药膏如钱，圆粘乳际，寤而松生，果符墨志。 When I was born,my father dreamed that one sick and thin monk,whose right shoulder was exposed came into room,the round ointment was like a coin, was sticked near the nipple, I had been born after my father awoke,as a result a mole near my right nipple. 瞿昙：梵语，原为佛教始祖姓氏，后泛指僧人。悬弧：《礼记·内则》：“子生，男子设弧于门左，女子设帨于门右。”弧，木弓。后以“悬弧”表男子诞生。(比弄璋弄瓦高级一点..)偏袒：和尚身穿袈裟，袒露右肩，故称ointment [ˈɔɪntmənt]n. 药膏；[药] 油膏网络释义OINTMENT: 药膏Erythromycin Ointment: 红霉素软膏mole [məʊl]n. 鼹鼠；痣；防波堤；胎块；间谍 且也，少羸多病，长命不犹。门庭之凄寂，则冷淡如僧；笔墨之耕耘，则萧条似钵。 What’s more,I was week and valetudinarian when I was young, and couldn’t become longveous. My room is silent and miserable,I am as cold as a monk; I write the book with pen and ink,it is as depressed as the earthen bowl. valetudinarian [,vælɪtjuːdɪ’neərɪən]n. 过分担心自己健康的人；体弱多病的人adj. 过分担心健康的；虚弱的；有病的earthen [ˈɜːθn]adj. 土制的；陶制的；地球上的earthen: 土制的earthen pot: 砂锅 每搔头自念，勿亦面壁人果是吾前身耶？ Each time I scratch my head to consider myself, isn’t that monk my previous status? 盖有漏根因，未结人天之果；而随风荡堕，竟成藩溷之花。 Because I lack for the reasons and roots,so couldn’t get the achievements of heaven and prominent person; as I degenerate into the destiny and tendency,even could become the flower of toilet and dirty place. prominent [ˈprɒmɪnənt]adj. 突出的，显著的；杰出的；卓越的prominent: 突出的prominent intellectuals: 高知识群体Prominent Figures: 人物degenerate [dɪ’dʒen(ə)rət]v. 使退化；恶化；堕落adj. 退化的；堕落的；退化的；简并的n. 堕落的人 茫茫六道，何可谓无其理哉！ The indistinct Six Worlds, isn’t there any reason? indistinct [ˌɪndɪˈstɪŋkt]adj. 模糊的，不清楚的；朦胧的；难以清楚辨认的indistinct: 不清楚的indistinct strategy: 模糊战略marking indistinct: 标志不清 独是子夜荧荧，灯昏欲蕊；萧斋瑟瑟，案冷疑冰。 Lonely I write in the glimmering night,the dim light is like the stamen; miserably I live in the rustling room,the cold table is like the ice. stamen(这个直译简直了…)n. [植] 雄蕊n. (Stamen)人名；(塞、保)斯塔门stamen: 雄蕊 集腋为裘，妄续《幽冥》之录；浮白载笔，仅成《孤愤》之书。 I gather the stories into a book,boldly want to continue the &lt;Nether World&gt;; I write the tales with a pen,only try to complete the &lt;Isolated Resentment&gt;. 《幽冥》之录：南朝刘义庆著《幽冥录》，记神鬼怪异事。这里泛指志怪小说。孤愤之书：战国韩非著有《孤愤》。《史记·老子韩非列传》索引云：“孤愤，愤孤直不容于时也。”此指代《聊斋志异》。boldly [ˈbəʊldli]adv. 大胆地；冒失地；显眼地 寄托如此，亦足悲矣。 My aspiration is it,it’s also grieved. aspiration [ˌæspəˈreɪʃn]n. 渴望；抱负；送气；吸气；吸引术 嗟乎！惊霜寒雀，抱树无温；吊月秋虫，偎阑自热。知我者，其在青林黑塞间乎！ Oh! The cold sparrow who is astonished by frost, feels no warm when it stays on the tree;the autumn insect who is exposed to moonlight,gets any heat as it leans by the railing.The creatures who know me,perhaps live in the gloomy Spiritual World! 青林黑塞：语本杜甫《梦李白二首》（其二）：“魂来枫林青，魂返关塞黑。”比喻冥冥中。 康熙己末春日。 1679 Spring","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"},{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"小议macOS Catalina Sidecar命名及'随航'翻译的准确性","date":"2019-10-22T13:17:29.000Z","path":"2019/10/22/小议macOS-Catalina-Sidecar命名及-随航-翻译的准确性/","text":"微服务中有所谓“sidecar”概念，无独有偶，最新的macOS Catalina增加了一个同名功能，旨在将iPad作为Mac的扩展屏幕。 sidecar译为『边车，跨斗』，听了这解释基本还是一脸懵逼。其实就是过去这种老式摩托，抗日神剧里常见，我小时貌似派出所出警，也多用这种车，伴随汽车普及，几乎被淘汰。 微服务中，此概念解释为:就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展/增强功能特性，同时Sidecar与主应用是松耦合的。 Sidecar与主应用依然是一体的，用这种老式摩托车比喻十分生动。而Mac和iPad，虽说水果一直想将桌面操作系统和移动操作系统整合，但现下看，依然是同一公司搭载macOS和iOS不同操作系统的两款独立设备，此情境下，用“wing plane”或“corvette”更是贴合，尤其后者，与该功能的中文名“随航”，翻译得堪称神来之笔。 —————— 另:继美洲大型猫科动物被用得差不多后，苹果开始用加州知名风景区作为新系统名称。Catalina是洛杉矶附近一座小岛，以景色秀丽著称。catalina和katrina，分别译作“卡特琳娜”/“卡特丽娜”。以后者命名的飓风，曾在我刚上初中时席卷佛州，最终造成1800多人丧生，小布什因为行动迟缓，备受诟病。 与苹果的文艺不同，谷歌则属吃货阵营。从2009年的Cupcake开始，至2019年Android 10为止，10年间，“CP”之间的14种甜点，被谷歌用来作为新版本“机器人”的代号。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"sync.Once-保证运行期间的某段代码只会执行一次","date":"2019-10-14T13:40:32.000Z","path":"2019/10/14/sync-Once-保证运行期间的某段代码只会执行一次/","text":"初入门径 sync.Once提供了保证某个操作只被执行一次的功能,其最常应用于单例模式之下,例如初始化系统配置、保持数据库唯一连接,以及并发访问只需要初始化一次的共享资源。 1234567891011121314151617181920package mainimport ( \"fmt\" \"sync\")func main() &#123; var once sync.Once fun1 := func() &#123; fmt.Println(\"一只老虎\") &#125; once.Do(fun1) fun2 := func() &#123; fmt.Println(\"两只老虎\") &#125; once.Do(fun2)&#125; 输出为: 1一只老虎 并发调用 Do() 12345678910111213141516171819202122package mainimport ( \"fmt\" \"sync\" \"time\")func main() &#123; var once sync.Once for i := 0; i &lt; 5; i++ &#123; go func(i int) &#123; fun1 := func() &#123; fmt.Printf(\"i:=%d\\n\", i) &#125; once.Do(fun1) &#125;(i) &#125; // 为防止主goroutine直接运行完，什么都看不到 time.Sleep(50 * time.Millisecond)&#125; 在上面这段代码里,开启了5个并发的 goroutine ，不管执行多少次, 始终只打印一次. 至于 i 是多少,就看先执行的是哪个 g 了。 Once 保证只有第一次调用 Do() 方法时, 传递的 f (无参数无返回值的函数) 才会执行,并且之后不管调用的参数是否改变了,也不管f执行时是否发生了panic,之后都不再执行。 这段是官方Demo: 123456789101112131415161718192021222324 package main import ( \"fmt\" \"sync\" ) func main() &#123; var once sync.Once onceBody := func() &#123; fmt.Println(\"Only once\") &#125; done := make(chan bool) for i := 0; i &lt; 10; i++ &#123; go func() &#123; once.Do(onceBody) done &lt;- true &#125;() &#125; for i := 0; i &lt; 10; i++ &#123; &lt;-done &#125;&#125;// 结果只打印一次：only once 源码实现 其代码实现很简洁, 从头到尾加注释不超过 70 行. 对外暴露了一个唯一接口 Do(f func()), 使用起来也很简单,可以多次调用,但是只有第一次调用Do方法时f参数才会执行,这里的f是一个无参数无返回值的函数。 点击查看 sync.Once源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.package syncimport ( \"sync/atomic\")// Once is an object that will perform exactly one action.type Once struct &#123; // done indicates whether the action has been performed. // It is first in the struct because it is used in the hot path. // The hot path is inlined at every call site. // Placing done first allows more compact instructions on some architectures (amd64/x86), // and fewer instructions (to calculate offset) on other architectures. // done用来表示当前的操作是否已经被执行, 0表示还没有执行过, 1表示已经执行 // done属性放在结构体的第一位,是因为它在hot path中使用 // hot path在每个调用点会被内联 // 将done放在结构体首位,像amd64/386等架构上可以允许更多的压缩指令,且在其他架构上更少的指令去计算偏移量 done uint32 m Mutex&#125;// Do calls the function f if and only if Do is being called for the// first time for this instance of Once. In other words, given// var once Once// if once.Do(f) is called multiple times, only the first call will invoke f,// even if f has a different value in each invocation. A new instance of// Once is required for each function to execute.//// Do is intended for initialization that must be run exactly once. Since f// is niladic, it may be necessary to use a function literal to capture the// arguments to a function to be invoked by Do:// config.once.Do(func() &#123; config.init(filename) &#125;)//// Because no call to Do returns until the one call to f returns, if f causes// Do to be called, it will deadlock.//// If f panics, Do considers it to have returned; future calls of Do return// without calling f.//// Do的作用主要是针对初始化且有且只能执行一次的场景。因为Do直到f返回才返回，`// 所以如果f内再调用Do则会导致死锁// 如果f执行过程中panic了 那么Do任务f已经执行完毕 未来再次调用不会再执行ffunc (o *Once) Do(f func()) &#123; // Note: Here is an incorrect implementation of Do: // // if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) &#123; // f() // &#125; // // Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first's call to f to complete. // This is why the slow path falls back to a mutex, and why // the atomic.StoreUint32 must be delayed until after f returns. if atomic.LoadUint32(&amp;o.done) == 0 &#123; // Outlined slow-path to allow inlining of the fast-path. // 原子获取 done 的值，判断 done 值是否为 0，如果为 0 就调用 doSlow 方法，进行二次检查。 // 可能会存在并发 进入slow-path o.doSlow(f) &#125;&#125;func (o *Once) doSlow(f func()) &#123; // 二次检查时，持有互斥锁，保证只有一个 goroutine 执行。 o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; //二次判断f是否已经被执行 // 二次检查，如果 done 的值仍为 0，则认为是第一次执行，执行参数 f，并将 done 的值设置为 1。 //即使此时有多个 goroutine 同时进入了 doSlow 方法,因为双检查的机制,后续的 goroutine 会看到 o.done 的值为 1,也不会再次执行 f defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125; Once 结构体中包含两个字段, 分别是 uint32 类型的 done 和 Mutex 类型的 m. Once 实现了两个方法, 分别是 Do 和 doSlow。其中 doSlow 是一个非可导出方法,只能在内部被 Do 方法调用. Done 方法先原子获取 done 的值,如果 done 的值为 0,则调用 doSlow 方法进行二次检查,二次检查时,持有互斥锁,保证只有一个 goroutine 执行操作.如果二次检查的结果为 0,则认为是第一次执行,程序执行函数类型的参数 f,然后将 done 的值设置为 1. 注意事项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"fmt\" \"sync\")func main() &#123; panicDo() //nestedDo() nestedDo2()&#125;func panicDo() &#123; once := &amp;sync.Once&#123;&#125; defer func() &#123; if err := recover(); err != nil &#123; once.Do(func() &#123; fmt.Println(\"run in recover\") &#125;) &#125; &#125;() once.Do(func() &#123; panic(\"panic i=0\") &#125;)&#125;func nestedDo() &#123; once := &amp;sync.Once&#123;&#125; once.Do(func() &#123; once.Do(func() &#123; fmt.Println(\"test nestedDo\") &#125;) &#125;)&#125;func nestedDo2() &#123; once1 := &amp;sync.Once&#123;&#125; once2 := &amp;sync.Once&#123;&#125; once1.Do(func() &#123; once2.Do(func() &#123; fmt.Println(\"test nestedDo\") &#125;) &#125;)&#125; 详解并发编程之sync.Once的实现(附上三道面试题) (1). sync.Once()方法中传入的函数发生了panic，重复传入还会执行吗？ 执行panicDo方法,不会打印任何东西. sync.Once.Do 方法中传入的函数只会被执行一次,哪怕函数中发生了 panic； (2). sync.Once()方法传入的函数中再次调用sync.Once()方法会有什么问题吗？ 会发生死锁! 执行nestedDo方法,会报 fatal error: all goroutines are asleep - deadlock! 根据源码实现,可知在第二个do方法会一直等doshow()中锁的释放导致发生了死锁; (3). 执行nestedDo2,会输出什么? 会打印出 test nestedDo. once1，once2是两个对象,互不影响. 所以sync.Once是使方法只执行一次对象的实现。 官方库或知名项目中的使用 net包 系统的网络配置 就是存放在一个变量里,用sync.Once控制读写 当且仅当第一次读某个变量时，进行初始化（写操作）变量被初始化过程中，所有读都被阻塞（读操作；当变量初始化完成后，读操作继续进行变量仅初始化一次，初始化完成后驻留在内存里 Golang package sync 剖析(一)： sync.Once 参考: 你真的了解 sync.Once 吗 深入源码分析golang之sync.Once","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"mysql的sql_mode设置","date":"2019-10-12T13:51:51.000Z","path":"2019/10/12/mysql的sql-mode设置/","text":"疑窦丛生 疑惑一: 在公司的测试数据库, 执行 select * from 某张表 group by 某字段, 居然不会报错?? 但我在本地执行类似sql,则会 11055 - Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;xxx表.id&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by, Time: 0.036000s (1055-SELECT列表的表达式＃1不在GROUP BY子句中，并且包含未聚合的列’xx表.id’，该列在功能上不依赖于GROUP BY子句中的列； 这与sql_mode = only_full_group_by不兼容，时间：0.036000s) 疑惑二: 从公司的测试数据库,导出部分表结构到本地,竟然有些表无法导下来. 查看原因,是 1067 - Invalid default value for &#39;ctime&#39;, Time: 0.033000s, 而这个字段的DDL为 ctime timestamp NOT NULL DEFAULT &#39;0000-00-00 00:00:00&#39; COMMENT &#39;创建时间&#39;, 拨云见日 最初以为是MariaDB和MySQL的差异导致,最后一搜索,实际是sql_mode 因sql_mode而导致的错误,错误码为 1067 测试数据库下执行select @@sql_mode: NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 本地数据库下执行select @@sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 可参考mysql的sql_mode合理设置,了解每一项的含义,及设置或取消设置后的影响 可参考Mysql 的sql_mode修改,来进行全局的修改(但这种修改方式,在重启mysql服务后会失效,想永久修改,需要去mysql的配置文件中设置) 执行 set @@global.sql_mode=&#39;NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;, 这样本地就和测试环境sql_mode的设置一致了 参考: sql_mode相关","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"余过淮扬","date":"2019-10-03T13:05:43.000Z","path":"2019/10/03/余过淮扬/","text":"#己亥癸酉正午，余过淮扬# 『盱眙龙虾香天下，美丽清纯洪泽湖』的“洗耳”广告已多年未闻。 当年受胯下之辱的少年，几十年干戈杀伐，几历裂土封地又几经贬谪，以“淮阴侯”身份荣归故里，复修『漂母坟』，得偿幼时愿。 还有一位明朝的吴姓秀才，科举屡遭挫折，宦途困顿不堪，后索幸闭门著书，虽是写鬼神写幻境，却是付梓不多时，便为“禁书”。但依靠这部作品，他比所在王朝所有状元首辅的寿命加在一起还要绵长。中国儿童碰触中国文学，他这里是绕不过的一站。 当然，还有成人版的&lt;老残游记&gt;，希望多年后，我也能有刘鹗丰富经历，更有其犀利笔触。 『淮安城内少年郎，发奋读书为国强』。这是一百年前，一位周姓少年之秩事。然而，无论北上津门或是远渡重洋，却一生未能迈进大学引为平生憾事。但用另一种方式——像他那个“弃医从文”的远房亲戚，实现了自己所夸海口。他没有子嗣不留遗体，骨灰撒散赤县神州。周公吐哺天下归心，今天，他好像还在我们身边。 以南的扬州尝曾专程前去，但高邮不曾有缘。庵赵庄荸荠庵的明海小法师，怕已是耄耋老僧。从那天后，你又见过小英子吗？ 宝应，这里不曾有何煊赫人物，亦无知名景区。但于我，有一位相逢可一笑的当年故友。『昔别尔未婚，儿女忽成行』，用在这里，怕是再恰当不过。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"慎写指针类型的全局变量","date":"2019-09-30T15:11:19.000Z","path":"2019/09/30/慎写指针类型的全局变量/","text":"简述: 在 关于range二三事 第二个case中,介绍了对于指针类型的 切片/map变量A 的循环,要格外注意, 迭代出的value作用域是整个方法而非循环体内.改进办法:在循环体中引入中间变量,”暂存”下每次迭代的value的值 但对于这个A,如果是全局变量,则又极有可能出现问题: 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\")type UserInfo struct &#123; Name string Age int&#125;var ( defaultInfo = UserInfo&#123;Name: \"fliter\", Age: 26&#125; defaultInfoSli = []*UserInfo&#123;&amp;defaultInfo&#125;)func main() &#123; for _, v := range defaultInfoSli &#123; tmp := v //go func() &#123; tmp.Age = 100 //&#125;() &#125; //time.Sleep(1e9) fmt.Println(defaultInfoSli[0].Age)&#125; defaultInfoSli迭代出的v为指针类型,tmp仍为指针类型,对其赋值,会改变全局变量defaultInfoSli的值 复现: 在具体业务场景中,服务启动时初始化(取数据库或redis,或读取配置文件,加载到内存中)了一个全局变量.每个http请求过来,golang都会有一个新的协程去处理相关逻辑. 对于某个具体方法内的变量,对每次请求都是独立和隔离(每次请求都相当于一个个cellar,彼此之间不会有干涉和影响), 但对于永久存在内存中的全局变量,如果有对其写操作,每次请求都会影响该全局变量. 当出现并发请求如用户x和y同时请求接口, 两次请求都会改写全局变量, 这时就很可能出现返回的x和y的数据错乱 Demo如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package mainimport ( \"encoding/json\" \"fmt\" \"github.com/davecgh/go-spew/spew\" \"log\" \"net/http\")type BookInfo struct &#123; Title string Rank int Data interface&#123;&#125;&#125;var ( defaultBook1 = BookInfo&#123;Title: \"水浒传\", Rank: 1&#125; defaultBook2 = BookInfo&#123;Title: \"三国演义\", Rank: 2&#125; defaultBook3 = BookInfo&#123;Title: \"西游记\", Rank: 3&#125; defaultBook4 = BookInfo&#123;Title: \"红楼梦\", Rank: 4&#125; DefaultBookSli = []*BookInfo&#123;&amp;defaultBook1, &amp;defaultBook2, &amp;defaultBook3, &amp;defaultBook4&#125;)type CommonParams struct &#123; ID int64 Name string&#125;var ( ModuleHandlers = map[int]func(params *CommonParams) *BookInfo&#123; 1: HandleTypeOne, 2: HandleTypeTwo, 3: HandleTypeThree, 4: HandleTypeFour, &#125;)func main() &#123; fmt.Println(DefaultBookSli) http.HandleFunc(\"/index\", deal) //设置访问的路由 err := http.ListenAndServe(\":80\", nil) //设置监听的端口 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125;func deal(w http.ResponseWriter, r *http.Request) &#123; name := r.URL.Query().Get(\"name\") //fmt.Println(\"name值为:\", name) par := &amp;CommonParams&#123; ID: 0, Name: name, &#125; // 获取相关数据 for _, v := range DefaultBookSli &#123; module := v //fmt.Println(\"module is:\", module) //fmt.Println(\"排序为:\", module.Rank) m := ModuleHandlers[module.Rank](par) // 填充模块数据 if m.Data != nil &#123; module.Data = m.Data &#125; // (如果需要),重写模块标题(在此不需要) //if m.Title != \"\" &#123; // module.Title = m.Title //&#125; &#125; //time.Sleep(1e9) //此处等待并不是因为协程,而是方便测试,不加这个等待,执行100次秒速就完成. 加这个等待是为了方便模拟\"几个用户同时请求\" //fmt.Println(DefaultBookSli[0].Rank) spew.Dump(DefaultBookSli) rsJson, _ := json.Marshal(DefaultBookSli) //fmt.Println(string(rsJson)) //这个写入到w的是输出到客户端的 fmt.Fprintf(w, string(rsJson)) //这个写入到w的是输出到客户端的&#125;func HandleTypeOne(p *CommonParams) *BookInfo &#123; res := \"\" if p.Name == \"施耐庵\" &#123; res = \"我叫施耐庵,我是作者!\" &#125; return &amp;BookInfo&#123;Data: res&#125;&#125;func HandleTypeTwo(p *CommonParams) *BookInfo &#123; res := \"\" if p.Name == \"罗贯中\" &#123; res = \"我叫罗贯中,我是作者!\" &#125; return &amp;BookInfo&#123;Data: res&#125;&#125;func HandleTypeThree(p *CommonParams) *BookInfo &#123; res := \"\" if p.Name == \"吴承恩\" &#123; res = \"我叫吴承恩,我是作者!\" &#125; return &amp;BookInfo&#123;Data: res&#125;&#125;func HandleTypeFour(p *CommonParams) *BookInfo &#123; res := \"\" if p.Name == \"曹雪芹\" &#123; res = \"我叫曹雪芹,我是作者!\" &#125; return &amp;BookInfo&#123;Data: res&#125;&#125; 带着参数x, 使用Postman进行串行调用100次, 同时再访问这个接口,带参数y,此时可以发现,出现了数据错乱: 修改方案: 在module := v这一步,实际上module依然是指针类型. 可以module := *v,这样module就不是指针类型,也就不会出现如上问题. 当时问题紧急,直接在里面新加了一个临时变量,即: 1234567891011121314151617// 获取相关数据for _, v := range DefaultBookSli &#123; module := v var temModule = &amp;BookInfo&#123; Title: module.Title, Rank: module.Rank, &#125; m := ModuleHandlers[temModule.Rank](par) // 填充模块数据 if m.Data != nil &#123; module.Data = m.Data &#125;&#125; 详细过程参见 私有笔记 并发写全局变量导致的数据错乱问题,印象深刻的一次体验","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"Adler32算法","date":"2019-09-30T13:20:17.000Z","path":"2019/09/30/Adler32算法/","text":"ZooKeeper 为什么需要Adler-32算法关于校验码算法，我们最熟悉的算法应该是CRC校验算法，那么有了CRC校验算法之后，为什么还要提出这样一个算法呢？ 这个算法比CRC算法更加快速，但是安全性不如CRC．换句话说，就是在安全性和速度之间做了一个权衡． https://www.jianshu.com/p/7e983c9c4d69","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"SOLID原则","date":"2019-09-25T14:07:13.000Z","path":"2019/09/25/SOLID原则/","text":"SOLID原则指五个面向对象的设计原则，每个设计原则的首字母拼起来，刚好是SOLID这个单词： SRP: 单一职责原则。每个软件模块有且只有一个需要被改变的理由。 OCP: 开闭原则。软件系统应该允许通过新增代码来修改原有系统行为，而不是通过修改现有代码。 LSP: 里氏替换原则。实现某些接口的组件，必须同时遵守同一个约定，以便让这些组件可以相互替换。 ISP: 接口隔离原则。只依赖自己需要的部分。 DIP: 依赖倒置原则。调用方不应该依赖于被调用方的实现，而应该依赖于接口。 SOLID原则、设计模式适用于Python语言吗 阮一峰-代码的抽象三原则","tags":[{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"Routine-Tech","date":"2019-09-24T11:09:10.000Z","path":"2019/09/24/Routine-Tech/","text":"代码调试使用go module且生成vendor,想要(临时)修改用到的第三方包的代码,go run/go build时改动的代码是无效的..当确实需要修改第三方的包,这个问题该怎样较好解决的? 在2019-09-24 19:09:10 说: 一致性算法最近在看『一致性算法』,主要是Raft,事实上其已取代过去十年几乎是分布式领域一致性协议代名词的Paxos。后者以晦涩艰深出名,而Raft在设计之初,就是要解决Paxos难于理解的痛点,故而其以『Understandable』自居。 其核心为『leader election』和『log replication』(safety勉强也算)。前者是有一个时间不等的倒计时,后者则类似两阶段提交(2PC)… 具体细节可见 基于这两种协议实现的最知名产品,即ZooKeeper和etcd名字取得都非常有意思—-像“动物园饲养员”一样有条不紊并行不悖,被三只猫折腾得天翻地覆的我,表示这个期许实在不低; 而“etcd”表示分布式的 etc 目录,我用它来在分布式系统中做配置中心,而至于etc目录—-/etc:系统主要的配置文件几乎都放置到这个目录内,例如人员的账号密码文件、各种服务的起始文件等。一般来说,这个目录下的各文件属性是可以让一般用户用户查阅的,但是只有root有权利修改。FHS(绝大多数linux采用的文件组织形式)建议不要放置可执行文件(binary)在这个目录中。比较重要的文件有: /etc/inittab, /etc/init.d/,/ etc/modprobe.conf, /etc/x11, /etc/fstab, /etc/sysconfig/等。 http://thesecretlivesofdata.com/raft/ 个人笔记 在2019-08-07 23:09:10说: &lt;小议使用英文词汇的准确性&gt;下午分享讲到NFV和SDN,瞥了眼其英文全称,中规中矩不过如此。在讲到主干网络和分支网络拓扑时,又扫了眼ppt,一时在极速思考:此处的“主干”,用哪个单词更为贴切形象?main吗?作为go或java等开发者恐怕已经不想用这个烂大街的词汇。当图像翻到下页,看到结果是“spine”,脊椎,脊柱之意,大呼生动准确。 在我最近几年的职业生涯中,还曾有两次这样的“被惊艳瞬间”: 1.有道云笔记之前某个版本,可以观看广告视频,完毕后弹出三个礼盒,你可选其中一个,获取1-10M空间。某天我突发奇想,这三个盒子里的空间数量,会不会早已经算好放在里面,只待你“拆开”?虽然换位思考,我不会这样设计,而会采用更合理的点击时服务端依据随机算法即时生成。抱着试试看看心态,抓包查验。果不其然,无法通过此伎俩,提前获悉哪个盒子里的空间数最大。但意外之喜,是好奇弹出礼盒的这个接口,如无记错叫做“Cerberus”,是希腊神话里的一只三头怪物。换成我,大概率会用“threebox”。 2.之前遇到一个“分润”bug,此前我一直不清楚何为“分润”。搜索到对应词是distribution,但该词更多用作“分配,分布,分销”。原代码中用到的词是refund,即退款,返还款,貌似已较贴切。直到某天无意看到支付宝的接口文档,叫做distribute_royalty。 这感觉,似是“初极狭才通人,复行数十步豁然开朗”。更像出恭中的阎公,听闻“落霞与孤鹜”句拍腿叫绝。 于2019-09-21 21:05:12修正: 之前全网寻找上图不得,现在又出现该功能,果断抓包查看接口名称。 实际上不是叫『Cerberus』,而为『Gorgon』。是三个姐妹,通常情况头生毒蛇,睹其真颜者将会石化。 除去历史上赫赫有名的符(彦卿)家三姐妹,独孤(信)家三姐妹,近现代的宋(嘉树)家三姐妹,以及文学史上的夏洛蒂三姐妹,又get到神话里的福耳库斯三姐妹,且有一个专属词汇“Gorgon” 关于”哨兵” 「sentinel」，在软件领域，有“带哨兵节点的链表”，“redis的哨兵模式”，还有某些公司开发的中间件。 但这个词在不同场景下，其实含义有所差异。在list中，更好的翻译实则是“标记节点/标志节点”，就像边界线，像孙悟空给唐僧画的那个圈。（理解成水位线，多少也有点哨兵的意思） 而redis的这个“哨兵”，才是真正意义上的哨兵。它会监控集群状态，当主服务器宕掉，会自动将某台从服务器扶正，并通知其他从服务器。 逆波兰表达式 Lukasiewicz一般被译作“卢卡西维奇”。 “烈士暮年”的当世第一中锋莱万多夫斯基，其波兰语原称是Lewandowski。 10年前死于空难的波兰时任总统 卡钦斯基，原称是Kaczynski。 看到“抖动”, 我首先想到的，是垃圾回收时STW，或者是某些非渐进式扩容的哈希，在扩容时对程序的影响。 而把Thrash，把这个酷似“Trash”的词在此处被译作“抖动”，真的是不够妥当。 这里场景是，数据块始终缓存不命中，即高速缓存反复地加载和驱逐相同的高速缓存块的组。「使得性能下降。这种情况称为抖动（Thrash）」 用其本意“激烈扭动，翻来覆去”，只是表征和模拟了“反复加载和驱逐”。其实thrash还有一层引申义“白忙”，类似竹篮打水，狗熊掰棒子。但译者中文词汇有限，找不到一个更贴合词汇，也没有魄力与能力，为此新造一个词。 我相信，这里实际意义的“抖动”，都和绝大多数读者以为的有所出入。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"日志结构合并树(LSM-Tree)","date":"2019-09-21T13:47:41.000Z","path":"2019/09/21/日志结构合并树-LSM-Tree/","text":"听了蚂蚁金服OceanBase的一场线下MeetUp,了解到其底层使用LSM, 又分动态数据区和静态数据区.其中动态数据区使用B+树和HashTable,前者用于范围检索,后者用于更快速的单行直等查询. 最近频繁听到LSM,一探究竟,在此记录. 非常适用于写多读少的场景 此前看过操作系统的文件系统, 磁盘的顺序读写和随机读写,差了三个数量级. 对于Mysql的Innodb存储引擎, 对数据读取,做了比较好的优化.但写入操作的效率一直饱受诟病(关系型数据库的通病). 查找primary-key的过程很高效，但是调整B+树的磁盘IO开销却很大，因此关系型数据库mysql的写效率一致饱受诟病。那有没有一种替代B+树的数据组织模型，在不太影响读效率的前提下，提高数据的写效率（随机写-&gt;顺序写） 参考: 关于LSM树: 浅析LSM存储模型 在LSM里面，我们把内存里的二叉树称为memtable。 布隆过滤器的特点是，它可能会把一个不存在的key判定为存在；但是它绝不会把一个存在的key判定为不存在。这是可以接受的，因为对于极少数误判为存在的key，只是多几次搜索而已，只要不会将存在的key误判为不存在就行。而且它带来的好处是显而易见的：可以节省大量的对不存在的key的搜索时间。 如果把key作为搜寻目标的是,那布隆过滤器的特点就是”宁肯误杀,绝不漏过” LSM存储引擎基本原理 数据存储检索之B+树和LSM-Tree LSM-Tree,即日志结构合并树（ Log-Structured Merge-Tree） 看图轻松理解数据结构与算法系列(NoSQL存储-LSM树) 有道云笔记-lsm LSM树由来、设计思想以及应用到HBase的索引 关于B+树: B-Tree和B+Tree 数据结构: B-Tree 简介及插入 BTree和B+Tree详解 什么是B-Tree 论文: The Log-Structured Merge-Tree (LSM-Tree)","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"哈希函数族谱","date":"2019-09-20T13:02:36.000Z","path":"2019/09/20/哈希函数族谱/","text":"https://halfrost.com/go_map_chapter_one/ https://blog.cyeam.com/hash/2018/05/28/hash-method DJB，也称Times33 Times33 DJB Hash 算法 FNV 这个算法的厉害之处在于他可以保存状态。比如有个字符串ab，它的哈希值是aE+b=HashAB，如果计算bc的哈希值，可以利用第一次计算的结果(HashAB-aE)*E+c=HashBC。这么一个转换例子里是两个字符效果不明显，如果当前串是100个字符，后移一位的哈希算法性能就会快很多。 https://blog.cyeam.com/hash/2014/07/28/fnv_md5","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"记一次面试","date":"2019-09-13T01:23:19.000Z","path":"2019/09/13/记一次面试/","text":"第一面,怎么样判断一个数是否为偶数;先是要求代码行数尽可能少;接着要求性能最高123456789101112131415161718192021package mainimport ( \"fmt\" \"strconv\")func main()&#123; fmt.Printf(\"传入的值是否为奇数:%t\\n\",Judge_is_even(7))&#125;func Judge_is_even(num int) bool &#123; //fmt.Println(num % 2) rs, _ := strconv.ParseBool(strconv.Itoa(num % 2)) return rs&#125; num % 2,值为0时即无余数,为偶数;值为1时即余1,为奇数; Go中泛int型无法直接转换为bool类型,需要先转成string..再由string转为bool 要求性能尽可能高: 考虑本质,用位运算. 一个整数,无论占1个Byte还是2个或4个,即无论能表征2的8次方多的整数,亦或是2的16次方或2的32次方多,但在二进制转十进制中,其最后一个坑位都是X*2的0次方即X(X为0或1),而其上面几位为0或1乘以2的1-n次方,必为偶数,故而最后一位X为0或1,即决定了整个整数的奇偶:如果为0,最后一位值为0*2的0次方=0*1=0,为偶数;如果为1,则为1*1=1,为奇数; “计算机中的数字通常用二进制补码表示—— 如果为正数，补码与原码相同，直接看最后一位（因为数字1的前面N位均为0，跟它做与运算，前面肯定为0），奇数为1，偶数为0，与1相与，结果不变。 如果为负数，补码转原码：保持符号位不动，其它各位取反+1，即为负数的绝对值原码全部取反+1。还是看最后1位，先取反，再+1，结果还是和原来相同。进行与运算时还是原来的末位，所以用跟1做与运算还是保持原来的结果。” 奇数的二进制数的最后一位永远是 1，与 1 按位且只会得到 1，偶数相反。 12345678910111213141516171819package mainimport ( \"fmt\" \"strconv\")func main() &#123; fmt.Printf(\"传入的值是否为奇数:%t\\n\", Judge_is_even(81))&#125;func Judge_is_even(num int) bool &#123; rs, _ := strconv.ParseBool(strconv.Itoa(num &amp; 1)) return rs&#125; 可参考 ###","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go异常处理机制panic和recover","date":"2019-09-12T04:02:43.000Z","path":"2019/09/12/Go异常处理机制panic和recover/","text":"有关defer,参见Golang中的defer recover 使用panic抛出异常后, 将立即停止当前函数的执行并运行所有被defer的函数，然后将panic抛向上一层，直至程序crash。但是也可以使用被defer的recover函数来捕获异常阻止程序的崩溃，recover只有被defer后才是有意义的。 12345678910func main() &#123; print(123) print(456) panic(\"throw an error\") print(678) //IDE会有提示: Unreachable code&#125; 结果: 12345123456panic: throw an errorgoroutine 1 [running]:main.main() /Users/shuangcui/explore/panicandrecover.go:31 +0x67 使用recover()捕获异常:12345678910111213141516func main() &#123; print(123) defer func() &#123; if err := recover(); err != nil &#123; print(\"recover it\") &#125; &#125;() print(456) panic(\"throw an error\") print(678) //IDE会有提示: Unreachable code&#125; 结果为: 1123456recover it 如果有两个recover,则捕获异常的是后一个 12345678910111213141516171819202122func main() &#123; print(123) defer func() &#123; if err := recover(); err != nil &#123; print(\"recover it\") &#125; &#125;() defer func() &#123; if err := recover(); err != nil &#123; print(\"复原!\") &#125; &#125;() print(456) panic(\"throw an error\") print(678) //IDE会有提示: Unreachable code&#125; 结果为:1123456复原! panic之后的任何代码都不会继续执行 前提是panic不在if里面 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"func main() &#123; defer_call() fmt.Println(\"333 Helloworld\")&#125;func defer_call() &#123; defer func() &#123; fmt.Println(\"11111\") &#125;() defer func() &#123; fmt.Println(\"22222\") &#125;() defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(\"Recover from r : \", r) &#125; &#125;() defer func() &#123; fmt.Println(\"33333\") &#125;() fmt.Println(\"111 Helloworld\") panic(\"Panic 1!\") //使用panic抛出异常后, 将立即停止当前函数的执行并运行所有被defer的函数，然后将panic抛向上一层, 直至程序crash //但是也可以使用被defer的recover函数来捕获异常阻止程序的崩溃，recover只有被defer后才是有意义的。 panic(\"Panic 2!\") //panic1之后的panic2没有任何机会会被执行, panic2之后的任何代码更没有任何机会被执行 fmt.Println(\"222 Helloworld\")&#125; 输出为: 123456111 Helloworld33333Recover from r : Panic 1!2222211111333 Helloworld 对于goroutine中的panic,协程外面的recover是无法恢复的,goroutine中的recover,同样无法恢复协程外的panic 但协程中的recover可以恢复协程中的panic 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"time\")func main() &#123; go func() &#123; defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(\"recover err:\", err) &#125; &#125;() panic(\"里面出错了\") &#125;() //panic(\"外面出错了\") time.Sleep(1 * time.Second)&#125; 输出为： recover err 里面出错了 主方法中的recover,也可以恢复子方法里的panic 但如果go subfunc(),则同样无法捕获subfunc中的异常 123456789101112131415161718192021222324func main() &#123; fmt.Println(123) defer fmt.Println(999) defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(\"恢复异常:\",err) &#125; &#125;() subfunc()&#125;func subfunc() &#123; defer fmt.Println(888) panic(\"出现了bug\") defer fmt.Println(456)&#125; 结果为: 1234123888恢复异常: 出现了bug999 因为panic发生的时候，panic函数后面的语句都不会执行了，所以recover函数不能放在panic语句后面执行，而要放在defer函数中执行。 使用 panic 抛出异常后，函数执行将从调用 panic 的地方停止，如果函数内有 defer 调用，则执行 defer 后边的函数调用，如果 defer 调用的函数中没有捕获异常信息，这个异常会沿着函数调用栈往上传递，直到 main 函数仍然没有捕获异常，将会导致程序异常退出 如何区别使用 panic 和 error 两种方式？ 惯例是：导致关键流程出现不可修复性错误的使用 panic ，其他使用 error 。 panic 和 recover 的组合有如下特性： 有 panic 没 recover ，程序宕机。 有 panic 也有 recover ，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。 拓展&amp;参考: golang panic和recover 实现原理 Go 学习笔记（19）— 函数（05）[如何触发 panic、触发 panic 延迟执行、panic 和 recover 的关系] Go 语言踩坑记——panic 与 recover","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"把所有质数从小到大排列起来，前1009个质数的乘积与第2019个质数相比，哪个大？","date":"2019-09-09T14:43:24.000Z","path":"2019/09/09/把所有质数从小到大排列起来，前1009个质数的乘积与第2019个质数相比，哪个大？/","text":"把所有质数从小到大排列起来，前1009个质数的乘积与第2019个质数相比，哪个大？ 据说,华罗庚的解法相当巧妙~ 先不去揣测大师的解法,使用暴力解法先算一下.根据之前这篇相亲帖?诈骗帖?不,其实是招聘帖,稍作修改,不难得到前1009个质数及第2019个质数. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"func main() &#123; var sli []int for i := 2; i &lt;= 1000000; i++ &#123; for n := 2; n &lt;= i; n++ &#123; // 当走到最后n等于i 了，则说明下面的i%n==0 &amp;&amp; n &lt; i 始终没有成立。说是这个数是个质数。 if n == i &#123; sli = append(sli, i) &#125; // 当满足这个条件的时候就终止里面的循环，不用继续往下走了,因为它已经不是一个质数了。 if i%n == 0 &amp;&amp; n &lt; i &#123; break &#125; &#125; if len(sli) == 2019 &#123; fmt.Println(\"第2019个质数为:\", i) break &#125; &#125; fmt.Println(len(sli)) // fmt.Println(sli) product := 1 i := 0 for i = 0; i &lt; 1009; i++ &#123; product *= sli[i] &#125; fmt.Println(i) fmt.Println(\"前1009个质数之积是:\", product)&#125; 输出为: 1234第2019个质数为: 1756920191009前1009个质数之积是: 6557633650925796802 这个问题挺神奇的。前1009个质数之积是个巨大的数字，即便是前1009个质数之和，也比第2019个质数大得多。 所以这个问题大概专门针对猜题党。以为这样的题设，答案一定是乍看之下不可能的那个。但是这么一试，立马显影。 至于大师的解法,我想即便有讨巧的办法，这么巨大的差距得出正确结果也没啥意思。应该找两个极其相近的点，如有无可能，前n个质数之和与第n+1个质数相差在10以为，甚至有无可能相等。这样题目就得到了升华~","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Rust的所有权与生命周期","date":"2019-09-01T15:43:46.000Z","path":"2019/09/01/Rust的所有权与生命周期/","text":"想要改变世界的 Rust 语言 Rust 学习笔记之内存管理与生命周期 很难编写内存安全的代码 很难编写线程安全的代码 Rust 中默认是是移动语义。C++ 默认则是 Copy语义，直到 C++ 11 才引入 Move 移义。复制语义意味着得到是值的副本，两个变量之间其实并没有联系。至于移动语义，并不进行拷贝，而是进行了所有权的转移。Rust 由于它的类型系统是仿射类型系统，默认具有移动语义。仿射类型系统的一个突出的特点就是值或者资源只能用一次。 如果 Rust 只有移动语义，有时就有一定的局限性。因此，Rust 提供了 Copy trait 来实现 Copy 语义。————————————————版权声明：本文为CSDN博主「谷雨の梦」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/guyu2019/article/details/113749257 Rust 借鉴了很多语言，比如Cyclone（一种安全的C语言方言）的基于区域的内存管理模型；C++ 的RAII 原理；Haskell 的类型系统、错误处理类型、typeclasses等等。Rust 有非常小的 runtime，不需要垃圾回收，默认情况下是在栈上进行分类内存，而不是堆上。Rust 的编译器 rustc，一开始使用 Ocaml （一种函数式语言）编写，后来在2011年 Rust 实现了自举。 ————————————————版权声明：本文为CSDN博主「谷雨の梦」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/guyu2019/article/details/105132774 Rust 还有一个静态的生命周期，使用 ‘static 表示，Rust 中所有的字符串文本都是具有 static 的生命周期长度，意味着在程序的整个时间内都持续有效。 张汉东老师在 三万字 | 2021 年 Rust 行业调研报告中， 有Go基础：Go语言开发者比较容易理解Rust的类型和trait抽象模式，但Go也是GC语言，所以所有权机制和函数式语言特性是他们的学习重点。 1、Rust所有权机制，包括所有权的语义，生命周期和借用检查所有权机制是Rust语言最核心的特性，它保证了在没有垃圾回收机制下的内存安全，所以对于习惯了GC的开发者，理解Rust的所有权是最关键的一环，切记这三点：Rust中的每一个值都有一个被称为其所有者 (owner)的变量。值有且只有一个所有者。当所有者（变量）离开作用域，这个值将被丢弃。这其中又涉及到生命周期和借用检查等概念，是相对比较难啃的一块硬骨头。 https://www.bilibili.com/video/BV1564y1177A?t=2333 编程语言的变革者 Ada语言，当时很先进，但没有流行起来 近些年来，所以编程语言思想的集大成者 汲取百家之长 编译期就能检测出大多数问题，而无需等到运行时才发现 锈菌，生命了顽强，5种孢子 Robust+Trust=Rust 设计Rust playground 悬垂指针(野指针)，Use after free，Double free， 目前内存三大问题 RAII(资源获取即初始化)，C缺少这种机制，C++有 Rust将堆上的数据视为资源，每个资源都只能拥有唯一的所有者 (解决了Double free问题) 能够从资源的所有者处借用资源 (只有使用权，没有所有权) 当资源被其他代码借用时，资源的所有者不可以释放资源或修改资源 (第2点和第3点结合，一定程度保证了不会有悬垂指针的问题，即指针不会指向无效区域) （整数比较特殊） 借用规则： 可变借用&amp;mut 和只读(共享)借用&amp; （类似mysql的共享锁和排它锁） - 彻底解决了悬垂指针的问题 - 可变借用 &amp;mut：我能拿到你的指针，而且可以通过你的指针进行数据的修改. （去掉了Aliasing，保留了Mutation） 可变性： 生命周期即 变量作用域的长度 和大多数语言不一样… 数据构建和析构的顺序 如果在同一样中声明两个变量，那它们的声明周期是一样的。但如果之间存在依赖关系，编译器会报错 拒绝迭代器失效 其实是一种误报 解决并发安全问题借用 + 生命周期 = 痛苦之源一个关于rust生命周期的问题分析 借用 + 生命周期 保证了程序不会有内存问题~ 泛型与TraitTrait的作用 接口抽象(类似Go的interface) 泛型参数约束 (传入了泛型，必须具有xx特征，起到泛型参数约束的效果。) 类型标签(Copy,Clone) (不关心具体类型，只要事现这个特征就行了~ 即鸭子类型) 抽象类型 数据竞争： 线程安全的一生之敌 闭包，静态生命周期： Unsafe 所有权：Rust 语言内存安全机制Rust 的设计深深地吸取了关于安全系统编程的学术研究的精髓。特别是，与其他主流语言相比，Rust 设计的最大特色在于采用了所有权类型系统（在学术文献中通常称为仿射或子结构类型系统36[10]）。所有权机制，就是Rust 语言借助类型系统，承载其“内存安全”的思想，表达出来的安全编程语义和模型。所有权机制要解决的内存不安全问题包括：引用空指针。使用未初始化内存。释放后使用，也就是使用悬垂指针。缓冲区溢出，比如数组越界。非法释放已经释放过的指针或未分配的指针，也就是重复释放。注意，内存泄露不属于内存安全问题范畴，所以 Rust 也不解决内存泄露问题。为了保证内存安全，Rust 语言建立了严格的安全内存管理模型：所有权系统。每个被分配的内存都有一个独占其所有权的指针。只有当该指针被销毁时，其对应的内存才能随之被释放。借用和生命周期。每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。如果是借用，则可以通过标记生命周期参数供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。其中所有权系统还包括了从现代 C++ 那里借鉴的 RAII 机制，这是 Rust 无 GC 但是可以安全管理内存的基石。建立了安全内存管理模型之后，再用类型系统表达出来即可。Rust 从 Haskell 的类型系统那里借鉴了以下特性：没有空指针默认不可变表达式高阶函数代数数据类型模式匹配泛型trait 和关联类型本地类型推导为了实现内存安全，Rust 还具备以下独有的特性：仿射类型（Affine Type），该类型用来表达 Rust 所有权中的 Move 语义。借用、生命周期。借助类型系统的强大，Rust 编译器可以在编译期对类型进行检查，看其是否满足安全内存模型，在编译期就能发现内存不安全问题，有效地阻止未定义行为的发生。内存安全的 Bug 和并发安全的 Bug 产生的内在原因是相同的，都是因为内存的不正当访问而造成的。同样，利用装载了所有权的强大类型系统，Rust 还解决了并发安全的问题。Rust 编译器会通过静态检查分析，在编译期就检查出多线程并发代码中所有的数据竞争问题。","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Golang中的defer","date":"2019-08-24T13:14:00.000Z","path":"2019/08/24/Golang中的defer/","text":"面试常问之defer()的执行次序 情形1 12345678910111213141516171819202122232425package mainfunc main() &#123; defer print(123) defer_call() defer print(789) //panic之后的代码不会被执行 print(\"不会执行到这里\")&#125;func defer_call() &#123; defer func() &#123; print(\"打印前\") &#125;() defer func() &#123; print(\"打印中\") &#125;() defer print(\"打印后\") panic(\"触发异常\") defer print(666) //IDE会有提示: Unreachable code &#125; 结果为: 1234567打印后打印中打印前123panic: 触发异常goroutine 1 [running]:main.defer_call() /Users/shuangcui/explore/panicandrecover.go:19 +0xe5main.main() /Users/shuangcui/explore/panicandrecover.go:6 +0x51 可见: panic之后的defer()不会被执行 panic之前的defer(),按照先进后出的次序执行,最后输出panic信息 (defer机制底层,是用链表实现的一个栈) 再如: 12345678910111213141516171819202122func main() &#123; fmt.Println(123) defer fmt.Println(999) subfunc()&#125;func subfunc() &#123; defer fmt.Println(888) for i := 0; i &gt; 10; i++ &#123; fmt.Println(\"当前i为:\", i) panic(\"have a bug\") &#125; defer fmt.Println(456)&#125; 结果为: 1234123456888999 defer会延迟到当前函数执行 return 命令前被执行, 多个defer之间按LIFO先进后出顺序执行 情形2 (在defer内打印defer之外的主方法里操作的变量) 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"func main() &#123; foo()&#125;func foo() &#123; i := 0 defer func() &#123; //i-- fmt.Println(\"第一个defer\", i) &#125;() i++ fmt.Println(\"+1后的i：\", i) defer func() &#123; //i-- fmt.Println(\"第二个defer\", i) &#125;() i++ fmt.Println(\"再+1后的i：\", i) defer func() &#123; //i-- fmt.Println(\"第三个defer\", i) &#125;() i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125; 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 669第二个defer 669第一个defer 669 情形3 (在defer内外操作同一变量) 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"func main() &#123; foo()&#125;func foo() &#123; i := 0 defer func() &#123; i-- fmt.Println(\"第一个defer\", i) &#125;() i++ fmt.Println(\"+1后的i：\", i) defer func() &#123; i-- fmt.Println(\"第二个defer\", i) &#125;() i++ fmt.Println(\"再+1后的i：\", i) defer func() &#123; i-- fmt.Println(\"第三个defer\", i) &#125;() i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125; 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 668第二个defer 667第一个defer 666 情形4! (发生了参数传递!---传递参数给defer后面的函数, defer内外同时操作该参数) 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"func main() &#123; foo2()&#125;func foo2() &#123; i := 0 defer func(k int) &#123; //k-- fmt.Println(\"第一个defer\", k) &#125;(i) i++ fmt.Println(\"+1后的i：\", i) defer func(k int) &#123; //k-- fmt.Println(\"第二个defer\", k) &#125;(i) i++ fmt.Println(\"再+1后的i：\", i) defer func(k int) &#123; //k-- fmt.Println(\"第三个defer\", k) &#125;(i) i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125; 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 2第二个defer 1第一个defer 0 如果取消三处k--的注释, 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 1第二个defer 0第一个defer -1 等同于: 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport \"fmt\"func main() &#123; foo3()&#125;func foo3() &#123; i := 0 defer f1(i) i++ fmt.Println(\"+1后的i：\", i) defer f2(i) i++ fmt.Println(\"再+1后的i：\", i) defer f3(i) i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125;func f1(k int) &#123; k-- fmt.Println(\"第一个defer\", k)&#125;func f2(k int) &#123; k-- fmt.Println(\"第二个defer\", k)&#125;func f3(k int) &#123; k-- fmt.Println(\"第三个defer\", k)&#125; defer指定的函数的参数在 defer 时确定，更深层次的原因是Go语言都是值传递。 情形5! (传递指针参数!---传递参数给defer后面的函数, defer内外同时操作该参数) 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"func main() &#123; foo5()&#125;func foo5() &#123; i := 0 defer func(k *int) &#123; fmt.Println(\"第一个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"+1后的i：\", i) defer func(k *int) &#123; fmt.Println(\"第二个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"再+1后的i：\", i) defer func(k *int) &#123; fmt.Println(\"第三个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125; 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 669第二个defer 669第一个defer 669 作如下修改: 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"func main() &#123; foo5()&#125;func foo5() &#123; i := 0 defer func(k *int) &#123; (*k)-- fmt.Println(\"第一个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"+1后的i：\", i) defer func(k *int) &#123; (*k)-- fmt.Println(\"第二个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"再+1后的i：\", i) defer func(k *int) &#123; (*k)-- fmt.Println(\"第三个defer\", *k) &#125;(&amp;i) i++ fmt.Println(\"再再+1后的i：\", i) i = i + 666 fmt.Println(\"+666后的i为:\", i)&#125; 输出为: 1234567+1后的i： 1再+1后的i： 2再再+1后的i： 3+666后的i为: 669第三个defer 668第二个defer 667第一个defer 666 总结一下即 如果传参进defer后面的函数(无论是闭包(i)方式还是字方法f(i)方式,或是直接跟如fmt.Println(i)),defer回溯时均以以当时传参时i的值去计算 反之,defer回溯时,以最后i的值带入计算;(参考下面的例子). 参考: Go面试题答案与解析 几种写法之间的归类与区别 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; rs := foo6() fmt.Println(\"in main func:\", rs)&#125;func foo6() int &#123; i := 0 defer fmt.Println(\"in defer :\", i) //defer func() &#123; // fmt.Println(\"in defer :\", i) //&#125;() i = 1000 fmt.Println(\"in foo:\", i) return i+24&#125; 输出为: 123in foo: 1000in defer : 0in main func: 1024 如果改为: 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; rs := foo6() fmt.Println(\"in main func:\", rs)&#125;func foo6() int &#123; i := 0 //defer fmt.Println(\"in defer :\", i) defer func() &#123; fmt.Println(\"in defer :\", i) &#125;() i = 1000 fmt.Println(\"in foo:\", i) return i+24&#125; 输出为: 123in foo: 1000in defer : 1000in main func: 1024 也可见, 1defer fmt.Println(\"in defer :\", i) 相当于 123defer func(k int) &#123; fmt.Println(k) &#125;(i) 或 123func f(k int)&#123; fmt.Println(k)&#125; 这时的参数,都是传递时的值 而如 123defer func() &#123; fmt.Println(\"in defer :\", i) &#125;() 这时的参数,为最后return之前那一刻的值 defer会影响返回值吗? 函数的return value 不是原子操作, 在编译器中实际会被分解为两部分：返回值赋值 和 return 。而defer刚好被插入到末尾的return前执行(即defer介于二者之间)。故可以在defer函数中修改返回值 1234567891011121314151617181920212223package mainimport ( \"fmt\")func main() &#123; fmt.Println(doubleScore(0)) //0 fmt.Println(doubleScore(20.0)) //40 fmt.Println(doubleScore(50.0)) //50&#125;func doubleScore(source float32) (rs float32) &#123; defer func() &#123; if rs &lt; 1 || rs &gt;= 100 &#123; //将影响返回值 rs = source &#125; &#125;() rs = source * 2 return //或者 //return source * 2&#125; 输出为:12304050 再如: 12345678910111213141516func main() &#123; fmt.Println(\"foo return :\", foo2())&#125;func foo() map[string]string &#123; m := map[string]string&#123;&#125; defer func() &#123; m[\"a\"] = \"b\" &#125;() return m&#125; 输出为: 1foo return : map[a:b] 又如: 123456789101112131415161718package mainimport \"fmt\"func main() &#123; fmt.Println(\"foo return :\", foo())&#125;func foo() int &#123; i := 0 defer func() &#123; i = 10086 &#125;() return i + 5&#125; 输出为: 1foo return : 5 若作如下修改: 123456789func foo() (i int) &#123; i = 0 defer func() &#123; i = 10086 &#125;() return i + 5&#125; 则返回为: 1foo return : 10086 return之后的语句先执行，defer后的语句后执行 将return value拆解为两步: 确定value值,然后return..即如果return 后面是个方法或者复杂表达式,且有某个值i,会先计算.完成后defer再执行,如果defer里面也有对i的改动,是可以影响返回值的 (给函数返回值申明变量名, 这时, 变量的内存空间空间是在函数执行前就开辟出来的，且该变量的作用域为整个函数,return时只是返回这个变量的内存空间的内容，因此defer能够改变返回值) defer不影响返回值，除非是map、slice和chan这三种引用类型，或者返回值定义了变量名 参考: Golang研学：如何掌握并用好defer–存疑(“引用传递”那里明显错误) 权威参考: Golang中的Defer必掌握的7知识点 Go语言,C语言,都是值拷贝语言,当返回一个变量时,如return i,返回值是没有名称的(匿名的),不是把i返回给上层(方法/函数),而是把i的值返回给上层的一个内存. (上层调用方(如main)得到的这个变量(即子方法的返回值)的内存块,和子方法的这个i的内存,不是一个…所以经过值拷贝后,main里得到的值不是i本身.) 当return时,上层会拷贝一份i,存在内存块里(如记为变量p),main里就得到了p里的值..然后子方法触发defer,只会修改局部变量i,而不会影响p, 进而也不会影响main里得到的值 而如果指定了返回值的名称如t,则上层存储变量值的内存p,始终会与t的值一致.进而就可以修改 而map/slice/chan为引用类型,即返回的是一个指向内存地址的指针,故而:复制了一份返回值的地址---触发了defer,修改了返回值---main中根据返回值地址得到的值,也会发生改变 特别感谢刘丹冰Aceld大神的不吝指点与赐教 关于”值传递和引用传递”,可参考: Java 到底是值传递还是引用传递？ C++ 值传递、指针传递、引用传递详解 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 更多扩展: 使用 defer 还是不使用 defer? 最新版本对此做了优化","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Mac安装配置rz、sz","date":"2019-08-18T13:14:12.000Z","path":"2019/08/18/Mac安装配置rz、sz/","text":"该篇在Mac使用sz/rz进行了部分优化,本质大同小异~ 下载 iTerm2 下载 lrzsz 12345brew install lrzszln -s /usr/local/Cellar/lrzsz/0.12.20_1/bin/szln -s /usr/local/Cellar/lrzsz/0.12.20_1/bin/rz 下载并安装 automatic zmoderm for iTerm2 123456789101112131415161718cd /usr/local/binvim iterm2-recv-zmodem.shvim iterm2-send-zmodem.sh将 https://gitee.com/cuishuang/box/blob/master/rz-sz/iterm2-recv-zmodem.sh 以及https://gitee.com/cuishuang/box/blob/master/rz-sz/iterm2-send-zmodem.sh中的内容,复制到以上两个.sh文件中sudo chmod 777 /usr/local/bin/iterm2-* 添加iTerm2 trigger 打开 iTerm2 –&gt; Profiles –&gt; Open Profiles –&gt; Edit Profiles –&gt; Advanced –&gt; Edit Trigger (可在Advanced页面搜索Edit Trigger) 进行如下配置: | Regular expression | Action | Parameters | | ---- | ---- | -----| | `\\*\\*B0100` | Run Silent Coprocess | /usr/local/bin/iterm2-send-zmodem.sh | | `\\*\\*B00000000000000` | Run Silent Coprocess | /usr/local/bin/iterm2-recv-zmodem.sh| 使用 rz为received,运行该命令会弹出一个文件选择窗口,从本地选择文件上传到远程机器(用于在远程机器上,从本机接受什么文件) sz为 send, 将选定的文件由远程机器发送（send）到本地机器 &lt;img src=&quot;Mac安装配置rz、sz/3.png&quot; width = 100% height = 50% /&gt; &lt;br&gt; &lt;img src=&quot;Mac安装配置rz、sz/4.png&quot; width = 100% height = 50% /&gt;","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Mac使用sz/rz","date":"2019-08-17T10:19:11.000Z","path":"2019/08/17/Mac使用sz-rz/","text":"从使用体验上说,sz/rz要比scp要好得多.但Mac上使用这两个命令需要进行相应配置. sz：将选定的文件发送（send）到本地机器rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器 下载安装lrzsz 1brew install lrzsz 注意设置软链接时,要和当前brew安装的sz/rz的版本一致 12ln -s /usr/local/Cellar/lrzsz/你所安装的版本/bin/szln -s /usr/local/Cellar/lrzsz/你所安装的版本/bin/rz 注意： 新版本homebrew的安装路径为/opt/homebrew/Cellar/,不再是/usr/local/Cellar/,以上目录需相应修改如下： 12ln -s /opt/homebrew/Cellar/lrzsz/你所安装的版本/bin/szln -s /opt/homebrew/Cellar/lrzsz/你所安装的版本/bin/rz 下载并安装automatic zmoderm for iTerm2配置automatic zmoderm for iTerm2 cd /usr/local/bin 新建两个脚本,iterm2-recv-zmodem.sh和iterm2-send-zmodem.sh 内容如下: iterm2-recv-zmodem.sh: 12345678910111213141516171819202122232425#!/bin/bash# 这个脚本来自 github，删掉了一些 ** 言论。osascript -e 'tell application \"iTerm2\" to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = \"iTerm\" ]]; then FILE=$(osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\\"\\\")\")else FILE=$(osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\\"\\\")\")fiif [[ $FILE = \"\" ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse cd \"$FILE\" /usr/local/bin/rz -E -e -b --bufsize 4096 sleep 1 echo echo echo \\# Sent \\-\\&gt; $FILEfi iterm2-send-zmodem.sh: 12345678910111213141516171819202122#!/bin/bash# 这个脚本来自 github，删掉了一些 ** 言论。osascript -e 'tell application \"iTerm2\" to version' &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTermif [[ $NAME = \"iTerm\" ]]; then FILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\\"\\\")\"`else FILE=`osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\\\"\\\")\"`fiif [[ $FILE = \"\" ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transferelse /usr/local/bin/sz \"$FILE\" -e -b sleep 1 echo echo \\# Received $FILEfi 然后执行 sudo chmod 777 /usr/local/bin/iterm2-* 添加iTerm2 trigger 打开iTerms2-&gt;Preferences,搜索trigger 然后新添加两行: Regular expression Action Parameters \\*\\*B0100 Run Silent Coprocess /usr/local/bin/iterm2-send-zmodem.sh \\*\\*B00000000000000 Run Silent Coprocess /usr/local/bin/iterm2-recv-zmodem.sh","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go中的“魔数”","date":"2019-08-16T12:01:15.000Z","path":"2019/08/16/Go中的“魔数”/","text":"src/math/bits.go:const SmallestNormal = 2.2250738585072014e-308 // 2**-1022 Numeric limitations src/math/cbrt.go12345678910const ( B1 = 715094163 // (682-0.03306235651)*2**20 B2 = 696219795 // (664-0.03306235651)*2**20 C = 5.42857142857142815906e-01 // 19/35 = 0x3FE15F15F15F15F1 D = -7.05306122448979611050e-01 // -864/1225 = 0xBFE691DE2532C834 E = 1.41428571428571436819e+00 // 99/70 = 0x3FF6A0EA0EA0EA0F F = 1.60714285714285720630e+00 // 45/28 = 0x3FF9B6DB6DB6DB6E G = 3.57142857142857150787e-01 // 5/14 = 0x3FD6DB6DB6DB6DB7 SmallestNormal = 2.22507385850720138309e-308 // 2**-1022 = 0x0010000000000000 ) 本地队列中的g被执行61次后，全局队列中的g得到一次被执行的机会 为什么是61？ 最早是C写的，后来改成Go https://codereview.appspot.com/10042044最原始的提交就是61检视中还讨论到了59[旺柴] Issue 10042044: code review 10042044: runtime: improve scheduler fairness (Closed) tech-talk之magicNumber-61","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"风过原野","date":"2019-08-15T14:22:22.000Z","path":"2019/08/15/风过原野/","text":"年方十余的堂弟，‌从各式各样令人窒‌息的兴趣班中难得‌脱身，打算拿出几‌日从沪来杭，探望‌他独处一城的兄长‌(的猫)。暌违许久，第一次于杭州相见。提早行动，备几支雪糕几盒‌糖果。 丝丝缕‌缕穿过旷野的风，‌只似在蒸笼里游荡‌。捺不住拆开取‌出一支，看到了熟‌悉的商标---最早相‌遇于齿颊，当是四‌年前，在五羊城C‌BD最繁华的商场‌。那时一无所有，以区域经济爱‌好者身份，孤身游‌历南隅穗鹏。 ‌在未离家乡的18‌年里，绝少会买‌雪糕。每次都是去‌卖雪糕的姥爷那里‌大飨饥肠。即便市‌面更多见的是雀巢‌梦龙蒙牛伊利，但‌在心里，最标志‌的品牌叫“美伦”‌，最好吃的雪糕叫‌“劲香豆”。 ‌低首走过桥头，‌瞥到角落尚未燃烬‌的纸钱，掏出手机‌，看了眼日历。似‌是沉思良久，又‌抬头，看到远处飘‌荡的层云。低悬着‌的似是触手‌可着‌的月，和五年‌前‌那轮一模一样。‌‌当时故人所谓暌违‌‌分离，还只从地‌理‌从空间角度。‌ ‌会在踽踽缓‌步时，‌有那么几‌个瞬间，‌想起22年前，姥‌爷用‌没被炸掉的那‌只‌手抱起，朝院‌‌子里的梧桐树磕落‌‌鞋底尘土，放到‌冰‌糕箱里，骑车‌穿过‌一条铁路和‌国道，‌满足我几‌分钟看新‌家有无‌贴上瓷砖的‌心愿‌。想起姥娘风‌急‌火燎，颤颤巍巍‌‌踩在路上如鼓点密‌‌集的小脚，被央‌求一起去大集‌买小‌马玩偶。。‌想来‌温馨如此‌，嘴角弯‌弯翘起‌。不多时脸‌颊漫‌涣，舌尖感到‌浓‌浓咸意，天气很‌‌闷，不知道是汗水‌‌还是泪水。 ‌夜‌幕漆黑，只有‌知了‌不知疲倦地‌再叫。‌摘下眼‌镜，抹了‌把脸俄‌又戴上，没‌有人‌知晓。 他过得‌很好，每天都充实‌，丰富多彩，他对‌未来充满希望。他‌极少再有大段时间‌用于漂泊流浪，在‌距家1600里外‌的南方某城落户安‌居。但这些，却都‌不能和你们诉说。‌ 60年后，青‌年的旅途也将近尾‌声，他会像那曲&lt;‌Dream It‌ Possibl‌e&gt;，去经历，去‌感悟，去跌倒，去‌爬起，去找寻，去‌相爱，去穷尽余生‌不懈奋斗。他知道‌，这是对最疼爱他‌的逝者，最好的缅‌怀与悼念。 他‌还想把一路所见所‌闻记录在案，像自‌诩“书记员”的巴‌尔扎克。他想留下‌一幅描绘俗世众生‌的清明上河图，和刻画社‌会百态的浮世绘，‌而后欣慰闭目，赤‌裸裸再相见。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"},{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"探究Vcenter虚拟化方案中,VirtualMachine庞大结构体中各字段的含义","date":"2019-08-08T08:27:50.000Z","path":"2019/08/08/探究Vcenter虚拟化方案中-VirtualMachine庞大结构体中各字段的含义/","text":"SDK中mo.VirtualMachine结构体定义如下: 123456789101112131415161718192021type VirtualMachine struct &#123; ManagedEntity Capability types.VirtualMachineCapability `mo:\"capability\"` Config *types.VirtualMachineConfigInfo `mo:\"config\"` Layout *types.VirtualMachineFileLayout `mo:\"layout\"` LayoutEx *types.VirtualMachineFileLayoutEx `mo:\"layoutEx\"` Storage *types.VirtualMachineStorageInfo `mo:\"storage\"` EnvironmentBrowser types.ManagedObjectReference `mo:\"environmentBrowser\"` ResourcePool *types.ManagedObjectReference `mo:\"resourcePool\"` ParentVApp *types.ManagedObjectReference `mo:\"parentVApp\"` ResourceConfig *types.ResourceConfigSpec `mo:\"resourceConfig\"` Runtime types.VirtualMachineRuntimeInfo `mo:\"runtime\"` Guest *types.GuestInfo `mo:\"guest\"` Summary types.VirtualMachineSummary `mo:\"summary\"` Datastore []types.ManagedObjectReference `mo:\"datastore\"` Network []types.ManagedObjectReference `mo:\"network\"` Snapshot *types.VirtualMachineSnapshotInfo `mo:\"snapshot\"` RootSnapshot []types.ManagedObjectReference `mo:\"rootSnapshot\"` GuestHeartbeatStatus types.ManagedEntityStatus `mo:\"guestHeartbeatStatus\"`&#125; 使用fmt.Printf(“%#v”,该结构体的实例),返回值如下: 1mo.VirtualMachine&#123;ManagedEntity:mo.ManagedEntity&#123;ExtensibleManagedObject:mo.ExtensibleManagedObject&#123;Self:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Value:[]types.BaseCustomFieldValue(nil), AvailableField:[]types.CustomFieldDef(nil)&#125;, Parent:(*types.ManagedObjectReference)(0xc0002cd240), CustomValue:[]types.BaseCustomFieldValue(nil), OverallStatus:\"green\", ConfigStatus:\"green\", ConfigIssue:[]types.BaseEvent(nil), EffectiveRole:[]int32&#123;-2&#125;, Permission:[]types.Permission(nil), Name:\"IDCOMD.192.168.111.207.JumpServer\", DisabledMethod:[]string&#123;\"MakePrimaryVM_Task\", \"TerminateFaultTolerantVM_Task\", \"ResetVM_Task\", \"UnmountToolsInstaller\", \"MountToolsInstaller\", \"MountToolsInstallerImage\", \"RebootGuest\", \"StandbyGuest\", \"ShutdownGuest\", \"PowerOffVM_Task\", \"ExtractOvfEnvironment\", \"SuspendVM_Task\", \"AcquireMksTicket\", \"AnswerVM\", \"UpgradeVM_Task\", \"UpgradeTools_Task\", \"UpgradeToolsFromImage_Task\", \"StartRecording_Task\", \"StopRecording_Task\", \"StartReplaying_Task\", \"StopReplaying_Task\", \"TurnOffFaultToleranceForVM_Task\", \"MakePrimaryVM_Task\", \"TerminateFaultTolerantVM_Task\", \"DisableSecondaryVM_Task\", \"EnableSecondaryVM_Task\", \"CreateSecondaryVM_Task\", \"CreateSecondaryVMEx_Task\", \"StopRecording_Task\", \"StopReplaying_Task\", \"MarkAsVirtualMachine\"&#125;, RecentTask:[]types.ManagedObjectReference(nil), DeclaredAlarmState:[]types.AlarmState&#123;types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-10.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-10\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x20a77770, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de040), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-11.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-11\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x21124b18, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de190), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-2.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-2\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x23562868, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de2e0), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-23.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-23\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x23a273a8, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de430), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-26.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-26\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x23eebee8, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de580), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-30.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-30\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x243b0e10, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de6d0), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-49.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-49\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x251fefd0, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de820), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-50.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-50\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x254dba78, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003de970), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-51.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-51\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x257b8138, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003deac0), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-59.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-59\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x25d70eb8, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003dec10), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-6.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-6\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x2604d578, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003ded60), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-65.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-65\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x266066e0, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003deeb0), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-67.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-67\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x268e2da0, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003df000), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-7.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-7\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x26bbf460, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003df150), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;, types.AlarmState&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"alarm-95.vm-60\", Entity:types.ManagedObjectReference&#123;Type:\"VirtualMachine\", Value:\"vm-60\"&#125;, Alarm:types.ManagedObjectReference&#123;Type:\"Alarm\", Value:\"alarm-95\"&#125;, OverallStatus:\"gray\", Time:time.Time&#123;wall:0x27bf5e88, ext:63700308213, loc:(*time.Location)(nil)&#125;, Acknowledged:(*bool)(0xc0003df2a0), AcknowledgedByUser:\"\", AcknowledgedTime:(*time.Time)(nil), EventKey:0&#125;&#125;, TriggeredAlarmState:[]types.AlarmState(nil), AlarmActionsEnabled:(*bool)(0xc000544dd8), Tag:[]types.Tag(nil)&#125;, Capability:types.VirtualMachineCapability&#123;DynamicData:types.DynamicData&#123;&#125;, SnapshotOperationsSupported:true, MultipleSnapshotsSupported:true, SnapshotConfigSupported:true, PoweredOffSnapshotsSupported:true, MemorySnapshotsSupported:true, RevertToSnapshotSupported:true, QuiescedSnapshotsSupported:true, DisableSnapshotsSupported:false, LockSnapshotsSupported:true, ConsolePreferencesSupported:false, CpuFeatureMaskSupported:true, S1AcpiManagementSupported:true, SettingScreenResolutionSupported:false, ToolsAutoUpdateSupported:false, VmNpivWwnSupported:true, NpivWwnOnNonRdmVmSupported:true, VmNpivWwnDisableSupported:(*bool)(0xc000026e5c), VmNpivWwnUpdateSupported:(*bool)(0xc000026e6c), SwapPlacementSupported:true, ToolsSyncTimeSupported:true, VirtualMmuUsageSupported:true, DiskSharesSupported:true, BootOptionsSupported:true, BootRetryOptionsSupported:(*bool)(0xc000026ecc), SettingVideoRamSizeSupported:true, SettingDisplayTopologySupported:(*bool)(0xc000026eec), RecordReplaySupported:(*bool)(0xc000026efd), ChangeTrackingSupported:(*bool)(0xc000026f0c), MultipleCoresPerSocketSupported:(*bool)(0xc000026f1c), HostBasedReplicationSupported:(*bool)(0xc000026f2c), GuestAutoLockSupported:(*bool)(0xc000026f3c), MemoryReservationLockSupported:(*bool)(0xc000026f4c), FeatureRequirementSupported:(*bool)(0xc000026f5c), PoweredOnMonitorTypeChangeSupported:(*bool)(0xc000026f6c), SeSparseDiskSupported:(*bool)(0xc000026f7c), NestedHVSupported:(*bool)(0xc000026f8c), VPMCSupported:(*bool)(0xc000026f9c), SecureBootSupported:(*bool)(nil), PerVmEvcSupported:(*bool)(nil), VirtualMmuUsageIgnored:(*bool)(nil), VirtualExecUsageIgnored:(*bool)(nil), DiskOnlySnapshotOnSuspendedVMSupported:(*bool)(nil)&#125;, Config:(*types.VirtualMachineConfigInfo)(0xc0005d4000), Layout:(*types.VirtualMachineFileLayout)(0xc00044b260), LayoutEx:(*types.VirtualMachineFileLayoutEx)(0xc0003b6960), Storage:(*types.VirtualMachineStorageInfo)(0xc0005d8000), EnvironmentBrowser:types.ManagedObjectReference&#123;Type:\"EnvironmentBrowser\", Value:\"envbrowser-60\"&#125;, ResourcePool:(*types.ManagedObjectReference)(0xc000534020), ParentVApp:(*types.ManagedObjectReference)(nil), ResourceConfig:(*types.ResourceConfigSpec)(0xc0001120e0), Runtime:types.VirtualMachineRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, Device:[]types.VirtualMachineDeviceRuntimeInfo&#123;types.VirtualMachineDeviceRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, RuntimeState:(*types.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState)(0xc000208c80), Key:4000&#125;, types.VirtualMachineDeviceRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, RuntimeState:(*types.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState)(0xc000208d00), Key:4001&#125;&#125;, Host:(*types.ManagedObjectReference)(0xc0004059a0), ConnectionState:\"connected\", PowerState:\"poweredOff\", FaultToleranceState:\"notConfigured\", DasVmProtection:(*types.VirtualMachineRuntimeInfoDasProtectionState)(nil), ToolsInstallerMounted:false, SuspendTime:(*time.Time)(nil), BootTime:(*time.Time)(nil), SuspendInterval:0, Question:(*types.VirtualMachineQuestionInfo)(nil), MemoryOverhead:0, MaxCpuUsage:0, MaxMemoryUsage:0, NumMksConnections:0, RecordReplayState:\"inactive\", CleanPowerOff:(*bool)(nil), NeedSecondaryReason:\"\", OnlineStandby:(*bool)(0xc0003ff04d), MinRequiredEVCModeKey:\"\", ConsolidationNeeded:(*bool)(0xc0003ff05d), OfflineFeatureRequirement:[]types.VirtualMachineFeatureRequirement&#123;types.VirtualMachineFeatureRequirement&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"cpuid.lm\", FeatureName:\"cpuid.lm\", Value:\"Bool:Min:1\"&#125;&#125;, FeatureRequirement:[]types.VirtualMachineFeatureRequirement(nil), FeatureMask:[]types.HostFeatureMask(nil), VFlashCacheAllocation:0, Paused:(*bool)(0xc0003ff120), SnapshotInBackground:(*bool)(0xc0003ff13b), QuiescedForkParent:(*bool)(nil), InstantCloneFrozen:(*bool)(nil), CryptoState:\"\"&#125;, Guest:(*types.GuestInfo)(0xc000192f00), Summary:types.VirtualMachineSummary&#123;DynamicData:types.DynamicData&#123;&#125;, Vm:(*types.ManagedObjectReference)(0xc000416500), Runtime:types.VirtualMachineRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, Device:[]types.VirtualMachineDeviceRuntimeInfo&#123;types.VirtualMachineDeviceRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, RuntimeState:(*types.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState)(0xc000208d80), Key:4000&#125;, types.VirtualMachineDeviceRuntimeInfo&#123;DynamicData:types.DynamicData&#123;&#125;, RuntimeState:(*types.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState)(0xc000208e00), Key:4001&#125;&#125;, Host:(*types.ManagedObjectReference)(0xc000416b60), ConnectionState:\"connected\", PowerState:\"poweredOff\", FaultToleranceState:\"notConfigured\", DasVmProtection:(*types.VirtualMachineRuntimeInfoDasProtectionState)(nil), ToolsInstallerMounted:false, SuspendTime:(*time.Time)(nil), BootTime:(*time.Time)(nil), SuspendInterval:0, Question:(*types.VirtualMachineQuestionInfo)(nil), MemoryOverhead:0, MaxCpuUsage:0, MaxMemoryUsage:0, NumMksConnections:0, RecordReplayState:\"inactive\", CleanPowerOff:(*bool)(nil), NeedSecondaryReason:\"\", OnlineStandby:(*bool)(0xc0003ff8bd), MinRequiredEVCModeKey:\"\", ConsolidationNeeded:(*bool)(0xc0003ff8cd), OfflineFeatureRequirement:[]types.VirtualMachineFeatureRequirement&#123;types.VirtualMachineFeatureRequirement&#123;DynamicData:types.DynamicData&#123;&#125;, Key:\"cpuid.lm\", FeatureName:\"cpuid.lm\", Value:\"Bool:Min:1\"&#125;&#125;, FeatureRequirement:[]types.VirtualMachineFeatureRequirement(nil), FeatureMask:[]types.HostFeatureMask(nil), VFlashCacheAllocation:0, Paused:(*bool)(0xc0003ff966), SnapshotInBackground:(*bool)(0xc0003ff97b), QuiescedForkParent:(*bool)(nil), InstantCloneFrozen:(*bool)(nil), CryptoState:\"\"&#125;, Guest:(*types.VirtualMachineGuestSummary)(0xc000208e80), Config:types.VirtualMachineConfigSummary&#123;DynamicData:types.DynamicData&#123;&#125;, Name:\"IDCOMD.192.168.111.207.JumpServer\", Template:false, VmPathName:\"[VOL02] IDCOMD.192.168.111.207.JumpServer/IDCOMD.192.168.111.207.JumpServer.vmx\", MemorySizeMB:8192, CpuReservation:0, MemoryReservation:0, NumCpu:12, NumEthernetCards:2, NumVirtualDisks:1, Uuid:\"420ecd79-a338-89a5-0eb8-977dd843814d\", InstanceUuid:\"500e347d-daeb-8379-9b85-af1b18d6bb2f\", GuestId:\"centos64Guest\", GuestFullName:\"CentOS 4/5/6/7 (64-bit)\", Annotation:\"\", Product:(*types.VAppProductInfo)(nil), InstallBootRequired:(*bool)(0xc0003ffcba), FtInfo:types.BaseFaultToleranceConfigInfo(nil), ManagedBy:(*types.ManagedByInfo)(nil), TpmPresent:(*bool)(nil), NumVmiopBackings:0&#125;, Storage:(*types.VirtualMachineStorageSummary)(0xc000091740), QuickStats:types.VirtualMachineQuickStats&#123;DynamicData:types.DynamicData&#123;&#125;, OverallCpuUsage:0, OverallCpuDemand:0, GuestMemoryUsage:0, HostMemoryUsage:0, GuestHeartbeatStatus:\"gray\", DistributedCpuEntitlement:0, DistributedMemoryEntitlement:0, StaticCpuEntitlement:0, StaticMemoryEntitlement:0, PrivateMemory:0, SharedMemory:0, SwappedMemory:0, BalloonedMemory:0, ConsumedOverheadMemory:0, FtLogBandwidth:-1, FtSecondaryLatency:-1, FtLatencyStatus:\"gray\", CompressedMemory:0, UptimeSeconds:0, SsdSwappedMemory:0&#125;, OverallStatus:\"green\", CustomValue:[]types.BaseCustomFieldValue(nil)&#125;, Datastore:[]types.ManagedObjectReference&#123;types.ManagedObjectReference&#123;Type:\"Datastore\", Value:\"datastore-211\"&#125;&#125;, Network:[]types.ManagedObjectReference&#123;types.ManagedObjectReference&#123;Type:\"Network\", Value:\"network-16\"&#125;&#125;, Snapshot:(*types.VirtualMachineSnapshotInfo)(nil), RootSnapshot:[]types.ManagedObjectReference(nil), GuestHeartbeatStatus:\"gray\"&#125; 这段返回值,纯字符串长度15636;如果再考虑到其中嵌套的层层结构体,完全可以堪称’庞大’. 这样的结构体嵌套格式,无法直观展示所有信息,尤其当类型为*(指针类型)时,打印出的是指针即对象变量的内存地址;这里有一种方案,即给相应的*(指针类型)字段实现String()方法,从而解决这个问题;关于String()方法,可参考之前博文 尝试进行挨个分析: ManagedEntity: “管理实体” 匿名字段123456789101112131415161718type ManagedEntity struct &#123; ExtensibleManagedObject //可扩展的管理对象 Parent *types.ManagedObjectReference `mo:\"parent\"` CustomValue []types.BaseCustomFieldValue `mo:\"customValue\"` OverallStatus types.ManagedEntityStatus `mo:\"overallStatus\"` ConfigStatus types.ManagedEntityStatus `mo:\"configStatus\"` ConfigIssue []types.BaseEvent `mo:\"configIssue\"` EffectiveRole []int32 `mo:\"effectiveRole\"` Permission []types.Permission `mo:\"permission\"` Name string `mo:\"name\"` DisabledMethod []string `mo:\"disabledMethod\"` RecentTask []types.ManagedObjectReference `mo:\"recentTask\"` DeclaredAlarmState []types.AlarmState `mo:\"declaredAlarmState\"` TriggeredAlarmState []types.AlarmState `mo:\"triggeredAlarmState\"` AlarmActionsEnabled *bool `mo:\"alarmActionsEnabled\"` Tag []types.Tag `mo:\"tag\"`&#125; 123456type ExtensibleManagedObject struct &#123; Self types.ManagedObjectReference Value []types.BaseCustomFieldValue `mo:\"value\"` AvailableField []types.CustomFieldDef `mo:\"availableField\"`&#125; 1234type ManagedObjectReference struct &#123; Type string `xml:\"type,attr\"` Value string `xml:\",chardata\"`&#125; 写到这里,发现*(指针)类型的字段非常多(上面那段已0x开头的),挨个对其实现String()方法,工作量大,且会侵入SDK的代码; 可以将原结构体转换为json格式,再利用各种在线解析json的工具,更直观和方便地进行梳理; 123b,_ := json.Marshal(该结构体的实例)fmt.Println(string(b)) 返回值为: 1&#123;\"Self\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Value\":null,\"AvailableField\":null,\"Parent\":&#123;\"Type\":\"Folder\",\"Value\":\"group-v341\"&#125;,\"CustomValue\":null,\"OverallStatus\":\"green\",\"ConfigStatus\":\"green\",\"ConfigIssue\":null,\"EffectiveRole\":[-2],\"Permission\":null,\"Name\":\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template\",\"DisabledMethod\":[\"Destroy_Task\",\"UnregisterVM\",\"UnmountToolsInstaller\",\"AnswerVM\",\"UpgradeVM_Task\",\"UpgradeTools_Task\",\"UpgradeToolsFromImage_Task\",\"TurnOffFaultToleranceForVM_Task\",\"MakePrimaryVM_Task\",\"TerminateFaultTolerantVM_Task\",\"DisableSecondaryVM_Task\",\"EnableSecondaryVM_Task\",\"CreateSecondaryVM_Task\",\"CreateSecondaryVMEx_Task\",\"StopRecording_Task\",\"StopReplaying_Task\",\"CustomizeVM_Task\",\"MarkAsTemplate\",\"ResetGuestInformation\",\"ExportVm\",\"PowerOnVM_Task\",\"MarkAsVirtualMachine\"],\"RecentTask\":null,\"DeclaredAlarmState\":[&#123;\"Key\":\"alarm-10.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-10\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.547846Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-11.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-11\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.554847Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-2.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-2\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.592849Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-23.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-23\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.597849Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-26.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-26\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.601849Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-30.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-30\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.60685Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-49.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-49\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.62285Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-50.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-50\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.625851Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-51.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-51\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.628851Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-59.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-59\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.634851Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-6.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-6\"&#125;,\"OverallStatus\":\"green\",\"Time\":\"2019-06-28T06:59:39.478Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-65.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-65\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.643852Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-67.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-67\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.646852Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-7.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-7\"&#125;,\"OverallStatus\":\"green\",\"Time\":\"2019-06-28T06:59:39.478Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;,&#123;\"Key\":\"alarm-95.vm-389\",\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Alarm\":&#123;\"Type\":\"Alarm\",\"Value\":\"alarm-95\"&#125;,\"OverallStatus\":\"gray\",\"Time\":\"2019-08-02T02:03:33.666853Z\",\"Acknowledged\":false,\"AcknowledgedByUser\":\"\",\"AcknowledgedTime\":null,\"EventKey\":0&#125;],\"TriggeredAlarmState\":null,\"AlarmActionsEnabled\":true,\"Tag\":null,\"Capability\":&#123;\"SnapshotOperationsSupported\":true,\"MultipleSnapshotsSupported\":true,\"SnapshotConfigSupported\":true,\"PoweredOffSnapshotsSupported\":true,\"MemorySnapshotsSupported\":true,\"RevertToSnapshotSupported\":true,\"QuiescedSnapshotsSupported\":true,\"DisableSnapshotsSupported\":false,\"LockSnapshotsSupported\":true,\"ConsolePreferencesSupported\":false,\"CpuFeatureMaskSupported\":true,\"S1AcpiManagementSupported\":true,\"SettingScreenResolutionSupported\":false,\"ToolsAutoUpdateSupported\":false,\"VmNpivWwnSupported\":true,\"NpivWwnOnNonRdmVmSupported\":true,\"VmNpivWwnDisableSupported\":true,\"VmNpivWwnUpdateSupported\":true,\"SwapPlacementSupported\":true,\"ToolsSyncTimeSupported\":true,\"VirtualMmuUsageSupported\":true,\"DiskSharesSupported\":true,\"BootOptionsSupported\":true,\"BootRetryOptionsSupported\":true,\"SettingVideoRamSizeSupported\":true,\"SettingDisplayTopologySupported\":false,\"RecordReplaySupported\":true,\"ChangeTrackingSupported\":true,\"MultipleCoresPerSocketSupported\":true,\"HostBasedReplicationSupported\":true,\"GuestAutoLockSupported\":true,\"MemoryReservationLockSupported\":true,\"FeatureRequirementSupported\":true,\"PoweredOnMonitorTypeChangeSupported\":true,\"SeSparseDiskSupported\":true,\"NestedHVSupported\":true,\"VPMCSupported\":true,\"SecureBootSupported\":null,\"PerVmEvcSupported\":null,\"VirtualMmuUsageIgnored\":null,\"VirtualExecUsageIgnored\":null,\"DiskOnlySnapshotOnSuspendedVMSupported\":null&#125;,\"Config\":&#123;\"ChangeVersion\":\"2019-06-28T06:58:45.542465Z\",\"Modified\":\"1970-01-01T00:00:00Z\",\"Name\":\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template\",\"GuestFullName\":\"CentOS 4/5/6/7 (64-bit)\",\"Version\":\"vmx-11\",\"Uuid\":\"42372cc9-0811-74e4-e7b6-abaa96a8ee85\",\"CreateDate\":null,\"InstanceUuid\":\"50372076-6a91-f48a-818c-867387badbdd\",\"NpivNodeWorldWideName\":null,\"NpivPortWorldWideName\":null,\"NpivWorldWideNameType\":\"\",\"NpivDesiredNodeWwns\":0,\"NpivDesiredPortWwns\":0,\"NpivTemporaryDisabled\":true,\"NpivOnNonRdmDisks\":null,\"LocationId\":\"564db8fc-fc74-7db8-122a-ace19fce3bd0\",\"Template\":false,\"GuestId\":\"centos64Guest\",\"AlternateGuestName\":\"\",\"Annotation\":\"\",\"Files\":&#123;\"VmPathName\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmx\",\"SnapshotDirectory\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/\",\"SuspendDirectory\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/\",\"LogDirectory\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/\",\"FtMetadataDirectory\":\"\"&#125;,\"Tools\":&#123;\"ToolsVersion\":2147483647,\"ToolsInstallType\":\"\",\"AfterPowerOn\":true,\"AfterResume\":true,\"BeforeGuestStandby\":true,\"BeforeGuestShutdown\":true,\"BeforeGuestReboot\":null,\"ToolsUpgradePolicy\":\"manual\",\"PendingCustomization\":\"\",\"CustomizationKeyId\":null,\"SyncTimeWithHost\":false,\"LastInstallInfo\":&#123;\"Counter\":0,\"Fault\":null&#125;&#125;,\"Flags\":&#123;\"DisableAcceleration\":false,\"EnableLogging\":true,\"UseToe\":false,\"RunWithDebugInfo\":false,\"MonitorType\":\"release\",\"HtSharing\":\"any\",\"SnapshotDisabled\":false,\"SnapshotLocked\":false,\"DiskUuidEnabled\":false,\"VirtualMmuUsage\":\"automatic\",\"VirtualExecUsage\":\"hvAuto\",\"SnapshotPowerOffBehavior\":\"powerOff\",\"RecordReplayEnabled\":false,\"FaultToleranceType\":\"unset\",\"CbrcCacheEnabled\":null,\"VvtdEnabled\":null,\"VbsEnabled\":null&#125;,\"ConsolePreferences\":null,\"DefaultPowerOps\":&#123;\"PowerOffType\":\"soft\",\"SuspendType\":\"hard\",\"ResetType\":\"soft\",\"DefaultPowerOffType\":\"soft\",\"DefaultSuspendType\":\"hard\",\"DefaultResetType\":\"soft\",\"StandbyAction\":\"powerOnSuspend\"&#125;,\"Hardware\":&#123;\"NumCPU\":4,\"NumCoresPerSocket\":2,\"MemoryMB\":4096,\"VirtualICH7MPresent\":false,\"VirtualSMCPresent\":false,\"Device\":[&#123;\"Key\":100,\"DeviceInfo\":&#123;\"Label\":\"PCI controller 0\",\"Summary\":\"PCI controller 0\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":0,\"UnitNumber\":null,\"BusNumber\":0,\"Device\":[500,12000,1000,4000]&#125;,&#123;\"Key\":200,\"DeviceInfo\":&#123;\"Label\":\"IDE 0\",\"Summary\":\"IDE 0\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":0,\"UnitNumber\":null,\"BusNumber\":0,\"Device\":null&#125;,&#123;\"Key\":201,\"DeviceInfo\":&#123;\"Label\":\"IDE 1\",\"Summary\":\"IDE 1\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":0,\"UnitNumber\":null,\"BusNumber\":1,\"Device\":[3002]&#125;,&#123;\"Key\":300,\"DeviceInfo\":&#123;\"Label\":\"PS2 controller 0\",\"Summary\":\"PS2 controller 0\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":0,\"UnitNumber\":null,\"BusNumber\":0,\"Device\":[600,700]&#125;,&#123;\"Key\":400,\"DeviceInfo\":&#123;\"Label\":\"SIO controller 0\",\"Summary\":\"SIO controller 0\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":0,\"UnitNumber\":null,\"BusNumber\":0,\"Device\":[8000]&#125;,&#123;\"Key\":500,\"DeviceInfo\":&#123;\"Label\":\"Video card \",\"Summary\":\"Video card\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":100,\"UnitNumber\":0,\"VideoRamSizeInKB\":4096,\"NumDisplays\":1,\"UseAutoDetect\":false,\"Enable3DSupport\":false,\"Use3dRenderer\":\"automatic\",\"GraphicsMemorySizeInKB\":262144&#125;,&#123;\"Key\":600,\"DeviceInfo\":&#123;\"Label\":\"Keyboard \",\"Summary\":\"Keyboard\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":300,\"UnitNumber\":0&#125;,&#123;\"Key\":700,\"DeviceInfo\":&#123;\"Label\":\"Pointing device\",\"Summary\":\"Pointing device; Device\"&#125;,\"Backing\":&#123;\"DeviceName\":\"\",\"UseAutoDetect\":false,\"HostPointingDevice\":\"autodetect\"&#125;,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":300,\"UnitNumber\":1&#125;,&#123;\"Key\":1000,\"DeviceInfo\":&#123;\"Label\":\"SCSI controller 0\",\"Summary\":\"LSI Logic\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":100,\"UnitNumber\":3,\"BusNumber\":0,\"Device\":[2000],\"HotAddRemove\":true,\"SharedBus\":\"noSharing\",\"ScsiCtlrUnitNumber\":7&#125;,&#123;\"Key\":2000,\"DeviceInfo\":&#123;\"Label\":\"Hard disk 1\",\"Summary\":\"20,971,520 KB\"&#125;,\"Backing\":&#123;\"FileName\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmdk\",\"Datastore\":&#123;\"Type\":\"Datastore\",\"Value\":\"datastore-210\"&#125;,\"BackingObjectId\":\"\",\"DiskMode\":\"persistent\",\"Split\":false,\"WriteThrough\":false,\"ThinProvisioned\":true,\"EagerlyScrub\":null,\"Uuid\":\"6000C290-ed00-a439-bd66-52afaf8bd3e7\",\"ContentId\":\"86ae82146e1dc126db60196bfffffffe\",\"ChangeId\":\"\",\"Parent\":null,\"DeltaDiskFormat\":\"\",\"DigestEnabled\":false,\"DeltaGrainSize\":0,\"DeltaDiskFormatVariant\":\"\",\"Sharing\":\"\",\"KeyId\":null&#125;,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":1000,\"UnitNumber\":0,\"CapacityInKB\":20971520,\"CapacityInBytes\":21474836480,\"Shares\":&#123;\"Shares\":1000,\"Level\":\"normal\"&#125;,\"StorageIOAllocation\":&#123;\"Limit\":-1,\"Shares\":&#123;\"Shares\":1000,\"Level\":\"normal\"&#125;,\"Reservation\":0&#125;,\"DiskObjectId\":\"59-2000\",\"VFlashCacheConfigInfo\":null,\"Iofilter\":null,\"VDiskId\":null,\"NativeUnmanagedLinkedClone\":null&#125;,&#123;\"Key\":3002,\"DeviceInfo\":&#123;\"Label\":\"CD/DVD drive 1\",\"Summary\":\"Remote device\"&#125;,\"Backing\":&#123;\"DeviceName\":\"\",\"UseAutoDetect\":false,\"Exclusive\":false&#125;,\"Connectable\":&#123;\"MigrateConnect\":\"\",\"StartConnected\":false,\"AllowGuestControl\":true,\"Connected\":true,\"Status\":\"ok\"&#125;,\"SlotInfo\":null,\"ControllerKey\":201,\"UnitNumber\":0&#125;,&#123;\"Key\":4000,\"DeviceInfo\":&#123;\"Label\":\"Network adapter 1\",\"Summary\":\"IDC-NET\"&#125;,\"Backing\":&#123;\"DeviceName\":\"IDC-NET\",\"UseAutoDetect\":false,\"Network\":&#123;\"Type\":\"Network\",\"Value\":\"network-16\"&#125;,\"InPassthroughMode\":null&#125;,\"Connectable\":&#123;\"MigrateConnect\":\"\",\"StartConnected\":true,\"AllowGuestControl\":true,\"Connected\":true,\"Status\":\"ok\"&#125;,\"SlotInfo\":null,\"ControllerKey\":100,\"UnitNumber\":7,\"AddressType\":\"assigned\",\"MacAddress\":\"00:50:56:b7:12:51\",\"WakeOnLanEnabled\":true,\"ResourceAllocation\":&#123;\"Reservation\":0,\"Share\":&#123;\"Shares\":50,\"Level\":\"normal\"&#125;,\"Limit\":-1&#125;,\"ExternalId\":\"\",\"UptCompatibilityEnabled\":null&#125;,&#123;\"Key\":8000,\"DeviceInfo\":&#123;\"Label\":\"Floppy drive 1\",\"Summary\":\"Remote\"&#125;,\"Backing\":&#123;\"DeviceName\":\"\",\"UseAutoDetect\":false&#125;,\"Connectable\":&#123;\"MigrateConnect\":\"\",\"StartConnected\":false,\"AllowGuestControl\":true,\"Connected\":false,\"Status\":\"ok\"&#125;,\"SlotInfo\":null,\"ControllerKey\":400,\"UnitNumber\":0&#125;,&#123;\"Key\":12000,\"DeviceInfo\":&#123;\"Label\":\"VMCI device\",\"Summary\":\"Device on the virtual machine PCI bus that provides support for the virtual machine communication interface\"&#125;,\"Backing\":null,\"Connectable\":null,\"SlotInfo\":null,\"ControllerKey\":100,\"UnitNumber\":17,\"Id\":-1767313787,\"AllowUnrestrictedCommunication\":false,\"FilterEnable\":true,\"FilterInfo\":null&#125;]&#125;,\"CpuAllocation\":&#123;\"Reservation\":0,\"ExpandableReservation\":false,\"Limit\":-1,\"Shares\":&#123;\"Shares\":4000,\"Level\":\"normal\"&#125;,\"OverheadLimit\":null&#125;,\"MemoryAllocation\":&#123;\"Reservation\":0,\"ExpandableReservation\":false,\"Limit\":-1,\"Shares\":&#123;\"Shares\":40960,\"Level\":\"normal\"&#125;,\"OverheadLimit\":93&#125;,\"LatencySensitivity\":&#123;\"Level\":\"normal\",\"Sensitivity\":0&#125;,\"MemoryHotAddEnabled\":false,\"CpuHotAddEnabled\":false,\"CpuHotRemoveEnabled\":false,\"HotPlugMemoryLimit\":4096,\"HotPlugMemoryIncrementSize\":0,\"CpuAffinity\":null,\"MemoryAffinity\":null,\"NetworkShaper\":null,\"ExtraConfig\":[&#123;\"Key\":\"nvram\",\"Value\":\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template.nvram\"&#125;,&#123;\"Key\":\"pciBridge0.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"svga.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"pciBridge4.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"pciBridge4.virtualDev\",\"Value\":\"pcieRootPort\"&#125;,&#123;\"Key\":\"pciBridge4.functions\",\"Value\":\"8\"&#125;,&#123;\"Key\":\"pciBridge5.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"pciBridge5.virtualDev\",\"Value\":\"pcieRootPort\"&#125;,&#123;\"Key\":\"pciBridge5.functions\",\"Value\":\"8\"&#125;,&#123;\"Key\":\"pciBridge6.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"pciBridge6.virtualDev\",\"Value\":\"pcieRootPort\"&#125;,&#123;\"Key\":\"pciBridge6.functions\",\"Value\":\"8\"&#125;,&#123;\"Key\":\"pciBridge7.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"pciBridge7.virtualDev\",\"Value\":\"pcieRootPort\"&#125;,&#123;\"Key\":\"pciBridge7.functions\",\"Value\":\"8\"&#125;,&#123;\"Key\":\"hpet0.present\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"cpuid.coresPerSocket\",\"Value\":\"2\"&#125;,&#123;\"Key\":\"ethernet0.uptCompatibility\",\"Value\":\"true\"&#125;,&#123;\"Key\":\"vmware.tools.internalversion\",\"Value\":\"2147483647\"&#125;,&#123;\"Key\":\"vmware.tools.requiredversion\",\"Value\":\"9541\"&#125;,&#123;\"Key\":\"migrate.hostLogState\",\"Value\":\"none\"&#125;,&#123;\"Key\":\"migrate.migrationId\",\"Value\":\"0\"&#125;,&#123;\"Key\":\"migrate.hostLog\",\"Value\":\"./IDCOMD_192.168.110.191_CentOS6.10.X64.Template-f0564f4b.hlog\"&#125;,&#123;\"Key\":\"ethernet0.pciSlotNumber\",\"Value\":\"160\"&#125;,&#123;\"Key\":\"monitor.phys_bits_used\",\"Value\":\"42\"&#125;,&#123;\"Key\":\"pciBridge0.pciSlotNumber\",\"Value\":\"17\"&#125;,&#123;\"Key\":\"pciBridge4.pciSlotNumber\",\"Value\":\"21\"&#125;,&#123;\"Key\":\"pciBridge5.pciSlotNumber\",\"Value\":\"22\"&#125;,&#123;\"Key\":\"pciBridge6.pciSlotNumber\",\"Value\":\"23\"&#125;,&#123;\"Key\":\"pciBridge7.pciSlotNumber\",\"Value\":\"24\"&#125;,&#123;\"Key\":\"replay.filename\",\"Value\":\"\"&#125;,&#123;\"Key\":\"replay.supported\",\"Value\":\"false\"&#125;,&#123;\"Key\":\"sched.swap.derivedName\",\"Value\":\"/vmfs/volumes/5c4ec2f8-6b4feaec-3bde-90b11c12a830/IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template-f0564f4b.vswp\"&#125;,&#123;\"Key\":\"scsi0.pciSlotNumber\",\"Value\":\"16\"&#125;,&#123;\"Key\":\"scsi0:0.redo\",\"Value\":\"\"&#125;,&#123;\"Key\":\"softPowerOff\",\"Value\":\"false\"&#125;,&#123;\"Key\":\"virtualHW.productCompatibility\",\"Value\":\"hosted\"&#125;,&#123;\"Key\":\"vmci0.pciSlotNumber\",\"Value\":\"32\"&#125;,&#123;\"Key\":\"vmotion.checkpointFBSize\",\"Value\":\"4194304\"&#125;,&#123;\"Key\":\"vmotion.checkpointSVGAPrimarySize\",\"Value\":\"4194304\"&#125;,&#123;\"Key\":\"svga.guestBackedPrimaryAware\",\"Value\":\"true\"&#125;],\"CpuFeatureMask\":null,\"DatastoreUrl\":[&#123;\"Name\":\"VOL01\",\"Url\":\"/vmfs/volumes/5c4ec2f8-6b4feaec-3bde-90b11c12a830\"&#125;],\"SwapPlacement\":\"inherit\",\"BootOptions\":&#123;\"BootDelay\":0,\"EnterBIOSSetup\":false,\"EfiSecureBootEnabled\":null,\"BootRetryEnabled\":false,\"BootRetryDelay\":10000,\"BootOrder\":null,\"NetworkBootProtocol\":\"\"&#125;,\"FtInfo\":null,\"RepConfig\":null,\"VAppConfig\":null,\"VAssertsEnabled\":false,\"ChangeTrackingEnabled\":false,\"Firmware\":\"bios\",\"MaxMksConnections\":40,\"GuestAutoLockEnabled\":false,\"ManagedBy\":null,\"MemoryReservationLockedToMax\":false,\"InitialOverhead\":null,\"NestedHVEnabled\":false,\"VPMCEnabled\":false,\"ScheduledHardwareUpgradeInfo\":&#123;\"UpgradePolicy\":\"never\",\"VersionKey\":\"\",\"ScheduledHardwareUpgradeStatus\":\"none\",\"Fault\":null&#125;,\"ForkConfigInfo\":&#123;\"ParentEnabled\":false,\"ChildForkGroupId\":\"\",\"ParentForkGroupId\":\"\",\"ChildType\":\"\"&#125;,\"VFlashCacheReservation\":0,\"VmxConfigChecksum\":null,\"MessageBusTunnelEnabled\":null,\"VmStorageObjectId\":\"\",\"SwapStorageObjectId\":\"\",\"KeyId\":null,\"GuestIntegrityInfo\":null,\"MigrateEncryption\":\"\"&#125;,\"Layout\":&#123;\"ConfigFile\":[\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmxf\",\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template.nvram\",\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmsd\"],\"LogFile\":[\"vmware.log\"],\"Disk\":[&#123;\"Key\":2000,\"DiskFile\":[\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmdk\"]&#125;],\"Snapshot\":null,\"SwapFile\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template-f0564f4b.vswp\"&#125;,\"LayoutEx\":&#123;\"File\":[&#123;\"Key\":0,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmx\",\"Type\":\"config\",\"Size\":2935,\"UniqueSize\":2935,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":8,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmxf\",\"Type\":\"extendedConfig\",\"Size\":0,\"UniqueSize\":0,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":4,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.nvram\",\"Type\":\"nvram\",\"Size\":8684,\"UniqueSize\":8684,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":1,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmsd\",\"Type\":\"snapshotList\",\"Size\":0,\"UniqueSize\":0,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":2,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmdk\",\"Type\":\"diskDescriptor\",\"Size\":0,\"UniqueSize\":0,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":3,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template-flat.vmdk\",\"Type\":\"diskExtent\",\"Size\":4447010816,\"UniqueSize\":4447010816,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":5,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template-f0564f4b.vswp\",\"Type\":\"swap\",\"Size\":4294967296,\"UniqueSize\":4294967296,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":6,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/vmx-IDCOMD_192.168.110.191_CentOS6.10.X64.Template-4032188235-1.vswp\",\"Type\":\"uwswap\",\"Size\":174063616,\"UniqueSize\":174063616,\"BackingObjectId\":\"\",\"Accessible\":true&#125;,&#123;\"Key\":7,\"Name\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/vmware.log\",\"Type\":\"log\",\"Size\":265539,\"UniqueSize\":265539,\"BackingObjectId\":\"\",\"Accessible\":true&#125;],\"Disk\":[&#123;\"Key\":2000,\"Chain\":[&#123;\"FileKey\":[2,3]&#125;]&#125;],\"Snapshot\":null,\"Timestamp\":\"2019-08-12T01:17:49.437936Z\"&#125;,\"Storage\":&#123;\"PerDatastoreUsage\":[&#123;\"Datastore\":&#123;\"Type\":\"Datastore\",\"Value\":\"datastore-210\"&#125;,\"Committed\":8916318886,\"Uncommitted\":17027826230,\"Unshared\":4447010816&#125;],\"Timestamp\":\"2019-08-12T01:17:49.439Z\"&#125;,\"EnvironmentBrowser\":&#123;\"Type\":\"EnvironmentBrowser\",\"Value\":\"envbrowser-389\"&#125;,\"ResourcePool\":&#123;\"Type\":\"ResourcePool\",\"Value\":\"resgroup-62\"&#125;,\"ParentVApp\":null,\"ResourceConfig\":&#123;\"Entity\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"ChangeVersion\":\"\",\"LastModified\":null,\"CpuAllocation\":&#123;\"Reservation\":0,\"ExpandableReservation\":false,\"Limit\":-1,\"Shares\":&#123;\"Shares\":4000,\"Level\":\"normal\"&#125;,\"OverheadLimit\":null&#125;,\"MemoryAllocation\":&#123;\"Reservation\":0,\"ExpandableReservation\":false,\"Limit\":-1,\"Shares\":&#123;\"Shares\":40960,\"Level\":\"normal\"&#125;,\"OverheadLimit\":93&#125;&#125;,\"Runtime\":&#123;\"Device\":[&#123;\"RuntimeState\":&#123;\"VmDirectPathGen2Active\":false,\"VmDirectPathGen2InactiveReasonVm\":null,\"VmDirectPathGen2InactiveReasonOther\":[\"vmNptIncompatibleNetwork\"],\"VmDirectPathGen2InactiveReasonExtended\":\"\",\"ReservationStatus\":\"\",\"AttachmentStatus\":\"\",\"FeatureRequirement\":null&#125;,\"Key\":4000&#125;],\"Host\":&#123;\"Type\":\"HostSystem\",\"Value\":\"host-13\"&#125;,\"ConnectionState\":\"connected\",\"PowerState\":\"poweredOn\",\"FaultToleranceState\":\"notConfigured\",\"DasVmProtection\":null,\"ToolsInstallerMounted\":false,\"SuspendTime\":null,\"BootTime\":\"2019-06-28T06:58:45.518084Z\",\"SuspendInterval\":0,\"Question\":null,\"MemoryOverhead\":0,\"MaxCpuUsage\":10104,\"MaxMemoryUsage\":4096,\"NumMksConnections\":0,\"RecordReplayState\":\"inactive\",\"CleanPowerOff\":null,\"NeedSecondaryReason\":\"\",\"OnlineStandby\":false,\"MinRequiredEVCModeKey\":\"\",\"ConsolidationNeeded\":false,\"OfflineFeatureRequirement\":[&#123;\"Key\":\"cpuid.lm\",\"FeatureName\":\"cpuid.lm\",\"Value\":\"Bool:Min:1\"&#125;],\"FeatureRequirement\":[&#123;\"Key\":\"cpuid.SSE3\",\"FeatureName\":\"cpuid.SSE3\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.PCLMULQDQ\",\"FeatureName\":\"cpuid.PCLMULQDQ\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSSE3\",\"FeatureName\":\"cpuid.SSSE3\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.CMPXCHG16B\",\"FeatureName\":\"cpuid.CMPXCHG16B\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSE41\",\"FeatureName\":\"cpuid.SSE41\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSE42\",\"FeatureName\":\"cpuid.SSE42\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.POPCNT\",\"FeatureName\":\"cpuid.POPCNT\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.AES\",\"FeatureName\":\"cpuid.AES\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.DS\",\"FeatureName\":\"cpuid.DS\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SS\",\"FeatureName\":\"cpuid.SS\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.LAHF64\",\"FeatureName\":\"cpuid.LAHF64\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.NX\",\"FeatureName\":\"cpuid.NX\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.RDTSCP\",\"FeatureName\":\"cpuid.RDTSCP\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.LM\",\"FeatureName\":\"cpuid.LM\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.Intel\",\"FeatureName\":\"cpuid.Intel\",\"Value\":\"Bool:Min:1\"&#125;],\"FeatureMask\":null,\"VFlashCacheAllocation\":0,\"Paused\":false,\"SnapshotInBackground\":false,\"QuiescedForkParent\":null,\"InstantCloneFrozen\":null,\"CryptoState\":\"\"&#125;,\"Guest\":&#123;\"ToolsStatus\":\"toolsOk\",\"ToolsVersionStatus\":\"guestToolsUnmanaged\",\"ToolsVersionStatus2\":\"guestToolsUnmanaged\",\"ToolsRunningStatus\":\"guestToolsRunning\",\"ToolsVersion\":\"2147483647\",\"ToolsInstallType\":\"\",\"GuestId\":\"\",\"GuestFamily\":\"otherGuestFamily\",\"GuestFullName\":\"Linux 2.6.32-754.15.3.el6.x86_64 CentOS release 6.10 (Final)\",\"HostName\":\"CentOS6-X64-Template\",\"IpAddress\":\"192.168.110.191\",\"Net\":[&#123;\"Network\":\"IDC-NET\",\"IpAddress\":[\"192.168.110.191\",\"fe80::250:56ff:feb7:1251\"],\"MacAddress\":\"00:50:56:b7:12:51\",\"Connected\":true,\"DeviceConfigId\":4000,\"DnsConfig\":null,\"IpConfig\":&#123;\"IpAddress\":[&#123;\"IpAddress\":\"192.168.110.191\",\"PrefixLength\":23,\"Origin\":\"\",\"State\":\"preferred\",\"Lifetime\":null&#125;,&#123;\"IpAddress\":\"fe80::250:56ff:feb7:1251\",\"PrefixLength\":64,\"Origin\":\"\",\"State\":\"unknown\",\"Lifetime\":null&#125;],\"Dhcp\":null,\"AutoConfigurationEnabled\":null&#125;,\"NetBIOSConfig\":null&#125;],\"IpStack\":[&#123;\"DnsConfig\":&#123;\"Dhcp\":false,\"HostName\":\"CentOS6-X64-Template\",\"DomainName\":\"\",\"IpAddress\":[\"114.114.114.114\",\"233.5.5.5\"],\"SearchDomain\":[\"\"]&#125;,\"IpRouteConfig\":&#123;\"IpRoute\":[&#123;\"Network\":\"192.168.110.0\",\"PrefixLength\":23,\"Gateway\":&#123;\"IpAddress\":\"\",\"Device\":\"0\"&#125;&#125;,&#123;\"Network\":\"169.254.0.0\",\"PrefixLength\":16,\"Gateway\":&#123;\"IpAddress\":\"\",\"Device\":\"0\"&#125;&#125;,&#123;\"Network\":\"0.0.0.0\",\"PrefixLength\":0,\"Gateway\":&#123;\"IpAddress\":\"192.168.111.254\",\"Device\":\"0\"&#125;&#125;,&#123;\"Network\":\"fe80::\",\"PrefixLength\":64,\"Gateway\":&#123;\"IpAddress\":\"\",\"Device\":\"0\"&#125;&#125;,&#123;\"Network\":\"ff00::\",\"PrefixLength\":8,\"Gateway\":&#123;\"IpAddress\":\"\",\"Device\":\"0\"&#125;&#125;]&#125;,\"IpStackConfig\":null,\"DhcpConfig\":null&#125;],\"Disk\":[&#123;\"DiskPath\":\"/\",\"Capacity\":18369396736,\"FreeSpace\":15049367552&#125;,&#123;\"DiskPath\":\"/boot\",\"Capacity\":499355648,\"FreeSpace\":444992512&#125;],\"Screen\":&#123;\"Width\":800,\"Height\":600&#125;,\"GuestState\":\"running\",\"AppHeartbeatStatus\":\"appStatusGray\",\"GuestKernelCrashed\":null,\"AppState\":\"none\",\"GuestOperationsReady\":true,\"InteractiveGuestOperationsReady\":false,\"GuestStateChangeSupported\":true,\"GenerationInfo\":null&#125;,\"Summary\":&#123;\"Vm\":&#123;\"Type\":\"VirtualMachine\",\"Value\":\"vm-389\"&#125;,\"Runtime\":&#123;\"Device\":[&#123;\"RuntimeState\":&#123;\"VmDirectPathGen2Active\":false,\"VmDirectPathGen2InactiveReasonVm\":null,\"VmDirectPathGen2InactiveReasonOther\":[\"vmNptIncompatibleNetwork\"],\"VmDirectPathGen2InactiveReasonExtended\":\"\",\"ReservationStatus\":\"\",\"AttachmentStatus\":\"\",\"FeatureRequirement\":null&#125;,\"Key\":4000&#125;],\"Host\":&#123;\"Type\":\"HostSystem\",\"Value\":\"host-13\"&#125;,\"ConnectionState\":\"connected\",\"PowerState\":\"poweredOn\",\"FaultToleranceState\":\"notConfigured\",\"DasVmProtection\":null,\"ToolsInstallerMounted\":false,\"SuspendTime\":null,\"BootTime\":\"2019-06-28T06:58:45.518084Z\",\"SuspendInterval\":0,\"Question\":null,\"MemoryOverhead\":0,\"MaxCpuUsage\":10104,\"MaxMemoryUsage\":4096,\"NumMksConnections\":0,\"RecordReplayState\":\"inactive\",\"CleanPowerOff\":null,\"NeedSecondaryReason\":\"\",\"OnlineStandby\":false,\"MinRequiredEVCModeKey\":\"\",\"ConsolidationNeeded\":false,\"OfflineFeatureRequirement\":[&#123;\"Key\":\"cpuid.lm\",\"FeatureName\":\"cpuid.lm\",\"Value\":\"Bool:Min:1\"&#125;],\"FeatureRequirement\":[&#123;\"Key\":\"cpuid.SSE3\",\"FeatureName\":\"cpuid.SSE3\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.PCLMULQDQ\",\"FeatureName\":\"cpuid.PCLMULQDQ\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSSE3\",\"FeatureName\":\"cpuid.SSSE3\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.CMPXCHG16B\",\"FeatureName\":\"cpuid.CMPXCHG16B\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSE41\",\"FeatureName\":\"cpuid.SSE41\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SSE42\",\"FeatureName\":\"cpuid.SSE42\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.POPCNT\",\"FeatureName\":\"cpuid.POPCNT\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.AES\",\"FeatureName\":\"cpuid.AES\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.DS\",\"FeatureName\":\"cpuid.DS\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.SS\",\"FeatureName\":\"cpuid.SS\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.LAHF64\",\"FeatureName\":\"cpuid.LAHF64\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.NX\",\"FeatureName\":\"cpuid.NX\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.RDTSCP\",\"FeatureName\":\"cpuid.RDTSCP\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.LM\",\"FeatureName\":\"cpuid.LM\",\"Value\":\"Bool:Min:1\"&#125;,&#123;\"Key\":\"cpuid.Intel\",\"FeatureName\":\"cpuid.Intel\",\"Value\":\"Bool:Min:1\"&#125;],\"FeatureMask\":null,\"VFlashCacheAllocation\":0,\"Paused\":false,\"SnapshotInBackground\":false,\"QuiescedForkParent\":null,\"InstantCloneFrozen\":null,\"CryptoState\":\"\"&#125;,\"Guest\":&#123;\"GuestId\":\"\",\"GuestFullName\":\"Linux 2.6.32-754.15.3.el6.x86_64 CentOS release 6.10 (Final)\",\"ToolsStatus\":\"toolsOk\",\"ToolsVersionStatus\":\"guestToolsUnmanaged\",\"ToolsVersionStatus2\":\"guestToolsUnmanaged\",\"ToolsRunningStatus\":\"guestToolsRunning\",\"HostName\":\"CentOS6-X64-Template\",\"IpAddress\":\"192.168.110.191\"&#125;,\"Config\":&#123;\"Name\":\"IDCOMD_192.168.110.191_CentOS6.10.X64.Template\",\"Template\":false,\"VmPathName\":\"[VOL01] IDCOMD_192.168.110.191_CentOS6.10.X64.Template/IDCOMD_192.168.110.191_CentOS6.10.X64.Template.vmx\",\"MemorySizeMB\":4096,\"CpuReservation\":0,\"MemoryReservation\":0,\"NumCpu\":4,\"NumEthernetCards\":1,\"NumVirtualDisks\":1,\"Uuid\":\"42372cc9-0811-74e4-e7b6-abaa96a8ee85\",\"InstanceUuid\":\"50372076-6a91-f48a-818c-867387badbdd\",\"GuestId\":\"centos64Guest\",\"GuestFullName\":\"CentOS 4/5/6/7 (64-bit)\",\"Annotation\":\"\",\"Product\":null,\"InstallBootRequired\":false,\"FtInfo\":null,\"ManagedBy\":null,\"TpmPresent\":null,\"NumVmiopBackings\":0&#125;,\"Storage\":&#123;\"Committed\":8916318886,\"Uncommitted\":17027826230,\"Unshared\":4447010816,\"Timestamp\":\"2019-08-12T01:17:49.439936Z\"&#125;,\"QuickStats\":&#123;\"OverallCpuUsage\":0,\"OverallCpuDemand\":0,\"GuestMemoryUsage\":0,\"HostMemoryUsage\":2814,\"GuestHeartbeatStatus\":\"green\",\"DistributedCpuEntitlement\":0,\"DistributedMemoryEntitlement\":829,\"StaticCpuEntitlement\":1631,\"StaticMemoryEntitlement\":4189,\"PrivateMemory\":2755,\"SharedMemory\":97,\"SwappedMemory\":0,\"BalloonedMemory\":0,\"ConsumedOverheadMemory\":37,\"FtLogBandwidth\":-1,\"FtSecondaryLatency\":-1,\"FtLatencyStatus\":\"gray\",\"CompressedMemory\":0,\"UptimeSeconds\":3870025,\"SsdSwappedMemory\":0&#125;,\"OverallStatus\":\"green\",\"CustomValue\":null&#125;,\"Datastore\":[&#123;\"Type\":\"Datastore\",\"Value\":\"datastore-210\"&#125;],\"Network\":[&#123;\"Type\":\"Network\",\"Value\":\"network-16\"&#125;],\"Snapshot\":null,\"RootSnapshot\":null,\"GuestHeartbeatStatus\":\"green\"&#125; 如图: 最后使用这种方法,较为高效地进行了梳理,得到了需要的字段; 总结两点: 对于复杂的嵌套结构体,将其转化为json格式,是清晰获取其内容的最佳方式; 对于Vcenter的SDK,核心信息都在Summary字段中; 更多详情参见私有笔记 开发者账号及文档地址,以及一些专有词汇的意义点此","tags":[]},{"title":"搭建GraphQL服务器","date":"2019-08-05T13:34:54.000Z","path":"2019/08/05/搭建GraphQL服务器/","text":"js版 GraphQL在 NodeJS 服务端中使用最多 安装graphql-yoga: npm install graphql-yoga 新建index.js: 12345678910111213141516171819202122232425const &#123;GraphQLServer&#125; = require(\"graphql-yoga\")const server = new GraphQLServer(&#123; typeDefs: ` type Query &#123; hello(name:String):String! &#125; `, resolvers: &#123; Query: &#123; hello: (parent, &#123;name&#125;, ctx) =&gt; &#123; return `$&#123;name&#125;,你好！`; &#125; &#125; &#125;&#125;)server.start(&#123; port: 4600&#125;, (&#123;port&#125;) =&gt; &#123; console.log(`服务器已启动，请访问： http://localhost:$&#123;port&#125;`);&#125;) node index.js 运行 点击链接 进入playground： 123query&#123; hello(name:\"dashen\")&#125; 参考自 5分钟快速搭建一个Graphql服务器 Golang版 入门教程 Go常用的GraphQL服务端库 graphql-go/graphql项目的demo: (文档点此) 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"encoding/json\" \"fmt\" \"log\" \"github.com/graphql-go/graphql\")func main() &#123; // Schema fields := graphql.Fields&#123; \"hello\": &amp;graphql.Field&#123; Type: graphql.String, Resolve: func(p graphql.ResolveParams) (interface&#123;&#125;, error) &#123; return \"world\", nil &#125;, &#125;, &#125; rootQuery := graphql.ObjectConfig&#123;Name: \"RootQuery\", Fields: fields&#125; schemaConfig := graphql.SchemaConfig&#123;Query: graphql.NewObject(rootQuery)&#125; schema, err := graphql.NewSchema(schemaConfig) if err != nil &#123; log.Fatalf(\"failed to create new schema, error: %v\", err) &#125; // Query query := ` &#123; hello &#125; ` params := graphql.Params&#123;Schema: schema, RequestString: query&#125; r := graphql.Do(params) if len(r.Errors) &gt; 0 &#123; log.Fatalf(\"failed to execute graphql operation, errors: %+v\", r.Errors) &#125; rJSON, _ := json.Marshal(r) fmt.Printf(\"%s \\n\", rJSON) // &#123;\"data\":&#123;\"hello\":\"world\"&#125;&#125;&#125; 执行输出 {&quot;data&quot;:{&quot;hello&quot;:&quot;world&quot;}} 基于此项目的实践，参考 Graphql Go 基于Golang实践 代码 参考： GraphQL中文社区","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"GraphQL小试","date":"2019-08-04T14:40:33.000Z","path":"2019/08/04/GraphQL小试/","text":"之前做的需求，基本都是REST风格，以github提供的api为例，比较二者差异。试用GraphQL，找寻其独到之处 REST REST 一个URI代表一种资源 通过HTTP动词对资源进行操作 以创建一个仓库为例 GET, PATCH和DELETE类似 GraphQL GraphQL的endpoint只有一个 所有请求都是POST 可以在 Exploer左边写查询，右边显示结果。 查询当前登录的用户名： 查询Go项目当前的star数： GraphQL的endpoint只有一个，即 https://api.github.com/graphql 使用Postman： 使用query和mutation来区分是查询还是修改 二者区别 REST一个URI就是一个资源，GraphQL只有一个URI REST返回所有的内容，response体积较大，GraphQL可以只返回需要的数据，返回值体积小 GraphQL是一种语言，有自己的语法和类型系统 会有错误提示~ GraphQL的优势： 取你所需要的数据，不多也不少 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;n+1问题 nesting(嵌套查询) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 比如想取一个pr的commits、comment、reviews，用REST需要请求四次，然后还需要对返回值进行组装；而用GraphQL则只需要一次请求，拿到的就是需要的数据 资源孤岛 (REST) vs Graph（GraphQL） graphql-voyager 强类型（每一个GraphQL的请求发到服务端之后，服务端都会进行校验，不通过会报错） Migrating from REST to GraphQL 参考： 为什么GraphQL比REST好用？","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"根据条件关闭软件","date":"2019-07-31T14:17:39.000Z","path":"2019/07/31/根据条件关闭软件/","text":"使用下载工具时，经常出现磁盘空间已满，无法下载的情况。 使用shell写一个监控，每2分钟执行一次。判断当前磁盘的空间，低于2G时，关闭下载软件。 获取空间大小 123456789➜ ~ df -h Filesystem Size Used Avail Capacity iused ifree %iused Mounted on/dev/disk1s5s1 233Gi 14Gi 9.0Gi 62% 553757 2447547563 0% /devfs 196Ki 196Ki 0Bi 100% 678 0 100% /dev/dev/disk1s4 233Gi 1.0Gi 9.0Gi 10% 1 2448101319 0% /System/Volumes/VM/dev/disk1s2 233Gi 300Mi 9.0Gi 4% 1209 2448100111 0% /System/Volumes/Preboot/dev/disk1s6 233Gi 920Ki 9.0Gi 1% 17 2448101303 0% /System/Volumes/Update/dev/disk1s1 233Gi 208Gi 9.0Gi 96% 1517128 2446584192 0% /System/Volumes/Datamap auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /System/Volumes/Data/home 可通过 df -h | grep &quot;/$&quot; | awk &#39;{print $4}&#39; | sed &#39;s/Gi/ /g&#39; 获取当前磁盘的剩余空间 详细可参考 linux三剑客 获取下载软件的pid并关闭 通过 ps -ef | grep /Applications/Thunder.app/Contents/MacOS/Thunder | grep -v grep | cut -c 7-15 可得到pid。 使用 ps -ef | grep /Applications/Thunder.app/Contents/MacOS/Thunder | grep -v grep | cut -c 7-15 | xargs kill -9 关闭该进程。 命令详解 参见 批量kill掉包含某个关键字的进程 写成shell脚本，并配置定时任务 shell脚本 12345678910111213141516171819202122#!/bin/bashspareDisk=$(df -h | grep &quot;/$&quot; | awk &apos;&#123;print $4&#125;&apos; | sed &apos;s/Gi/ /g&apos;)echo &apos;当前剩余空间&apos;$spareDisk&apos;GB&apos;#echo &quot;scale=0; ($spareDisk - 2)&quot; | bc safeDisk=$(echo &quot;scale=0; ($spareDisk - 2)/1&quot; | bc)echo &apos;当前空间离2GB还剩&apos;$safeDisk&apos;GB&apos;if [ $safeDisk -gt 0 ]then echo &apos;安全&apos;else ps -ef | grep /Applications/Thunder.app/Contents/MacOS/Thunder | grep -v grep | cut -c 7-15 | xargs kill -9 echo &apos;空间不足，已关闭软件&apos;fi 配置crontab crontab -e */3 * * * * /Users/xxxxx/kill.sh &gt; space_check.log 每3分钟检查一次~ 参考： Linux bc 命令 bc 命令是任意精度计算器语言，通常在linux下当计算器用。 scale=2 设小数位，2 代表保留两位: 12$ echo 'scale=2; (2.777 - 1.4744)/1' | bc1.30 (/1是为使精确到小数点后2位生效)","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"InnoDB一棵B+树,可以存放多少行数据","date":"2019-07-29T10:42:24.000Z","path":"2019/07/29/InnoDB一棵B-树-可以存放多少行数据/","text":"show global status 结果如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353Aborted_clients 2Aborted_connects 322Binlog_cache_disk_use 0Binlog_cache_use 0Binlog_stmt_cache_disk_use 0Binlog_stmt_cache_use 0Bytes_received 35910Bytes_sent 381776Com_admin_commands 4Com_assign_to_keycache 0Com_alter_db 0Com_alter_db_upgrade 0Com_alter_event 0Com_alter_function 0Com_alter_instance 0Com_alter_procedure 0Com_alter_server 0Com_alter_table 0Com_alter_tablespace 0Com_alter_user 0Com_analyze 0Com_begin 0Com_binlog 0Com_call_procedure 0Com_change_db 27Com_change_master 0Com_change_repl_filter 0Com_check 0Com_checksum 0Com_commit 0Com_create_db 0Com_create_event 0Com_create_function 0Com_create_index 0Com_create_procedure 0Com_create_server 0Com_create_table 0Com_create_trigger 0Com_create_udf 0Com_create_user 0Com_create_view 0Com_dealloc_sql 0Com_delete 0Com_delete_multi 0Com_do 0Com_drop_db 0Com_drop_event 0Com_drop_function 0Com_drop_index 0Com_drop_procedure 0Com_drop_server 0Com_drop_table 0Com_drop_trigger 0Com_drop_user 0Com_drop_view 0Com_empty_query 0Com_execute_sql 0Com_explain_other 0Com_flush 4Com_get_diagnostics 0Com_grant 0Com_ha_close 0Com_ha_open 0Com_ha_read 0Com_help 0Com_insert 0Com_insert_select 0Com_install_plugin 0Com_kill 0Com_load 0Com_lock_tables 0Com_optimize 0Com_preload_keys 0Com_prepare_sql 0Com_purge 0Com_purge_before_date 0Com_release_savepoint 0Com_rename_table 0Com_rename_user 0Com_repair 0Com_replace 0Com_replace_select 0Com_reset 0Com_resignal 0Com_revoke 0Com_revoke_all 0Com_rollback 0Com_rollback_to_savepoint 0Com_savepoint 0Com_select 40Com_set_option 11Com_signal 0Com_show_binlog_events 0Com_show_binlogs 0Com_show_charsets 0Com_show_collations 0Com_show_create_db 0Com_show_create_event 0Com_show_create_func 0Com_show_create_proc 0Com_show_create_table 0Com_show_create_trigger 0Com_show_databases 0Com_show_engine_logs 0Com_show_engine_mutex 0Com_show_engine_status 0Com_show_events 0Com_show_errors 0Com_show_fields 78Com_show_function_code 0Com_show_function_status 0Com_show_grants 0Com_show_keys 0Com_show_master_status 0Com_show_open_tables 0Com_show_plugins 0Com_show_privileges 0Com_show_procedure_code 0Com_show_procedure_status 0Com_show_processlist 0Com_show_profile 0Com_show_profiles 0Com_show_relaylog_events 0Com_show_slave_hosts 0Com_show_slave_status 0Com_show_status 3Com_show_storage_engines 0Com_show_table_status 4Com_show_tables 5Com_show_triggers 0Com_show_variables 6Com_show_warnings 0Com_show_create_user 0Com_shutdown 0Com_slave_start 0Com_slave_stop 0Com_group_replication_start 0Com_group_replication_stop 0Com_stmt_execute 0Com_stmt_close 0Com_stmt_fetch 0Com_stmt_prepare 0Com_stmt_reset 0Com_stmt_send_long_data 0Com_truncate 0Com_uninstall_plugin 0Com_unlock_tables 0Com_update 0Com_update_multi 0Com_xa_commit 0Com_xa_end 0Com_xa_prepare 0Com_xa_recover 0Com_xa_rollback 0Com_xa_start 0Com_stmt_reprepare 0Connection_errors_accept 0Connection_errors_internal 0Connection_errors_max_connections 0Connection_errors_peer_address 0Connection_errors_select 0Connection_errors_tcpwrap 0Connections 342Created_tmp_disk_tables 107Created_tmp_files 8Created_tmp_tables 164Delayed_errors 0Delayed_insert_threads 0Delayed_writes 0Flush_commands 1Handler_commit 5Handler_delete 0Handler_discover 0Handler_external_lock 249Handler_mrr_init 0Handler_prepare 0Handler_read_first 115Handler_read_key 1806Handler_read_last 0Handler_read_next 386Handler_read_prev 0Handler_read_rnd 2001Handler_read_rnd_next 13162Handler_rollback 0Handler_savepoint 0Handler_savepoint_rollback 0Handler_update 0Handler_write 4740Innodb_buffer_pool_dump_status Dumping of buffer pool not startedInnodb_buffer_pool_load_status Buffer pool(s) load completed at 200917 19:39:58Innodb_buffer_pool_resize_status Innodb_buffer_pool_pages_data 396Innodb_buffer_pool_bytes_data 6488064Innodb_buffer_pool_pages_dirty 3Innodb_buffer_pool_bytes_dirty 49152Innodb_buffer_pool_pages_flushed 138Innodb_buffer_pool_pages_free 7795Innodb_buffer_pool_pages_misc 0Innodb_buffer_pool_pages_total 8191Innodb_buffer_pool_read_ahead_rnd 0Innodb_buffer_pool_read_ahead 0Innodb_buffer_pool_read_ahead_evicted 0Innodb_buffer_pool_read_requests 11382Innodb_buffer_pool_reads 328Innodb_buffer_pool_wait_free 0Innodb_buffer_pool_write_requests 5342Innodb_data_fsyncs 7Innodb_data_pending_fsyncs 0Innodb_data_pending_reads 0Innodb_data_pending_writes 0Innodb_data_read 5444096Innodb_data_reads 368Innodb_data_writes 155Innodb_data_written 2295808Innodb_dblwr_pages_written 2Innodb_dblwr_writes 1Innodb_log_waits 0Innodb_log_write_requests 0Innodb_log_writes 2Innodb_os_log_fsyncs 4Innodb_os_log_pending_fsyncs 0Innodb_os_log_pending_writes 0Innodb_os_log_written 1024Innodb_page_size 16384Innodb_pages_created 69Innodb_pages_read 327Innodb_pages_written 138Innodb_row_lock_current_waits 0Innodb_row_lock_time 0Innodb_row_lock_time_avg 0Innodb_row_lock_time_max 0Innodb_row_lock_waits 0Innodb_rows_deleted 0Innodb_rows_inserted 4440Innodb_rows_read 6149Innodb_rows_updated 0Innodb_num_open_files 32Innodb_truncated_status_writes 0Innodb_available_undo_logs 128Key_blocks_not_flushed 0Key_blocks_unused 13394Key_blocks_used 3Key_read_requests 38Key_reads 5Key_write_requests 0Key_writes 0Locked_connects 0Max_execution_time_exceeded 0Max_execution_time_set 0Max_execution_time_set_failed 0Max_used_connections 3Max_used_connections_time 2020-09-17 21:26:19Not_flushed_delayed_rows 0Ongoing_anonymous_transaction_count 0Open_files 14Open_streams 0Open_table_definitions 131Open_tables 93Opened_files 355Opened_table_definitions 131Opened_tables 309Performance_schema_accounts_lost 0Performance_schema_cond_classes_lost 0Performance_schema_cond_instances_lost 0Performance_schema_digest_lost 0Performance_schema_file_classes_lost 0Performance_schema_file_handles_lost 0Performance_schema_file_instances_lost 0Performance_schema_hosts_lost 0Performance_schema_index_stat_lost 0Performance_schema_locker_lost 0Performance_schema_memory_classes_lost 0Performance_schema_metadata_lock_lost 0Performance_schema_mutex_classes_lost 0Performance_schema_mutex_instances_lost 0Performance_schema_nested_statement_lost 0Performance_schema_prepared_statements_lost 0Performance_schema_program_lost 0Performance_schema_rwlock_classes_lost 0Performance_schema_rwlock_instances_lost 0Performance_schema_session_connect_attrs_lost 0Performance_schema_socket_classes_lost 0Performance_schema_socket_instances_lost 0Performance_schema_stage_classes_lost 0Performance_schema_statement_classes_lost 0Performance_schema_table_handles_lost 0Performance_schema_table_instances_lost 0Performance_schema_table_lock_stat_lost 0Performance_schema_thread_classes_lost 0Performance_schema_thread_instances_lost 0Performance_schema_users_lost 0Prepared_stmt_count 0Qcache_free_blocks 1Qcache_free_memory 16760152Qcache_hits 0Qcache_inserts 0Qcache_lowmem_prunes 0Qcache_not_cached 40Qcache_queries_in_cache 0Qcache_total_blocks 1Queries 198Questions 193Select_full_join 0Select_full_range_join 0Select_range 0Select_range_check 0Select_scan 161Slave_open_temp_tables 0Slow_launch_threads 0Slow_queries 0Sort_merge_passes 1Sort_range 0Sort_rows 2001Sort_scan 21Ssl_accept_renegotiates 0Ssl_accepts 0Ssl_callback_cache_hits 0Ssl_cipher Ssl_cipher_list Ssl_client_connects 0Ssl_connect_renegotiates 0Ssl_ctx_verify_depth 0Ssl_ctx_verify_mode 0Ssl_default_timeout 0Ssl_finished_accepts 0Ssl_finished_connects 0Ssl_server_not_after Ssl_server_not_before Ssl_session_cache_hits 0Ssl_session_cache_misses 0Ssl_session_cache_mode NONESsl_session_cache_overflows 0Ssl_session_cache_size 0Ssl_session_cache_timeouts 0Ssl_sessions_reused 0Ssl_used_session_cache_entries 0Ssl_verify_depth 0Ssl_verify_mode 0Ssl_version Table_locks_immediate 115Table_locks_waited 0Table_open_cache_hits 207Table_open_cache_misses 309Table_open_cache_overflows 209Tc_log_max_pages_used 0Tc_log_page_size 0Tc_log_page_waits 0Threads_cached 2Threads_connected 1Threads_created 3Threads_running 1Uptime 344001Uptime_since_flush_status 344001 show global status like &quot;Innodb_page_size&quot; 返回为: Innodb_page_size 16384 单位为字节(Byte). 16384/1024=16,即为16KB 而对于Linux操作系统,其默认的文件系统的页大小为 getconf PAGE_SIZE 即4KB. (Mac也支持该命令,且默认的Page大小也是4KB) mysql中, 一个int类型占4个字节,对于varchar,最多可以占65532字节即64KB(最多能存纯汉字21844个),但绝大多数情况下,不会超过100Byte. MySQL中varchar最大长度是多少？ 即一般情况下,一行记录不太会超过1000Byte. 也就是说,一般一个Page能存10-20行数据 根据局部性原理, 当执行查询某条记录时,会把那一页的查出来放在内存,所以再查其相邻几行记录时,少了磁盘IO速度会快得多. Mysql的”页”,有三个重要的结构: 页头,页目录,用户数据区 链表和数组正好相反, 链表写易读难. 页目录存放这一组的范围(即这一组记录行中,id的起始值和终点值----实际只需要记起点值,终点值即下一组的起点) 页目录这个东西,才是真正提高检索效率的东西 当这一页(16KB空间)已经放满了数据(比如放了18行),则需要新开辟一页. 写入时需要(重新)排序,这个动作任何(写入)时都会有,所以提升读效率的同时,降低了写的效率. 页头部分有两个指针,指向前一页和后一页. 当记录有几千几万行,由一个个page组成的一个链表,又会出现之前的问题. 把每一页,当做之前的每一行,再增加一个用于管理页的目录,称为目录页,被它管理的这些个页,成为数据页. (注意区分目录页和数据页的页目录) 这就是一棵B+树(其实和学术上的纯粹B+树不完全一致) abcde五个字段,a为主键,abcd均为int型,e为varchar类型 create index idx_t1_bcd on t1(b,c,d), 为t1表的bcd字段,创建一个联合索引,名为idx_t1_bcd B+树的一个节点可以存多个元素 随着数据增多,其深度(或称高度)增加的不多 MySql中的”索引”,和es中的”索引”,含义不完全一样. 以上都是以主键的大小对一行行记录进行排序. 同时还是聚簇索引(或称 聚集索引),即 数据和索引存放在一起(上图中最底层为用户数据,其上为索引数据; 即叶子节点为用户数据,非叶子节点为索引数据). 在MySiam中,不存在聚集索引,即数据和索引是分开的. 在Innodb中,主键索引就是一个聚簇索引. 如果从上到下找,则用到了索引; 如果从左到右找,就是全表扫描. 对于非主键索引,下图黄色部分,存的实际是其对应记录的主键的值. 如果不这样的话, 如上图是”b-c-d”的联合索引,此时只能得到bcd的值. 但如果查询的是select *,如果不存黄色部分即主键的值, 是拿不到其他字段的值; 而如果有主键的值,就可以再进行一次查询,拿到整条记录的所有字段的信息(主键那个索引的每个叶子节点,即存了一行记录的全部信息, abcde 5个字段都存了) 这也就是建联合索引的意义. 所以即便where后面的是b=? and c=? and d=?,但如果前面是select *或select e,那还是无法避免回表. 如果前面是select b,c,d,则无需回表 对于Innode,完整的数据,只存在主键索引的叶子节点上面..所以但凡是select *,都少不了要去那里查 “最左匹配原则”,也称”最左前缀原则” 当除了主键索引,只还有一个’bcd’的联合索引,如果是select * from t1 where c=1 and d=2,这时是会全表扫描,而无法走索引.(explain一下, 结果的type字段肯定是ALL) 从数学上看, 就是在一个按大小排好序的树状结构里,11*是可以确定大致范围的,而*11则不行. 这其实就是最左匹配的数学含义 B+树 就是按照比较大小的规则排序而来的… like “%123” 同理 如果是select * from t1 where b=1 and d=2, 即1*1, 其实是会走索引, 但只能确定一个范围. explain看一下,type字段值为ref, key_len字段为5,即走了索引的字段的大小 (int型占4个字节,还有可能为null,即占5个字节,如果bcd都走了索引,这个字段的值就是15;如果只有b走了索引,这个字段的值就是5) 对于不等操作, 如 select * from t1 where a&gt;1, 可以走索引,先按=1查找,找到之后,叶子节点之间的指针就起了作用,在=1对应的位置右侧的值都符合条件. 对于 select * from t1 where b&gt;1, explain之后的type字段是ALL,即没有走索引.但possible_key字段不为null,即可以走索引,但还是选了全表扫描. 这是因为虽然可以从上往下查用上索引(bcd为联合索引),但因为是select *,还得回表,而且是回表多次(有多少行符合条件的记录,就得回表那么多次)…在记录数不多时,不如全表扫描效率更高. 如果是select b from t1 where b&gt;1,则会走索引(range) select * from t1 where b&gt;5 (假设共有7行记录) 这时也是会走索引的(range), 查询优化器会做权衡,决定到底用哪一种 如果不加where条件,即如 select * from t1, 目的是找到表中所有b字段的值. 这个值在当前(这两个索引下)的表中,有两个地方有,即在bcd索引和在主键索引上. 那会从那个地方取呢? 主键索引的叶子节点存的是 一行记录 完整的数据,而bcd的叶子节点存的只是部分字段(即bcd)的数据,同样大小的一个page, bcd索引能存放的记录行数更多.(或者说,相同的记录数,bcd用的page更少) explain一下,type字段为index. 前面的索引检索方式都是从上到下,这里是利用了叶子节点从左到右来扫描. 先看这样几条sql: select 1=1 返回为1,即认为相等. select 0=&#39;a&#39; 返回为1,mysql认为两者相等 select 0=&#39;1&#39; 返回为0 两个数据类型不同的值进行比较时,需要先进行类型转换.一般都会把字符转换为数字: 如果是数字类型的字符,则会转为其对应的int型. 如果不是,比如为”abcd”,则直接会转为0.. 这会引发出很多问题…. 如下图,结果会是第一条记录 再创建一个索引: select index idx_t1_e on t1(e) 对于: select * from t1 where a = &#39;1&#39; // ‘1’会被转换为1,可以走索引 select * from t1 where a = 1 // 本来就可以走索引 select * from t1 where e = &#39;1&#39; // 本来就可以走索引 select * from t1 where e = 1 // 不会走索引..需要把字符转换为数字,需要把t1表所有的e字段的记录都转为int后,才可以执行判断..这时索引已经没有作用了… 在执行sql时需要 类型转换/计算/日期格式的转换 等时,如果需要对整张表的某个字段对操作,则不会走索引. 如 select * from t1 where a+1 = 2, 不会走索引(type字段为ALL),需要全表扫描(即会认为需要对所有的a都先加1) limit 使用limit时,越取后面的会越慢,即 select * from t1 limit 0,1000 和 select * from t1 limit 10000,11000, 后者要慢的多. 因为找起点时,后者要花更多时间. 解决办法: 加一个子查询, order by select * from t1 order by b asc, c asc, d asc 不会走索引,而会全表扫描. 且explain的Extra字段是Using filesort(之前大多为where) 会先把bcd字段所有的记录取出来,然后在内存的buffer中进行排序.如果数据量非常大,内存不够,就需要用到文件(磁盘)做swap交换. 排序本身还是比较快的. 而如果走bcd索引,虽然已经排好序了,但是,用的是select *,需要回表…需要把这n条数据每一个主键,重新走一遍主键索引…这样还不如全表扫描再排序 如果是 select b from t1 order by b asc, c asc, d asc, 则会利用bcd索引,从左到右走一遍.explain的type字段为index (index一般是叶子节点从左到右扫描) 如果是 select * from t1 where b=1 order by b asc, c asc, d asc, 这样回表的成本就小多了,有可能会走bcd这个索引 如果是 select * from t1 where order by b asc, c asc, d desc, 这样是用不到索引的. mysql 8.0 正式支持降序索引(之前版本只是语法上支持) 对于如下创建索引的语句: create index idx_t1_bcd on t1(b asc,c asc,d desc), 8.0之前,不管怎么写,底层其实都是asc(只是语法上支持,所以8.0之前创建索引时,都省略后面的asc/desc) 8.0之后,desc起作用了 所以在8.0中,如果建这样的索引create index idx_t1_bcd on t1(b asc,c asc,d desc),上面的sql是可以用到索引的 更多 参考: Backward index scan 基于一些合理的前提和假设,当B+树高度为3时,最多只能存2000多万行数据. B+树变成4层,即多了一次磁盘IO,效率便会大幅度降低. 假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右. 所以(主键索引中)叶子节点的一个节点(即一个page,且为数据页),在这里认为可以放16行记录. 假设主键ID为bigint类型(长度为8字节)，而指针大小在InnoDB源码中是6字节，这样一共14字节，我们一个页(Page,在此为目录页)中能存放多少这样的(索引)单元，其实就代表有多少指针，即16384/14=1170。即一个目录Page,能存大概1170个(索引)单元. 那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。 根据同样原理, 可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。 所以在InnoDB中B+树高度一般为1-3层，就能满足千万级的数据存储。在查找数据时一次页的查找代表一次磁盘IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。 “在InnoDB的表空间文件中，约定page number为3的代表主键索引的根页，而在根页偏移量为64的地方存放了该B+树的page level。如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；” 1234567SELECTb.name, a.name, index_id, type, a.space, a.PAGE_NOFROMinformation_schema.INNODB_SYS_INDEXES a,information_schema.INNODB_SYS_TABLES bWHEREa.table_id = b.table_id AND a.space &lt;&gt; 0; 详细操作参见原文:InnoDB一棵B+树,可以存放多少行数据 结论: 表A的数据行数为600多万，B+树高度为3，表B的数据行数只有15万，B+树高度也为3。可以看出尽管数据量差异较大，这两个表树的高度都是3，换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做3次IO。如果有一张表行数是一千万，那么其B+树高度依旧是3，查询效率仍然不会相差太大。 当然如果一张表只有5行数据，那么它的B+树高度为1。 即当数据量在18720到21902400行之间时,B+树的高度都是3,查询的速度几乎相同. 因为二分查找是在内存里边进行的,速度很快.和磁盘IO差几个数量级,可以忽略. 那么即从2万行记录到2200万行记录,主体的查询性能差不多 参考: InnoDB一棵B+树,可以存放多少行数据 备存地址 索引和锁 有非常密切的关系","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"函数式编程","date":"2019-07-26T11:32:33.000Z","path":"2019/07/26/函数式编程/","text":"如函数式编程–酷壳 总结， 函数式编程的三大特性; 数据不可变性 函数作为一等公民(函数可以像变量一样来创建/修改/传递 等) 尾递归优化(重用stack,减轻栈的压力) 函数式编程用到的几个技术： 函数式编程的理念：把函数当成变量来用，关注于描述问题而不是怎么实现（这样可以让代码更易读） 下面详细探讨 Map &amp; Reduce 其实完整的操作有三种，即Map、Reduce、Filter，这三种操作可以非常方便灵活地对一些数据进行处理，而不是大量使用for循环 （有的也把Reduce称为fold，比较早期且经典的函数式语言有OCaml， Lisp，Haskell等) 其实恰好对应PHP中的array_map()、array_reduce()、array_filter() Map如 有这样一个人名的集合[“\bZhangSan”,”lisi”,”WANGWU”]，有大写有小写，将其全部转为大写， Go语言版本对于传统方式，对切片进行循环，在循环中进行处理即可： 123456789101112131415161718func UpperSli(arr []string) (newArr []string) &#123; for _, item := range arr &#123; newArr = append(newArr, strings.ToUpper(item)) &#125; return&#125;func main() &#123; arr := []string&#123;\"\bZhangSan\",\"lisi\",\"WANGWU\"&#125; newArr := UpperSli(arr) fmt.Printf(\"%v\\n\", newArr) //[ZHANGSAN LISI WANGWU]&#125; “在函数式编程中，不应该用循环迭代的方式，而该用更为高级的方法” 使用函数式编程的写法： 12345678910111213141516171819func MapStrUpper(arr []string, fn func(s string) string) []string &#123; var newArray []string for _, it := range arr &#123; newArray = append(newArray, fn(it)) &#125; return newArray&#125;func main() &#123; var list = []string&#123;\"\bZhangSan\",\"lisi\",\"WANGWU\"&#125; x := MapStrUpper(list, func(s string) string &#123; return strings.ToUpper(s) &#125;) fmt.Printf(\"%v\\n\", x) //[ZHANGSAN LISI WANGWU]&#125; “这样的代码很易读，因为，这样的代码是在描述要干什么，而不是怎么干” PHP版本123456789101112&lt;?php$arr = [\"ZhangSan\", \"lisi\", \"WANGWU\"];var_export($arr);$newArr = [];foreach ($arr as $val) &#123; $newVal = strtoupper($val); array_push($newArr, $newVal);&#125;var_export($newArr); 使用函数式编程的写法： array_map() 该函数可将用户自定义的函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 可以传递多个数组，回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。 12345678910&lt;?php$arr = [\"ZhangSan\", \"lisi\", \"WANGWU\"];var_export($arr);$newArr = array_map(function ($val1) &#123; return strtoupper($val1);&#125;, $arr);var_export($newArr); Rust版本传统方式，对数组进行循环，在循环中进行处理： 12345678910111213141516171819fn main() &#123; let arr: [String;3] = [\"ZhangSan\".to_string(),\"lisi\".to_string(),\"WANGWU\".to_string()]; println!(\"&#123;:?&#125;\",arr); let mut new_arr: [String;3] = [\"\".to_string(),\"\".to_string(),\"\".to_string()]; // for i in arr.iter() &#123; // println!(\"值为 : &#123;&#125;\", i); // &#125; for index in 0..3 &#123; println!(\"index is: &#123;&#125; &amp; value is : &#123;&#125;\",index,arr[index]); new_arr[index] = arr[index].to_ascii_uppercase(); &#125; println!(\"&#123;:?&#125;\",new_arr); &#125; 输出： 12345678[\"ZhangSan\", \"lisi\", \"WANGWU\"]// 值为 : ZhangSan// 值为 : lisi// 值为 : WANGWUindex is: 0 &amp; value is : ZhangSanindex is: 1 &amp; value is : lisiindex is: 2 &amp; value is : WANGWU[\"ZHANGSAN\", \"LISI\", \"WANGWU\"] 麻雀虽小，却涉及到 关于rust：如何打印结构和数组？ {:?} Rust 数组 Rust中的String和&amp;str 函数式编程的方式： 12 Reduce map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次;reduce()是将传入的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算） reduce()方法是对数组的遍历,返回一个单个返回值 如 有一个数字集合[1，4，7，2，8]，计算其和 会把上一次迭代返回的结果存起来,带到下一次迭代中,使用reduce方法可以很容易的计算数组累加,累乘 Go语言版本123456789101112131415161718192021package mainimport \"fmt\"func Reduce(arr []int, fn func(s int) int) int &#123; sum := 0 for _, it := range arr &#123; sum += fn(it) &#125; return sum&#125;func main() &#123; var list = []int&#123;1,4,7,2,8&#125; x := Reduce(list, func(s int) int &#123; return s &#125;) fmt.Printf(\"%v\\n\", x) // 22&#125; PHP版本123456789101112131415&lt;?phpfunction sum($carry, $item)&#123; var_dump($carry, $item); $carry += $item; echo \"\\n\"; return $carry;&#125;$a = array(1, 4, 7, 2, 8);$sum = array_reduce($a, 'sum', 0);echo $sum; 输出为： 12345678910111213141516int(0)int(1)int(1)int(4)int(5)int(7)int(12)int(2)int(14)int(8)22 更多参考 array_reduce 的理解 JS中的Array.reduce()方法 Rust版本 FilterFilter 重点在于过滤（而不是新增）某个元素 如 有一个数字集合[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，筛选出哪些是奇数，哪些大于5 Go版本123456789101112131415161718192021222324252627package mainimport \"fmt\"func Filter(arr []int, fn func(n int) bool) []int &#123; var newArray []int for _, it := range arr &#123; if fn(it) &#123; newArray = append(newArray, it) &#125; &#125; return newArray&#125;func main() &#123; var intset = []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; out := Filter(intset, func(n int) bool &#123; return n%2 == 1 &#125;) fmt.Printf(\"%v\\n\", out) //[1 3 5 7 9] out = Filter(intset, func(n int) bool &#123; return n &gt; 5 &#125;) fmt.Printf(\"%v\\n\", out) //[6 7 8 9 10]&#125; PHP版本12345678910111213141516&lt;?php$arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];$newArr = array_filter($arr, function ($val) &#123; return $val % 2 == 1;&#125;);//返回结果var_export($newArr);$newArr = array_filter($arr, function ($val) &#123; return $val &gt; 5;&#125;);//返回结果var_export($newArr); 输出： 123456789101112131415array ( 0 =&gt; 1, 2 =&gt; 3, 4 =&gt; 5, 6 =&gt; 7, 8 =&gt; 9,)array ( 5 =&gt; 6, 6 =&gt; 7, 7 =&gt; 8, 8 =&gt; 9, 9 =&gt; 10,) Rust版本 参考： GO编程模式：MAP-REDUCE robpike/filter array_filter()、array_map()、array_walk()三者的用法和区别 123456 array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组 array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组 array_walk() 重点在于遍历数组进行某种操作 array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后 array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数 更多可参见 阮一峰-函数式编程初探 阮一峰-函数式编程入门教程 阮一峰-图解 Monad","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"},{"name":"PHP","slug":"PHP","permalink":"http://www.dashen.tech/tags/PHP/"}]},{"title":"How to Measure Execution Time of a Program","date":"2019-07-19T13:14:35.000Z","path":"2019/07/19/How-to-Measure-Execution-Time-of-a-Program/","text":"https://serhack.me/articles/measure-execution-time-program/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"多级指针","date":"2019-07-15T13:25:16.000Z","path":"2019/07/15/多级指针/","text":"Go 语言指向指针的指针 如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。 当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址： 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() &#123; var a int var ptr *int var pptr **int a = 3000 /* take the address of var */ ptr = &amp;a // 变量ptr = 变量a的地址 /* take the address of ptr using address of operator &amp; */ pptr = &amp;ptr // 变量pptr = 变量ptr的地址,即(变量a地址)的地址 /* take the value using pptr */ fmt.Printf(\"变量 a = %d, type %T\\n\", a, a) fmt.Printf(\"指针变量 *ptr = %d, type %T\\n\", *ptr, *ptr) fmt.Printf(\"指向指针的指针变量 **pptr = %d, type %T\\n\", **pptr, **pptr)&#125; 输出 123变量 a = 3000, type int指针变量 *ptr = 3000, type int指向指针的指针变量 **pptr = 3000, type int Golang中slice与二级指针的陷阱 &amp; 只是个取地址的运算符，后面的值可以寻址就可以，不可以就会报错 GoLang 学习笔记（三）– slice 二级指针，接口的应用等 虽然Go吸收融合了很多其语言中的各种特性，但是Go主要被归入C语言家族。其中一个重要的原因就是Go和C一样，也支持指针。 （虽然Go中的指针相比C指针有很多限制） 一个内存地址表示操作系统管理的整个内存中的一个偏移量（相对于从整个内存的起始，以字节计数） 解引用操作符*的优先级高于自增++和自减–操作符 Go 101-指针 **多级指针 简析多级指针解引用 野指针","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go中的iota","date":"2019-07-14T13:58:53.000Z","path":"2019/07/14/Go中的iota/","text":"基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport \"fmt\"const a0 = iota // a0 = 0 // const出现, iota初始化为0const ( a1 = iota // a1 = 0 // 又一个const出现, iota初始化为0 a2 = iota // a2 = 1 // const新增一行, iota 加1 a3 = 6 // a3 = 6 // 自定义一个常量 a4 // a4 = 6 // 不赋值就和上一行相同 a5 = iota // a5 = 4 // const已经新增了4行, 所以这里是4)const ( b = iota // b = 0 c // c = 1 d = 1111 e f = iota)const ( TestMin = -1 TestA TestB = iota TestC)func main() &#123; fmt.Println(\"a0:\", a0) fmt.Println(\"a1:\", a1) fmt.Println(\"a2:\", a2) fmt.Println(\"a3:\", a3) fmt.Println(\"a4:\", a4) fmt.Println(\"a5:\", a5) fmt.Println(\"---------\") fmt.Println(\"b is:\", b) fmt.Println(\"c is:\", c) fmt.Println(\"d is:\", d) fmt.Println(\"e is:\", e) fmt.Println(\"f is:\", f) fmt.Println(\"---------\") fmt.Println(\"TestMin:\", TestMin) fmt.Println(\"TestA:\", TestA) fmt.Println(\"TestB:\", TestB) fmt.Println(\"TestC:\", TestC)&#125; 输出为： 1234567891011121314151617a0: 0a1: 0a2: 1a3: 6a4: 6a5: 4---------b is: 0c is: 1d is: 1111e is: 1111f is: 4---------TestMin: -1TestA: -1TestB: 2TestC: 3 123456789101112131415161718package mainimport \"fmt\"const ( TestMin = -1 TestA _ TestB = iota TestC)func main() &#123; fmt.Println(TestMin) fmt.Println(TestA) fmt.Println(TestB) fmt.Println(TestC)&#125; 输出为： 1234-1-134 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"// 跳值使用iota使用_来达到目的：const ( h = iota // 0 i = iota // 1 _ k = iota // 3)// 当常量表达式为空时，会自动继承上一个存在非空的表达式。const ( x = iota * 2 y z)func main() &#123; fmt.Println(h) fmt.Println(i) fmt.Println(k) fmt.Println(\"-------\") fmt.Println(x) fmt.Println(y) fmt.Println(z)&#125; 输出为 1234567013-------024 用来定义枚举值123456789101112131415161718192021222324252627282930package mainimport \"fmt\"type OrderState uint8const ( // 0-待支付 WaitPay OrderState = iota // 1-支付中 Paying // 2-支付成功 PaySucc // 3-支付失败 PayFail)// 对应于xx表is_show字段const ( _ uint8 = iota Show // 1-显示 NotShow // 2-不显示)func main() &#123; fmt.Println(PaySucc) fmt.Println(Show)&#125; 输出为 1221 高阶用法12345678910111213141516171819package mainimport ( \"fmt\")const ( i = 1 &lt;&lt; iota j = 3 &lt;&lt; iota k l)func main() &#123; fmt.Println(\"i=\", i) fmt.Println(\"j=\", j) fmt.Println(\"k=\", k) fmt.Println(\"l=\", l)&#125; 输出为 1234i= 1j= 6k= 12l= 24 iota每出现一次，自动加1；而前面的操作数如果不指定，默认使用上一个的，在这里是3； 即 1234i=1&lt;&lt;iotaj=3&lt;&lt;iotakl 等价于 1234i=1&lt;&lt;0j=3&lt;&lt;1k=3&lt;&lt;2l=3&lt;&lt;3 又如 1234567891011121314package mainimport \"fmt\"func main() &#123; const ( IgEggs = 1 &lt;&lt; iota // 1 &lt;&lt; 0 which is 00000001 IgChocolate // 1 &lt;&lt; 1 which is 00000010 IgNuts // 1 &lt;&lt; 2 which is 00000100 IgStrawberries // 1 &lt;&lt; 3 which is 00001000 IgShellfish // 1 &lt;&lt; 4 which is 00010000 ) fmt.Println(IgEggs, IgChocolate, IgNuts, IgStrawberries, IgShellfish)&#125; 输出为 1 2 4 8 16 每次可以左移一位，因此对于定义数量级大有裨益 1234567891011121314151617181920212223package mainimport \"fmt\"type ByteSize int64const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10*1) MB // 1 &lt;&lt; (10*2) GB // 1 &lt;&lt; (10*3) TB // 1 &lt;&lt; (10*4) PB // 1 &lt;&lt; (10*5) EB // 1 &lt;&lt; (10*6) //ZB // 1 &lt;&lt; (10*7) //YB // 1 &lt;&lt; (10*8))func main() &#123; fmt.Printf(\"KB= %d Byte\\n\", KB) fmt.Printf(\"MB= %d Byte\\n\", MB) fmt.Printf(\"GB= %d Byte\\n\", GB)&#125; 输出为 123KB= 1024 ByteMB= 1048576 ByteGB= 1073741824 Byte","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"爬取豆瓣电影信息","date":"2019-07-13T15:38:38.000Z","path":"2019/07/13/爬取豆瓣电影信息/","text":"爬取&amp;分析豆瓣关闭了api接口，只好用爬虫方式，获取此刻Top250以及所看700余部影片的相关信息。 避开豆瓣设置的各种坑，略费周章将数据爬取&amp;入库。简要分析如下: .在此时间点，Top250中，韩国电影占据10席。排名最前的是&lt;熔炉&gt;，位列第20。这是自&lt;辩护人&gt;后我看的第二部韩国电影，从此彻底改变对其偏见，也为孔侑圈粉。 .Top250中，美国是独自完成数量最多的国家，有81部。日本和中国香港紧随其后，分别占31和12席。中国大陆占据8席，分别是姜文禁片&lt;鬼子来了&gt;，&lt;心迷宫&gt;，&lt;二十二&gt;，&lt;哪吒闹海&gt;，&lt;天书奇谭&gt;，&lt;我不是药神&gt;，&lt;驴得水&gt;，&lt;四个春天&gt;。如果扩大到“合拍作品”，则为20部。其中如&lt;霸王别姬&gt;，&lt;活着&gt;，&lt;让子弹飞&gt;，&lt;可可西里&gt;，&lt;疯狂的石头&gt;，主创团队绝大部分属中国大陆。 .年份分布中，2010年是诞生Top250最多的一年，高达14部。2004年以13部紧随其后。众所周知的“电影奇迹年” 1994，有11部作品上榜，与2013年并列第三。这11部作品参见下图。 .上榜作品中，评分最高的为9.6分，分别是常年占据榜首的&lt;肖申克的救赎&gt;，挤下&lt;阿甘正传&gt;跃升第二的&lt;霸王别姬&gt;，以及62年前的老片&lt;控方证人&gt;。8.7分是250部电影中，分布最多的一个区间，有45部。 .导演方面，宫崎骏和诺兰以7部并列榜首。斯皮尔伯格，王家卫和李安以6部/5部/4部紧随其后。刘镇伟，吴宇森，姜文，各有3部入选。 .类型方面，剧情片是无可撼动的霸主。 2013年，我极是欣赏的“贾科长”，有一部作品，将当时发生的一些轰动性社会事件串联在一起，果不其然，问世即被禁。…我看完&lt;熔炉&gt;，想到无论历史还是人口疆域都远不及我们的韩国电影，不说太远只联系最近几天的时事——女童失踪，豪车醉驾，栾川判决，山大学伴，猥亵幼女，稍微放开一个口子，艺术来源生活反映事实，我们完全可以有比韩国人波澜壮阔或入木三分得多得作品。 代码及sql建表语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;?php$pdo = new PDO(\"mysql:host=127.0.0.1;dbname=future\", \"root\", \"123456\");$pdo-&gt;query('set names utf8');function deal()&#123; for ($i = 0; $i &lt;= 225; $i = $i + 25) &#123; $url = \"https://movie.douban.com/top250?start=\" . $i . \"&amp;filter=\"; $rs = curl($url); $preg = '/&lt;ol class=\"grid_view\"&gt;[\\s\\S]*?&lt;\\/ol&gt;/i'; preg_match_all($preg, $rs, $res); $newStr = $res[0][0]; $allArr = explode(\"&lt;/li&gt;\", $newStr); foreach ($allArr as $k =&gt; $str) &#123; $reg2 = \"#&lt;span[^&gt;]*&gt;([\\s\\S]*?)&lt;/span&gt;#i\"; $str = str_replace(\"&amp;nbsp;\", \"\", $str); preg_match_all($reg2, $str, $arr); $name = $arr[1][0]; if (count($arr[1]) == 9) &#123; $otherName = substr($arr[1][1], 1) . \"|\" . substr($arr[1][2], 1); //去掉开头的\"/\",两个名称拼接在一起 $score = $arr[1][5]; $quote = $arr[1][8]; &#125; if (count($arr[1]) == 8) &#123; $otherName = substr($arr[1][1], 1); $score = $arr[1][4]; $quote = $arr[1][7]; &#125; if (count($arr[1]) == 7) &#123; $otherName = substr($arr[1][1], 1); $score = $arr[1][3]; if ($score == \"\") &#123; $score = $arr[1][4]; //我是不是药神 &#125; $quote = $arr[1][6]; if (strstr($quote, \"评价\")) &#123; $quote = \"无\"; &#125; &#125; $reg3 = \"#&lt;p[^&gt;]*&gt;([\\s\\S]*?)&lt;/p&gt;#i\"; preg_match_all($reg3, $str, $arr2); $infoStr = trim($arr2[1][0]); if ($infoStr == \"\") &#123; continue; &#125; $infoStr = str_replace(\"&amp;nbsp;\", \"\", $infoStr); $infoStr = str_replace(\"导演: \", \"\", $infoStr); $infoStr = str_replace(\"主演: \", \"/\", $infoStr); $infoStr = str_replace('...&lt;br&gt;', \"/\", $infoStr); $infoArr = explode(\"/\", $infoStr); $director = str_replace(\"'\", \"\", $infoArr[0]);//如海豚湾 主演: Richard O'Barry $actor = str_replace(\"'\", \"\", $infoArr[1]);//如海豚湾 主演: Richard O'Barry if (count($infoArr) == 7) &#123; $year = substr(trim($infoArr[4]), -4); $country = $infoArr[5]; $category = $infoArr[6]; //天书奇谭 if (strstr($infoArr[4], '重映')) &#123; $year = trim($infoArr[3]); $year = substr($year, 0, 4); &#125; &#125; if (count($infoArr) == 6 &amp;&amp; $infoArr[2] != \"\") &#123; $actor = $actor . \"|\" . str_replace(\"'\", \"\", $infoArr[2]); &#125; if (count($infoArr) == 6) &#123; $year = substr(trim($infoArr[3]), -4); $country = $infoArr[4]; $category = $infoArr[5]; &#125; if (count($infoArr) == 5) &#123; $year = substr(trim($infoArr[2]), -4); //截取最后4位,当展示出的演员多于两位时,就会有此情况 $country = $infoArr[3]; $category = $infoArr[4]; &#125; //172,二十二 if (count($infoArr) == 4) &#123; $year = substr(trim($infoArr[1]), -4); $country = $infoArr[2]; $category = $infoArr[3]; &#125; $sql = \"insert into douban_top250(`name`,othername,score,`quote`,director,actor,`year`,country,category) VALUES ( '$name' , '$otherName','$score', '$quote','$director','$actor','$year','$country','$category')\"; global $pdo; $pdo-&gt;exec($sql); &#125; &#125;&#125;function curl($domain)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $domain); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //若给定url自动跳转到新的url,有了下面参数可自动获取新url内容：302跳转 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); ### 该条设置十分重要,相当于curl的-L参数;但curl -L 61.com依然无法得到预期返回,上面方法中的添加www操作仍然不能少;但添加该设置后,一般可不用再尝试https,基本都会自动跳过去 // 在尝试连接时等待的秒数 curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30); // 最大执行时间 curl_setopt($ch, CURLOPT_TIMEOUT, 30); $output = curl_exec($ch); curl_close($ch); return $output;&#125;deal(); 12345678910111213CREATE TABLE `douban_top250` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL COMMENT '电影名称', `othername` varchar(255) DEFAULT NULL COMMENT '其他名称', `score` varchar(255) DEFAULT NULL COMMENT '评分', `quote` varchar(255) DEFAULT NULL COMMENT '评价', `director` varchar(255) DEFAULT NULL COMMENT '导演', `actor` varchar(255) DEFAULT NULL COMMENT '主演', `year` varchar(255) DEFAULT NULL COMMENT '年份', `country` varchar(255) DEFAULT NULL COMMENT '国家', `category` varchar(255) DEFAULT NULL COMMENT '类型', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=251 DEFAULT CHARSET=utf8","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.dashen.tech/tags/PHP/"}]},{"title":"从钱塘江边到余杭塘河","date":"2019-07-13T01:29:42.000Z","path":"2019/07/13/从钱塘江边到余杭塘河/","text":"把两个月前 钱江边的聚会小酌 成功移到余杭塘河。三巡五味后，一行三人在偌大的校园走着聊着。在滨江某知名支付公司的测试经理，感叹管理层间人浮于事站队排位;在阿里的前端程序员，困顿于今年未能升P竞争压力山大。而我，定位为服务端却在走全栈路线，也在纠结更换技术栈，看不清寻不到一个更满意充满想象力的未来。 似乎吐槽和患得患失，多过幸福和豪气干云。而回想这一切刚开始时的忐忑不安踌躇满志，绝没想到，会在一个雨过方晴的深夜，有这样一番对话。 4年前的今天，我离开家乡，从济南坐上一节南下的橙皮车。当慢慢悠悠走过十余个小时，从微山湖夕阳落下到寒山寺晨钟响彻，我来到了曾一见倾心风云际会的魔都，一只怯怯什么也不会的菜鸟，正式开启了必将色彩斑斓的职业生涯。 此前几天，第一次用58找房，还不知有那么多套路。我发了100多条短信，大多如泥牛入海不见回声。偶有的几条，也是中介答复:“便宜的前几天租出去了，还有套价格贵一些的”。我终在豆瓣小组，在车来到济宁时收到了这条回复。满是欣喜打开，充满失望关闭。 此前几个月，我放弃割舍许多，不曾随我的相当多数同学，去那几家中字头央企，也不曾青眼相向，可以一辈子安稳无虞的公务员事业编，而选择了一家未曾听闻的“互联网”公司。我知道，当我听到这三个字，郁结于胸口怏怏不乐的大石顿被粉碎，我知道，我的第一家公司，不会再有其他。然而回宿舍后我做的第一件事，是查证这家公司是否为诈骗组织皮包公司。我也在暗暗忧心，空有一腔热爱，就真能做得好吗？兴趣真的可以打败科班无视专业？ 我在仙霞路工程技术大学的国家级创业园，度过了终生难忘的两年，也完美回答了上面的疑惑。又在两年前魔都落户安家周折太巨，选择如候鸟，随潮离沪来杭。 四年里，我以平均一年一家的频率，换过四家公司，薪资较最初翻转500%。四年前，创新创业之风荡涤全国，o2o风云乍起，p2p方兴未艾。而今，内外部趋势交织，猪从风口跌落，独角沦为毒角。我也面临职业和薪资门卡:我是否还能心平静气在一家单位多呆几年，沉淀而不颓废？我如何还能保持在基数较大的情况下，使薪资以较高速率增长？我有哪些要学哪些要放，我要走哪条职业路线？… 实在有太多要学，我给自己的目标是:除去工作所用，还要试图从数学和物理角度，理解背后机理;要紧跟潮流，对新出现的技术和事物保有热切好奇;要外语足够优秀，能无障碍阅读英语文档。… 从没想过，有一天“学习”也会成为甜蜜负担。但我清楚，并不是所有的职业，所有的从业者，都有我们这样可以不断学习不断提高，如果愿意可以练就一身本事的机会。我会在无边学海中偶尔迷失，但却清楚，一样技能可以一陈不变从生到死，那会让我因无成就感和提高的满足而生不如死。 我的感触是，从毕业到30岁，真的太短太短了。只有夜以继日只有目不见睫。几年里，太多的熬夜让我皮肤不复当年紧致滑腻，太多的久坐让我发福增重，或许还有双眼疲劳颈椎酸痛。…我会注意保重，但当解决一个问题，当当搞懂一样东西，那种感觉，像一个木匠做出一件工艺品，抖落浑身木屑站起时的满足。所有的疲乏，所有的周折劳累，都将烟消云散。 回瞰这几年，我总会在他们看不见的地方，感谢B哥L哥H哥，但我还想感谢并告诫自己:我很勇敢，也因而幸运，在一个几百年不遇的信息时代，如果我还因循守旧患得患失，畏葸不前混吃等死，那既是对自己得辜负，也是对时代得辜负。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"三个月内遭遇的第二次比特币勒索","date":"2019-07-11T05:41:26.000Z","path":"2019/07/11/三个月内遭遇的第二次比特币勒索/","text":"早前搭过一个wiki (可点击wiki.dashen.tech 查看),用于”团队协作与知识分享”.把游客账号给一位前同事,其告知登录出错. 我用笔记里记录的账号密码登录,同样报错; 打开数据库一看,疑惑全消. To recover your lost Database and avoid leaking it: Send us 0.05 Bitcoin (BTC) to our Bitcoin address 3F4hqV3BRYf9JkPasL8yUPSQ5ks3FF3tS1 and contact us by Email with your Server IP or Domain name and a Proof of Payment. Your Database is downloaded and backed up on our servers. Backups that we have right now: mm_wiki, shuang. If we dont receive your payment in the next 10 Days, we will make your database public or use them otherwise. (按照今日比特币价格,0.05比特币折合人民币4 248.05元..) 大多时候不使用该服务器上安装的mysql,因而账号和端口皆为默认,密码较简单且常见,为在任何地方navicat也可连接,去掉了ip限制…对方写一个脚本,扫描各段ip地址,用常见的几个账号和密码去”撞库”,几千几万个里面,总有一两个能得手. 被窃取备份而后删除的两个库,一个是来搭建该wiki系统,另一个是用来亲测mysql主从同步,详见此篇,价值都不大 实践告诉我们，不要用默认账号，不要用简单密码，要做ip限制。… 登录服务器,登录到mysql: mysql -u root -p 修改密码: 尝试使用如下语句来修改 set password for 用户名@yourhost = password(‘新密码’); 结果报错;查询得知是最新版本更改了语法,需用 alter user ‘root‘@’localhost’ identified by ‘yourpassword’; 成功~ 但在navicat里,原连接依然有效,而输入最新的密码,反倒是失败 打码部分为本机ip 在服务器执行 – 查询所有用户 select user from mysql.user; 再执行 select host,user,authentication_string from mysql.user; user及其后的host组合在一起,才构成一个唯一标识;故而在user表中,可以存在同名的root 使用 1alter user &apos;root&apos;@&apos;%&apos; identified by &apos;xxxxxx&apos;; 注意主机此处应为% 再使用1select host,user,authentication_string from mysql.user; 发现 “root@%” 对应的authentication_string已发生改变; 在navicat中旧密码已失效,需用最新密码才可登录 参考: mysql 5.7 修改用户密码 关于修改账号,可参考此 这不是第一次遭遇”比特币勒索”,在四月份,收到了这么一封邮件: 后来证明这是唬人的假消息,但还是让我学小扎,把Mac的摄像头覆盖了起来.. 关于此次事件,更多信息记录参考私人笔记","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"值类型与引用类型,值传递与引用传递","date":"2019-07-08T06:42:47.000Z","path":"2019/07/08/值类型与引用类型-值传递与引用传递/","text":"值传递和引用传递 Go语言参数传递是传值还是传引用 一文整得明明白白~ Go全部都是值传递，不存在引用传递 值传递 是原始值copy出一份副本，然后传递； 引用传递 是直接传原始值的指针； 值传递并非不能修改原始值，当原始值是引用类型时(指针、map、slice、chan等这些)，值传递就可以修改原始值 （值传递传的指针是原始值指针的副本，但两个指针都指向同一个地址） 值类型和引用类型 slice，map，channel，interface，func等 是引用类型，都(或者至少某个字段)是指针 (引用类型可以看作是对指针的封装) （使用make函数创建的map,channel 其实都是一个指针，slice是其结构体SliceHeader的Data字段是指针） 1234567891011// SliceHeader is the runtime representation of a slice.// It cannot be used safely or portably and its representation may// change in a later release.// Moreover, the Data field is not sufficient to guarantee the data// it references will not be garbage collected, so programs must keep// a separate, correctly typed pointer to the underlying data.type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; int、float、bool、array、sturct 是值类型 string比较有争议，感觉是值类型，但有种说法也是引用类型 几种说法 说法1： “引用类型保存在堆上，值类型保存在栈上”？这种说法是不准确的 1首先不要纠结字面意思，Java中（byte、short、int、long、float、double）、字符型（char）、布尔型（boolean）这些基本类型数据直接保存在栈中，而类、接口、数组数据是保存在堆中，栈只是保存一个指向堆内存的指针。 一文理清 Go 引用的常见疑惑","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"fmt包源码剖析","date":"2019-07-07T13:33:24.000Z","path":"2019/07/07/fmt包源码剖析/","text":"https://yourbasic.org/golang/fmt-printf-reference-cheat-sheet/ https://blog.cyeam.com/golang/2018/09/10/fmt https://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool https://juejin.cn/post/6844903865469386760","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang中slice扩容一定是double或1.25倍吗","date":"2019-06-28T13:19:37.000Z","path":"2019/06/28/golang中slice扩容一定是double或1-25倍吗/","text":"本文是对 Go slice扩容分析之 不是double或1.25那么简单的学习与记录 问题 依据大多数资料,slice的扩容机制是当切片的容量小于1024时,进行双倍扩容;当大于1024时,进行1.25倍扩容,见如下代码: 1234567891011121314151617181920212223var sli = []int&#123;&#125;sli = append(sli, 666)fmt.Println(cap(sli))sli = append(sli, 777)fmt.Println(cap(sli))sli = append(sli, 888)fmt.Println(sli)fmt.Println(cap(sli))sli = append(sli, 999)fmt.Println(cap(sli))sli = append(sli, 1000)fmt.Println(cap(sli)) 输出为: 12345612[666 777 888]448 又见如下代码: 1234567891011var sli2 = []int&#123;&#125;for i := 0; i &lt; 10; i++ &#123; sli2 = append(sli2, i)&#125;fmt.Println(sli2)fmt.Println(len(sli2))fmt.Println(cap(sli2)) 输出为: 123[0 1 2 3 4 5 6 7 8 9]1016 用更”准确”的话描述,是当cap&lt;1024时,cap的值一定是2的n次方,且cap&gt;=len;每当发生append使len增加,如果导致len&gt;cap,此时cap会先于append操作进行double 即有 123456789101112131415var sli3 = []int&#123;&#125;for i := 0; i &lt; 512; i++ &#123; sli3 = append(sli3, i)&#125;fmt.Println(len(sli3))fmt.Println(cap(sli3))sli3 = append(sli3, 123)fmt.Println(len(sli3))fmt.Println(cap(sli3)) 结果为: 12345125125131024 对于 123456789101112131415var sli4 = []int&#123;&#125;for i := 0; i &lt; 1024; i++ &#123; sli4 = append(sli4, i)&#125;fmt.Println(len(sli4))fmt.Println(cap(sli4))sli4 = append(sli4, 123)fmt.Println(len(sli4))fmt.Println(cap(sli4)) 结果为: 12341024102410251280 1024*1.25 = 1280 看似无懈可击的结果, 不过, 果真确凿如此吗? 上面的操作是每次append一个元素，考虑另一种情形，一次性append很多元素，会发生什么呢？ 当同时append进多个元素时,如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport \"fmt\"func main() &#123; a := []byte&#123;1, 0&#125; fmt.Println(\"len of old a is \", len(a)) fmt.Println(\"cap of old a is \", cap(a)) fmt.Println(\"\") a = append(a, 1, 1, 1) fmt.Println(\"len of a is \", len(a)) fmt.Println(\"cap of a is \", cap(a)) fmt.Println(\"------\") b := []int&#123;23, 51&#125; fmt.Println(\"len of old b is \", len(b)) fmt.Println(\"cap of old b is \", cap(b)) fmt.Println(\"\") b = append(b, 4, 5, 6) fmt.Println(\"len of b is \", len(b)) fmt.Println(\"cap of b is \", cap(b)) fmt.Println(\"------\") c := []int32&#123;1, 23&#125; fmt.Println(\"len of old c is \", len(c)) fmt.Println(\"cap of old c is \", cap(c)) fmt.Println(\"\") c = append(c, 2, 5, 6) fmt.Println(\"len of c is \", len(c)) fmt.Println(\"cap of c is \", cap(c)) fmt.Println(\"------\") type D struct &#123; age byte name string &#125; d := []D&#123; &#123;1, \"123\"&#125;, &#123;2, \"234\"&#125;, &#125; fmt.Println(\"len of old d is \", len(d)) fmt.Println(\"cap of old d is \", cap(d)) fmt.Println(\"\") d = append(d, D&#123;4, \"456\"&#125;, D&#123;5, \"567\"&#125;, D&#123;6, \"678\"&#125;) fmt.Println(\"len of d is \", len(d)) fmt.Println(\"cap of d is \", cap(d))&#125; 结果为: 1234567891011121314151617181920212223len of old a is 2cap of old a is 2len of a is 5cap of a is 8------len of old b is 2cap of old b is 2len of b is 5cap of b is 6------len of old c is 2cap of old c is 2len of c is 5cap of c is 6------len of old d is 2cap of old d is 2len of d is 5cap of d is 5 匪夷所思? 其实是因为内存对齐 简化以上代码： 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; m := []int64&#123;2, 3&#125; fmt.Println(\"len of old m is \", len(m)) fmt.Println(\"cap of old m is \", cap(m)) fmt.Println(\"\") m = append(m, 4, 5, 6) fmt.Println(\"len of m is \", len(m)) fmt.Println(\"cap of m is \", cap(m)) fmt.Println() fmt.Println(\"------\") n := []int64&#123;2, 3&#125; fmt.Println(\"len of old n is \", len(n)) fmt.Println(\"cap of old n is \", cap(n)) fmt.Println(\"\") n = append(n, 4) n = append(n, 5) n = append(n, 6) fmt.Println(\"len of n is \", len(n)) fmt.Println(\"cap of n is \", cap(n)) fmt.Println(\"------\")&#125; 输出为： 12345678910111213len of old m is 2cap of old m is 2len of m is 5cap of m is 6------len of old n is 2cap of old n is 2len of n is 5cap of n is 8------ 为什么一次性append多个，最后切片的长度为6； 而多次append单个元素，最后切片的长度为8？ 切片扩容的源码,是/src/runtime/slice.go中的growslice方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// growslice handles slice growth during append.// It is passed the slice element type, the old slice, and the desired new minimum capacity,// and it returns a new slice with at least that capacity, with the old data// copied into it.// The new slice's length is set to the old slice's length,// NOT to the new requested capacity.// This is for codegen convenience. The old slice's length is used immediately// to calculate where to write new values during an append.// TODO: When the old backend is gone, reconsider this decision.// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.func growslice(et *_type, old slice, cap int) slice &#123; if raceenabled &#123; callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice)) &#125; if msanenabled &#123; msanread(old.array, uintptr(old.len*int(et.size))) &#125; if cap &lt; old.cap &#123; panic(errorString(\"growslice: cap out of range\")) &#125; if et.size == 0 &#123; // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn't need to preserve old.array in this case. return slice&#123;unsafe.Pointer(&amp;zerobase), old.len, cap&#125; &#125; newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap &#123; newcap = cap &#125; else &#123; if old.len &lt; 1024 &#123; newcap = doublecap &#125; else &#123; // Check 0 &lt; newcap to detect overflow // and prevent an infinite loop. for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123; newcap += newcap / 4 &#125; // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap &lt;= 0 &#123; newcap = cap &#125; &#125; &#125; var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch &#123; case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) &gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 &#123; // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63 &#125; else &#123; shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31 &#125; lenmem = uintptr(old.len) &lt;&lt; shift newlenmem = uintptr(cap) &lt;&lt; shift capmem = roundupsize(uintptr(newcap) &lt;&lt; shift) overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift) newcap = int(capmem &gt;&gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) &#125; // The check of overflow in addition to capmem &gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // type T [1&lt;&lt;27 + 1]int64 // // var d T // var s []T // // func main() &#123; // s = append(s, d, d, d, d) // print(len(s), \"\\n\") // &#125; if overflow || capmem &gt; maxAlloc &#123; panic(errorString(\"growslice: cap out of range\")) &#125; var p unsafe.Pointer if et.kind&amp;kindNoPointers != 0 &#123; p = mallocgc(capmem, nil, false) // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) &#125; else &#123; // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory. p = mallocgc(capmem, et, true) if writeBarrier.enabled &#123; // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem) &#125; &#125; memmove(p, old.array, lenmem) return slice&#123;p, old.len, newcap&#125;&#125; 原理 使用gdb调试工具进行调试 强烈建议先阅读此文，学习GDB基本用法 使用l 10可查看第10行附近的源码 使用 b 12 在第12行处设置断点 (可以设置多个断点) 这样会在运行到第12行时停止，可查看变量的值、堆栈情况等； 使用info b 查看断点处情况 可使用 s, 跳入断点，并看执行情况 可使用 r运行代码 可使用 p 变量名，显示变量值 如果调试过程中出现value optimized out，说明编译器进行了内联优化。可通过go build -gcflags &quot;-N -l&quot; -o 自定义的二进制文件名称 原始Go文件.go命令，禁用编译器优化gdb调试 出现value optimized out解决方法 可使用n单步运行. 非常好用，可以看到调用链 使用c, 使程序继续往下运行，直到再次遇到断点或程序结束 使用q, 退出gdb 调用roundupsize()函数，进行(向上)内存对齐 roundupsize()位于go/src/runtime/msize.go，更具体介绍与使用可参考12345678910111213141516171819202122232425// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Malloc small size classes.//// See malloc.go for overview.// See also mksizeclasses.go for how we decide what size classes to use.package runtime// Returns size of the memory block that mallocgc will allocate if you ask for the size.func roundupsize(size uintptr) uintptr &#123; if size &lt; _MaxSmallSize &#123; if size &lt;= smallSizeMax-8 &#123; return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) &#125; else &#123; return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]]) &#125; &#125; if size+_PageSize &lt; size &#123; return size &#125; return alignUp(size, _PageSize)&#125;go/src/runtime/sizeclasses.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Code generated by mksizeclasses.go; DO NOT EDIT.//go:generate go run mksizeclasses.gopackage runtime// class bytes/obj bytes/span objects tail waste max waste// 1 8 8192 1024 0 87.50%// 2 16 8192 512 0 43.75%// 3 24 8192 341 8 29.24%// 4 32 8192 256 0 21.88%// 5 48 8192 170 32 31.52%// 6 64 8192 128 0 23.44%// 7 80 8192 102 32 19.07%// 8 96 8192 85 32 15.95%// 9 112 8192 73 16 13.56%// 10 128 8192 64 0 11.72%// 11 144 8192 56 128 11.82%// 12 160 8192 51 32 9.73%// 13 176 8192 46 96 9.59%// 14 192 8192 42 128 9.25%// 15 208 8192 39 80 8.12%// 16 224 8192 36 128 8.15%// 17 240 8192 34 32 6.62%// 18 256 8192 32 0 5.86%// 19 288 8192 28 128 12.16%// 20 320 8192 25 192 11.80%// 21 352 8192 23 96 9.88%// 22 384 8192 21 128 9.51%// 23 416 8192 19 288 10.71%// 24 448 8192 18 128 8.37%// 25 480 8192 17 32 6.82%// 26 512 8192 16 0 6.05%// 27 576 8192 14 128 12.33%// 28 640 8192 12 512 15.48%// 29 704 8192 11 448 13.93%// 30 768 8192 10 512 13.94%// 31 896 8192 9 128 15.52%// 32 1024 8192 8 0 12.40%// 33 1152 8192 7 128 12.41%// 34 1280 8192 6 512 15.55%// 35 1408 16384 11 896 14.00%// 36 1536 8192 5 512 14.00%// 37 1792 16384 9 256 15.57%// 38 2048 8192 4 0 12.45%// 39 2304 16384 7 256 12.46%// 40 2688 8192 3 128 15.59%// 41 3072 24576 8 0 12.47%// 42 3200 16384 5 384 6.22%// 43 3456 24576 7 384 8.83%// 44 4096 8192 2 0 15.60%// 45 4864 24576 5 256 16.65%// 46 5376 16384 3 256 10.92%// 47 6144 24576 4 0 12.48%// 48 6528 32768 5 128 6.23%// 49 6784 40960 6 256 4.36%// 50 6912 49152 7 768 3.37%// 51 8192 8192 1 0 15.61%// 52 9472 57344 6 512 14.28%// 53 9728 49152 5 512 3.64%// 54 10240 40960 4 0 4.99%// 55 10880 32768 3 128 6.24%// 56 12288 24576 2 0 11.45%// 57 13568 40960 3 256 9.99%// 58 14336 57344 4 0 5.35%// 59 16384 16384 1 0 12.49%// 60 18432 73728 4 0 11.11%// 61 19072 57344 3 128 3.57%// 62 20480 40960 2 0 6.87%// 63 21760 65536 3 256 6.25%// 64 24576 24576 1 0 11.45%// 65 27264 81920 3 128 10.00%// 66 28672 57344 2 0 4.91%// 67 32768 32768 1 0 12.50%const ( _MaxSmallSize = 32768 smallSizeDiv = 8 smallSizeMax = 1024 largeSizeDiv = 128 _NumSizeClasses = 68 _PageShift = 13)var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;var class_to_allocnpages = [_NumSizeClasses]uint8&#123;0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4&#125;type divMagic struct &#123; shift uint8 shift2 uint8 mul uint16 baseMask uint16&#125;var class_to_divmagic = [_NumSizeClasses]divMagic&#123;&#123;0, 0, 0, 0&#125;, &#123;3, 0, 1, 65528&#125;, &#123;4, 0, 1, 65520&#125;, &#123;3, 11, 683, 0&#125;, &#123;5, 0, 1, 65504&#125;, &#123;4, 11, 683, 0&#125;, &#123;6, 0, 1, 65472&#125;, &#123;4, 10, 205, 0&#125;, &#123;5, 9, 171, 0&#125;, &#123;4, 11, 293, 0&#125;, &#123;7, 0, 1, 65408&#125;, &#123;4, 13, 911, 0&#125;, &#123;5, 10, 205, 0&#125;, &#123;4, 12, 373, 0&#125;, &#123;6, 9, 171, 0&#125;, &#123;4, 13, 631, 0&#125;, &#123;5, 11, 293, 0&#125;, &#123;4, 13, 547, 0&#125;, &#123;8, 0, 1, 65280&#125;, &#123;5, 9, 57, 0&#125;, &#123;6, 9, 103, 0&#125;, &#123;5, 12, 373, 0&#125;, &#123;7, 7, 43, 0&#125;, &#123;5, 10, 79, 0&#125;, &#123;6, 10, 147, 0&#125;, &#123;5, 11, 137, 0&#125;, &#123;9, 0, 1, 65024&#125;, &#123;6, 9, 57, 0&#125;, &#123;7, 9, 103, 0&#125;, &#123;6, 11, 187, 0&#125;, &#123;8, 7, 43, 0&#125;, &#123;7, 8, 37, 0&#125;, &#123;10, 0, 1, 64512&#125;, &#123;7, 9, 57, 0&#125;, &#123;8, 6, 13, 0&#125;, &#123;7, 11, 187, 0&#125;, &#123;9, 5, 11, 0&#125;, &#123;8, 8, 37, 0&#125;, &#123;11, 0, 1, 63488&#125;, &#123;8, 9, 57, 0&#125;, &#123;7, 10, 49, 0&#125;, &#123;10, 5, 11, 0&#125;, &#123;7, 10, 41, 0&#125;, &#123;7, 9, 19, 0&#125;, &#123;12, 0, 1, 61440&#125;, &#123;8, 9, 27, 0&#125;, &#123;8, 10, 49, 0&#125;, &#123;11, 5, 11, 0&#125;, &#123;7, 13, 161, 0&#125;, &#123;7, 13, 155, 0&#125;, &#123;8, 9, 19, 0&#125;, &#123;13, 0, 1, 57344&#125;, &#123;8, 12, 111, 0&#125;, &#123;9, 9, 27, 0&#125;, &#123;11, 6, 13, 0&#125;, &#123;7, 14, 193, 0&#125;, &#123;12, 3, 3, 0&#125;, &#123;8, 13, 155, 0&#125;, &#123;11, 8, 37, 0&#125;, &#123;14, 0, 1, 49152&#125;, &#123;11, 8, 29, 0&#125;, &#123;7, 13, 55, 0&#125;, &#123;12, 5, 7, 0&#125;, &#123;8, 14, 193, 0&#125;, &#123;13, 3, 3, 0&#125;, &#123;7, 14, 77, 0&#125;, &#123;12, 7, 19, 0&#125;, &#123;15, 0, 1, 32768&#125;&#125;var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32&#125;var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8&#123;32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67&#125;&gt; 当创建一个对象时，需要分配一块内存。假设创建的对象需要52 byte，系统是不会真就给分配52byte大小的内存，首先会根据上面代码中第6行注释部分，来计算需要分配的内存大小。可参考[go/src/runtime/msize.go] 中的 roundupsize 函数。也就是需要向上取整，即 48&lt;52&lt;64，所以申请52byte，实际会分配64byte大小的内存。另外还需要了解： 如果每次创建一个对象，Go runtime都向计算机中申请一块内存，而在程序运行时是会频繁的创建对象的，这样效率将会大大降低。 所以程序会预先申请好一些内存块，其大小就是 8、16、32、48 等等，这样在程序申请内存时序就可以把申请好的内存选一块给我们，也就提高了效率 growslice的三个参数： 第一个是类型(上例中为int64)，第二个是扩容前切片a（元素为2和3），第三个参数是预估容量5（原有切片容量加上新加元素个数，即2+3=5） 对容量进行计算： 12345678910111213141516171819202122...newcap := old.cap //​ 此时newcap = 2doublecap := newcap + newcap // doublecap 为2+2=4if cap &gt; doublecap &#123; // cap=5 newcap = cap // 故而newcap 最终为5&#125; else &#123; if old.len &lt; 1024 &#123; newcap = doublecap &#125; else &#123; // Check 0 &lt; newcap to detect overflow // and prevent an infinite loop. for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123; newcap += newcap / 4 &#125; // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap &lt;= 0 &#123; newcap = cap &#125; &#125;&#125;... 又因为int64 类型大小为8字节，故而下面会走到et.size == sys.PtrSize:代码块 对于const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63):1234567891011121314package mainimport \"fmt\"func main() &#123; const PtrSize = 4 &lt;&lt; (^uintptr(0) &gt;&gt; 63) // unsafe.Sizeof(uintptr(0)) but an ideal const fmt.Println(\"uintptr(0)值为:\", uintptr(0)) fmt.Println(\"^uintptr(0)值为:\", ^uintptr(0)) // 对0取反，在64位操作系统得到18446744073709551615； uint64(所有无符号 64 位整数的集合)，范围：0 到 18446744073709551615。 fmt.Println(\"^uintptr(0) &gt;&gt; 63值为:\", ^uintptr(0)&gt;&gt;63) // 1 fmt.Println(\"PtrSize值为:\", PtrSize) // 4左移一位，即8&#125;执行结果为：1234uintptr(0)值为: 0^uintptr(0)值为: 18446744073709551615^uintptr(0) &gt;&gt; 63值为: 1PtrSize值为: 8 123456case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize //即 2*8=16 newlenmem = uintptr(cap) * sys.PtrSize // 即 2*8=16 capmem = roundupsize(uintptr(newcap) * sys.PtrSize) // 即5*8=40,经过roundupsize处理后为48 overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize //是否超出上限，此处为false，在Darwin Arm64上maxAlloc为281474976710656 newcap = int(capmem / sys.PtrSize) // 关键步骤，48/8=6，故而最终得到的新切片的cap为6 &lt;font size=1 color=”grey&gt;关于maxAlloc:12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"const GoarchArm64 = 1const GoarchMips = 0const GoarchMipsle = 0const GoarchWasm = 0const GoosIos = 0func main() &#123; // _64bit = 1 on 64-bit systems, 0 on 32-bit systems _64bit := 1 &lt;&lt; (^uintptr(0) &gt;&gt; 63) / 2 fmt.Println(\"_64bit值为：\", _64bit) heapAddrBits := (_64bit*(1-GoarchWasm)*(1-GoosIos*GoarchArm64))*48 + (1-_64bit+GoarchWasm)*(32-(GoarchMips+GoarchMipsle)) + 33*GoosIos*GoarchArm64 fmt.Println(\"heapAddrBits值为：\", heapAddrBits) // maxAlloc is the maximum size of an allocation. On 64-bit, // it's theoretically possible to allocate 1&lt;&lt;heapAddrBits bytes. On // 32-bit, however, this is one less than 1&lt;&lt;32 because the // number of bytes in the address space doesn't actually fit // in a uintptr. maxAlloc := (1 &lt;&lt; heapAddrBits) - (1-_64bit)*1 fmt.Println(\"maxAlloc值为：\", maxAlloc)&#125;输出为：123_64bit值为： 1heapAddrBits值为： 48maxAlloc值为： 281474976710656 更多参考： Go Slice Growth Golang 切片容量（cap）增长探秘 深度解密Go语言之Slice 搜关键字 roundupsize 讨论群中关于切片的一个问题 Go源码解读-切片slice Linux内核中有rounddown方法，取数的最高二进制阶数 取数的最高二进制阶数rounddown_pow_of_two","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"kubernetes为什么叫k8s","date":"2019-06-23T16:02:40.000Z","path":"2019/06/24/kubernetes为什么叫k8s/","text":"小伙伴赴云原生大会前夕，一起探讨畅聊了k8s相关内容。在听到其所说的某相关项目官网为prow.k8s.io，当即提出质疑。 我理解许多名词中的“数字谐音”，如“b2c”，“p2p”中的“two”代“to”，许多人邮箱如box4bob@gmail.com中的“four”代“for”。但kubernetes简写为k8s，我推测应该只是中国有此叫法，毕竟在英文中“8”是“eight”发不出“ba”这个音。 我这位运维小伙伴在此领域钻研精深，当即问我可知道“国际化”的简称“I18N”，作为一名开发，这自是难不倒我。i18n为取internationalization的首尾字母，18为首尾字母中间的字符数。同样的还有“本地化”L10N即localization。 但这个一般用于单词较长的名词，疑惑难道k8s也缘由此？那这样确实k8s是kubernetes在全世界范围内简称而非只局限于国内。 动用搜索，证明他说的完全正确。 技术名词命名，大抵有三种方式:一是“昨夜西风凋碧树”，直接以物命名，如java，shell，ruby;二则当是几个单词组合一起，取其首字母缀连，如php(原称Personal Home Page，现改名Hypertext Preprocessor)，BSD(Berkeley Software Distribution伯克利软件套件)，这种方式组成的单词大多无甚实际含义，而最精巧别致可遇难求的，是组合出的词恰有意思且极贴切，这点又要提到那个在搭建DNS服务器常用到的bind(Berkeley Internet Name Domain，又又又出自ucb)。三则如前所述i18n，l10n，k8s，这种多见于单个较长单词。 其实还有非常小众的第四种，即类似“3M”这样的命名法，如著名的Amazon S3 即Amazon Simple Storage Service。其几家国内竞品的命名多为第二种，如oss(Object Storage Service)，ecs(Elastic Compute Service)，cvm(Cloud Virtual Machine)。而S3总给我一种是S2升级款的错觉","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go语言context包","date":"2019-06-23T10:58:38.000Z","path":"2019/06/23/Go语言context包/","text":"在Go中,控制Goroutine有三种方式,即 WaitGroup &emsp; &emsp; 可通过go run -race main.go查看竞态信息 &emsp; &emsp; 详见: sync包-Waitgroup实现原理 Channel &emsp; &emsp; 详见; golang之channel入门 Context 本篇着重研究 Context Go 1.7中加入官方库,可概括为 一个接口,四种具体实现,六个函数 四个方法: emptyCtx 本质上是个整型,*emptyCtx对context接口的实现,只是简单返回nil,false等,实际上什么也没做. Background和TODO这两个函数内部都会创建emptyCtx, 其中 Background主要用于在初始化时获取一个Context; TODO用在 本来应该使用外层传递的context,而外层却没有传递的地方使用. cancelCtx 可取消的context. done用于获取该Context的取消通知.Children用户存储以当前节点为根节点的所有可取消的Context,以便在根节点取消时,可以把它们一并取消.err用于存储取消时指定的错误信息.mu则是用来保护这几个字段的锁,以保障cancelCtx是线程安全的. 而WithCancel可以将一个Context包装为cancelCtx,并提供一个取消函数,调用它可以Cancel对应的Context timerCtx 在cancelCtx的基础上,又封装了一个定时器和一个截止时间.这样既可以根据需要主动取消,也可以在到达deadline时,通过timer来触发取消动作.这个timer也会由cancelCtx.mu来保护,确保取消操作也是线程安全的. 通过WithDeadline和WithTimeout函数,都可以创建timerCtx.其区别是WithDeadline函数需要指定一个时间点,而WithTimeout函数接收一个时间段. 可取消的Context都会被注册到离它最近的,可取消的祖先节点中(会在children中增加一个键值对) ValueCtx 用来支持键值对打包. WithValue函数可以给Context附加一个键值对信息,这样就可以通过Context传递数据了. “Go 语言中的 context.Context 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。 在真正使用传值的功能时我们也应该非常谨慎，使用 context.Context 进行传递参数请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。” valueCtx之间通过Context字段形成了一个链表结构. 传递数据时还要注意,Context本身是本着不可改变(immutable)的模式设计的,所以不要试图修改ctx里保存的值. 在http,sql等相关的库中,都提供了对Context的支持,方便我们在处理请求时,实现超时自动取消,或传递请求相关的控制数据等等. 参考: 【Golang】Context了解下~ 【Golang】Context基础篇 设计思想: 多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。 在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 context.Background 作为起始的上下文向下传递。 参考自 : 上下文 Context Golang 之context库用法 注:以下内容参考自“码农桃花源”公众号,定位是其阅读笔记;作者对计算机程序 理解深刻洞若观火,推荐关注; context 包 主要用于在 goroutine 之间传递取消信号、超时时间、截止时间以及一些共享的值 划重点: context,译作“上下文”，准确说是 goroutine 上下文，包含 goroutine 的运行状态、环境等信息。 主要用来在 goroutine 之间传递(共享)上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。 几乎成为了并发控制和超时控制的标准做法。标准库许多方法都加上了context参数 总览: 图中标注I的是interface{},T的是struct{},m的为方法,\bλ的是函数; Go 语言坑爹的 WithCancel","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"记一次区块链技术沙龙","date":"2019-06-22T15:55:50.000Z","path":"2019/06/22/记一次区块链技术沙龙/","text":"在脸书推出Libra，比特币借势大涨10%再破1万美刀关口，这大半年极少参加活动的我，在家门口参加了一场区块链沙龙。问了几个问题，在此记录: 1).听闻某个打掉以太坊许多市值的漏洞，是借由整型溢出，当超出2的256次方时，会出现该问题。我疑惑无论go中的int64还是java中的long，皆占8个字节即64个比特位，即能最大表征2的64次方无符号整数，为什么这里说是2的256次方？ 解答是智能合约里常用的Solidity，整型最大范围是2的256次方，与主流编程语言有所差异。 2).限制btc们发展的一大瓶颈是其基于工作量计算实在太过耗时，实现不了微信支付宝们的秒付，而介绍中cita在不同场景下实现了2900笔/秒和15000笔/秒，是借由分布式做微服务实现的吗？一致性如何保证? 回答:主要不是，主要是修改了工作量证明的条约。原来一比交易需要全网50%以上算力证明，这是最耗时的。而许多场景，不需要这样高的级别和规格。有点像电影的分级制度。 3).脑洞大开一下，互联网像水和电一样嵌入一个现代人日常生活，改变了社会的方方面面，不啻一场革命。如果区块链果真也能称“一场革命”，那未来大概会与现在有何不同？还有法定货币吗？还需要公证处吗？还需要各种审计各种稽查吗？ 回答:法定货币不太可能消失，也许是多种形态共存，像现在电子支付和现金支付等并行。银行等怕被革命，倒逼改革，都密切关注着区块链。","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"<漫画算法>摘录","date":"2019-06-22T13:48:17.000Z","path":"2019/06/22/漫画算法-摘录/","text":"1.算法概述1.1 算法和数据结构1.2 时间复杂度1.1 空间复杂度 2.数据结构基础2.1 数组2.2 链表2.3 栈和队列2.4 散列表 3.树3.1 数和二叉树3.2 二叉树的遍历3.3 二叉堆3.4 优先队列 4.排序算法4.1 引言4.2 冒泡排序鸡尾酒排序4.3 快速排序4.4 堆排序4.5 计数排序和桶排序 5.面试中的算法5.1 踌躇满志5.2 判断链表有环5.3 最小栈的实现5.4 求最大公约数5.5 判断一个数是否为2的整数次幂5.6 无序数组排序后的最大相邻差5.7 用栈实现队列5.8 寻找全排列的下一个数5.9 删去k个数字后的最小值5.10 实现大整数相加5.11 求解金矿问题(背包问题)5.12 寻找缺失的整数 6.算法的实际应用6.1 上班第一天6.2 Bitmap的巧用使用bitset 6.3 LRU算法的应用6.4 A星寻路算法6.5 实现红包算法6.6 气有浩然,学无止境","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"TCP/IP还有三次挥手","date":"2019-06-20T16:02:33.000Z","path":"2019/06/21/TCP-IP还有三次挥手/","text":"https://www.zhihu.com/question/50646354 https://blog.csdn.net/zqz_zqz/article/details/79548381","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"抓包体验TCP四次挥手","date":"2019-06-19T16:01:52.000Z","path":"2019/06/20/抓包体验TCP四次挥手/","text":"TCP三次握手、四次挥手及状态转换详解 time_wait 和 close_wait","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"抓包体验TCP三次握手","date":"2019-06-17T13:47:54.000Z","path":"2019/06/17/抓包体验TCP三次握手/","text":"打开Wireshark,在过滤器中键入ip.addr==118.126.97.71, 访问www.dashen.tech,随后快速关闭. Transmission Control Protocol – 传输层是我们最为关心的; 第一次握手 本地ip192.168.31.192的51417端口(客户端),请求118.126.97.71的80端口(服务端); 同步位SYN有值为1,序号seq为x(一般情况均为0) 主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机； 第二次握手 118.126.97.71的80端口,请求192.168.31.192的51417端口; 从标志位看出，同步位、确认位有值，在做应答（SYN+ACK）：SYN 同步位为 1 、Acknowledgment 确认位为 1 主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包； 第三次握手 客户端再次发送确认包(ACK), SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方. 主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。 相关参考1 相关参考2 相关参考3 四次挥手可参考","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"制作python包并上传pypi","date":"2019-06-07T13:25:58.000Z","path":"2019/06/07/制作python包并上传pypi/","text":"平时写Python,需要用到一个新包时,习惯了pip install packageName,写多了就会想,这些包都是怎么来的?自己能不能”制作”一个,任何人也都可以通过pip安装? 有此想法,躬行实践.答案显然是肯定的,而且难度也绝没有想的那样大,或者说 It is easy. 1.编写代码如要制作的包名为dashen,新建如下目录结构 其中两个__init__.py为空即可 README.md写一些该package的介绍,非必选 your_func.py是具体的功能实现,在此示例如下: 12345678910def dashen_address(): print('www.dashen.tech')def dashen_master(): print('shuang.cui')def author_hometown(): print('山东邹平') setup.py内容如下: 12345678910111213141516171819202122232425262728293031323334import setuptoolswith open(\"README.md\",\"r\") as fh: long_description = fh.read()setuptools.setup( # 包的分发名称，使用字母、数字、_、- name=\"dashen\", # 版本号, 版本号规范：https://www.python.org/dev/peps/pep-0440/ version=\"0.0.1\", # 作者名 author=\"fliter\", # 作者邮箱 author_email=\"i@dashen.tech\", # 包的简介描述 description=\"我的第二个python包\", # 包的详细介绍(一般通过加载README.md) long_description=long_description, # 和上条命令配合使用，声明加载的是markdown文件 long_description_content_type=\"text/markdown\", # 项目开源地址 url=\"http://www.dashen.tech\", # 如果项目由多个文件组成，我们可以使用find_packages()自动发现所有包和子包，而不是手动列出每个包，在这种情况下，包列表将是example_pkg packages=setuptools.find_packages(), # 关于包的其他元数据(metadata) classifiers=[ # 该软件包仅与Python3兼容 \"Programming Language :: Python :: 3\", # 根据MIT许可证开源 \"License :: OSI Approved :: MIT License\", # 与操作系统无关 \"Operating System :: OS Independent\", ],) 2.账号注册及打包 注册Pypi 更新pip,setuptools和wheel pip install --upgrade pip setuptools wheel 切换到setup.py的同级目录,进行打包 python setup.py sdist 会出现两个新文件 3.上传 上传Pypi pip install twine(如果已经安装twine，跳过此步骤) python -m twine upload dist/*输入Pypi的账号及密码 4.查看及检验 完结,撒花","tags":[{"name":"Python","slug":"Python","permalink":"http://www.dashen.tech/tags/Python/"}]},{"title":"博客性能优化2--提升图片加载速度","date":"2019-05-20T03:13:09.000Z","path":"2019/05/20/博客性能优化2-提升图片加载速度/","text":"详细优化步骤,可参见笔记","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"博客性能优化","date":"2019-05-17T11:55:55.000Z","path":"2019/05/17/博客性能优化/","text":"打开页面较慢,体验较差,考虑优化; 分析一下,现阶段慢的原因主要有两个,一是部署在github,服务器在美国,国内访问较慢;二则是没有做动静分离,静态资源加速,某些图片较多的文章,加载完成十分缓慢; 对于问题一,先是考虑用国内提供pages服务的网站,如码云和coding;但折腾半天发现二者都很坑,码云想要使用自己域名,需要支付每年99元的费用;和腾讯云深度合作的coing,免费版则对单项目的大小有严苛限制 最后想到,自己有国内服务器,为什么不自己部署呢? 研究了一下hexo,大概在执行hexo g时,将你用markdown书写的内容,转换为html;而查看.gitignore得知,大多数目录都被忽略,最终”转换”好并传到github的是public目录下的文件,该目录下index.html即主入口文件. 搞清楚了这些,剩下的也就不困难了. nginx加几行配置,阿里云域名解析加条记录,稍加测试,确实(在国内访问)速度快好多; 但这样有个问题,每次在本地执行hexo g &amp;&amp; hexo d后,github上的代码为最新,但我的cvm服务器还需要git pull;写一个脚本如cvmpull.sh(并加入.gitignore).只需简单两行,登录服务器pull代码,记得给该脚本配置权限.下次写完再要发布时,执行hexo g &amp;&amp; hexo d &amp;&amp; ./cvmpull.sh 解决~ 再下一步,就是去解决图片过多加载慢的问题~","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"用shell批量修改文件名","date":"2019-05-17T11:14:21.000Z","path":"2019/05/17/用shell批量修改文件名/","text":"场景一 给这些文件都加上.torrent后缀 12345#!/bin/bashfor i in *;domv \"$i\" \"$i.torrent\";done 场景二 给某些文件按某种规则重命名,如按照1,2,3,4..命名,保留原格式 123456789101112cd imagedeclare -i j=1 for i in * ;do #echo $i; x=$&#123;i##*.&#125;#echo $j.$xmv \"$i\" \"$j.$x\";j+=1done 注: Shell中实现整数自增的几种方法示例,此处用于声明是数字类型的declare -i必须添加,否则会认为是字符串;必须j+=1,而不能用j++,否则结果会为拼接字符串 shell获取文件扩展名 场景三 删除某些重复文件;如下图,想将所有带(x)的全部删掉 123456789101112131415#!/bin/bashfor i in * ;do#echo $&#123;i:1:2&#125;; #最常用的字符串截取方法,输出前两个字符if [[ $i =~ '(' ]]then echo $i; rm \"$i\"; #如果用rm $i会分为两部分: #ia_800000110 (2).jpg #rm: ia_800000110: No such file or directory #rm: (2).jpg: No such file or directoryfidone 参考: Shell判断字符串是否包含小结 Shell处理带空格的文件名的方法 shell 如何判断某个文件名以某个字符开头","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"微信「面对面建群」的功能设计及其技术实现","date":"2019-05-12T15:27:50.000Z","path":"2019/05/12/微信「面对面建群」的功能设计及其技术实现/","text":"马德堡半球实验— &lt;关于微信面对面建群的功能设计及其技术实现&gt;于拱墅一条小吃街，与pre-workmate&amp;&amp;bosom friend，畅谈近况及在研究的技术。忽然想起白天用的“面对面建群”，一群素不相识的人需建一群聊。在此场景下如何快速实现？打印出二维码众人再扫显然不是最佳。平时极低频次使用的这个功能，应是最便捷方案。 但这个功能是怎么个规则？又是怎样的实现？听我抛出以下几点事实和疑问，他也心生好奇，脱下扒小龙虾的手套，摆弄手机，而我也放下正啃食的猪蹄，擦拭双手，开始实验。 1 . 这个四位数字可以人为指定，并不是随机生成。经测试，除去“1111”“2222”“1234”外皆可用，即大概有近9000种选择。 最初以为这个四位数随机生成，并没有认为真在“面对面”上做文章，即腾讯认为，其10 0000 0000用户，不太可能在同一时刻，有超过9000人在使用该功能。但后来发现可以人为指定数字后，此论述不成立。 如身在杭州的我,和远在加州的Mark打开微信该功能,同一时刻输入同一串约定好的四位数字,很显然,我们不可能进入同一个群聊. 2 . 完全陌生的一群人在相近距离内,能否通过该功能创建并进入同一群聊?简化来说,即两个生人之间,是否需要有一共同好友,才可进群? 即如诸葛亮认识孟获,诸葛亮也认识鲁肃,但鲁肃与孟获素未谋面,如果诸葛亮率先输入一串数字发起,孟获鲁肃二人应可通过同一串数字加入群聊.但关键问题就是,假如抛去诸葛亮这个节点,不是好友的二人直接使用该功能,能否成功? 答案是肯定的 3 . 我去街对面,再和好友测试该功能,可正常使用. 4 . 关闭GPS,再使用该功能,仍然正常(此处应是因为微信会记录未关闭GPS之前的位置,所以即便二人关闭定位,依据上一次的历史,看上去二人仍在相近位置) 小结 通过以上几次测试,可以得出,「面对面建群」确实使用了GPS来估算,一定地理范围如方圆500米内,同一时间使用该功能输入同一串数字的用户,会进入到群聊 相关可参考 还有几点疑惑可以探讨 “面对面”,这个具体的距离范围是多少? 群主产生的逻辑是什么? 我在居住的A地和朋友们用该功能输入8888建一群聊,一天后,我们在群里聊得正嗨,有一新同学前来,我让他输入8888进群.但与此同时,隔壁邻居家来了客人,也想通过该功能建一群聊,且巧合的是也偏爱8888.于是这时,我这位新来的朋友,最终加入的是哪个群聊? 设计为腾讯下发四位数字,而非用户指定,是不是更合理? 假如有一大型活动3万人参与,在八万人体育场甚至是诺坎普这样能容纳近10万人的巨大空间,需要3人一队,分成1万组,这时候如果使用该功能,是不是会一定发生紊乱?","tags":[]},{"title":"手把手带你体验最新Windows Terminal","date":"2019-05-11T14:54:13.000Z","path":"2019/05/11/手把手带你体验最新Windows-Terminal/","text":"&emsp;&emsp;每年5,6月都是科技界的”小春晚”,今年市值重回世界第一的微软,先于两位老对手,召开一年一度的开发者大会 Build 2019. &emsp;&emsp;估计几天前,程序员的朋友圈都被微软发布的最新终端Windows Terminal刷屏了. &emsp;&emsp;不多时,该项目便登上了github趋势榜榜首位置(前一阵占据头把交椅的一直是996.icu) &emsp;&emsp;更多介绍点此, Windows 全新终端 Windows Terminal &emsp;&emsp;然而,官方还没有发布正式版,要编译安装该工具,并没有想象的那样简单.甚至可以说,坑非常多 &emsp;&emsp;虽然转投Mac已近3年,用的顺风顺水,但看到号称能让程序员”从Mac叛逃”的工具,还是想上手亲测验证一波. 经过一番探索&amp;折腾,在此给出最简便体验该工具的方案. &emsp;&emsp;(提前预警,Windows10版本号需要是更新至最新的1903) 下面正式开始: 下载编译好的文件,提取码:7mux 运行如图文件 过程中可能会报错你需要为此应用包安装新证书，或者使用带受信任证书的新应用包。系统管理员或应用开发人员可以提供帮助。已处理证书链，但处理过程因根证书不受信任而终止 (0x800B0109),可参考此文步骤轻松解决 过了这个坎是新的沟,应用安装失败，错误消息: 由于程序包 Microsoft.WindowsTerminal_2019.5.6.0_x64__8wekyb3d8bbwe 与设备不兼容，Windows 无法安装该程序包。该程序包要求 Windows.Universal 设备系列运行操作系统版本 10、0、18362、0 或更高版本。该设备当前运行的操作系统版本为 10、0、17763、316。 (0x80073cfd) 这个报错是说需将windows版本从17763升级至18362,查看当前版本信息可通过该网站下载对应操作系统最新的版本,点此,对64位系统,可直接复制ed2k://|file|cn_windows_10_consumer_editions_version_1903_x64_dvd_8f05241d.iso|4905476096|F28FDC23DA34D55BA466BFD6E91DD311|/至迅雷或电骡下载. 经过漫长的下载,点击iso安装最新版本 然后便可一马平川安装体验~ po几张体验图片","tags":[]},{"title":"一种诡异的Linux磁盘空间被占满问题","date":"2019-05-11T06:07:23.000Z","path":"2019/05/11/一种诡异的Linux磁盘空间被占满问题/","text":"- 服务报错,提示没有足够磁盘空间. 登录服务器,使用df -h 查看磁盘空间使用率(此台为模拟,真实服务器使用率100%) 在根目录下使用du -sh *, 查看各文件夹大小, 发现其实这些文件加一起也占不到服务器磁盘空间40G的一半 (使用du -sh * | sort -rh命令,对各文件按大小排序,更加直观) (外记:du -h --max-depth=1,用于查看当前目录各文件占用大小) 看到 cannot access &#39;proc/4086/task/4086/fd/4&#39;: No such file or directory, 很自然想到会不是这里的问题,最后发现实际是一条歧路,/proc目录有时可能会很大,甚至140T,但这个数字既不是磁盘空间,也不是内存空间.可将该目录简单理解为一个”运行中心”,是一个位于内存中的伪文件系统(in-memory pseudo-file system).该目录下保存的不是真正的文件和目录,而是一些“运行时”信息.linux中许多工具的数据来源正是proc目录中的内容 更多关于/proc的信息,可参见如下: linux /proc目录下的文件为何无法用vi编辑保存 linux /proc目录下的文件为何无法用vi编辑保存 /proc/kcore文件特别大，感觉很不正常(几个解答都有问题) 总之,/proc几乎不占用磁盘空间或只占用极少的空间,可以忽略不计 - 继续追查,谷歌到很多类似症状,大概答案是: 通过rm或者文件管理器删除文件，只是将它会从文件系统的目录结构上解除链接(unlink)，也就是说只是删除了文件和系统目录结构的链接；如果文件在删除时是被打开的（有一个进程正在使用该文件，文件被进程锁定或者有进程一直在向这个文件写数据等）状态，那么进程将仍然可以读取该文件，也就是说没有删除掉文件在读取的状态，所以磁盘空间也就会一直被占用。 一个文件在文件系统中的存放分为两个部分：数据部分和指针部分，指针位于文件系统的meta-data中，数据被删除后，这个指针就从meta-data中清除了，而数据部分存储在磁盘中，数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容，之所以出现删除文件后，空间还没释放，就是因为有进程还在一直向这个文件写入内容，导致虽然删除了文件，但文件对应的指针部分由于进程锁定，并未从meta-data中清除，而由于指针并未被删除，那么系统内核就认为文件并未被删除，因此通过df命令查询空间并未释放也就不足为奇了。 使用lsof | grep deleted,果然是好几屏的 已删除文件的磁盘读写操作进程 参见: Linux磁盘空间查看、磁盘被未知资源耗尽 Linux磁盘空间被占用问题 (分区目录占用空间比实际空间要大: 资源文件删除后, 空间没有真正释放) 在我准备写shell, 用kill pid 杀死占用被删除文件的进程时,发现那台占用率100%的机器没有安装lsof(是的,lsof需要手动install).想删掉部分日志文件,给其腾出空间,发现刚删除立即yum install lsof,都会提示free空间为0 无奈重启服务器,再打开使用df -h查看磁盘使用率,然后一切正常… 8G/20G,约为20% 总结 重启服务器或kill pid方式都能解决该问题 记录排查&amp;解决这个问题中涉及到的一些命令及延伸lsof lsof命令使用详解(原创) Linux之lsof命令 用 lsof 替代 netstat 和 ps 查看文件大小&amp;&amp;排序 linux 查看磁盘空间大小 Linux文件大小排序 ll -h,输出的文件大小就是human可读的样式了","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"sync包-Mutex","date":"2019-05-08T15:46:49.000Z","path":"2019/05/08/sync包-Mutex/","text":"初入门径 // A Mutex is a mutual exclusion lock. Mutex是互斥锁 // The zero value for a Mutex is an unlocked mutex. 互斥锁的零值是未锁定的互斥锁 // A Mutex must not be copied after first use. 首次使用后不得复制Mutex mutual 英[ˈmjuːtʃuəl]美[ˈmjuːtʃuəl]adj. 相互的; 彼此的; 共有的; 共同的;[例句]The East and the West can work together for their mutual benefit and progress东西方可以为彼此共同的利益和发展而合作。exclusion 英[ɪkˈskluːʒn]美[ɪkˈskluːʒn]n. 排斥; 排除在外; 不包括在内的人(或事物); 被排除在外的人(或事物); 排除; 认为不可能;[例句]It calls for the exclusion of all commercial lending institutions from the college loan program它提倡将所有商贷机构排除在高校贷款计划之外。 源码实现 go中semaphore源码解读 Go精妙的互斥锁设计 golang-浅析mutex Go语言sync包的应用详解 semaphore 的原理与实现 Golang 语言中基础同步原语 Mutex 和 RWMutex 的区别 手摸手Go 并发编程基建Semaphore 缓存击穿导致 golang 组件死锁的问题分享 官方库或知名项目中的使用 参考: GO: sync.Mutex 的实现与演进 Golang同步机制的实现 golang-浅析mutex","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"不要通过共享内存来通信,而应该通过通信来共享内存","date":"2019-05-07T15:23:55.000Z","path":"2019/05/07/不要通过共享内存来通信-而应该通过通信来共享内存/","text":"原文见此.因为有墙,将其抄录在此,版权归Google所有 Share Memory By Communicating 13 July 2010 Traditional threading models (commonly used when writing Java, C++, and Python programs, for example) require the programmer to communicate between threads using shared memory. Typically, shared data structures are protected by locks, and threads will contend over those locks to access the data. In some cases, this is made easier by the use of thread-safe data structures such as Python’s Queue. Go’s concurrency primitives - goroutines and channels - provide an elegant and distinct means of structuring concurrent software. (These concepts have an interesting history that begins with C. A. R. Hoare’s Communicating Sequential Processes.) Instead of explicitly using locks to mediate access to shared data, Go encourages the use of channels to pass references to data between goroutines. This approach ensures that only one goroutine has access to the data at a given time. The concept is summarized in the document Effective Go (a must-read for any Go programmer): Do not communicate by sharing memory; instead, share memory by communicating. Consider a program that polls a list of URLs. In a traditional threading environment, one might structure its data like so:12345678910111213141516171819202122232425262728293031323334353637383940414243type Resource struct &#123; url string polling bool lastPolled int64&#125;type Resources struct &#123; data []*Resource lock *sync.Mutex&#125;And then a Poller function (many of which would run in separate threads) might look something like this:func Poller(res *Resources) &#123; for &#123; // get the least recently-polled Resource // and mark it as being polled res.lock.Lock() var r *Resource for _, v := range res.data &#123; if v.polling &#123; continue &#125; if r == nil || v.lastPolled &lt; r.lastPolled &#123; r = v &#125; &#125; if r != nil &#123; r.polling = true &#125; res.lock.Unlock() if r == nil &#123; continue &#125; // poll the URL // update the Resource's polling and lastPolled res.lock.Lock() r.polling = false r.lastPolled = time.Nanoseconds() res.lock.Unlock() &#125;&#125; This function is about a page long, and requires more detail to make it complete. It doesn’t even include the URL polling logic (which, itself, would only be a few lines), nor will it gracefully handle exhausting the pool of Resources. Let’s take a look at the same functionality implemented using Go idiom. In this example, Poller is a function that receives Resources to be polled from an input channel, and sends them to an output channel when they’re done. 1234567891011type Resource stringfunc Poller(in, out chan *Resource) &#123; for r := range in &#123; // poll the URL // send the processed Resource to out out &lt;- r &#125;&#125; The delicate logic from the previous example is conspicuously absent, and our Resource data structure no longer contains bookkeeping data. In fact, all that’s left are the important parts. This should give you an inkling as to the power of these simple language features. There are many omissions from the above code snippets. For a walkthrough of a complete, idiomatic Go program that uses these ides, see the Codewalk Share Memory By Communicating. By Andrew Gerrand","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"高精度向低精度转换问题","date":"2019-04-29T13:34:58.000Z","path":"2019/04/29/高精度向低精度转换问题/","text":"高精度向低精度转换，在计算机中会从最低位开始截取直到截取满低精度的精度范围为止; 1234func main()&#123; c := int16(2000) fmt.Println(int8(c))&#125; 结果为:1-48 Why is -48 ? int16范围为16个比特位所能表征的数量,即占两个字节;转换为二进制为 0000 0111 1101 0000; 类似的,int8占一个字节,只能表示8个比特位所能表征的数量;从高向低转换时,从右向左截取,即 1101 0000 带符号整数有原码、反码、补码等几种编码方式。原码即直接将真值转换为其相应的二进制形式，而反码和补码是对原码进行某种转换编码方式。正整数的原码、反码和补码都一样，负数的反码是对原码的除符号位外的其他位进行取反后的结果（取反即如果该位为0则变为1而该位為1则变为0操作）而补码是先求原码的反码，然后在反码的末尾位加1后得到结果，即补码是反码+1 此时这个值是补码,需先转换成原码，原码再转换成真值; 因为是有符号的int8而非uint8,1101 0000第一位为1,即负号, 正数的补码是自身(正数的反码补码原码都一样),负数的补码是原码的反码+1; 将该补码转换为原码,转为原码后再转为真值; 1 101 0000负数是除符号位之外取反然后 +1,1 010 1111 + 1得1 011 0000,即-(2^5 + 2^4) 得到 -48 更多可参见 注: 此篇最开始有一处错误,即1表示负,0表示正; 更多可搜索计算机补码的规则或可点击 更多为何负数用补码表示而不直接用原码表示,可点此以及此文","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Rust中的关键字","date":"2019-04-28T13:49:58.000Z","path":"2019/04/28/Rust中的关键字/","text":"严格关键字 as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名 async - 返回一个 Future 而不是阻塞当前线程( 2018版新增) await - 暂停执行直到 Future 的结果就绪( 2018版新增) break - 立刻退出循环 const - 定义常量或不变裸指针（constant raw pointer） continue - 继续进入下一次循环迭代 crate - 链接（link）一个外部 crate 或一个代表宏定义的 crate 的宏变量 dyn - 动态分发 trait 对象 else - 作为 if 和 if let 控制流结构的 fallback enum - 定义一个枚举 extern - 链接一个外部 crate 、函数或变量 false - 布尔字面值 false fn - 定义一个函数或 函数指针类型 (function pointer type) for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期 if - 基于条件表达式的结果分支 impl - 实现自有或 trait 功能 in - for - 循环语法的一部分 let - 绑定一个变量 loop - 无条件循环 match - 模式匹配 mod - 定义一个模块 move - 使闭包获取其所捕获项的所有权 mut - 表示引用、裸指针或模式绑定的可变性 pub - 表示结构体字段、impl 块或模块的公有可见性 ref - 通过引用绑定 return - 从函数中返回 Self - 定义或实现 trait 的类型的类型别名 self - 表示方法本身或当前模块 static - 表示全局变量或在整个程序执行期间保持其生命周期 struct - 定义一个结构体 super - 表示当前模块的父模块 trait - 定义一个 trait true - 布尔字面值 true type - 定义一个类型别名或关联类型 union - 定义一个 union 并且是 union 声明中唯一用到的关键字 use - 引入外部空间的符号 where - 表示一个约束类型的从句 while - 基于一个表达式的结果判断是否进行循环 保留关键字 以下关键字目前没有任何功能，不过由 Rust 保留以备将来使用 abstract become box do final macro override priv try typeof unsized virtual yield 弱关键字 unsafe - 表示不安全的代码、函数、trait 或实现 static 可以使用原始标识符的方式，做到使用这些关键字也能通过编译 原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 r# 前缀","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"被无视的小细节","date":"2019-04-28T13:13:25.000Z","path":"2019/04/28/被无视的小细节/","text":"最近要写一个web服务,对外提供几个Api,选用gin框架. gin的路由广泛为人好评,一直是”gin为什么这么快”的主角. 正在看其用到的httprouter的源码, 对这种特殊的trie树---基树树(Radix Tree),也有还不错的理解. ( httprouter包只有200多k,非常值得一看 ) 就在自以为洞若观火 高屋建瓴,写几个接口如是小菜一碟时,一个诡异的获取数据库资源句柄的问题扰了我许久,最后解开疑惑,哑然失笑. 这是随便一搜,从某处复制的代码, 我用的是pg, 这里是mysql,于是调试, 顺手把代码做了下面这样看似更”简洁”的改动 在initDatabase方法里调试,可以正常连接pg,获取到数据. 为使项目层次更清晰,使以后接口数量增多而不致混乱,对项目进行了常规的分层. 在model这个package里,如下图 调用刚才的pg连接句柄,发现每次拿到的都是nil 而再回initDatabase方法调试,没问题,可以获取到数据 这就让我感到疑惑… 不得已重新梳理了一下复制的那段代码的逻辑,发现忽略了一个细小知识点----全局变量,局部变量及变量的作用范围: 上述代码中,全局变量会在init()方法执行前被执行,而后执行init()及其调用到的子方法. 当在其他地方调用到这个package里的函数时(此处为GetEngine),上述两步一定会先执行,完成后才到调用到的函数 看下面这个demo,就一目了然 output: 1234姓名:CUISHUANG年龄:27手机号:17666666666薪资:30000 可长点记性吧! 看,薪资一下少了5万 具体到遇到的问题,当在model中调用该方法以期返回资源时, 先初始化全局变量(或者说赋值,虽然很多情况下是赋零值),而后执行init(),然后到子方法initDatabase, 先前的写法, 1DB, err = xorm.NewEngine(\"postgres\", addr) 是在修改全局变量DB,或者说,在initDatabase里操作的,和在外面定义是同一块内存. 而自以为”简约”地改为如下之后, 1DB, err := xorm.NewEngine(\"postgres\", addr) 相当于在一个方法里,重新定一个一个同名的局部变量,这个局部变量DB指向的内存,与外面的全局变量DB并不相同. 而最后调用GetEngine方法,返回的DB,还是最开始定义的那个全局变量,其并未经过initDatabase的赋值操作,故而还是初始化时的值.","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"Some useful tips for Goland","date":"2019-04-27T13:10:29.000Z","path":"2019/04/27/Some-useful-tips-for-Goland/","text":"1. control+tab 快速切换/选择文件 command+E,快速选择最近编辑的文件 2.插件 插件 Presentation Assistant 可以显示每个快捷键操作. 如果用Win,在使用某快捷键时,可以显示在Mac上对应的快捷键; 反之亦然. 3.F1 输入一段字符串, 当出现多个各种package里的函数, 出现好多种选择时,可以使用F1查看具体内容,会新开一个小窗口. 4.有用更多可视空间 左下角的按钮,可以收起侧边栏和底边栏的各种工具 按两次command+1,收起左侧项目文件区域 演示模式:会全屏且使字体非常大 免打扰模式:会只剩下代码 5.智能的补齐推荐 补齐推荐是按照光标所在的位置,而不是当前打出的字符 6.error.nn快速打出判断是否为nil的区块 在一个error类型的变量后用.nn,可以快速打出如下判别块. 123if error != nil &#123; &#125; 输入error.panic,会自动变为panic(err) 7.command+R 8.show intention action快捷键为Enter 9.查找帮助 或者按两下 shift,进行(万能)搜索 10.快速重构 选中某段代码,control+T,选method,会新生成一个方法,并把选中的代码移动过去.. 之后修改某些变量,选择第二项,也非常有用 11.y 选中某段代码,control+T,选method,会新生成一个方法,并把选中的代码移动过去.. 之后修改某些变量,选择第二项,也非常有用","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Innodb间隙锁,以及RR隔离级别下防止幻读现象","date":"2019-04-25T12:29:33.000Z","path":"2019/04/25/Innodb间隙锁-以及RR隔离级别下防止幻读现象/","text":"MySQL在Innodb存储引擎下默认的隔离级别为”Repeatable Read”,可以杜绝”脏读”和”不可重复读”,但无法防止”幻读”. 起初,我以为在RR隔离级别下,防止”幻读”现象出现的办法,是在第一个事务的查询语句后,加”for update”即排它锁,但实际不是如此. 间隙锁 MySQL InnoDB支持三种行锁定方式: 行锁（Record Lock）:记录锁, 简称行锁, 锁直接加在索引记录上面，锁住的是key。 间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而说的。 Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。 InnoDB的默认加锁方式是: Next-Key Lcok 默认情况下，InnoDB工作在可重复读(Repeatable Read)隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。 Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录时，会首先对索引记录加行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。 故而: Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。间隙锁不分什么共享锁与排它锁。 当对数据进行条件/范围检索时，对其范围内的值进行加锁！当查询的索引含有唯一属性（主键索引PRI或唯一索引UNI）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即降低为行锁，而不是锁定范围！若是普通辅助索引(MUL)，则会使用传统的next-key lock进行范围锁定！ ( 要禁止间隙锁的话，可以把隔离级别降为Read Committed，或开启参数innodb_locks_unsafe_for_binlog。) Innodb自动使用间隙锁的条件： （1）必须在Repeatable Read级别下 （2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加） 浅析Mysql的隔离级别及MVCC MVCC Multi-Version Concurrency Control,, 多版本并发控制, MVCC主要适用于Mysql的RC(已提交读),RR(可重复读)隔离级别下. InnoDB MVCC 机制，看这篇就够了 —力荐!!! 多版本并发控制(MVCC)在分布式系统中的应用","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"子网划分及子网掩码的计算","date":"2019-04-18T15:39:33.000Z","path":"2019/04/18/子网划分及子网掩码的计算/","text":"子网划分 ①A类：占有1个字节（8位），定义最高位为 0 来标识此类地址，余下7位为真正的网络地址，支持$2^7-2=126$个网络；后面3个字节（24位）为主机地址，所包含的主机数量为：$2^{24}-2$（减去2，其中一个是全0的地址，另一个是全1的地址）。A类网络地址第一个字节的十进制值为000~127。 ②B类：占有2个字节（16位），使用最高两位为 10 来标识此类地址，其余14位为真正的网络地址，支持$2^{14}-2$个网络；后面2个字节（16位）为主机地址，所包含的主机数量为：$2^{16}-2$。B类网络地址第一个字节的十进制值为128~191。 ③C类：占有3个字节（24位），它是最通用的Internet地址，使用最高三位为 110 来标识此类地址，其余21位为真正的网络地址，支持$2^{21}-2$个网络；后面1个字节（8位）为主机地址，所包含的主机数量为：$2^8-2$。C类网络地址第一个字节的十进制值为192~223。 ④D类：它的识别头是 1110，用于组播，例如用于路由器修改。D类网络地址第一个字节的十进制值为224~239。 ⑤E类：实验保留，其识别头是 1111。E类网络地址第一个字节的十进制值为240~255。 A类：网络 ID 的第一位以 0 开始的地址。 B类：网络 ID 的第一位以 10 开始的地址。 C类：网络ID的第一位以 110 开始的地址。 D类：地址以 1110 开始的地址。 E类：地址以 11110 开始的地址。 A类：IP 地址范围为 0.0.0.0～127.255.255.255。 B类：IP 地址范围为 128.0.0.0～191.255.255.255。 C类：IP 地址范围为 192.0.0.0～223.255.255.255。 D类：IP 地址范围为 224.0.0.0～239.255.255.255。 E类：IP 地址范围为 240.0.0.0～255.255.255.254。 接下来是一组图片赏鉴: 参考: 计算机网络笔记（第二部分） 计算机网络-网络层-笔记 IP地址分类（A类 B类 C类 D类 E类） 科普-IP地址详解-你,是谁？(二）-超有趣学网络 子网掩码 出现的原因 &amp; 存在的意义 32位IPV4地址被分为两部分，即网络号和主机号。为提高IP地址的使用效率，子网编址的思想是将主机号部分进一步划分为子网号和主机号： 即由 网络号—主机号, 再进一步变为：网络号—子网号—主机号 在原来的IP地址模式中，网络号部分就标识一个独立的物理网络, 引入子网模式后，网络号部分加上子网号才能全局唯一地标识一个物理网络。 子网编址使得IP地址具有一定的内部层次结构，这种层次结构便于IP地址分配和管理。它的使用关键在于选择合适的层次结构---如何既能适应各种现实的物理网络规模，又能充分地利用IP地址空间(即：从何处分隔子网号和主机号)。 互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成 网络号和主机号 两部分，从而实现 将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而浪费IP。 但 IP地址的网络号和主机号各是多少位呢？如果不指定，就不知道哪些位是网络号、哪些是主机号，这就需要通过子网掩码来实现。 子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分 故而 子网掩码不能单独存在，必须结合IP地址一起使用 才有意义 与IPV4地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示 假设IP地址为“192.168.1.1”, 子网掩码为“255.255.255.0”, 其中，“1”有24个，代表与此相对应的IP地址左边24位是网络号；“0”有8个，代表与此相对应的IP地址右边8位是主机号。这样，子网掩码就确定了这个IP地址的32位二进制数字中哪些是网络号、哪些是主机号。 这对于采用TCP/IP协议的网络来说非常重要，只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。 子网掩码计算实例 左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示 引入子网模式后,网络号部分加上子网号才能全局唯一地标识一个物理网络, 即 子网号部分 用1填充 例1. 将B类IP地址 168.195.0.0 划分成27个子网,子网掩码为多少? 因为B类IP地址中，前两个字节（16位）是网络号(net_id)，后两个字节（16位）是主机号(host_id)。 现将其划分成27个子网，即用若干个主机位来充当子网号。 取1个主机位，可以得到2个子网(因为一个bit有0,1两种情况)；取2个主机位，可以得到4个子网；取3个主机位，可以得到8个子网； 即所取主机位k与子网N的关系为：$2^k = N$（或者$2^k-2 = N$） 故而 27个子网需要取 5个主机位（$ 2^5 = 32 &gt; 27 $）。 所以将原来的网络号位置(即前16位)全部改为1，并且将后面的5个主机号也改为1，再将其转为十进制，即为子网掩码: 原来的IP地址 168.195.0.0 转化为二进制格式如下: 最终可得,子网掩码为 255.255.248.0 例2. 将B类IP地址 168.195.0.0 划分为若干子网,每个子网内有主机700台,则子网掩码为多少? 每个子网内有主机700台，根据所取主机位k与子网N的关系 $2^k = N（或者2^k - 2 = N）$， 此处需满足：$2^k ≥ 700$，解得：k=10。 所以对于这个B类IP地址，它的后10位就是主机号(这是算出来的)，而前面的16位都是网络号(这是B类IP的特点)，所以中间剩余的6位是 子网号,用1填充,其和之前的网络号(即前16位),一起构成新的网络号 最后将其转为十进制，即为子网掩码: 最终可得,子网掩码为 255.255.252.0 一般就是这种套路, 问 需要几个子网,或子网主机容量 A类网的IP址址最高位二进制不大于011开头，所以A类范围就是:1—127。 B类网的IP址址最高位二进制不大于101开头，所以B类范围就是:128—191。 C类网的IP址址最高位二进制不大于110开头，所以C类范围就是:192—223。 D类网的IP址址最高位二进制不大于1110开头，所以D类范围就是:224—239。 E类网的IP址址最高位二进制不大于1111开头，所以E类范围就是:240—255。 私网地址 A类地址:10.0.0.0~10.255.255.255 B类地址:172.16.0.0 ~172.31.255.255 C类地址:192.168.0.0~192.168.255.255 所以 10.19.7.7属于A类IP私有IP地址 IP地址和子网掩码进行与运算，结果就是真实的网络地址 (与运算: 全1为1，否则为0) IP地址和子网掩码的相关运算 IP地址、子网掩码、网络号、主机号、网络地址、主机地址 的计算方法 参考: 子网划分及子网掩码计算方法 软考——软件设计师：第九章：计算机网络与信息安全考点总结 ip地址及子网掩码换算，子网划分教程 实用工具: 网络和IP地址计算器","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"json.Marshal为什么会对[]byte类型进行base64编码处理？","date":"2019-04-18T11:37:00.000Z","path":"2019/04/18/json-Marshal为什么会对-byte类型进行base64编码处理？/","text":"tech-talk/tech/jsonByteSliWillBase64/ json Marshal默认对[]byte类型进行base64编码处理 base64.go:1234567891011121314151617181920212223242526272829303132package mainimport ( \"encoding/json\" \"fmt\")// golang json Marshal默认对[]byte类型进行base64编码处理(源码里有base64的逻辑)，Unmarshal时也只能用[]byte类型接收才能还原。(如果用interface&#123;&#125;接收，得到的是base64后的内容)type test1 struct &#123; X string Y []byte&#125;type test2 struct &#123; X string Y interface&#123;&#125;&#125;func main() &#123; a := test1&#123;X: \"geek\", Y: []byte(\"geek\")&#125; fmt.Println(\"原始的a:\", a) b, _ := json.Marshal(a) fmt.Println(\"经过Marshal之后得到的b:\", string(b)) var c test1 var d test2 json.Unmarshal(b, &amp;c) json.Unmarshal(b, &amp;d) fmt.Println(\"Unmarshal 上面得到的b，之前的[]byte字段用[]byte接收:\", c) fmt.Println(\"Unmarshal 上面得到的b，之前的[]byte字段用interface&#123;&#125;接收:\", d)&#125; 输出： 1234原始的a: &#123;geek [103 101 101 107]&#125;经过Marshal之后得到的b: &#123;\"X\":\"geek\",\"Y\":\"Z2Vlaw==\"&#125;Unmarshal 上面得到的b，之前的[]byte字段用[]byte接收: &#123;geek [103 101 101 107]&#125;Unmarshal 上面得到的b，之前的[]byte字段用interface&#123;&#125;接收: &#123;geek Z2Vlaw==&#125; src/encoding/json/encode.go 1234567891011121314151617181920212223242526272829func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts) &#123; if v.IsNil() &#123; e.WriteString(\"null\") return &#125; s := v.Bytes() e.WriteByte('\"') encodedLen := base64.StdEncoding.EncodedLen(len(s)) if encodedLen &lt;= len(e.scratch) &#123; // If the encoded bytes fit in e.scratch, avoid an extra // allocation and use the cheaper Encoding.Encode. dst := e.scratch[:encodedLen] base64.StdEncoding.Encode(dst, s) e.Write(dst) &#125; else if encodedLen &lt;= 1024 &#123; // The encoded bytes are short enough to allocate for, and // Encoding.Encode is still cheaper. dst := make([]byte, encodedLen) base64.StdEncoding.Encode(dst, s) e.Write(dst) &#125; else &#123; // The encoded bytes are too long to cheaply allocate, and // Encoding.Encode is no longer noticeably cheaper. enc := base64.NewEncoder(base64.StdEncoding, e) enc.Write(s) enc.Close() &#125; e.WriteByte('\"')&#125; 在 json.Unmarshal时也有类似反向处理，src/encoding/json/decode.go： 为什么要这样做？ []byte 始终被编码为 base64，而不是直接做为utf8字符串输出。因为不是所有的byte都是合法的utf8字符 一些随机二进制字节序列是无效的 UTF-8 编码。因此，您不能将随机二进制字节序列解释为某些 UTF-8 数据，因为它将是无效的 UTF-8 编码.在 JSON 中，控制字符, &quot; 和 \\ 不允许出现在字符串中。因此二进制数据需要进行一些转换才能正确编码。JSON 不允许一些 ASCII 字符。 ASCII 的 33 个控制字符（[0..31] 和 127）以及 “ 和 \\ 必须排除。这只剩下 128-35 = 93 个字符 JSON 格式本身不支持二进制数据。 必须对二进制数据进行转义，以便可以将其放入 JSON 中的字符串元素 The problem with UTF-8 is that it is not the most space efficient encoding. Also, some random binary byte sequences are invalid UTF-8 encoding. So you can’t just interpret a random binary byte sequence as some UTF-8 data because it will be invalid UTF-8 encoding. The benefit of this constrain on the UTF-8 encoding is that it makes it robust and possible to locate multi byte chars start and end whatever byte we start looking at.As a consequence, if encoding a byte value in the range [0..127] would need only one byte in UTF-8 encoding, encoding a byte value in the range [128..255] would require 2 bytes ! Worse than that. In JSON, control chars, “ and \\ are not allowed to appear in a string. So the binary data would require some transformation to be properly encoded.Let see. If we assume uniformly distributed random byte values in our binary data then, on average, half of the bytes would be encoded in one bytes and the other half in two bytes. The UTF-8 encoded binary data would have 150% of the initial size.Base64 encoding grows only to 133% of the initial size. So Base64 encoding is more efficient.What about using another Base encoding ? In UTF-8, encoding the 128 ASCII values is the most space efficient. In 8 bits you can store 7 bits. So if we cut the binary data in 7 bit chunks to store them in each byte of an UTF-8 encoded string, the encoded data would grow only to 114% of the initial size. Better than Base64. Unfortunately we can’t use this easy trick because JSON doesn’t allow some ASCII chars. The 33 control characters of ASCII ( [0..31] and 127) and the “ and \\ must be excluded. This leaves us only 128-35 = 93 chars.So in theory we could define a Base93 encoding which would grow the encoded size to 8/log2(93) = 8*log10(2)/log10(93) = 122%. But a Base93 encoding would not be as convenient as a Base64 encoding. Base64 requires to cut the input byte sequence in 6bit chunks for which simple bitwise operation works well. Beside 133% is not much more than 122%.This is why I came independently to the common conclusion that Base64 is indeed the best choice to encode binary data in JSON. My answer presents a justification for it. I agree it isn’t very attractive from the performance point of view, but consider also the benefit of using JSON with it’s human readable string representation easy to manipulate in all programming languages.If performance is critical than a pure binary encoding should be considered as replacement of JSON. But with JSON my conclusion is that Base64 is the best. Java也是这样，提供了DatatypeConverter 使用base64编码后会使数据增大1/3，这里有讨论有没有更好的方式 binary-data-in-json-string-something-better-than-base64 Go-Json编码解码 –赞","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"重学js","date":"2019-04-16T15:17:33.000Z","path":"2019/04/16/重学js/","text":"一些’奇技淫巧’ 将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位 12b = -2.9 | 0;console.log(b); 结果为-2 对一个整数连续两次二进制否运算，得到它自身。对一个小数连续进行两次二进制否运算，也能达到取整效果(使用二进制否运算取整，是所有取整方法中最快的一种。) 1234c = ~~-7;console.log(c);d = ~~-3.14;console.log(d); 结果为-7,-3 “异或运算”有一个特殊运用，连续对两个数x和y进行三次异或运算，x^=y; y^=x; x^=y;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。(这是Js里互换两个变量的值最快的方法。) 12345678x = 10;y = 99;x ^= y;y ^= x;x ^= y;console.log(x,y); 结果为99,10 异或运算也可以用来取整 12f = 12.9 ^ 0;console.log(f); 结果为12 左移运算符（&lt;&lt;）表示将一个数的二进制值向左移动指定的位数，尾部补0，最后的结果(统一转换为十进制来表示),等于其十进制数乘以2的指定次方 右移运算符（&gt;&gt;）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动）。 头部补零的右移运算符（&gt;&gt;&gt;）与右移运算符（&gt;&gt;）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。 一些’坑’ ‘5’ + ‘1’ 结果为6 ‘5’ + 1 结果为’51’,而不是6; ‘5’ + true为’5true’而不是6 true - 1为0 ‘5’ * []为0 null + 1为1 undefined + 1 为NaN","tags":[{"name":"前端","slug":"前端","permalink":"http://www.dashen.tech/tags/前端/"}]},{"title":"将十进制数转化为ipv4","date":"2019-04-14T14:15:29.000Z","path":"2019/04/14/将十进制数转化为ipv4/","text":"有十进制数c=1766948540,如何得出其对应的ipv4地址? 可将该十进制数c转为二进制数,如小于32位,前面用0补全;再划分为4等块,对每一块二进制数转化为10进制,中间用.分隔,得到的字符串即为十进制数c对应的ipv4 手算结果如下:(得出一个31位的二进制数,在最左边补齐一个0) 用代码实现: 12345678910111213141516171819202122232425func f2() &#123; i := 1766948540 s2 := strconv.FormatInt(int64(i), 2) l := len(s2) if l &lt; 32 &#123; s2 = fmt.Sprintf(\"%032s\", s2) //01101001 01010001 01111110 10111100 &#125; a1 := string(s2[0:8]) //01101001 a2 := string(s2[8:16]) //01010001 a3 := string(s2[16:24]) //01111110 a4 := string(s2[24:32]) //10111100 //二进制转十进制 d1, _ := strconv.ParseInt(a1, 2, 64) d2, _ := strconv.ParseInt(a2, 2, 64) d3, _ := strconv.ParseInt(a3, 2, 64) d4, _ := strconv.ParseInt(a4, 2, 64) ipv4 := fmt.Sprintf(\"%d\", d1) + \".\" + fmt.Sprintf(\"%d\", d2) + \".\" + fmt.Sprintf(\"%d\", d3) + \".\" + fmt.Sprintf(\"%d\", d4) fmt.Println(ipv4)&#125; 当然还有其他实现方法可参考,如下: 1234567891011121314151617func IntToCidr(intip uint64) string &#123; segIp1 := intip &amp; 0xFF000000 segIp1 = segIp1 &gt;&gt; 24 segIp2 := intip &amp; 0x00FF0000 segIp2 = segIp2 &gt;&gt; 16 segIp3 := intip &amp; 0x0000FF00 segIp3 = segIp3 &gt;&gt; 8 segIp4 := intip &amp; 0x000000FF ip1 := strconv.FormatUint(segIp1, 10) ip2 := strconv.FormatUint(segIp2, 10) ip3 := strconv.FormatUint(segIp3, 10) ip4 := strconv.FormatUint(segIp4, 10) return ip1 + \".\" + ip2 + \".\" + ip3 + \".\" + ip4&#125; 如xxxxxx&lt;&lt;2即左移2位,将最左边两位去掉,剩余部分向左移动两位,最右边空余两位用0补齐 或 12345678910func IntToIpv4()&#123; i:= 1766948540 fmt.Println(byte(i &gt;&gt; 24)) fmt.Println(byte(i &gt;&gt; 16)) fmt.Println(byte(i &gt;&gt; 8)) fmt.Println(byte(i)) &#125; 结果:123410581126188","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"两载回眸","date":"2019-04-13T14:35:37.000Z","path":"2019/04/13/两载回眸/","text":"『结束第一份工作两周年』 我在落英缤纷的桃花港，在鸥鸟翔集的海鸥路，踯躅往复，痴痴想念着那一天，仙霞路的彩云与落霞。 再有半个月，更确切地说，是在28号之后，我在杭时间将超过魔都，成为有生26年来，除去家乡小城和大学四年某省会，所呆最久一地；且对飘蓬落定的我，终有一天它会超过生养我的家乡，成为久居终老之所。回瞰近两年，技艺飞涨，薪资提升，结束漂泊，落户安居，我不能说有什么遗憾和不满。但毫不夸张，不带矫情，我分明更留恋和回味上海那两年，虽是蜗居密室，虽是薪水微薄，虽是天天凌晨前后回去休憩，纵是常捉襟见肘，买件酷爱的电子设备要瞻前顾后，但却有对明天无限的期待和愿景，有兴冲冲浇不灭的劲头和源源不竭的内力，有永远生猛下去什么也锤不倒的豪情魄力… 按说比之魔都并不让我感冒的高档商场，这里的山色湖光更具吸引，而被我吐槽的公共交通尤其地铁，也在一日千里发展且技术设备更好更新。但在无人深夜漫步余杭塘河沿时，我还是时常想起苏州河畔的斑斓灯火，仙霞路的片片云朵和工技大外墙茂盛的爬山虎，也许是我妥协没在魔都扎根做了逃兵，也许是那里有我工作之初最是真挚的早期同事和回忆，也许更是那里有血脉亲属可以常聚 交心倾诉。… 也或许，是对时光大河一去不返的悲哀，我拼搏数年沮丧发现，努力不可或缺但机遇权重更大，我不再有看不到顶的无限可能了，不能再自视甚高甚以南阳岗卧龙自居了。而更可能只是中规中矩。 我不再能轻盈如昔年往常，也不再动力满满。尤是姥姥姥爷先后高龄辞世那几月，最小接受ｔａ们最多关爱，却无暇回馈万一，一度让我心灰意颓，我的世界不再圆满，我的拼搏还有何意义？…这个执念一度缠绕我许久，虽然明知逝者最是希望我能释怀能笑口常开。 明天太阳升起，还是会精神满满前去工作学习，改用一位朋友状态，“为了爱，为了父母，为了爱自己的人和自己爱的人，为了在和不在的人，为了书写自己的故事。更为了能在历史的长河中，用蘸了自来水的笔留下自己淡淡的一点“。 曾有梦，还有梦。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"将ipv4转成十进制数","date":"2019-04-10T15:47:36.000Z","path":"2019/04/10/将ipv4转成十进制数/","text":"阅读本文前,细致浏览此文以及粗略速览ipv4和无类域间路由效果更佳 本文涉及算法很简单,更多更有价值之处是此间过程和来龙去脉. 前言IPV4由4个Byte组成,每个Byte有8个Bit,每个Bit有0/1两种情况,也即32位0/1字符串(IPV6由128位组成);但为了显示直观方便记忆,会将4个Byte分开,将每个Byte的值转成10进制,中间用”.”拼接,也就成了平时常见的IPV4地址(这样也不太容易记忆,于是后来就用字符（域名，例如：www.dashen.tech）来表示IP地址,每次请求时,通过DNS服务器,将字符（域名）解析成IP地址) 科普一下:把一个比特位Bit想象成一个坑,这个坑里只能放0或者1;一个字节Byte有8个比特位,则一个字节可以表征多少种不同情况?&amp;nbsp&amp;nbsp很显然,根据乘法原理,是2x2x2x2x2x2x2x2即2的8次方即256种情况,中学学过二进制与十进制的转换,二进制00000000和11111111之间的256个不同值,对应十进制0到255. 于是,对于任意一串32位的二进制数,都可以转换为ipv4的形式,如对”01101001 01010001 01111101 00101010”,可以分别计算每段对应的十进制数字,中间用”.”分隔,即105.81.125.42 对于IDC部门,划分到的IP地址是一个区间,如从上面的”01101001 01010001 01111101 00101010”(记为a),到”01101001 01010001 01111111 00101000”(记为b),转换为ipv4即是”105.81.125.42”到105.81.127.40”, Step1:理论基础那问题来了,如何判断某个ipv4地址,如”105.81.126.188”,在不在这个区间范围内? 制定这套规则,做出这套转换的人类,当然能判断得出,但对于计算机,变成ipv4这个鬼样子格式,已经无法”一眼识别”. 解决办法也很直观,即将ipv4格式转化为原本的二进制,如对”105.81.126.188”,其对应的二进制值为”01101001 01010001 01111110 10111100”(记为c);此时即可以判断,c是否在[a,b]区间范围内. 但人类还是不习惯二进制比较大小,于是会将a,b,c全部转为10进制再做比较, 对于a对应的十进制数为1766948138,b为1766948648,c为1766948540,现在,人类能够读懂,c在[a,b]之间. 进制转换可借助此网站快速实现,戳此直达 (注意去掉中间可能存在的空格) 具体到代码层面,可借助位运算符实现快速进制转换, 123456789101112131415161718192021222324252627282930313233package mainimport ( \"strings\" \"strconv\" \"fmt\")func main() &#123; rs := CidrToInt(\"105.81.126.188\") fmt.Println(rs)&#125;func CidrToInt(ip string) uint64 &#123; ipSegement := strings.Split(ip, \".\") segment1, _ := strconv.ParseUint(ipSegement[0], 10, 64) segment2, _ := strconv.ParseUint(ipSegement[1], 10, 64) segment3, _ := strconv.ParseUint(ipSegement[2], 10, 64) segment4, _ := strconv.ParseUint(ipSegement[3], 10, 64) intip := uint64(0) intip = intip + (segment1 &lt;&lt; 24) intip = intip + (segment2 &lt;&lt; 16) intip = intip + (segment3 &lt;&lt; 8) intip = intip + segment4 return intip&#125; 结果为: 1766948540 该网站功能背后其实就是这么个方法~ 关于位运算: 多说几句,实际位操作符,就是将数字左/右移动n位,然后在原位置补0;位操作符操作得到的是原数字对应的二进制数如xxxxxx&lt;&lt;2即左移2位,将最左边两位去掉,剩余部分向左移动两位,最右边空余两位用0补齐 Step2:应用实践现在我们可以通过ipv4地址对应的十进制数,直接在浏览器地址栏进行访问,以访问百度为例, DNS解析服务器会将域名baidu.com解析到IPV4地址220.181.57.216,通过该地址访问实际更为直接. 现在我们将其转换为10进制数,将结果放在地址栏,看是否”更为直接” 将3702864344复制到地址栏,如期望跳到了百度. 借助如上所提进制转换网站, 我们同样可通过其对应的补码之后的8进制和16进制数进行访问, 试试在地址栏键入0033455234730和0xdcb539d8 实际上,leetcode第751题,疑似就是这么个问题,但不知为何这道题被”消失”了,或许是太简单了 如有兴趣,我们再写一个方法,将对应的十进制数转换为ipv4格式~详见下篇","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"相亲帖?诈骗帖?不,其实是招聘帖","date":"2019-04-04T13:35:58.000Z","path":"2019/04/04/相亲帖-诈骗帖-不-其实是招聘帖/","text":"别说话,看图 step 1 第一关不费吹灰,顺利淌过~ step 2然而,如同数学数列或解析几何压轴题,第一问只是开胃甜点;真正的正餐,都留在最后 思路历程: 我原来想 算出6541367999以内所有的质数,然后遍历相乘,记下乘积落在6541367000-6541367999之间的因数,即为所求…时间复杂度为O(n的平方) 但实际操作,发现获取1000万以内的所有质数,电脑cpu就已经300%多了,不要说获取到10亿数量级;和RSA加密算法的理论基石 —- 分解大(质)数没有有效方法一样,如何高效率获取更大的质数,实际也是一个难题,这也是关系到算法安全性的核心问题.(受前一阵黎曼猜想的影响,此处不需要叙述太多) 用最传统获取质数的方式,获取50万以内所有质数,用时100秒;获取50到100万以内所有质数,则用时280秒… 其实对于golang,还有一种精巧的获取质数的方法,即利用go语言独特的协程优势;创始三巨头之一曾经演示. 更多可戳此查看 强攻亦可,但感觉这不是最普遍路数;反过头来再看一遍问题 先来看这样一个问题: 对于两个质数a,b，有c=ab，能否找到两个与a,b都不相等的质数x,y，使得c=xy？ 初步判断是不能，但该怎样简洁地证明？假设存在这样的质数x,y，要推出a,b不可能为质数 戳此查看更多 即设c为6541367000到6541367999之间的任一整数,a,b为两个质数,且有c=ab,则不存在与a,b都不同的质数x,y,使得c=xy 如果c为如上区间内偶数,则a,b至少一个为偶数,而偶数不为质数;即若满足a,b均为质数,且c=ab,则c不可能为偶数. 综上,对6541367000到6541367999之间的所有奇数进行遍历,对每一个数,用第一问中方法进行处理,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func main() &#123; i := 6541367001 for i &lt; 6541367999 &#123; f3(i) i = i + 2 &#125;&#125;// IfPrime 是否是质数func IfPrime(value int) (bool) &#123; end := int(math.Sqrt(float64(value))) for i := 2; i &lt;= end; i++ &#123; if value%i == 0 &#123; return false &#125; &#125; return true&#125;func f3(bigint int) &#123; //取这个数的算数平方根,向上取整,结果记为a; //用这个大质数去除2,3,4...一直到a(其实此处可以优化,只除2到a之间的质数即可,不需全部都除) //当恰好被整除时,此时的除数和商即为结果 max := math.Sqrt(float64(bigint)) a, _ := math.Modf(max) m := make(map[int]int) for i := 2; i &lt;= int(a); i ++ &#123; if bigint%i == 0 &#123; if IfPrime(i) &amp;&amp; IfPrime(bigint/i)&#123; m[i] = bigint / i &#125; //if len(m) &gt;= 3 &#123; // break //&#125; &#125; &#125; if len(m) &gt; 0 &#123; fmt.Println(\"对于大整数\", bigint) fmt.Println(\"分可分解为如下两个质数的乘积:\", m) fmt.Println(\"\\n\") &#125;&#125; 结果如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510对于大整数 6541367003分可分解为如下两个质数的乘积: map[23:284407261]对于大整数 6541367005分可分解为如下两个质数的乘积: map[5:1308273401]对于大整数 6541367011分可分解为如下两个质数的乘积: map[37:176793703]对于大整数 6541367017分可分解为如下两个质数的乘积: map[41:159545537]对于大整数 6541367023分可分解为如下两个质数的乘积: map[5419:1207117]对于大整数 6541367037分可分解为如下两个质数的乘积: map[3:2180455679]对于大整数 6541367039分可分解为如下两个质数的乘积: map[14177:461407]对于大整数 6541367043分可分解为如下两个质数的乘积: map[3:2180455681]对于大整数 6541367053分可分解为如下两个质数的乘积: map[13:503182081]对于大整数 6541367059分可分解为如下两个质数的乘积: map[20359:321301]对于大整数 6541367061分可分解为如下两个质数的乘积: map[3:2180455687]对于大整数 6541367071分可分解为如下两个质数的乘积: map[31:211011841]对于大整数 6541367077分可分解为如下两个质数的乘积: map[7:934481011]对于大整数 6541367113分可分解为如下两个质数的乘积: map[53:123422021]对于大整数 6541367117分可分解为如下两个质数的乘积: map[17:384786301]对于大整数 6541367127分可分解为如下两个质数的乘积: map[3:2180455709]对于大整数 6541367135分可分解为如下两个质数的乘积: map[5:1308273427]对于大整数 6541367137分可分解为如下两个质数的乘积: map[73:89607769]对于大整数 6541367141分可分解为如下两个质数的乘积: map[23:284407267]对于大整数 6541367153分可分解为如下两个质数的乘积: map[11839:552527]对于大整数 6541367159分可分解为如下两个质数的乘积: map[37:176793707]对于大整数 6541367167分可分解为如下两个质数的乘积: map[4231:1546057]对于大整数 6541367169分可分解为如下两个质数的乘积: map[3:2180455723]对于大整数 6541367171分可分解为如下两个质数的乘积: map[2089:3131339]对于大整数 6541367173分可分解为如下两个质数的乘积: map[11:594669743]对于大整数 6541367177分可分解为如下两个质数的乘积: map[19:344282483]对于大整数 6541367179分可分解为如下两个质数的乘积: map[24439:267661]对于大整数 6541367189分可分解为如下两个质数的乘积: map[7:934481027]对于大整数 6541367201分可分解为如下两个质数的乘积: map[2857:2289593]对于大整数 6541367207分可分解为如下两个质数的乘积: map[40819:160253]对于大整数 6541367239分可分解为如下两个质数的乘积: map[11:594669749]对于大整数 6541367241分可分解为如下两个质数的乘积: map[3:2180455747]对于大整数 6541367257分可分解为如下两个质数的乘积: map[31:211011847]对于大整数 6541367267分可分解为如下两个质数的乘积: map[409:15993563]对于大整数 6541367277分可分解为如下两个质数的乘积: map[3:2180455759]对于大整数 6541367289分可分解为如下两个质数的乘积: map[3:2180455763]对于大整数 6541367293分可分解为如下两个质数的乘积: map[32707:199999]对于大整数 6541367297分可分解为如下两个质数的乘积: map[263:24872119]对于大整数 6541367309分可分解为如下两个质数的乘积: map[331:19762439]对于大整数 6541367311分可分解为如下两个质数的乘积: map[883:7408117]对于大整数 6541367317分可分解为如下两个质数的乘积: map[55901:117017]对于大整数 6541367323分可分解为如下两个质数的乘积: map[241:27142603]对于大整数 6541367341分可分解为如下两个质数的乘积: map[5107:1280863]对于大整数 6541367353分可分解为如下两个质数的乘积: map[52901:123653]对于大整数 6541367359分可分解为如下两个质数的乘积: map[137:47747207]对于大整数 6541367369分可分解为如下两个质数的乘积: map[97:67436777]对于大整数 6541367379分可分解为如下两个质数的乘积: map[3:2180455793]对于大整数 6541367413分可分解为如下两个质数的乘积: map[7:934481059]对于大整数 6541367419分可分解为如下两个质数的乘积: map[269:24317351]对于大整数 6541367421分可分解为如下两个质数的乘积: map[3:2180455807]对于大整数 6541367429分可分解为如下两个质数的乘积: map[73:89607773]对于大整数 6541367431分可分解为如下两个质数的乘积: map[53:123422027]对于大整数 6541367433分可分解为如下两个质数的乘积: map[3:2180455811]对于大整数 6541367439分可分解为如下两个质数的乘积: map[3:2180455813]对于大整数 6541367447分可分解为如下两个质数的乘积: map[6203:1054549]对于大整数 6541367451分可分解为如下两个质数的乘积: map[3:2180455817]对于大整数 6541367459分可分解为如下两个质数的乘积: map[11:594669769]对于大整数 6541367461分可分解为如下两个质数的乘积: map[947:6907463]对于大整数 6541367471分可分解为如下两个质数的乘积: map[5839:1120289]对于大整数 6541367473分可分解为如下两个质数的乘积: map[1013:6457421]对于大整数 6541367477分可分解为如下两个质数的乘积: map[157:41664761]对于大整数 6541367479分可分解为如下两个质数的乘积: map[89:73498511]对于大整数 6541367483分可分解为如下两个质数的乘积: map[7:934481069]对于大整数 6541367485分可分解为如下两个质数的乘积: map[5:1308273497]对于大整数 6541367489分可分解为如下两个质数的乘积: map[67049:97561]对于大整数 6541367491分可分解为如下两个质数的乘积: map[17:384786323]对于大整数 6541367497分可分解为如下两个质数的乘积: map[7:934481071]对于大整数 6541367501分可分解为如下两个质数的乘积: map[19081:342821]对于大整数 6541367503分可分解为如下两个质数的乘积: map[11:594669773]对于大整数 6541367521分可分解为如下两个质数的乘积: map[13:503182117]对于大整数 6541367523分可分解为如下两个质数的乘积: map[3:2180455841]对于大整数 6541367531分可分解为如下两个质数的乘积: map[83:78811657]对于大整数 6541367541分可分解为如下两个质数的乘积: map[3:2180455847]对于大整数 6541367545分可分解为如下两个质数的乘积: map[5:1308273509]对于大整数 6541367551分可分解为如下两个质数的乘积: map[47:139178033]对于大整数 6541367557分可分解为如下两个质数的乘积: map[19:344282503]对于大整数 6541367563分可分解为如下两个质数的乘积: map[97:67436779]对于大整数 6541367577分可分解为如下两个质数的乘积: map[3:2180455859]对于大整数 6541367597分可分解为如下两个质数的乘积: map[431:15177187]对于大整数 6541367599分可分解为如下两个质数的乘积: map[13:503182123]对于大整数 6541367603分可分解为如下两个质数的乘积: map[37:176793719]对于大整数 6541367605分可分解为如下两个质数的乘积: map[5:1308273521]对于大整数 6541367609分可分解为如下两个质数的乘积: map[7:934481087]对于大整数 6541367611分可分解为如下两个质数的乘积: map[11497:568963]对于大整数 6541367617分可分解为如下两个质数的乘积: map[113:57888209]对于大整数 6541367619分可分解为如下两个质数的乘积: map[3:2180455873]对于大整数 6541367627分可分解为如下两个质数的乘积: map[17:384786331]对于大整数 6541367649分可分解为如下两个质数的乘积: map[3:2180455883]对于大整数 6541367663分可分解为如下两个质数的乘积: map[58049:112687]对于大整数 6541367669分可分解为如下两个质数的乘积: map[71:92131939]对于大整数 6541367681分可分解为如下两个质数的乘积: map[443:14766067]对于大整数 6541367689分可分解为如下两个质数的乘积: map[1693:3863773]对于大整数 6541367707分可分解为如下两个质数的乘积: map[7:934481101]对于大整数 6541367719分可分解为如下两个质数的乘积: map[9421:694339]对于大整数 6541367727分可分解为如下两个质数的乘积: map[3:2180455909]对于大整数 6541367731分可分解为如下两个质数的乘积: map[9887:661613]对于大整数 6541367743分可分解为如下两个质数的乘积: map[971:6736733]对于大整数 6541367747分可分解为如下两个质数的乘积: map[19:344282513]对于大整数 6541367761分可分解为如下两个质数的乘积: map[10709:610829]对于大整数 6541367765分可分解为如下两个质数的乘积: map[5:1308273553]对于大整数 6541367771分可分解为如下两个质数的乘积: map[79801:81971]对于大整数 6541367773分可分解为如下两个质数的乘积: map[211:31001743]对于大整数 6541367793分可分解为如下两个质数的乘积: map[3:2180455931]对于大整数 6541367795分可分解为如下两个质数的乘积: map[5:1308273559]对于大整数 6541367829分可分解为如下两个质数的乘积: map[3:2180455943]对于大整数 6541367843分可分解为如下两个质数的乘积: map[113:57888211]对于大整数 6541367845分可分解为如下两个质数的乘积: map[5:1308273569]对于大整数 6541367851分可分解为如下两个质数的乘积: map[1567:4174453]对于大整数 6541367857分可分解为如下两个质数的乘积: map[19309:338773]对于大整数 6541367871分可分解为如下两个质数的乘积: map[3:2180455957]对于大整数 6541367873分可分解为如下两个质数的乘积: map[541:12091253]对于大整数 6541367879分可分解为如下两个质数的乘积: map[61:107235539]对于大整数 6541367883分可分解为如下两个质数的乘积: map[3:2180455961]对于大整数 6541367887分可分解为如下两个质数的乘积: map[8681:753527]对于大整数 6541367901分可分解为如下两个质数的乘积: map[3:2180455967]对于大整数 6541367909分可分解为如下两个质数的乘积: map[49109:133201]对于大整数 6541367915分可分解为如下两个质数的乘积: map[5:1308273583]对于大整数 6541367921分可分解为如下两个质数的乘积: map[11:594669811]对于大整数 6541367923分可分解为如下两个质数的乘积: map[23:284407301]对于大整数 6541367927分可分解为如下两个质数的乘积: map[47:139178041]对于大整数 6541367929分可分解为如下两个质数的乘积: map[487:13431967]对于大整数 6541367933分可分解为如下两个质数的乘积: map[17:384786349]对于大整数 6541367951分可分解为如下两个质数的乘积: map[97:67436783]对于大整数 6541367959分可分解为如下两个质数的乘积: map[7:934481137]对于大整数 6541367963分可分解为如下两个质数的乘积: map[13:503182151]对于大整数 6541367971分可分解为如下两个质数的乘积: map[331:19762441]对于大整数 6541367989分可分解为如下两个质数的乘积: map[13:503182153]对于大整数 6541367995分可分解为如下两个质数的乘积: map[5:1308273599] 到此大功告成,攻破魔塔最顶层; 等等,先看看网上, 这是不是和多年前,遍布大城小邑街头巷尾的”重金求子”广告有异曲同工之处?… 依据哥多年来经验,倒也不绝对是诈骗帖,而更像是招聘帖… 就像这样 后记其实这里还有一个”半素数”的概念,如上这些大整数,都是半素数 本人长期对大质数分解,非对称加密等有浓厚兴趣,欢迎探讨新思路&amp;方法; 可加微信: cuimoman 非套路,有图有真相:","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"mtr命令","date":"2019-03-28T14:16:07.000Z","path":"2019/03/28/mtr命令/","text":"Mac使用此命令需先安装,推荐使用brew install mtr 如下使用该命令测试到谷歌 DNS服务器 的连通性 具体含义: 第一列:显示的是IP地址，这点和traceroute很像 第二列:是显示的每个对应IP的丢包率 第三列:Snt:10 设置每秒发送数据包的数量，默认值是10, 可以通过参数 -c来指定。其中-c+是：–report-cycles COUNT 第四列:显示的最近一次的返回时延 第五列:平均值 ,发送ping包的平均时延 第六列:是最好或者说是延迟最短的 第七列:是最差或者说是延迟最长的 第八列:是标准偏差","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"排序算法汇总","date":"2019-03-26T15:51:11.000Z","path":"2019/03/26/排序算法汇总/","text":"十大经典排序算法 生成一串无序的随机数: 长度为15,范围在0-1000之间 12345678910111213141516171819202122package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; var length = 15 var list []int // 以时间戳为种子生成随机数，保证每次生成的数据不重复 r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; length; i++ &#123; list = append(list, r.Intn(1000)) &#125; fmt.Println(list)&#125; 各大算法 的 时间复杂度及稳定性: 注: 希尔排序的平均时间复杂度应该为n的1.5次方,上图有误 冒泡排序的时间复杂度为O(n的平方),即如果要比较的元素n=5,就需要25次比较; 当n=10000时,将急剧飙升到1亿次比较. 计算机科学家对排序,这一基本算法的研究和优化,从未停止. 对于时间复杂度为O(n的平方)和O(n乘以log以2为底n的对数)的排序算法(此处以冒泡排序和快速排序为例),其需要比较的次数和差距如上图,即: 当10个数排序时,冒泡需比快排多比较3倍;当100个数排序时,冒泡需比快排多比较15倍;当1000个数排序时,冒泡需比快排多比较100倍;当10000个数排序时,冒泡需比快排多比较750倍;当100000个数排序时,冒泡需比快排多比较6000倍; (直接)插入排序插入排序 Shell排序希尔排序 直接选择排序直接选择排序 堆排序堆排序 冒泡排序冒泡排序 快速排序快速排序 20行代码(8行递归,12行排序&amp;取枢轴点) 归并排序归并排序 扩展阅读: sort包源码分析 找工作知识储备(3)A—从头说12种排序算法：原理、图解、动画视频演示、代码以及笔试面试题目中的应用","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"reflect包连缀","date":"2019-03-26T11:21:10.000Z","path":"2019/03/26/reflect包连缀/","text":"姊妹篇: 反射 Golang类型断言 1.reflect.TypeOf(argument).Kind() == reflect.String有一个interface{}类型的切片,输出其中所有string类型的值及其索引 123456sli := []interface&#123;&#125;&#123;\"1213\", 3456, 7867, \"hao\", \"city\"&#125;for argNum, arg := range sli &#123; if reflect.TypeOf(arg).Kind() == reflect.String &#123; fmt.Printf(\"第%d个元素%s为string类型\\n\",argNum,arg) &#125;&#125; 输出为: 123第0个元素1213为string类型第3个元素hao为string类型第4个元素city为string类型 如果直接reflect.TypeOf(arg).Kind() == &quot;string&quot;,则会报错 1mismatched type Kind and string 这么直接粗暴地写是不行滴~ 参考: 深入Go语言 - 13 Go Reflect 性能 源码剖析 Golang 反射应用及源码分析 example_test.go中的几个测试用例: ExampleKind: 实现简单的类型判断 ExampleMakeFunc: 传入任意类型的两个参数,实现这两个参数之间的交换 ExampleStructTag:读取结构体定义的tag信息 ExampleStructTag_Lookup:tag的查找 ExampleTypeOf: 判断一个结构体是否实现了某个接口 ExampleStructOf: 两个slice(或map/struct)直接比较是不被允许的, 使用DeepEqual可以比较,如果元素一一对应,则为true 函数调用 https://github.com/KippaZou/learn-reflection/blob/main/function_call.go 一些用到反射的包 proto reflect sqlx scanAll testify 反射三大定律 The Laws of Reflection Reflection goes from interface value to reflection object. Reflection goes from reflection object to interface value. To modify a reflection object, the value must be settable. whimsical benchmark reflect benchmark reflect 阅读材料 反射","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"正是江南好风景","date":"2019-03-22T14:46:07.000Z","path":"2019/03/22/正是江南好风景/","text":"当我从齿颊的沉湎迷醉中片刻脱身，不经意透过窗棂阻隔，看到高悬着的清幽的月，刹那浮现的竟是”今夜鄜州月”。而起身看到所剩实在吃不下的五常稻米，犹带余温香气四溢，又自然想起系出同一人的另一诗作: 山晚浮云合，归时恐路迷。 涧寒人欲到，村黑鸟应栖。 野客茅茨小，田家树木低。 旧谙疏懒叔，须汝故相携。 白露黄粱熟，分张素有期。 已应舂得细，颇觉寄来迟。 味岂同金菊，香宜配绿葵。 老人他日爱，正想滑流匙。 几道泉浇圃，交横落慢坡。 葳蕤秋叶少，隐映野云多。 隔沼连香芰，通林带女萝。 甚闻霜薤白，重惠意如何。 (佐还山后寄三首) 这位一生尊崇诸葛，梦想致君尧舜却沉郁下僚的落魄文人，满身心兴冲冲回长安，又被诡谲的朝局侮弄，一气辞官下秦州，却生计无着，诗作即是向颇有家产的族侄杜佐”摧粮”的借条。 笔落不曾惊风雨，却是实实在在于不可能处做文章。”老人他日爱，正想滑流匙。…甚闻霜薤白，重惠意如何”，寥寥几句，一把年纪读书人的潦倒,脸面和无奈，跃然于上。 多年前，声望财富达到顶峰的乔布斯不无真挚地表示，愿用自己一切，换取和苏格拉底共处一个下午的机会。我理解这种千秋异代不同时而缘悭一面的遗憾，如我草芥，不也多次希望能成怪胎牛顿的小书童，成”不务正业”的徐宏祖仆役牵马坠蹬？ 假如有天超越光速回到过去的”时空旅行”成为可能，当也有机会和这位时常处温饱之下的落魄诗人相见，一个必须思考的问题，是选择在他哪个阶段相遇？是少年豪气会当凌绝顶时的飞龙在天，还是困守长安白头搔更短时的密云不雨，或是艰难苦恨写就古今七律第一时的履霜冰至羝羊触蕃？ 少时如日之方升气魄凌云，暮年则碰壁连连甚有消极抑郁。但如可选，我还是想不远千里去湘江上的那艘破败孤舟。诗人写就”吴楚东南坼乾坤日夜浮”不久，便断炊漂于江面，偶得牛肉而吃坏肚子即将撒手尘世。他一生不曾得志，不同于与他齐名的那位生前身后都潇洒不羁的李十二名动天下有一干小粉，他垂暮之年临去之时，也默默知之者不多，一定是自认loser，带着失意而去。 我只正襟危坐实言相告，你可知千年后，一个晚辈青年，在菜酣饭饱后的夜晚，在月下花间的江南好风景里，妄图跨越时空阻隔终究逢君不得，只好遥遥想起那个吾庐独破那个白露黄米的前辈。 不消几十年，青年会皓首卧床不起，会成齑粉归于尘土，但只要这个国家文化不绝，哪怕不可避免遭遇焚书破旧式的浩劫动荡，只要文字未灭，只要太阳和月亮还会正常起降，就还会有新一批的青年少年，摇头晃脑读着三吏三别，想象着尊敬并崇拜着几千年前那个生前困顿的糟老头子。 屈平辞赋悬日月，楚王台榭空山丘。想想吧，古往今来，究竟有哪个帝王将相巨贾贵胄，曾享有你这等与日月同辉的殊荣？","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"理解go import时的下划线","date":"2019-03-19T14:07:40.000Z","path":"2019/03/19/理解golang-import时的下划线/","text":"Go中”_”(下划线)，可简单理解为”舍弃/不使用”,如对某个未使用的变量a, _=a后就不会报unused的错误,这个简明易懂无甚好说; 当import包时,在包前加_,仅调用包中的初始化函数即init(),而不会使用(也没法使用)包中其他函数/方法,如对当前文件1.go,import _”github.com/go-sql-driver/mysql”,并不能调用其中的方法,仅仅是完成了初始化. 这几个字如何理解?又怎样实现? 就这么个简单的问题,通过搜索很难得出再进一步的理解,大多是复制粘贴,制造数字垃圾. 经过动手躬行,得出了以下理解: 对于1.go,在执行main.go之前,会先执行_”github.com/go-sql-driver/mysql”的init()函数 写一个demo如图 回到之前举的import _”github.com/go-sql-driver/mysql”这个包的例子,尝试搞清楚它具体做了啥,初始化完成了什么; 这个包里的driver.go引入了”database/sql”和”database/sql/driver”两个包,sql.Register(“mysql”, &amp;MySQLDriver{}),这步即对sql包做了修改，把mysql的驱动加了进去 关于此包更深层次的实现,即怎样把mysql驱动加了进去,择日有时间再研究 其实在golang中,下划线(underscore)大致有4种用途 除去上面提到的两种,还可以 用在变量 1234type T struct&#123;&#125;var _ I = T&#123;&#125;其中 I为interface 上面用来判断 type T是否实现了I,用作类型断言，如果T没有实现借口I，则编译错误. 用在入参或出参时, 省略某些变量的名称 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; fmt.Println(f1(1, 3, 5, 7, 9)) m, n, p, q := f2() fmt.Println(m, n, p, q)&#125;func f1(a, b, c, d, _ int) string &#123; return fmt.Sprintf(\"四个数的和为:%d\", a+b+c+d)&#125;func f2() (x, y int, _ string, total bool) &#123; x = 271828 y = 314159 total = false return x, y, \"爽哥\", total&#125; 结果为: 12四个数的和为:16271828 314159 爽哥 false","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go调度器GPM","date":"2019-03-19T13:28:26.000Z","path":"2019/03/19/Go调度器GPM/","text":"参考: Golang源码探索(二) 协程的实现原理 Goroutine调度机制 Go 调度器 深入Go语言 - 8 golang 在 runtime 中的一些骚东西 1.基础 1.1 关于运行时 Go的运行时(runtime)管理着调度(scheduler)、垃圾回收(GC)以及goroutine的运行环境,此篇只探讨调度 Go的运行时负责运行goroutine, 并把它们映射到操作系统的线程(thread,包含在进程之中, 是进程中的实际运作单位, 是独立调度和分派的基本单位)上。goroutine比线程还轻量, 启动的时候花费很少. 每个goroutine都是由一个 G 结构来表示，这个结构体的字段用来跟踪此goroutine的栈(stack)和状态， 所以可以认为G = goroutine runtime 管理着 G 并把它们映射到Logical Processor(称之为P ). P 可以看作是一个抽象的资源或者一个上下文，它需要获取以便操作系统线程(称之为 M )可以运行 G。通过1runtime.GOMAXPROCS (numLogicalProcessors)可以控制多少P可以获取操作系统运行线程，线程运行你的代码。Go的技巧是编译器会在Go运行时的一些地方插入系统调用，（如通过channel发送值,调用runtime包等），所以Go可以通知调度器执行特定的操作。—2. GPM之间的交互 G :Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。P :Processor，是一个抽象的概念，代表了Machine所需的上下文环境(context)，是处理用户级代码逻辑的处理器。可译为”逻辑处理器”，G只有绑定到P上才可以被调度，存放Goroutine队列（local runqueue），P的数量决定了系统真正可并行的最大G数量，P的数量由GOMAXPROCS()决定。M :Machine Thread, 指go语言对一个关联的内核线程的封装。 OS线程，G所依赖的系统级线程，亦即真正执行计算的资源，M里面维护了小对象内存，当前执行的goroutine，以及其他很多信息。Local Runqueue :本地运行队列由P所维护的G队列，每次从local runqueue中取出可执行的GoroutineGlobal Runbqueue :全局运行队列由go调度器所维护的全局G队列，当Local Runqueue中没有G的时候，P就会从Global Runqueue中取出可执行的GGo运行时 存在两种类型的queue： 一种是一个全局的queue(在schedt结构体中，很少用到)， 一种是每个 P 都维护自己的 G 的queue。为了运行goroutine, M 需要持有上下文 P 。M 会从 P 的queue弹出一个goroutine并执行。当你创建一个新的goroutine的时候(go func())，它会被放入 P 的queue。当然还有一个 work-stealing调度算法，当 M 执行了一些 G 后,如果它的queue为空，它会随机的选择另外一个 P ,从它的queue中取走一半的 G 到自己的queue中执行。(偷..)当你的goroutine执行阻塞的系统调用时(syscall)，阻塞的系统调用会中断(intercepted)，如果当前有一些 G 在执行，运行时会把这个线程从 P 中摘除(detach)，然后再创建一个新的操作系统的线程(如果没有空闲的线程可用的话)来服务于这个 P 。当系统调用继续的时候，这个goroutine被放入到本地运行queue，线程会park它自己(休眠)， 加入到空闲线程中。如果一个goroutine执行网络调用，运行时会做类似的动作。调用会被中断，但是由于Go使用集成的network poller,它有自己的线程，所以还给它。Go运行时会在下面的goroutine被阻塞的情况下运行另外一个goroutine：- blocking syscall (for example opening a file),- network input,- channel operations,- primitives in the sync package.—3.Goroutine调度机制 3.1 GPM都是如何被创建出来 G :在可执行函数前面加关键字go即可，这样便创建出了一个Goroutine，创建出的Goroutine会进入P所维护的Local RunqueueP :指定GOMAXPROCS之后，会在程序运行之初创建好对应数目的PM :当满足以下三个条件以后，M就会被创建：1.队列中G太多2.系统级线程M太少3.有空闲的P 3.2 M和P之间的调度 P是在程序运行之初就创建好的，数量由GOMAXPROCS决定（最大256个），从go1.5以后默认即CPU的核数，1.5之前默认是一个。P绑定到M上执行运算，当一个OS线程也就是一个M陷入阻塞的时候，会释放出P，P转而寻找另一个M（M可能是被新创建，也可能来自于线程缓存），继续执行其他G，如果没有其他的idle M，但是P的local runqueue中仍有G需要执行，就会创建一个新的M。 当上述阻塞完成后，G会尝试寻找一个idle的P进入它的Local Runqueue中恢复执行，如果没有找到，G就会进入Global Runqueue，等待其他P从队列中取出。 对M&amp;P的调度有了一个大概了解后，再继续深入理解上述的阻塞，什么情况下会阻塞呢？如下： blocking syscall (for example opening a file) network input (已通过netpoller实现了网络I/O阻塞不会导致M被阻塞，仅阻塞G) channel operations primitives in the sync package 这四种场景又可以分为两种类型： 用户态阻塞与唤醒 当goroutine因为channel操作或者network I/O而阻塞时（实际上golang已经用netpoller实现了goroutine网络I/O阻塞不会导致M被阻塞，仅阻塞G，这里仅仅是举个例子），对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，而M会跳过该G尝试获取并执行下一个G，如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态；当阻塞的G被另一端的G2唤醒时（比如channel的可读/写通知），G被标记为runnable，尝试加入G2所在P的runnext，然后再是P的Local队列和Global队列。 系统调用阻塞 当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态，此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。 3.3 P和G之间的调度 G维护在P所维持的Local Runqueue以及调度器维持的Global Runqueue中。 一、首先需要搞清楚Local Runqueue的入队出队操作。 出队:首先讲出队，每次执行一个G，P会从Local Runqueue中获取一个G执行，此为出队操作。 入队:每次用go关键字创建出来的Goroutine会进入P的Local Runqueue中，包括上述用户态阻塞后被唤醒的G的操作为入队操作。 其次当一个P的Local Runqueue中没有可供执行的G后，该P会随机从其他P的队列中拿一半的G出来，这叫work stealing算法，这又是另一种入队出队操作。 二、然后讲Global Runqueue的入队出队操作 入队:当M所运行的阻塞状态的G重新唤醒后，如果没有获取到空闲的P，这个G就会进入Global Runqueue中，此为入队。 出队:其他P没有可执行的G之后描绘直接从Global Runqueue中取，此为出队。 总结：P调度G的时候，首先从P的Local Runqueue中获取G， 如果Local Queue中没有的话，就从Global Runqueue中获取， 如果Global Runqueue中也没有的话，就随机从其他P的Local Runqueue中偷一半的G出来。 P相当于在G和M之间加了一个中间处理层,是一个broker,更直白说,像个拉皮条的,撮合无数的G和有限的M 4. 跟踪调试 12345678910111213141516171819202122232425262728package mainimport ( \"sync\" \"time\")func main() &#123; var wg sync.WaitGroup print(\"123...\") wg.Add(1) go func() &#123; print(\"567...\") time.Sleep(2e9) wg.Done() &#125;() wg.Wait() print(\"789...\")&#125; Go可以跟踪运行时(runtime)的调度器(scheduler)，是通过 GODEBUG 环境变量实现的: 1$ GODEBUG=scheddetail=1,schedtrace=1000 ./program 注意输出使用了 G、M 和P的概念以及它们的状态， 比如P的queue的大小。 输出为: 12345678910111213141516171819202122232425262728293031323334SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=3 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0 P0: status=1 schedtick=0 syscalltick=0 m=0 runqsize=1 gfreecnt=0 P1: status=1 schedtick=0 syscalltick=0 m=2 runqsize=0 gfreecnt=0 P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 M2: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1 M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1 M0: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=1 G1: status=1() m=-1 lockedm=0 G2: status=1() m=-1 lockedm=-1 G3: status=1() m=-1 lockedm=-1 G4: status=1() m=-1 lockedm=-1123...567...SCHED 1008ms: gomaxprocs=4 idleprocs=4 threads=5 spinningthreads=0 idlethreads=3 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0 P0: status=0 schedtick=1 syscalltick=1 m=-1 runqsize=0 gfreecnt=0 P1: status=0 schedtick=3 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 M4: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1 M3: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1 M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1 M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1 M0: p=-1 curg=6 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1 G1: status=4(semacquire) m=-1 lockedm=-1 G2: status=4(force gc (idle)) m=-1 lockedm=-1 G3: status=4(GC sweep wait) m=-1 lockedm=-1 G4: status=4(GC scavenge wait) m=-1 lockedm=-1 G5: status=4(sleep) m=-1 lockedm=-1 G6: status=3() m=0 lockedm=-1789... 如果你不想关心这些细节，可以使用： 1$ GODEBUG=schedtrace=1000 ./program 输出为: 12345SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0]123...567...SCHED 1002ms: gomaxprocs=4 idleprocs=4 threads=5 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]789... 更多参考: Scheduler Tracing In Go 除此,还可以使用golang自己的工具 go tool trace, 它有一个UI, 用来查看程序和运行时的状况. 更多值得一读: Golang调度器源码分析 Goroutine与GMP模型 30+张图讲解：Golang调度器GMP原理与调度全分析 大神是如何学习 Go 语言之调度器与 Goroutine 第 64 期深入浅出 Golang Runtime GC 的认识 Golang 的 goroutine 是如何实现的？ 更多关于netpoller 值得一看: Go 为什么这么“快” A.) Goroutine 非常轻量，主要体现在以下两个方面： 1.上下文切换代价小： Goroutine 上下文切换只涉及到三个寄存器(PC / SP / DX)的值修改;而对比线程的上下文切换则需要涉及模式切换(从用户态切换到内核态)、以及 16 个寄存器、PC、SP…等寄存器的刷新; 2.内存占用少：线程栈空间通常是 2M，Goroutine 栈空间最小 2K;Golang 程序中可以轻松支持10w 级别的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。 B.) 为了更加充分利用线程的计算资源，Go 调度器采取了以下几种调度策略： 任务窃取(work-stealing) 实际执行时有的 Goroutine 运行的快，有的慢，那势必带来的问题是，忙的忙死，闲的闲死，Go 肯定不允许摸鱼的 P 存在，势必要充分利用好计算资源。 为了提高 Go 并行处理能力，调高整体处理效率，当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。 减少阻塞 如果正在执行的 Goroutine 阻塞了线程 M 怎么办?P 上 LRQ 中的 Goroutine 会获取不到调度么? 在 Go 里面阻塞主要分为一下 4 种场景： (1).由于原子、互斥量或通道操作调用导致 Goroutine 阻塞，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine; (2).由于网络请求和 IO 操作导致 Goroutine 阻塞，这种阻塞的情况下，G 和 M 又会怎么做呢? Go 程序提供了网络轮询器(NetPoller)来处理网络请求和 IO 操作的问题，其后台通过 kqueue(MacOS)，epoll(Linux)或 iocp(Windows)来实现 IO 多路复用。 通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载。 … (3).当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器(NetPoller)无法使用，而进行系统调用的 Goroutine 将阻塞当前 M。 例如: 同步系统调用(如文件 I/O)会导致 M 阻塞的情况：G1 将进行同步系统调用以阻塞 M1。 调度器介入后：识别出 G1 已导致 M1 阻塞，此时，调度器将 M1 与 P 分离，同时也将 G1 带走。然后调度器引入新的 M2 来服务 P。此时，可以从 LRQ 中选择 G2 并在 M2 上进行上下文切换。 阻塞的系统调用完成后：G1 可以移回 LRQ 并再次由 P 执行。如果这种情况再次发生，M1 将被放在旁边以备将来重复使用。 (4).在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。 Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。 只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。 协程(此处的协程指用户线程”co-routine”)跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。 老的调度器只有一个全局的G队列, 取用时需要加全局的互斥锁; 后来引入了P, 有了local sequence之后, global sequence的作用就被弱化了","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"golang实现链表及常用操作","date":"2019-03-17T14:34:47.000Z","path":"2019/03/17/golang实现链表及常用操作/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"找出一段英文文本中出现次数最多的10个单词","date":"2019-03-09T11:39:32.000Z","path":"2019/03/09/找出一段英文文本中出现次数最多的10个单词/","text":"10年前,中本聪在第一个区块里写了那句著名的话”The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.（2009 年 1 月 3 日，财政大臣正处于实施第二轮银行紧急援助的边缘）”,用这句话的出处,&lt;泰晤士报&gt;头版那篇报道的全文为例. 关于这句话 比特币十周年：创世块隐藏了什么秘密？ &lt;泰晤士报&gt;全文 以及这个神奇的网站 全文如下: Chancellor Alistair Darling on brink of second bailout for banks Francis Elliott, Deputy Political Editor, and Gary Duncan, Economics Editor Billions may be needed as lending squeeze tightensAlistair Darling has been forced to consider a second bailout for banks as the lending drought worsens.The Chancellor will decide within weeks whether to pump billions more into the economy as evidence mounts that the Â£37 billion part-nationalisation last year has failed to keep credit flowing. Options include cash injections, offering banks cheaper state guarantees to raise money privately or buying up âtoxic assetsâ, The Times has learnt.The Bank of England revealed yesterday that, despite intense pressure, the banks curbed lending in the final quarter of last year and plan even tighter restrictions in the coming months. Its findings will alarm the Treasury.The Bank is expected to take yet more aggressive action this week by cutting the base rate from its current level of 2 per cent. Doing so would reduce the cost of borrowing but have little effect on the availability of loans.Under one option, a âbad bankâ would be created to dispose of bad debts. The Treasury would take bad loans off the hands of troubled banks, perhaps swapping them for government bonds. The toxic assets, blamed for poisoning the financial system, would be parked in a state vehicle or âbad bankâ that would manage them and attempt to dispose of them while âdetoxifyingâ the main-stream banking system.The idea would mirror the initial proposal by Henry Paulson, the US Treasury Secretary, to underpin the American banking system by buying up toxic assets. The idea was abandoned, ironically, when Mr Paulson decided to follow Britainâs plan of injecting cash directly into troubled banks.Mr Darling, Gordon Brown and Lord Mandelson, the Business Secretary, are expected to take the final decision on what extra help to give the banks by the end of the month.The banks have taken much of the heat for the economyâs woes. But ministers are said increasingly to accept that attacking the banks will not by itself transform a situation that is jeopardising Britainâs economic prospects.Insiders point out that Mr Darlingâs criticism of mortgage lenders has softened in recent weeks.After the Bank of Englandâs radical cuts in interest rates over the past two months, the focus at the Treasury has shifted away from mortgage lending to the pressure being put on businesses by the scarcity of loans, which is emerging as the bigger economic danger.Richard Lambert, the Director-General of the CBI, said yesterday: âThe Government is going to have to do more to restore credit flows across the economy.âHe said that the car industry was especially vulnerable: âWithout access to credit or loan guarantees on commercial terms, this vital part of the economy will incur lasting damage.âThe scale of the lending drought was highlighted as separate Bank figures showed that the number of new home loans approved plunged to a record low in November. Only 27,000 mortgages for house purchase were approved by banks and building societies, down from a revised 31,000 in October. It is the lowest level since the Bank began collecting data in 1999. The Bankâs quarterly credit conditions survey showed that banks restricted access to loans of all kinds by companies and consumers in the past quarter, and that they plan to tighten the screws more in this quarter.Halifax reported that the price of the average house fell by more than Â£100 a day last year. Its quarterly figures showed that the average house ended the year down in price by Â£37,178, or 16.2 per cent.PRESSING THEIR POINTâThe single most pressing challenge to economic policy is to get the banking system to get lending in any normal sense”Mervyn King, Governor of the Bank of England, Nov 26âThey are close to cutting off their noses to spite their facesâLord Mandelson, Business Secretary, accuses the banks of being too conservative, Nov 30âThe banks have to understand that we have put substantial sums of public money in to support them. They, in turn, need to play their partâAlistair Darling, Dec 10âQuite clearly a lot more needs to be doneâAlistair Darling, Dec 15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"io/ioutil\" \"strings\")func main() &#123; //假定存储该内容的文件存放于与当前文件同级的content.cs中 ctx := Ioutil(\"content.cs\") m := make(map[string]int) rs := strings.Split(ctx, \" \") //fmt.Println(rs) for _, v := range rs &#123; m[v] += 1 &#125; //此时m是一个键名为单词,键值为出现次数的map,对其进行排序 fmt.Printf(\"共有%d个不同的单词\\n\",len(m)) sli1 := make([]string, 0) sli2 := make([]int, 0) for key, val := range m &#123; sli1 = append(sli1, key) sli2 = append(sli2, val) &#125; //冒泡排序 for i := 0; i &lt; len(sli2)-1; i++ &#123; for j := i + 1; j &lt; len(sli2); j++ &#123; if sli2[i] &lt; sli2[j] &#123; sli2[i], sli2[j] = sli2[j], sli2[i] sli1[i], sli1[j] = sli1[j], sli1[i] &#125; &#125; &#125; fmt.Println(\"出现最多的10个单词为:\", sli1[0:10]) fmt.Println(\"出现的次数分别为:\", sli2[0:10])&#125;func Ioutil(name string) string &#123; if contents, err := ioutil.ReadFile(name); err == nil &#123; //因为contents是[]byte类型，直接转换成string类型后会多一行空格,需要使用strings.Replace替换换行符 result := strings.Replace(string(contents), \"\\n\", \"\", 1) return result &#125; return \"\"&#125; 运行结果为: 123共有380个不同的单词出现最多的10个单词为: [the to of in that banks by a and lending]出现的次数分别为: [49 29 25 14 12 10 10 8 7 6] 当然,还可以将m定义为make(map[[]string]int)来简化部分代码","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"海岛桃花已盛开","date":"2019-03-07T12:47:14.000Z","path":"2019/03/07/海岛桃花已盛开/","text":"14年前，在黄海边一个车牌同为”L”的海港小城，在一处同样题写”桃花岛”并落款先生大名的海岛外，彼时并不会游泳的我在浅海滨搏击风浪，像一个真正的弄潮儿有模有样。 受四遭一干金粉的耳濡目染，受那位中学副教授忘年交的”怂恿挑唆”，不知不觉，我也”误入此坑”不能自拔，如发现一片新大陆，像饥肠辘辘旅人突见饕餮。 同样”深陷于此”的，还有那个端坐”光明顶”自号”风清扬”的前英语老师，以及看到案头&lt;笑傲江湖&gt;，用fox命名自己邮箱作品的”微信之父”，还有笑看诸君”naive”天文地理无所不通的年迈长者。 唐宋以来巨族，江南有数人家。先生学识渊博浩瀚，先生文字汪洋恣肆。先生用笔和纸，构筑了许多中国人的精神价值观，家国，狭义，儒道，恩怨，人心… 先生家国情怀浓烈，虽迫于时局远走香江，却无时无刻不关心大陆，最是推崇诸葛和老杜。某年剧变，先生端坐电视机旁，见邓姓”老友”出面，才确信其未被软禁，悬心落下。 先生思想新潮进步，一个异族草莽，能成笔下最悲壮英雄豪杰；一些受桎梏压迫的旧时代女性，有独立主见更敢于发出自己声响。 先生来世一场，儿女情长。于是有了”陈家洛”，有了封禅台的剑舞”冲灵”，有了”世间多少痴情女，伤尽男儿不自知”，有了赵敏”偏要勉强”，有了”世间少年男子…不禁为之哑然失笑”。更看到删掉的”当时若爱韩公子”，以及新加的那句让人无尽唏嘘的”我当时还不明白”。 我尝追寻先生步履，不辞千里，在华山之巅，在洛城东郊，在少室山下，在西湖梅庄 …终南山古墓长闭，万花坳花落无声，绝情谷空山寂寂，风陵渡凝月冥冥。音讯阻隔终不能得偿所愿。 海岛桃花已盛开，昔人却驾黄鹤去。”大闹一场悄然离去”，在此刻这个云集70亿众生的星球，无论达官显贵，或是天王巨星，究竟能有几个，可以穿透历史云层到达彼岸？又有几个能够把自己名字，镌刻人类文明发展长卷？路人皆可随口诵几句”大江东去”，而几人得知那个让作者死去活来 一生颠沛的帝王年号追谥？ 我之宏愿，也能借先生如椽巨笔，写下三五遗篇。不消畅销人尽皆知，更不敢奢求成为景点 令后人跨海而来。 它能在我身后百年，在一个夏雨午后，能让一个优秀少年或青年在书桌前驻足凝思，隔纸页与我凝空对视，则实在已经心满意足。 先生铁粉 梁城莫颟 2019.3.6","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"星陨-2019","date":"2019-03-07T00:14:03.000Z","path":"2019/03/07/星陨-2019/","text":"一个真正的具有世界历史意义的时刻－－一个人类的群星闪耀时刻出现以前，必然会有漫长的岁月无谓地流逝而去，在这种关键的时刻，那些平时慢慢悠悠顺序发生和并列发生的事，都压缩在这样一个决定一切的短暂时刻表现出来。这一时刻对世世代代作出不可改变的决定，它决定着一个人的生死、一个民族的存亡甚至整个人类的命运 维基百科 2019年逝世人物列表 另: 即便不考虑巨大风险，品谈评论zz人物，也是一件顶困难之事，离之越近愈是如此。一方面，决然无有官媒盛赞的那般伟大光荣正确，“永垂不朽”恐是更难;但也绝不致另一帮人批驳得那样一无是处xxxx。总会相隔一层厚厚脂粉，白的黑的，以至如雾里探花，由是”说不好，不好说，不说好”。真相和事实看上去会因年代久远而褪色甚至变质，但对一些特定群体，或许恰恰相反。囿因于此，旨在记录“那些曾构筑和塑造这个时代，曾有形或无形影响你我，而今驾鹤远去”的&lt;星陨&gt;，原则上不记录zz人物，虽然ta们影响显然更深更广。这既出于人身安全，也为出言负责。“历史，往往在经过时间沉淀后可以看得更加清晰”。 顾方舟 1926.6.16-2019.1.2 “糖丸爷爷”,中国脊髓灰质炎(小儿麻痹症)疫苗之父 从正当盛年到年逾古稀,为脊髓灰质炎的防治奉献一生 为实现中国全面消灭脊髓灰质炎并长期维持无脊灰状态做出巨大贡献，护佑几代中国人健康成长。 曾携幼子以身试药 毕生心血化作一颗糖丸 事迹将登荧屏 迈克尔·阿蒂亚 1929.4.22-2019.1.11 “自伊萨克·牛顿年代以来，他在上世纪60年代以一种前所未有的方式，完美地将物理学和数学结合在一起。” 和震古烁今的牛勋爵一样,阿蒂亚爵士毕业于剑桥大学三一学院,亦任过英国皇家学会会长. 同时,作为世界数学中心的”王子屯”,不会少了这位”20世纪最伟大数学家之一”的身影. 1966年菲尔兹奖和2004年阿贝尔奖得主. 数学的皇冠是数论,哥德巴赫猜想是皇冠上的明珠.黎曼猜想则是皇冠上最难擦拭掉的那个斑点. 在生命尽头,置声誉不顾,奔走呼号.用尽自己最后一点能量,让人类了解和关注数学. 当大众欢呼雀跃于这数学王国中最难攻克的猜想得到证明时，真正的数学家们却非常淡然。而在预印本出来之后，来自同行的负面评论越来越多，有同行在网上表示，为了尊重这位曾经做出过非常杰出而漂亮工作的伟大数学家，就不要再讨论了，因为他的证明是“not even wrong”。 原文地址点此, 版权归原作者所有 于敏 1926.8.16-2019.1.16 核武器学家,两弹一星勋奖章及国家最高科学技术奖得主,“中国氢弹之父”. 手中无剑与有剑不用是两回事 国防科技事业改革发展的重要推动者 身为一叶无轻重 愿将一生献宏谋 “他永远是那个临门一脚的人” 林清玄 1953.2.26-2019.1.23 阳明山夜穹，少却一颗闪亮的星；赤县文坛，缺了一股清流涓涓。 ‘谁见过人蓄养凤凰呢?谁能束缚月光呢?一颗流星自有它来去的方向，我有我的去处。’ 天寒露重，望君保重。 谨以此诵读,缅怀先生 和时间赛跑(节选) 褚时健 1928.1.23—2019.3.5 一个图腾消失，一个logo落幕。🎉🎉🎉 志村五郎 1930.2.23-2019.5.3 打开通往费马大定理大门的传奇数学家去世了 更多可点击 志村五郎纪念安德烈·薇依的文章 志村先生于半个月前辞世，百度百科未做更新，更不要奢望页面置灰。绝大多数中国人，对这个敌国学者一无所知。 要说几百年前，法国律师费马，提出一个理解起来异常简单，而求证却难于登天的猜想，并挑衅地说已找到答案，只囿于页边狭窄不能写下。在此后的358年间，这个物种最聪明头脑前仆后继怏怏无果。直到25年前，英国人怀尔斯解决了这个问题。志村及其同僚的研究成果，为那个面壁九年终破壁的英国人，提供了基础。 志村和怀尔斯都有一段王子屯任教经历，如同卡文迪许实验室之于物理，这个坚决不扩招的藤校，依然是世界数学的中心。 在我所从事领域，或说对一个现代人如水和电一般的互联网信息行业，也深刻应用到志村的研究成果而浑然不自知。非对称加密公钥私钥的基石是“正易反难”，笼统说主要有两大类，一是几个大质数相乘很容易得到乘积，而知乘积(公钥)很难分解出因子，人类缺乏分解大数的方法，而如果几个月前，黎曼猜想被证明，则无疑会动摇包括rsa加密算法在内许多密码学根基。而这时人类并非一筹莫展，还有一种基于圆锥曲线更为安全的加密算法，即拜志村多年前的研究。 除去数学，他还是位imari瓷器的收藏家和著述者(伊万里,日本佐贺县西部的港口城市,以伊万里烧亦称有田烧而闻名) 胡进庆 1936.3-2019.5.13 一代人心中抹不去的记忆 贝聿铭 1917.4.26-2019.5.16 你要想往新的一条路走，免不了有很多人觉得不大舒服，为什么要改？要改进是非常难接受的，要往前走，唯一的办法就是往前走。 张士平 1946.11—2019.5.23 传奇虽去,传说不老. 多年以后，南方某城，满头白发的老人，会和对家世对祖籍充满好奇与疑问的孩童提起，在你爷爷长大的地方，出过一位顶了不起的人物。不管承认与否，他都润物无声一般深刻影响了许多人。 维基百科什么鬼? 无法想象，如果没有这群草莽出身的“粗人”筚路蓝缕，我邹大概如同所有山东乃至北方县城一样，对体制对稳定对面子迷之迷恋。无法假设，自小长在那里又被称“满腹经纶”的我，对世界的认知，对人生的选择，对好恶与否的价值判断，将会与今天有多不一样。我知道，如同几乎所有追梦人一样，费劲乃至上穷碧落追寻，最后多半如竹篮打水，但百年之时回望却是欣慰满足。感谢你，那个从未谋面却在无声无息影响我改变我的人。此生不枉，天国再会。 默里·盖尔曼 1929.9.15-2019.5.24 “夸克之父” 1969年诺贝尔物理学奖得主 “会走路的百科全书” 犹太人 喜欢观察鸟类和收藏古董。谙熟古代文化和民俗传说，甚至熟悉许多土著文化。能流利地使用13门语言，并乐于炫耀自己过人的外语能力。好为人师，有一次还想当面纠正杨振宁说的汉语。 在加州理工学院与理查德·费曼一起共事时所发生的一些逸闻趣事,常为人们所津津乐道。二人曾经常为”谁是加州理工学院最聪明的人”而争执不休 以爱炫耀自己的博学和看不起应用研究而闻名,量子场论大师史蒂文·温伯格评价”从考古到仙人掌，再到非洲约鲁巴克人的传说，再到发酵学，他懂得都比你多” （理论学家）用纸、笔和废纸篓作为研究工具，其中最重要的就是废纸篓。 更多参见 乔治·罗森克兰兹 1916.8.20-2019.6.23 乔治·罗森克兰兹（George Rosenkranz）,匈牙利化学家,避孕药发明人.同时还是一名出色的桥牌玩家. 避孕药改变了半个世纪以来女性的角色和社会地位 “我把关于避孕药价值的任何争论留给其他人去讨论，但是我们永远不能忘记，原创性的研究是制药和生物技术行业的命脉，跨学科的团队努力是重大研究成果不可或缺的动力。” 费尔南多·考巴托 1926.7.1－2019.7.12 费尔南多·考巴托 (Fernando José Corbató),人称”Corby”,计算机科学家;提出计算机密码概念;发展了分时操作系统,曾领导CTSS与Multics计划,因在此领域的开创性工作被授予1990年“图灵奖”。 2012年,成为计算机历史博物馆院士. (计算机历史博物馆,于1996年建立. 是为保存和展示信息时代的故事和产品,及探索计算机革命和其对人们生活的影响) “在一段固定时间内，不管他使用的是什么编程语言，一个程序员能写作的源代码行数是固定的。”— 柯巴托定理（Corbató’s Law） 关于”分时操作系统”(Time-sharing Operating System,简称TSOS),对应于实时操作系统(Real Time Operating System,简称RTOS)，TSOS是利用分时技术,使一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统,广泛应用于计算机早期,和现在的个人机中. Windows、Linux、Unix均为分时操作系统.一个很直观的例子,一台服务器,多个用户可以同时ssh远程连接进行各种操作..后来出现的vps,及用包括kvm等技术在内的虚拟化方案”分隔”出的云服务器,算是更高一个维度上的”分时”.实时系统和分时系统实时操作系统与分时操作系统的主要区别? 参考: 图灵奖得主Fernando Corbató逝世：没有他或许没有Linux和C语言 操作系统开发第一人去世，曾获图灵奖启发Linux和C语言 番外: 就商业角度说,MULTICS是个失败的操作系统,就理念上来讲,这个系统实在是有点超前且求全.一个失败的操作系统MULTICS 类似第谷与开普勒,或是开普勒与牛顿,Multics（Multiplexed Information and Computing System）本身不算成功,但启发和孕育了Unix.后者的两位发明者Ken Thompson(肯·汤普逊)和Dennis MacAlistair Ritchie(丹尼斯·里奇)先于Corby,于1983年获图灵奖. 其中,Ken Thompson同时也是B语言/Go语言之父,参与UTF-8设计.黑客文化圈子通常称他为“ken” Dennis MacAlistair Ritchie是C语言之父,。黑客圈子通常称他为“dmr”.在乔布斯逝世一周,祭奠缅怀文章多如雪片时,被人发现死于寓所. 提供该消息的是其之前的同事Rob Pike(罗勃特·派克) — UNIX小组成员,与Ken Thompson共同开发了UTF-8,与Ken Thompson同为Go语言三巨头之一. 有人将丹尼斯·里奇与史蒂夫·乔布斯进行对比，试图探究二人之中谁更重要，然后得出一条结论，“在过去四十年的技术革命里，里奇起到了关键作用——包括苹果公司想要用来创造财富的技术”。有人说“从另一方面讲，丹尼斯·里奇发明了两项关键的软件技术，这种技术是直接或间接组成现在每一件计算机产品的DNA。它听起来很疯狂，可事实的确如此。”还有人评价道，“许多在计算机科学和相关领域的人都清楚，里奇的重要性体现在一切需要通过计算机实现的工作之中”。 为纪念丹尼斯·里奇，Fedora的开发团队将Fedora 16（发布于里奇去世一个月后）献给他，而FreeBSD的开发团队也将FreeBSD 9.0（发布于2012年1月12日）献给他。 历届图灵奖得主及成就: 戴铁郎 1930-2019.9.04 “这是一个好时代，好到让我常常遗憾，要是再年轻一点就好了。” 90后的童年渐渐只能在回忆中了 曾宪梓 1934.2.2-2019.9.20 生于广东省粤东区绥靖专员公署梅县（今梅州市梅县区）一农民家庭，幼年丧父，少年辍学，自少砍柴放牛帮补家计。 后来得到政府扶助，重获接受教育机会，1961年毕业于广州中山大学生物学系。 1968年偷渡来香港，为照顾家人开始缝制领带，到街上贩卖，后以“金狮”作为商标，但销路不理想，后发现“狮”与“输”谐音，顾客觉得不吉利，于是改名为“金利来”，迅即销量大增，于1971年成为注册商标，同年赞助世界乒乓球单打冠军庄则栋来港表演的电视转播，令品牌更多人得知。1973年，金利来于中环永安百货设立领带售卖专柜，首创拆帐方式与百货公司合作，令业务逆市而上。 “香港领带之王” 1992年，捐赠1亿港元予中华人民共和国教育部，成立“曾宪梓教育基金”，扶助内地贫困地区教育事业。2004年以1亿港元成立“曾宪梓载人航天基金”，鼓励对中国航天事业有贡献的科学家及航天员。2008年再以1亿港元设立“曾宪梓体育基金”，鼓励北京奥运会及往后三届奥运会获得金牌的中国运动员。 南京紫金山天文台于1993年把编号3388的小行星，以曾宪梓命名。 2019年9月20日下午16时28分，在家乡梅州病逝，享年85岁。 永远以积极乐观的心态去拓展自己和身外的世界。 谢高华 1931.11-2019.10.23 你在中国地图上看，说要找一个地方，它能够成为全世界最大的小商品集散中心，你肯定不会想到义乌，那个地方交通不好，旁边也没什么产业基础，它就是金华中部一个特别小的县城。为什么义乌能成为全球最大的小商品集散中心？没有什么道理！ 1980年代初，就是他，在全中国所有的县里面第一个允许老百姓在马路边摆摊卖东西。然后下雨、下雪，摆摊的老百姓很可怜，怎么办？搭棚子。这个棚搭完以后，就是中国的第一个小商品交易市场。 中国有成千上万的谢高华，就是这些人决定性地改变了一个地区的经济面貌。他们手上有比欧美国家市长、州长大得多的权力，但同时他们需要比这些欧美的市长和州长承担更大责任。 引自 激荡四十年，这个时代从不辜负人，它只是磨炼我们 “2018年，在庆祝改革开放40周年大会时，马云与谢高华的一张握手照片在网上传开。此前，在人民大会堂举行的庆祝改革开放40周年文艺晚会上，同为入选改革开放杰出贡献表彰对象的马云，正巧坐在谢高华前排，晚会开始前他特意转身与谢高华握手。 一位是全球最大电子商务平台的缔造者，一位是全球最大的小商品市场的开创者，两人的手紧紧地握在了一起。这一握给人新的诠释——从谢高华到马云是浙商精神的一种传承。” 引自 谢谢！谢高华！ 更多点击: 86岁谢高华获“终身贡献奖”，系“世界超市”义乌的开拓者 对这个国家技术官僚的最好想象 流沙河 1931.11.11-2019.11.23 理想是石，敲出星星之火;理想是火，点燃熄灭的灯;理想是灯，照亮夜行的路;理想是路，引你走到黎明。… …就是那一只蟋蟀在《豳风·七月》里唱过在《唐风·蟋蟀》里唱过在《古诗十九首》里唱过在花木兰的织机旁唱过在姜夔的词里唱过劳人听过思妇听过就是那一只蟋蟀在深山的驿道边唱过在长城的烽台上唱过在旅馆的天井中唱过在战场的野草间唱过孤客听过伤兵听过… 天真的眼睛到处看到朋友阴沉的眼睛到处看到敌人恐惧的眼睛到处看到陷阱贪鄙的眼睛到处看到黄金忧愁的眼睛到处看到凄凉欢笑的眼睛到处看到光明 感谢古老的汉字，收容无家的远行客。感谢奇妙的汉字，愉悦避世的梦中人。 “后蜀国王孟昶遍植成都城上的芙蓉，早上开花，晚上凋落。这也让我想到我自己的生命，一转眼就到80多岁了。有时候梦醒，还以为自己在少年，其实已是白头老翁。让人不得不感慨：时间快如飞，人生短似梦，更好像芙蓉花早开夕败。我在成都的生活，好像也是一场芙蓉秋梦。” “劳我一生，博得书虫之名。前面是终点站，下车无遗憾了” 送别流沙河：跌宕起伏又干干净净的一生 不要迷信国学,不要读&lt;弟子规&gt; 在人类在命运降临的伟大瞬间，市民的一切美德 -- 小心、顺从、勤勉、谨慎，都无济于事，它始终只要求天才人物，并且将他造就成不朽的形象。命运鄙视地把畏首畏尾的人拒之门外。命运 -- 这世上的另一位神，只愿意用热烈的双臂把勇敢者高高举起，送上英雄们的天堂 历史，往往在经过时间沉淀后可以看得更加清晰","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"告白无声","date":"2019-02-24T13:19:47.000Z","path":"2019/02/24/告白无声/","text":"我们大多是在最近几年才相遇相识， 你们一个个从天涯海角，从北国南疆，不辞千里到我身旁， 也有在旅途相逢 一见倾心，蜗于行囊随我辗转归乡。 你们陪伴我跨越省域区划，从沪来杭；也与我蜷缩出租房，颠沛流亡。 出租屋逼仄甚或无窗，阴寒潮冷不见天光，曾让你们湿漉漉，与我床被一模一样。 今稍有立锥，迫不及待便是安置妥当。你们来自五湖四海，终相聚于一堂。 我知道你们听说不到，却还像怪胎一样自顾自说。当跨越千里阻隔，当我虔诚地翻开扉页，当我的眼珠乌溜溜扫过千行，当我小心翼翼做出批解图注，就好像为你们注入灵魂与生命，我们的故事，从那瞬便开始源远流长。 有你们在，如有取之不竭的无尽矿藏；有你们在，破衣烂衫也自信如着新装；有你们在，鸡飞狗跳我也能心中不慌。 我们好多还不算深交，我着急赶路步履匆匆，恐怕好些还只是一面之缘，相逢一笑便又如隔大江。 此后一甲子，望我们能杯茶片饮，晴天相约书房，阴雨相聚连廊。我更希望你们能跨越兵戈扰攘龙血玄黄，寿命比我更长。 2019.02.24","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"通过位运算，实现单字段标识多个状态位","date":"2019-02-21T14:00:16.000Z","path":"2019/02/21/通过位运算，实现单字段标识多个状态位/","text":"可能经常有如下这种需求: 需要一张表,来记录学员课程的通过与否. 课程数量不确定,往往很多,且会有变动,随时可能新增一门课. 这种情况下,在设计表结构时,一门课对应一个字段,就有些不合适, 因为不知道课程的具体数量,也无法应对后期课程的增加. 考虑只用一个状态标志位,利用位运算,来标识多门课的通过或否. 这与Linux的文件权限思路一致 Linux文件和目录的权限 设计及实现 左移（&lt;&lt;）: 右移（&gt;&gt;）: |（或运算）：只要当一方为 true 时，结果就是 true，否则为 false。 (有1就为1,全0才为0) &amp;（与运算）：只有当两方都为 true 时，结果才是 true，否则为 false。(全1才为1,有0就为0) 对于正数和负数，左移一位就相当于乘以2的1次方，左移n位就相当于乘以2的n次方 如xxxxxx&lt;&lt;2即左移2位,右边空出的位用0填补，高位左移溢出则舍弃该高位 步骤一: 如语文成绩率先出来,我们约定,以这个字段(记为attr)的第一位,来代表该学生语文有没有通过测评(0否1是) attr为当前该属性字段的值(从数据库里取出来的值). index为约定的第几位来标识当前业务,index从0开始计数 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"func main() &#123; // 记录阶段 //如果语文成绩测评通过,调一个写接口,初始attr值为0,约定的表示位置为第1位,又因为从0开始计数,故而index=0 setRs := set(0, 0) //将attr字段的最新值,记录进数据库的attr字段 // 查询阶段 //当需要获知该学生的语文是否通过时. 查数据库,获取上面记录进的值(此时setRs即attr=1); 进而get方法,可知道是否通过(如果rs结果为1,则通过) rs := get(setRs, 0) _ = rs&#125;func set(attr, index int) int &#123; tmp := 1 &lt;&lt; index // 1左移0位,即原地没动,还是1 fmt.Printf(\"1 &lt;&lt; index %d 值为%d:\\n\", index, tmp) // 1 | 0,或运算,有1就为1,故而setRs=1 setRs := tmp | attr fmt.Println(setRs) return setRs&#125;func get(attr, index int) int &#123; tmp := attr &gt;&gt; index // 1右移0位,即原地不动,还是1 fmt.Printf(\"attr %d &gt;&gt; index %d 值为 %d:\\n\", attr, index, tmp) // 0001 &amp; 0001,与运算,全1才为1,故而为0001,即为十进制数1 getRs := tmp &amp; 1 fmt.Println(getRs) return getRs&#125; 输出为: 12341 &lt;&lt; index 0 值为1:1attr 1 &gt;&gt; index 0 值为 1:1 假设孙山语文及格, 张继语文落榜(则不调用写接口,只有通过才调),则二人当前attr的值为1和0. 这样就完成了语文科目的处理 步骤二: 几天后数学测评结果也出来了,继续用attr,约定以这个字段的第二位,来代表该学生数学有没有通过测评(0否1是) 同样用之前的代码, 记录阶段: 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() &#123; // 记录阶段 //如果数学成绩测评通过,调写接口,约定的表示位置为第1位,又因为从0开始计数,故而index=1 // 对于孙山,从数据库取出其attr值,为1; 张继的attr值为0 // 加入二人都通过了数学测评,都需调用如下写接口 setRsSun := set(1, 1) //将attr字段的最新值,记录进数据库的attr字段 fmt.Println(\"-----------\") setRsZhang := set(0, 1)&#125;func set(attr, index int) int &#123; tmp := 1 &lt;&lt; index // 1左移1位,即由\"0001\"变为\"0010\",即为十进制数2 fmt.Printf(\"1 &lt;&lt; index %d 值为%d:\\n\", index, tmp) // 对于语文通过带孙山,0010 | 0001,或运算,有1就为1,故而setRs=0011,即十进制数3 // 对于语文未通过带张继,0010 | 0000,或运算,有1就为1,全0才为0, 故而setRs=0010,即十进制数2 setRs := tmp | attr fmt.Println(setRs) return setRs&#125; 123451 &lt;&lt; index 1 值为2:3-----------1 &lt;&lt; index 1 值为2:2 查询阶段: 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; // 查询阶段 //当需要获知该学生的语文/数学是否通过时. 查数据库,获取其attr的值; 进而get方法,index字段为该科目约定的位置(语文为1,其index为0; 数学为2,其index为1),即可知道是否通过(如果rs结果为1,则通过) sunMath := get(setRsSun, 1) //setRsSun=3 fmt.Println(\"-----------\") zhangChinese := get(setRsZhang, 0)//setRsZhang=2 fmt.Println(\"sunMath is:\",sunMath) fmt.Println(\"zhangChinese is:\",zhangChinese)&#125;func get(attr, index int) int &#123; tmp := attr &gt;&gt; index fmt.Printf(\"attr %d &gt;&gt; index %d 值为 %d:\\n\", attr, index, tmp) getRs := tmp &amp; 1 fmt.Println(getRs) return getRs&#125; 123456789101112 // 对于孙山,十进制数3即二进制0011,右移1位,即0001,即十进制数1attr 3 &gt;&gt; index 1 值为 1:// 0001 &amp; 0001,与运算,全1才为1,故而为1. 即孙山通过了数学1-----------// 对于张继,十进制数2即二进制0010,右移0位,即原地不动,还是0010,十进制数2attr 2 &gt;&gt; index 0 值为 2:// 0010 &amp; 0001,全1才为1,否则为0. 即张继没有通过语文0sunMath is: 1zhangChinese is: 0 步骤三: 过了几天,英语结果也出来了.假如孙山没通过,张继通过,爽哥三门都通过,则有 写入和读取过程同上 步骤四: 假如现在第60个科目’信息技术’的测评出炉, 爽哥前面59门课程全部通过,则attr字段的值为$1\\times2^{58}+1\\times2^{57} … + 1\\times2^2 + 1\\times2^1 + 1\\times2^0$, 即 $288230376151711744 + 144115188075855872 …+4+2+1 = 576460752303423487$ 2的n次方对照表 第60门课’信息技术’也高分通过, 则对于最新的attr值,即 1 &lt;&lt; index | attr, 即1 &lt;&lt; 59 | 576460752303423487 = 1152921504606846975,将这个值计入数据库. 如需获取爽哥有无通过第60门课程,1152921504606846975 &gt;&gt; 59 &amp; 1 = 1,即通过 如果将数据库这个attr字段设置为有符号的bigint类型,则最多可标识 60几个不同业务的状态 更通用的代码: 12345678910111213141516func main()&#123; index := uint8(\"约定的位置\" - 1) attr := \"来自数据库\"&#125;func SetAttrBit(attr int, index uint8) int &#123; return 1 &lt;&lt; index | attr&#125;func GetAttrBit(attr int, index uint8) int &#123; return attr &gt;&gt; index &amp; 1&#125; 参考: 用位运算来标识状态 番外 “光学电报”","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"记一次问题排查","date":"2019-02-21T06:05:19.000Z","path":"2019/02/21/记一次问题排除/","text":"1785年，卡文迪许在实验中发现，把不含水蒸气、二氧化碳的空气除去氧气和氮气后，仍有很少量的残余气体存在。这种现象在当时并没有引起化学家的重视。一百多年后，英国物理学家瑞利测定氮气的密度时，发现从空气里分离出来的氮气每升质量是1.2572克，而从含氮物质制得的氮气每升质量是1.2505克。经多次测定，两者质量相差仍然是几毫克。— &lt;氩气的发现&gt;点击查看更多 对账系统的核心计算部分在定时任务timetask项目中,其中python脚本从sql server中按规则获取并计算当天符合条件的记录,写入到mysql中;展示部分(店主端)属于早期项目,没有用golang,用php的lumen框架,从mysql相应表中查取数据 后来同事反应,店主端资金明细展示,出现重复或者漏项等情况.查看了数据库,数据本身并无问题,不存在重复或缺少,于是推出是展示部分出现了问题 看了一下sql语句,因业务要求,这段sql由几个union all拼接而成,然后有order by,再limit;于是推断每次请求查出的结果不同(每次顺序会变化),再经过limit分页,就出现了所谓的数据”重复”和”缺漏” 网上很多关于union all order by 导致乱序的问题,但我这段sql,并不会如此; 后来发现顺序发生改变的一个原因,是有几条记录order by的字段完全一样;看上去只需要再加一个order by的字段如id asc,就可以解决问题 但不想就此停止,因为看上去用navicat执行这段sql,无论多少次,结果顺序都是稳定的;为了深入研究,抽象化后建了两张表1234567891011121314CREATE TABLE `cui` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT '', `book` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '1', '宋江', '&lt;水浒传&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '2', '卢俊义', '&lt;水浒传&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '3', '吴用', '&lt;水浒传&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '4', '公孙胜', '&lt;水浒传&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '5', '关胜', '&lt;水浒传&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`cui` ( `id`, `name`, `book`, `create_time`) values ( '6', '林冲', '&lt;水浒传&gt;', '2018-07-11 00:00:00'); 1234567891011121314CREATE TABLE `shuang` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT '', `book` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '1', '林黛玉', '&lt;红楼梦&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '2', '薛宝钗', '&lt;红楼梦&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '3', '贾元春', '&lt;红楼梦&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '4', '贾探春', '&lt;红楼梦&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '5', '史湘云', '&lt;红楼梦&gt;', '2018-07-11 00:00:00');insert into `你的库名`.`shuang` ( `id`, `name`, `book`, `create_time`) values ( '6', '妙玉', '&lt;红楼梦&gt;', '2018-07-11 00:00:00'); 经过多次实践发现,用lumen或者pdo执行几次后,最开始几次一定会乱序,随着执行次数的增多,会渐”趋于稳定”,这是个神奇的现象;为复现顺序会变,可多次修改表名 在lumen中写一个方法测验: navicat中的执行结果如下,无论执行多次,返回值始终幂等如一 但此时还不能认为是lumen存有问题,也许是navicat做了什么处理,还需要查看执行原始sql的结果;见下图,执行多次亦始终如一 其实这里还有一个小问题,那就是虽然同样”稳定”,但navicat和命令行执行结果,可能出现不一样的情况…即用navicat执行上面这段sql无论多少次,返回的结果始终如a不会改变;命令行执行这段sql无论多少次,始终如b,但a和b顺序可能不同;这是实践得出的一个非必现的诡异现象 在我准备给lumen提pr时,h哥提出,还要看看php的mysql扩展(在此即pdo)有无问题.框架的orm操作基于php的mysql扩展,如果上游数据即会变序,lumen这里肯定会每次执行顺序不同 pdo直连数据库,代码及结果如下: 在pdo这一步,如果union all中order by的字段存在相同的情况,就会发生乱序;不知道这是扩展的bug,还是官方已说明如此,为此,需要和PECL进行沟通; 我们多只是使用,对于其更深层次的具体实现和原理,其实还缺乏足够认知…这是需要补充加强处","tags":[{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"},{"name":"PHP","slug":"PHP","permalink":"http://www.dashen.tech/tags/PHP/"}]},{"title":"为网站配置SSL","date":"2019-02-17T13:28:03.000Z","path":"2019/02/17/为网站配置SSL/","text":"HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间），这个系统提供了身份验证与加密通讯方法。 现状 证书申请 除了向公有云申请证书, 也可使用 自签名或openssl生成的证书,但方便起见还是使用云厂商提供的证书. 一般免费版,只有一年有效期.到期需要重新申请&amp;更换 Nginx配置 将证书文件上传至/usr/local/openresty/nginx/conf/cert目录下. 博客项目当前的conf配置如下: 1234567891011121314server &#123; listen 80; server_name dashen.tech www.dashen.tech; access_log /var/log/blog.access.log main; error_log /var/log/blog.error.log; location / &#123; root /home/ubuntu/cuishuang.github.io; index index.html; expires 1d; add_header Cache-Control public; access_log off; &#125;&#125; 新增启用https的配置: 12345678910111213141516171819server &#123; listen 443 ssl; server_name dashen.tech www.dashen.tech; #域名 ssl_certificate /usr/local/openresty/nginx/conf/cert/shuang_blog.pem; #证书路径 ssl_certificate_key /usr/local/openresty/nginx/conf/cert/shuang_blog.key; #key路径 ssl_session_cache shared:SSL:1m; #s储存SSL会话的缓存类型和大小 ssl_session_timeout 5m; #会话过期时间 access_log /var/log/blog.access.log main; error_log /var/log/blog.error.log;location / &#123; root /home/ubuntu/cuishuang.github.io; index index.html; expires 1d; add_header Cache-Control public; access_log off; &#125; &#125; 删掉之前的conf. 重启nginx,访问https://www.dashen.tech,已能正常访问. 再访问之前的网址http://www.dashen.tech,则 配置将http访问自动跳转到https 再增加一段配置: 12345678910111213141516server &#123; listen 80; server_name dashen.tech www.dashen.tech; access_log /var/log/blog.access.log main; error_log /var/log/blog.error.log; return 301 https://$server_name$request_uri; #这是nginx最新支持的写法 location / &#123; root /home/ubuntu/cuishuang.github.io; index index.html; expires 1d; add_header Cache-Control public; access_log off; &#125;&#125; 参考: Nginx强制跳转Https 再次重启nginx,这时请求http://www.dashen.tech就可以跳转到https://www.dashen.tech 但因为网站下有部分资源使用了http,所以浏览器依然没有变为安全锁, 可参考Hexo启用https加密连接, 也可右键查看哪些请求使用了http,将其修改为https即可~","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"},{"name":"密码学","slug":"密码学","permalink":"http://www.dashen.tech/tags/密码学/"}]},{"title":"经典问题--超大字符串型整数乘除","date":"2019-02-15T02:08:10.000Z","path":"2019/02/15/经典问题-超大字符串型整数乘除/","text":"之前留了坑,关于超大字符串型整数乘除的问题还是以加减一文中的a1和a2为例(假设π小数点后50位乘以$10^{50}$的值为a1,e小数点后30位乘以$10^{30}$的值为a2),计算a1xa2,以及a1/a2的值 分析,两个数x,y相乘,即(y的个位乘以x) + (y的十位乘以x)乘以10 + … + (y的最高位乘以x)乘以最高位 之和~ 如以1035x287为例,即7x1035 + 8x1035x10 + 2x1035x100,即乘法分配律的变形,1035x(7+80+200)=1035x287 //两个数相乘,积的长度不会超过两个数长度之和,如9999x9999=99980001 一个核心点,确定好结果多长有几个坑,想办法设计算法,往坑位写入正确的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func main()&#123; str1 := \"314159265358979323846264338327950288419716939937510\" str2 := \"2718281828459045235360287471352\" rs := multiply(str1,str2) fmt.Println(rs)&#125;func multiply(str1, str2 string) string &#123; l1, l2 := len(str1), len(str2) l := l1 + l2 num := make([]int, l) for i := 0; i &lt; l1; &#123; for j := 0; j &lt; l2; &#123; num[l-i-j-1] += int(str1[l1-1-i]-'0') * int(str2[l2-1-j]-'0') j = j + 1 &#125; i = i + 1 &#125; //上面这段循环是核心,下面和大数加减大致都一样了~ //从最右往左边,处理进位 for n := l; n &gt; 1; &#123; temp := num[n-1] num[n-1] = num[n-1] % 10 //如35/10,得5 num[n-2] += temp / 10 //如35/10,得3,将3加到上一位 n = n - 1 &#125; //汇总字符串结果 res := \"\" for _, i := range num &#123; s := strconv.Itoa(i) res += s &#125; //去除开头可能存在的0 if len(res) &gt; 1 &#123; res = strings.TrimLeft(res, \"0\") &#125; return res&#125; 运行结果: 1853973422267356706546355086954449319694770135199398255015274067614534738795213520 戳此查看更多有趣的入门算法问题 Golang实现大数乘法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"动态规划--最短路问题","date":"2019-02-14T06:51:24.000Z","path":"2019/02/14/动态规划-最短路问题/","text":"首先补补课 详细可点此 先从此抛砖引玉 如果暴力遍历,需要 1x3x3x2x1=18次计算 用DP’剪枝’,将乘法变加法,需要1x2+2x3+3x3+3x1=18次计算(从后向前算) 此时看上去计算次数相当,但如果层级一多,每层节点一多,暴力遍历将会是指数级增长,即&lt;数学之美&gt;中的10的15次方 推演一下10的15次方的由来假设北京为点X,广州为点Y,之间隔了15层A,B,C…..M,N,O,每一层有10个城市,如A层有A1,A2,…A10,根据乘法原理,从X到Y,共有10x10x10…x10x1=10的15次方种可能的路线 再解释一下如何”规划”(优化),变成了10x10x15 但凡降低时间复杂度,大多要通过借由增大空间复杂度,即用空间换时间 从后向前推导,计算出从O到Y的距离,需经过10次计算(书中认为这步不需要计算),再计算从N到Y的距离,需经过10x10次计算,得出N1,N2,…N10到Y的最短距离,假设这10段最短距离中,N5到Y距离最短,这时并不能说最短路一定经由N5到Y,而是N1,N2…N10都有可能,不推到最后一步,永远不知道这条路线是不是最优;所能做就是每层的每个节点各司其职,算出当前节点到终点的最短距离,以备上一层级使用 类似,从M到N又有10x10种不同路线,N1,N2..N10到Y的最短距离上一步已经算出,经过10x10次计算,可得出M1,M2…M10到Y的最短距离 依此类推,共需要10x10+10x10+…+10x10次计算,可以到达A层,且得出A1,A2,…A10到Y的最短距离A1Y,A2Y…A10Y;再进行10次计算,取最小值,即min(XA1+A1Y,XA2+A2Y…XA10+A10Y),所得结果即最短路的距离,所经历的节点即最短路 可参照上图,进行简化和类比 在编码时,要维护一个map,来记录每一层的每个节点到终点的最短距离及经过的下层节点名称;最后的最短路未必经过该节点,却可保证,倘若经过该节点,最短路一定是我们维护的这个距离及路径 更多动态规划内容,可点击 回忆帖","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"经典问题--超大字符串型整数加减","date":"2019-02-13T15:18:14.000Z","path":"2019/02/13/经典问题-超大字符串型整数加减/","text":"int64所能表示的数字范围为$-2^{63} 到 2^{63}-1$,即·-9223372036854775808~9223372036854775807·, (19位长度),当超过这一数字,则会溢出 1234fmt.Println(9223372036854775808)执行结果:constant 9223372036854775808 overflows int 但当有相关需求,如假设π小数点后50位乘以$10^{50}$的值为a1, e小数点后30位乘以$10^{30}$的值为a2,现需要计算a1+a2,以及a1-a2的值; 即对两个可正可负的字符串型整数str1和str2,计算str1+str2的值 1.当两数皆为正整数 如a1+a2 一些必要操作,如去除最左边的所有0,在代码中不做展现, 默认已通过strings.TrimLeft(str,”0”)处理为不是以0开头的正整数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func main()&#123; str1 := \"314159265358979323846264338327950288419716939937510\" str2 := \"2718281828459045235360287471352\" rs := \"\" if len(str1) &gt; len(str2) &#123; rs = AddStr(str1,str2) &#125; else&#123; rs = AddStr(str2,str1) &#125; fmt.Println(rs)&#125;func AddStr(n1,n2 string)(res string) &#123; var num []int x,y := len(n1),len(n2) num = make([]int,x+1) //因为可能存在两个数的最高位相加大于10的情况,故而比两者中最大数的位数+1 for i :=0;i&lt;y; &#123; num[x-i] = int(n1[x-1-i]-'0') + int(n2[y-1-i]-'0') i = i + 1 &#125; for i:=0;i&lt;x-y;&#123; num[x-y-i] = int(n1[x-y-i-1]-'0') i = i + 1 &#125; //处理进位 for i := len(num);i&gt;1;&#123; if num[i-1]/10==1 &#123; num[i-1]-=10 num[i-2]++ &#125; i = i - 1 &#125; //汇总字符串结果 for _,i := range num&#123; s:=strconv.Itoa(i) res+=s &#125; //去除开头可能存在的0 if len(res) &gt; 1 &#123; res = strings.TrimLeft(res,\"0\") &#125; return&#125; 运行结果: 1314159265358979323848982620156409333655077227408862 2.当两数可能为负整数 即a1-a2,或a2-a1,或-a1-a2 当两数皆为负数,先把负号取出,这样就和两个正整数相加无异, 最后得出结果再加上负号~ 当两数一正一负, 如下代码,默认已做如下处理,a1为正,a2为负,且a1的绝对值&gt;a2的绝对值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 func main()&#123; str1 := \"314159265358979323846264338327950288419716939937510\" str2 := \"-2718281828459045235360287471352\" str2 = strings.TrimLeft(str2,\"-\") res := subtractStr(str1,str2) fmt.Println(res) &#125; func subtractStr(n1,n2 string)(res string) &#123; var num []int x,y := len(n1),len(n2) num= make([]int,x+1) for i := 0;i &lt; y; &#123; num[x-i] = int(n1[x-1-i]-'0') - int(n2[y-1-i]-'0') i = i + 1 &#125; for i:=0;i&lt;x-y;&#123; num[x-y-i] = int(n1[x-y-i-1]-'0') i = i + 1 &#125; //处理进位 for i := len(num);i&gt;1;&#123; if num[i-1] &lt; 0 &#123; num[i-1]+=10 num[i-2]-- &#125; i = i- 1 &#125; //汇总字符串结果 for _,i := range num&#123; s:=strconv.Itoa(i) res+=s &#125; //去除开头可能存在的0 if len(res) &gt; 1 &#123; res = strings.TrimLeft(res,\"0\") &#125; return&#125; 运行结果: 1314159265358979323843546056499491243184356652466158 思考:当str1,str2未必为整数型字符串,而可能是小数型时,该如何处理?以及超大字符串型整数的乘除问题,如何处理","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"分析浏览器使用记录","date":"2019-02-12T14:48:51.000Z","path":"2019/02/12/分析浏览器使用记录/","text":"WakaTime 一直使用WakaTime这款时间统计工具，来记录每天花费在各种软件上的时间(支持各种IDE,浏览器，Office，Adobe系列软件等)，发现每天大多数时间花在浏览器上 Web Timer 具体到都访问过哪些网站以及占比，有用Web Timer这款浏览器插件 但这款插件只能比较笼统地统计，无法再进一步分析，也较难满足跨机器/跨平台/跨浏览器等要求。 1History 之后有了解过国内一位开发者用Rust写的1History,”一个跨平台的命令行工具，能够同时备份本机不同浏览器的浏览记录，放进一个 SQLite 数据库，支持导出和可视化” 除去直接下载二进制文件，还可以通过brew install 1History/onehistory/onehistory或cargo install onehistory来安装。 之后使用sudo onehistory backup 先备份(导出)当前机器浏览器的历史记录(需要关闭浏览器)，此时就会在/Users/xxxx下，生成onehistory.db文件 接着可通过onehistory -d onehistory.db serve启动服务，可以通过访问127.0.0.1:9960 图形化查看各网站的访问情况。 点击折线图中的点，可以查看详情 最多的一天，居然访问了1614个网站，从早忙到晚…","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"前缀索引,一种优化索引大小的解决方案","date":"2019-02-08T15:46:39.000Z","path":"2019/02/08/前缀索引-一种优化索引大小的解决方案/","text":"https://www.cnblogs.com/studyzy/p/4310653.html https://www.jianshu.com/p/4bd422fa5bdb https://www.jianshu.com/p/bdc9e57ccf8b https://www.timiguo.com/archives/106/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"芳华渐去","date":"2019-02-08T15:35:46.000Z","path":"2019/02/08/芳华渐去/","text":"2019.02.08 爷爷感冒身体不适，入院查看检查无碍，只伴有低烧。稳妥起见输液几天再走。但无论如何捺不住，各种要求回家。缓兵之计无用，托词借口识破，红脸束手，黑脸枉然。 然而遵医嘱不能出院，开始了从昨天下午到今天拂晓的斗智斗勇。一个近90岁的病中人，气力和精力把三个值青年壮年的儿孙整得侧目歪头。…叔叔可能是近1/4个世纪来第一次回家过年，逢见此事，我之以为人中龙凤大场面先生，也无计可施。 我正为一道找寻最大字符串子串的算法题焦头烂额，却联系诸事，突得发现，数理之难，逻辑之难，并非真难，好多说不清讲不通搞不定的人间事，才是真的让人无从下手，一团乱麻般地无有头绪。 夜半爷爷不折腾稍睡期间，听爸爸叔叔讲幼时种种，兄弟之谊，跃然于前。我也忽然想起爷爷幼时抱我的照片，想最近些年渐去的故人和渐淡的年味。 白天终于拗他不过，匆匆回家了。我拿回了两双作为”传家宝”的银筷子(实际应该是铝质)，却一点高兴不起。 也许一转帧，像&lt;山河故人&gt;，又是几十年后。须发皆白的我有几多儿孙，也许会在某个入院深宵不寐的时刻，恍惚间想起那个遥远年份的大年初三。那时我爷爷还老当益壮，我即将知天命的叔叔和爸爸聊着当年往事，我正对算法如痴如醉，对未来忐忑中充满期待。 一眨眼，却又都消失不见，除去空中一轮同样皎洁的弯月。时间，像一个恶作剧里的坏小子，让我再写不出过去几年的文字，让我再不能平静回忆十多年前的山遥水远。 2016.02.07 过年已经像电视机一样被日渐边缘。物质丰盛再无需把一年的饕餮欲望攒到年底一天集中爆发，技术进步天涯也如咫尺可见，那种积攒一年的期待，那样满心欢喜激动的氛围一去不返了。 我躺在床上，没感觉出今天与其它364天异样在何，只是隔窗听着不间断的响声心里还在遥想当年记忆残存的盛况：乡村夜晚的天格外漆黑，三五如豆的昏黄路灯不及天上耀眼的星，月儿皎白，我呼吸着带着火药味的寒冽空气，脚步在雪里一深一浅地吱吖吱吖，粗劣的花炮时而点缀夜空，雪花飘落挂在眉梢。那方块老电视传出的热烈喜庆的歌儿，那灶台上摆放着的各式各样的吃食，那低矮铁炉上的锅葱和牛肉馅儿水饺冒出腾腾热气，炉口摆放着的烤地瓜香气四溢。大红的对联和福字粘在门楹，细嗅还能闻出浆糊的香味。爆仗声此起彼伏，孩童欢呼，却惊怕远处寒鸦静雀。 这些封印在我的思维殿堂，已经好久没有出现。我在想，对那些长在大城市的新一代，对春节的印象和感情维系在哪里？如今在那里，内环线内禁止燃放烟花爆竹已成铁律，城市的高楼大厦也逐渐掩盖老家村庄的习俗，半生羁旅他乡终成故里。 春节尚是我们最大最广泛的文化认同之一，人活着更需要一点仪式感。单从我考虑，我希望它能如常然又知这根本无望，这些都是趋势，趋势通向的未来，我们自己都无法知晓。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"谈谈索引失效","date":"2019-02-03T14:52:59.000Z","path":"2019/02/03/谈谈索引失效/","text":"1.索引无法存储null值 &emsp; a.单列索引无法储null值，复合索引无法储全为null的值。 &emsp; b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。 &emsp; 为什么索引列无法存储Null值? &emsp; a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法比较，无法确定null出现在索引树的叶子节点位置。） &emsp; b.如果需要把空值存入索引，方法有二：其一，把NULL值转为一个特定的值，在WHERE中检索时，用该特定值查找。其二，建立一个复合索引。例如: create index ind_a on table(col1,1); &emsp; 通过在复合索引中指定一个非空常量值，而使构成索引的列的组合中，不可能出现全空值。 2.不适合键值较少的列（重复数据较多的列） &emsp; 假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问表中的2000个数据块。 &emsp;再加上访问索引块，一共要访问大于2000个的数据块。 &emsp;如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块少一些，肯定就不会利用索引了。 3.前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’) &emsp; 假如有这样一列code的值为’AAA’,’AAB’,’BAA’,’BAB’ ,如果where code like ‘%AB’条件，由于前面是模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like ‘A % ‘，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。 4.索引失效的几种情况 &emsp; 1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因) &emsp; 要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 &emsp; 2.对于多列索引，不是使用的第一部分，则不会使用索引 &emsp; 3.like查询以%开头 &emsp; 4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 &emsp; 5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引 5.MySQL主要提供2种方式的索引：B-Tree索引，Hash索引 参看 mysql索引类型(按存储结构划分) &emsp; B+树索引具有范围查找和前缀查找的能力，对于有N节点的B+树，检索一条记录的复杂度为O(LogN)。相当于二分查找。 &emsp; 哈希索引只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。 &emsp; 显然，如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。 &emsp; 如果值的差异性相对较差，并且以范围查找为主，B+树是更好的选择，它支持范围查找。","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"杂谈-创新经济的活力","date":"2019-01-31T00:06:29.000Z","path":"2019/01/31/杂谈-创新经济的活力/","text":"链接戳此","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"起承转合--由陈子昂<国殇>","date":"2019-01-20T15:04:17.000Z","path":"2019/01/20/起承转合-由陈子昂-国殇/","text":"没看上下文，乍以为这『国殇文』是王孝杰所作，着实惊讶了。相形之下，后世给狄大人杜撰的这几句看似气势激昂的台词，简直太小儿科。 公元697年，清边道行军总管王孝杰，率大军攻伐契丹。于东硖石谷(今河北唐山一带)误中埋伏，寡不敌众坠谷而亡。 两度从军，对边塞防务颇有见数的陈子昂，闻讯后悲恸不已。于他41岁人生的倒数第5年，愤而作『国殇』。一年后，陈子昂解官回乡，照看膏肓病父。而后居丧期间，为武三思指使射洪县令，罗织罪名，枉死狱中 他回四川老家这年，盛唐时代的“七绝圣手”王昌龄出生。59年后安史大乱时，这位”诗家天子”，同样以令人扼腕的悲壮方式，令后来人“天地悠悠，怆然涕下”。 陈子昂和“初唐四杰”年代大致。虽是“初唐”，其实大多不在太宗时期，而主要活动于唐高宗和武则天年间: 李世民于公元649年病逝，在位23年(略少于隋文帝)。四杰中享寿最长的骆宾王，约生于619年，卒于687年;卢照邻约生于635年，溺水亡于685年;杨炯生于650年，卒于693年，王勃同样生于650年，溺亡于676年。 从高宗649年继位至武曌705年驾崩，时间长河里约略的这窄窄一甲子，属于初唐诗人们驰骋之天地。公元8世纪前后，接过前人衣钵的晚辈已然鱼贯而出，他们有王昌龄(生于698年)，李白，王维(均生于701年)，高适(704年)。早他们而来的襄阳孟山人(孟浩然，生于689年)启后，晚一旬而来的襄阳杜工部(杜甫，生于712年)承前。至公元755年渔阳鞞鼓动地来，盛唐乃至整个民族最高光璀璨时刻，将由他们见证记述。 8年战后，开元天宝的繁盛一去不返，藩镇割据，吐蕃东扰，整个国家凋敝，生灵涂炭。战乱结束的前一年，李白“追月坠水”而去; 又8年后，生活无着老病无依的杜甫，客死于湘江上的一叶孤舟。两年后，白居易出生，此后他将四处寻落，将这60年来前辈诗文里出现的绮丽景象，和天崩地坼山呼海啸的叛乱，凝结为一曲『长恨歌』。 安史之乱发生于唐朝建立的第137个年头，距离这个王朝寿终正寝却还有152年。此后更漫长的后半程，有元白的“激情四射”，有因王叔文改革造就的一票诗文，有风格迥然的小李杜高歌低咏，但属于这个朝代，更多是江河日下的悲歌，那如日中天的60年，再也未能复演。 姊妹篇: 盛唐之殇–观&lt;长安十二时辰&gt;记 姊妹篇: 渔阳鞞鼓","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"golang之channel并发访问","date":"2019-01-19T11:38:23.000Z","path":"2019/01/19/golang之channel并发访问/","text":"channel底层是加锁的，是一个有锁的环形队列。。故而肯定并发安全 可参考 golang之channel进阶 Channel 在运行时的内部表示是 runtime.hchan，该结构体中包含了一个用于保护成员变量的互斥锁，从某种程度上说，Channel 是一个用于同步和通信的有锁队列。有很多试图通过各种方式 实现 无锁 Channel 的方案,但目前都还有各种各样问题尚不够完美.所以实际上也借助了锁 (sync.Mutex)","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之map并发访问","date":"2019-01-18T13:13:55.000Z","path":"2019/01/18/golang之map并发访问/","text":"map不是并发安全的! 并发安全也称线程安全,如果在并发中出现了数据的丢失或错乱,就是并发不安全 golang的map不是并发安全的，并发对map读写可能会报”fatal error” 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"time\")const N = 5func main() &#123; m := make(map[int]int) go func() &#123; for i := 0; i &lt; N; i++ &#123; m[i] = i*10 + 6 &#125; &#125;() go func() &#123; for i := 0; i &lt; N; i++ &#123; fmt.Println(i, m[i]) &#125; &#125;() time.Sleep(1e9 * 5)&#125; 输出为: 123450 61 162 263 364 46 上面第一个协程对map写,第二个对map读, 注:如上代码中,调换两个协程的顺序,并不会对结果有影响 当 N 较大如等于1000时,该程序将报错: 12345678910111213141516171819202122232425262728fatal error: concurrent map read and map writegoroutine 18 [running]:runtime.throw(0x10cb62d, 0x21) /usr/local/go/src/runtime/panic.go:617 +0x72 fp=0xc00002ef30 sp=0xc00002ef00 pc=0x10281e2runtime.mapaccess1_fast64(0x10ab340, 0xc000084000, 0x0, 0x0) /usr/local/go/src/runtime/map_fast64.go:21 +0x1b3 fp=0xc00002ef58 sp=0xc00002ef30 pc=0x100eac3main.main.func2(0xc000084000) /Users/shuangcui/go/note/map/1.go:22 +0x67 fp=0xc00002efd8 sp=0xc00002ef58 pc=0x1093c37runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc00002efe0 sp=0xc00002efd8 pc=0x1051b51created by main.main /Users/shuangcui/go/note/map/1.go:20 +0x6agoroutine 1 [sleep]:runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:307time.Sleep(0x12a05f200) /usr/local/go/src/runtime/time.go:105 +0x159main.main() /Users/shuangcui/go/note/map/1.go:26 +0x7dgoroutine 17 [runnable]:main.main.func1(0xc000084000) /Users/shuangcui/go/note/map/1.go:16 +0x45created by main.main /Users/shuangcui/go/note/map/1.go:14 +0x48exit status 2 解决方案: 加锁实现 可以用sync.Mutex (互斥锁)，或者sync.RWMutex(读写锁)来”重构”map, 即定义一个新的结构体,为该结构体实现两个方法,在方法里使用sync包的Mutex或RWMutex来做加锁保证并发安全. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"time\" \"sync\")const N = 1000type Cmap struct &#123; m map[int]int lock *sync.RWMutex&#125;func (c *Cmap) Get(key int) int &#123; c.lock.RLock() defer c.lock.RUnlock() return c.m[key]&#125;func (c *Cmap) Set(key, val int) &#123; c.lock.Lock() defer c.lock.Unlock() c.m[key] = val*10 + 8&#125;func main() &#123; m := make(map[int]int) lock := new(sync.RWMutex) cm := Cmap&#123; m: m, lock: lock, &#125; go func() &#123; for i := 0; i &lt; N; i++ &#123; fmt.Println(i, cm.Get(i)) &#125; &#125;() go func() &#123; for i := 0; i &lt; N; i++ &#123; cm.Set(i, i) &#125; &#125;() time.Sleep(1e9 * 5)&#125; 直接使用sync.Map 从 go1.9 开始,新增了sync.Map,对并发情况下map的安全做了支持,可以对上面代码进行简化: 1234567891011121314151617181920212223242526272829package mainimport ( \"sync\" \"fmt\" \"time\")const N = 1000func main() &#123; var m sync.Map go func() &#123; for i := 0; i &lt; N; i++ &#123; v, _ := m.Load(i) //读 fmt.Println(i, v) &#125; &#125;() go func() &#123; for i := 0; i &lt; N; i++ &#123; m.Store(i, i*10+4) //写 &#125; &#125;() time.Sleep(5 * 1e9)&#125; Store为写,Load为读 除去Store和Load两个方法,sync.Map还有几个方法: 删除 func (m *Map) Delete(key interface{}) 遍历，类似于js的forEach循环 func (m *Map) Range(f func(key, value interface{}) bool) 存或者取 func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)这个方法有点绕，举例说下： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"sync\")func main() &#123; var m sync.Map actual, loaded := m.LoadOrStore(\"k1\", \"v1\") fmt.Println(actual, loaded) // v1 false actual, loaded = m.LoadOrStore(\"k1\", \"v1\") fmt.Println(actual, loaded) // v1 true actual, loaded = m.LoadOrStore(\"k1\", \"v2\") fmt.Println(actual, loaded) // v1 true actual, loaded = m.LoadOrStore(\"k2\", \"v2\") fmt.Println(actual, loaded) // v2 false&#125; LoadOrStore方法其实是先取，如果有key的话就返回，没有再存储，即优先取，没有再存储； 该方法有两个返回值,第一个是键值,第二个是之前有无该键名(bool类型) (和缓存的做法很类似：先从缓存中取，如果没有则从数据库中读，读回来存入缓存，下次就可以从缓存中取到了。)","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之slice并发访问","date":"2019-01-17T13:08:53.000Z","path":"2019/01/17/golang之slice并发访问/","text":"slice在并发执行中不会报错, 但数据会丢失, 可以加锁解决; map在高并发执行中会直接报错, 需要加锁使用 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"sort\" \"time\")var s []intfunc appendValue(i int) &#123; s = append(s, i)&#125;func main() &#123; for i := 0; i &lt; 10000; i++ &#123; go appendValue(i) &#125; sort.Ints(s) //给切片排序,先排完序再打印, for i, v := range s &#123; fmt.Println(i, \":\", v) &#125; time.Sleep(5e9)&#125; 输出为: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002010 : 01 : 02 : 03 : 04 : 05 : 06 : 07 : 08 : 09 : 010 : 011 : 012 : 013 : 014 : 015 : 016 : 017 : 018 : 019 : 020 : 021 : 022 : 023 : 024 : 025 : 026 : 027 : 028 : 029 : 030 : 031 : 032 : 033 : 034 : 035 : 036 : 037 : 038 : 039 : 040 : 041 : 042 : 043 : 044 : 045 : 046 : 047 : 048 : 049 : 050 : 051 : 052 : 053 : 054 : 055 : 056 : 057 : 058 : 059 : 060 : 061 : 062 : 063 : 064 : 065 : 066 : 067 : 068 : 069 : 070 : 071 : 072 : 073 : 074 : 075 : 076 : 077 : 078 : 079 : 080 : 081 : 082 : 083 : 084 : 085 : 186 : 287 : 388 : 689 : 890 : 1291 : 1392 : 1493 : 1994 : 2895 : 3096 : 3197 : 3298 : 3399 : 34100 : 35101 : 36102 : 44103 : 45104 : 46105 : 47106 : 48107 : 49108 : 50109 : 51110 : 52111 : 53112 : 54113 : 55114 : 56115 : 57116 : 58117 : 59118 : 60119 : 61120 : 62121 : 63122 : 64123 : 65124 : 66125 : 67126 : 68127 : 69128 : 70129 : 71130 : 72131 : 73132 : 74133 : 75134 : 76135 : 77136 : 78137 : 79138 : 80139 : 81140 : 82141 : 83142 : 84143 : 85144 : 86145 : 87146 : 88147 : 89148 : 90149 : 91150 : 92151 : 93152 : 94153 : 95154 : 96155 : 97156 : 98157 : 99158 : 100159 : 101160 : 102161 : 103162 : 104163 : 105164 : 106165 : 107166 : 108167 : 109168 : 110169 : 111...8309 : 99708310 : 99718311 : 99728312 : 99738313 : 99748314 : 99768315 : 99778316 : 99788317 : 99798318 : 99808319 : 99818320 : 99828321 : 99838322 : 99848323 : 99858324 : 99868325 : 99878326 : 99888327 : 99898328 : 99908329 : 99918330 : 99928331 : 99938332 : 99958333 : 99968334 : 99948335 : 99978336 : 99988337 : 9999 没有到 9999 : 9999 加锁之后: 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"sort\" \"sync\" \"time\")var s []intvar lock sync.Mutexfunc appendValue(i int) &#123; lock.Lock() s = append(s, i) lock.Unlock()&#125;func main() &#123; for i := 0; i &lt; 10000; i++ &#123; go appendValue(i) &#125; sort.Ints(s) //给切片排序,先排完序再打印, for i, v := range s &#123; fmt.Println(i, \":\", v) &#125; time.Sleep(5e9)&#125; 输出为: 12345678910111213141516171819202122232425260 : 01 : 12 : 23 : 34 : 45 : 56 : 67 : 78 : 89 : 910 : 1011 : 1112 : 1213 : 1314 : 14...9992 : 99929993 : 99939994 : 99949995 : 99959996 : 99969997 : 99979998 : 99989999 : 9999 参考: golang并发安全: slice和map并发不安全,及其解决方法","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Linux中的一个彩蛋","date":"2019-01-12T13:02:54.000Z","path":"2019/01/12/Linux中的一个彩蛋/","text":"使用Linux时，当查看某命令的用法，一般都用 man xx（不过我更喜欢用精简版 tldr） man即manual的缩略，也是RTFM中的M (read the f**king manual) 但在凌晨12:30时,使用这个命令会出现 12gimme gimme gimmeWhat manual page do you want? date +%T -s &quot;00:30:00&quot; 可将系统时间置为00:30:00其中%T 显示时间，24小时制（hh:mm:ss）date -s //设置当前时间，只有root权限才能设置，其他只能查看更多可查看 date命令 有人提了这个问题 Why does man print “gimme gimme gimme” at 00:30? 始作俑者很快“自首”，man 的维护者是其好友，其开玩笑建议如果有人大半夜之后用man命令，应该打印出 “gimme gimme gimme” … 没想到他的好友真这么干了 12345678910111213141516171819202122diff --git a/src/man.c b/src/man.cindex 1978329e..48af3c08 100644--- a/src/man.c+++ b/src/man.c@@ -1154,8 +1154,16 @@ int main (int argc, char *argv[]) debug (\"\\nusing %s as pager\\n\", pager); - if (first_arg == argc)+ if (first_arg == argc) &#123;+ /* http://twitter.com/#!/marnanel/status/132280557190119424 */+ time_t now = time (NULL);+ struct tm *localnow = localtime (&amp;now);+ if (localnow &amp;&amp;+ localnow-&gt;tm_hour == 0 &amp;&amp; localnow-&gt;tm_min == 1)+ fprintf (stderr, \"gimme gimme gimme\\n\");+ gripe_no_name (NULL);+ &#125; section_list = get_section_list (); 那“gimme gimme gimme”到底什么意思呢？ 说是因为 Abba 乐队著名的 《gimme gimme gimme! (a man after midnight)》(半夜后给我找一个男人) … 参考: Linux彩蛋：gimme gimme gimme Gimme! Gimme! Gimme! (A Man After Midnight)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"竹杖赋","date":"2019-01-11T12:59:11.000Z","path":"2019/01/11/竹杖赋/","text":"桓宣武平荆州，外白：「有称楚丘先生，来诣门下。」桓公曰：「名父之子，流离江汉，孤之责矣！」及令引进，乃曰：「噫，子老矣！鹤发皮，蓬头历齿。乃是江、汉英灵，衡、荆杞梓，虽有闻于十室，幸无求于千里。寡人有铜环灵寿，银角桃枝。开木瓜而未落，养莲花而不萎。迎仙客于锦市，送游龙于葛陂。先生将以养老，将以扶危。」 先生笑而言曰：「中国明于礼义，暗于知人。心之忧矣，惟我生民。虽复条劲柘，促节贞筠，杖端刻鸟，角首图麟，岂能相予此疾，将予此身？若乃世变市朝，年移陵谷，猿吟鹰厉，风霜惨黩；楚、汉争衡，袁、曹竞逐，兽食无草，禽巢无木。于时无惧而栗，不寒而战。胡马哀吟，笳凄啭，亲友离绝，妻孥流转。玉关寄书，章台留钏，寒关凄怆，羁旅悲凉。疏毛抵于矰缴，脆骨被于风霜，发种种而愈短，眉髟髟而竞长。是以忧干扶，悲条郁结，宿昔僛丑，俄然耆耋。变田凤于承宫，改阳文于鬷蔑。潘岳秋兴，嵇生倦游，桓谭不乐，吴质长愁，皆年华未暮，容貌先秋。予此衰矣，虽然有以，非鬼非蜮，乃心忧矣。未见从心，先求顺耳。伯玉何嗟，丘明唯耻。拉虎捭熊，余犹稚童；观形察貌，子实悲翁。别有九棘庞眉，三槐暮齿，孔光谢病，袁逢致仕，吴濞不朝，杨彪丧子。明公此赠，或非乖理。」 先生乃歌曰：「秋藜促节，白藋同心。终堪荷蓧，自足驱禽。一传大夏。空成邓林。」 参考: 从《竹杖赋》解读庾信入北后对仕途的看法 《竹杖赋》是南北朝著名作家庾信入北后的借物咏怀之作。全文以“楚丘先生见桓温”始，通篇表达了“楚丘先生”对“赐杖”的强烈反应。这实际代表着自比为“楚丘先生”的庾信与隐喻为“桓宣武”的魏、周政权的一次正面交涉。正是基于这个原因，此赋对说明庾信入北后的仕隐观，就成为不可忽视的一个证据。但令人遗憾的是，后人对此赋寓意的推测往往莫衷一是，竟然形成了“辞官之作”和“求官之作”两种截然不同的看法！前者认定魏、周逼迫庾信仕敌，过分关注庾信的“哀思”，继而推理出庾信由“哀”到“恨”，不情愿步入北周仕途的心态，得出此篇亦为哀思之作；后者认为庾信入北后因为对自身的高度自负与现实有强烈的反差，借文章表达求官之意。其实这两种看法都忽视了庾信心态的矛盾性，因而难免各有片面之见。事实上庾信在入北后一直怀有矛盾的心情，一方面他总结了梁王朝灭亡的原因，指出了梁元帝在政治、军事、外交等方面的失误（见《哀江南赋》），可见他虽恨西魏政权夺他家园，使得他不能返回故土，但也不能不面对现实，客观地总结教训，况且陈已代梁，想回也回不去了。面对这个现实，羁留北方多年的庾信不再象刚入北时那样愤怒。同时他在魏、周也得到了一定的尊敬，出于实现个人抱负的想法，他也想做出一番事业！只是家仇国恨一直困扰着他，强烈的思乡又使他悲伤不已，所以他一面仕周，一面在作品中自然流露出哀伤的情感。这种矛盾的心理，使得他进入了“仕途”与“归田”两难的境地。因此他在文中所表达的思想情感也时时存在着矛盾，如何把握这种矛盾的心态是理解此赋的关键。桓宣武平荆州，外白：“有称楚丘先生，来诣门下。”庾信在赋中为何要设置桓温和楚丘先生这两个人物，成为后人理解此赋时第一个要点。桓温为东晋大将，永和元年（345年）任荆州刺史，专擅朝政，死后封宣武侯。其子篡晋帝位，追其为宣武皇帝。这与魏相宇文泰的发迹史十分相似。这里有个历史问题，宇文泰并不是平荆州的人，而且平荆州时庾信也不在江陵，因此桓温指代谁也引起了后人的争议。鲁释在桓宣武指代谁的问题上，认为不过是 “借古人发端，并无需合乎历史，更不益事事比附。”这一理解典故的方法十分可取，但他在解释时仍有拘泥：鉴于史实，他推翻了倪释的桓玄武指代宇文泰的说法，指出桓玄武实际上既非宇文泰，亦非于瑾，而是比喻北周朝廷，又各含于瑾、周武帝的影子。我认为根据鲁释的出发点，就不必拘泥于宇文泰是否参与当平荆州，庾信借用桓温其人，显然意在比喻北魏与北周得当权者。“楚丘”、“荆州”都指代梁元帝时的国都“江陵”。可见庾信时时不忘自己的来历。“楚丘先生”，倪释中提到是出自刘向《新序》“楚丘先生见孟尝君”。谭正璧、纪馥华《庾信诗赋选》注出处为《韩诗外传》，记载如下：“楚丘先生披蓑带索，往见孟尝君。孟尝君曰：‘先生老矣！春秋高矣！多遗忘矣！何以教文？楚丘先生曰：‘恶君谓我老！恶君谓我老！意者将使我投石超距乎？追车赴马乎？逐麋鹿、搏豹虎乎？吾则死矣，何暇老哉！将使我深计远谋乎？定犹豫而决嫌疑乎？出正辞而当诸侯乎？吾乃始壮耳，何老之有！孟尝君赧然，汗出至踵，曰：‘文过矣！文过矣！诗曰：‘老夫灌灌。”刘向《新序》中所记与此大体相同。这段典故能否成为证明《竹杖赋》为求官之作的首要依据？有必要参照赋中如下描写：桓帝曰：“名父之子，流离江汉，孤之责矣！”及命引进，乃曰：“噫，子老矣！鹤发鸡皮，蓬头历齿。乃是江、汉英灵，衡、荆杞梓，虽有闻於十室，幸无求於千里。寡人有铜环灵寿，银角桃枝。开木瓜而未落，养莲花而不萎。迎仙客於锦市，送游龙於葛陂。先生将以养老，将以扶危。”所谓“名父之子”与庾信的身世很吻合。我国古代王朝，都有赐杖与老臣的惯例，如：《礼记?王制》：“五十杖于家，六十杖于乡，七十杖于国，八十杖于朝。”；《礼记·曲礼》：“大夫七十而致事。若不得谢，则必赐之几杖。”；“谋与长者，必操几杖以从之。”可见赐杖之举偏重于尊老，“先生将以养老，将以扶危”。对于赐杖的理解，鲁释把重点放在“养老”，而倪释把重点放在“扶危”上，认为这是魏、周王朝借赐杖赋予庾信以权位。虽然授杖也有过给予权力的象征，但是从下文楚丘先生举的几个“授杖”的例子：“孔光谢病，袁逢致仕，吴濞不朝，杨彪丧子”，读者不难看出，这里的“授杖”重点在于“养老”，倪注不确，谭正璧、纪馥华释为 “是魏、周逼己以仕也”也是臆测。 但是否真如鲁释所说是庾信 “求官”的发端？其实庾信在接着的一段文字中，借楚丘先生之口，已表达出此时自己对做官的态度：先生笑而言曰：“中国明於礼义，闇於知人。心之忧矣，为我生民。这句话可谓庾信的心理写照！上文桓宣武十分客气委婉的表达了对楚丘先生“老矣”的看法，庾信对此既礼貌地点出了所谓“赐杖”是符合“礼义”的，又对当权者不懂己心的事实作了先扬后抑式的批评。这里“闇於知人”有两重意思：一是不知民心，二是不知庾信之心，即他的抱负所在：“心之忧矣，为我生民”，把“民心”与“己心”很好的连在了一起。“重民生”是庾信思想的重要内涵：“在昔金陵，天下丧乱，王室板荡，生民涂炭”（《伤心赋》）、“城崩杞妇之哭，竹染湘妃之泪”《哀江南赋》；由于他长期为官，也有一套政治理论和思想：“达人以四海为务，明君以百姓为心”（《郊庙歌辞·徵调曲》）、 “皇帝以上圣之姿……克己备于礼容，威武总于戎政……百姓为心，虽复疏条劲拓，促节贞筠，杖端刻鸟，角首图麟，岂能相予此疾，将于此身！若乃世变市朝，年移陵谷，猿吟鹰厉，风霜惨黩；楚、汉争衡，袁、曹竞逐，兽食无草，禽巢无木。於时无惧而慄，不寒而战。胡马哀吟，羌笳凄啭，亲友离绝，妻孥流转，玉关寄书，章台留钏，寒关凄怆，羁旅悲凉。庾信针对“赐杖”一事，不断表述自己的“忧”，百姓的“苦难”，从“若乃世变市朝”到“羁旅悲凉”几句，全是庾信战乱中的所见所感。这其中包含了对自己处境幽怨，同时更多的是在向当权者控诉战争的残酷。庾信赋予“楚丘先生”以善辩之才，抓住 “赐杖”一事，在其 “忧而貌老”上大做文章！疏毛抵於矰缴，脆骨被於风霜。发种种而愈落，眉髟髟而竞长。是以忧干扶疏，悲条郁结，宿昔僛丑，俄然耄耋。变田凤於承宫，改阳文於鬷篾。潘越秋兴，嵇生倦游，桓谭不乐，吴质长愁，并皆年华未暮，容貌先秋。予此衰矣，虽然有以，非鬼非蜮，乃心忧矣。未见从心，先求顺耳。伯玉何嗟，丘明唯耻，拉虎捭熊，予犹稚童；观形察貌，子实悲翁。别有九棘庞眉，三槐暮齿，孔光谢病，袁逢致仕，吴濞不朝，杨彪丧子。明公此赠，或非乖理。这段话曾被研究者作为证明庾信有求官之心主要依据，但文意的理解果然如此吗？从“疏毛抵於矰缴”到“俄然耄耋”，都是庾信对自己老态的直接描写。“变田凤於承宫，改阳文於鬷篾。”均是由貌美之人变成丑陋之人。这种“老丑”的变化，与上文所提到的经历了世事沧桑，整日“惧怕”、“寒心”、“悲哀”是密不可分的。庾信为了强调自己的衰老是由于“心病”的缘故，因此他一连举了四个因心忧而容貌先衰的例子：“潘越秋兴，嵇生倦游，桓谭不乐，吴质长愁，并皆年华未暮，容貌先秋。”他的重点不是在反驳自己貌老，而是在一直强调貌老的实际原因。“未见从心，先求顺耳。伯玉何嗟，丘明唯耻”一句,倪释为庾信自觉虽匿怨于魏周，却仍在出仕，实在可耻，意在强调若不是魏、周强逼，庾信本身是不愿以身仕敌的。这种说法不确切。《论语·为政篇》：“子曰：‘六十而耳顺，七十而从心所欲，不逾距。”作者在说明自己年龄的同时，也隐约透露了对目前人生状况的一种无奈。《论语·公冶长》“子曰：‘匿怨而友其人，左丘明耻之，丘亦耻之。”这句意思是说对于自己怨恨的人，把怨恨隐藏在内心深处而与他交往，对于这样的事情，左丘明感到羞耻，不会去做，我（孔子）也感到羞耻，不会做这样的事情的。庾信深受儒家思想的影响，自然也遵循着这一原则，他在复述自己貌老的原因时，实际上也是在表达心中的些许不满，即“怨”：因统治者发动战争，弄得民不聊生，本身也因心忧而早衰。自己已然身事敌国，这些沉痛的经历就不能不反思，这些“怨由”就更不能不说！否则“伯玉何嗟，丘明唯耻。”这里并不存在逼仕的问题，而是作者在对无可奈何的命运的感伤！庾信对当权者说他“老”有否辩解，这成为理解其入仕心态的关键。而对赋中“拉虎捭熊，予犹稚童”一句的理解大为举足轻重。此句真如有的阐释者所说是他在向统治者证明自己力犹能仕吗？这里又要翻看前文所说“楚丘先生见孟尝君”的典故了，乍一看，好像庾信犹如楚丘先生，在力驳统治者对其不能为官的判断。但我认为这句话恰恰证明了庾信此番前来不是为了求官！仔细比较庾信与楚丘先生的不同，这个问题就可以迎刃而解。一，楚丘先生真的有七十岁了，而庾信要年轻得多；二，楚丘先生明确表示自己年老，不能胜任年轻力壮的人所做的事了：“意者将使我投石超距乎？追车赴马乎？逐麋鹿、搏豹虎乎？吾则死矣，何暇老哉！”这是以体力上的衰弱与心智上的茂盛形成对比。庾信始终在“貌老”上做文章，强调的是形态上的衰老：“拉虎捭熊，予犹稚童；观形察貌，子实悲翁”，进而道出未老先衰的缘由；三，楚丘先生有明确的求官目的，“将使我深计远谋乎？定犹豫而决嫌疑乎？出正辞而当诸侯乎？吾乃始壮耳，何老之有！”而庾信一直在强调“心之忧矣，为我生民”，这其实也正是庾信的政治理想和抱负的叙说。综合这三点，我认为庾信并不是在驳其年老以求得官职，而是借题发挥，坦陈了自己的怨言和抱负。理解了这一点，我们再看结局是不肯“受杖”，更能明白作者的内在意图。先生乃歌曰：“秋藜促节，白藋同心。终堪荷筱，自足驱禽。一传大夏，空成邓林。”对于这段“歌词”，几乎所有的注释都未予深论。但这恰恰是庾信矛盾心理的体现。“秋藜”、“ 白藋”都是野生植物，和竹子体性相通：“促节”、“同心”，“荷筱”、“驱禽”。竹从大夏传来，做成竹杖。“空成邓林”的典故取自《山海经》夸父追日的故事，表明持杖的人达不到自己的理想，也只能弃其杖，化成树林，反而不如卑贱的野草实用。这正是庾信的兴叹，也使原本靠个人意志所能决定的不肯受杖之举，更染上了一种宿命的色彩。庾信在入北后确实经历了一段生不如死的丧国被羁的痛苦，但他毕竟是个软弱的文人，在归国无望的情况下，他的政治主张和思想，尤其是民本思想，也希望得到统治者的认可，他对待仕途既不是毫无眷恋，也并不是十分渴求。在经历了变故后，庾信一直处在矛盾和痛苦之中，变故使他的一些思想得到升华，作为故国遗臣，他悔恨自己的懦弱，痛恨魏、周夺取他的家园；作为现任政府的官员，他又想把自己丧国的经验教训和原来的抱负理想运用进去，所以赋中的寓意人物“楚丘先生”去见了统治者，但偏偏统治者触动了他内心的痛楚，从而得以借题发挥。(刘雅娇，南京大学外国语学院)","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"常见生僻词","date":"2018-12-24T06:02:43.000Z","path":"2018/12/24/常见生僻词/","text":"List 4 census statute assumption catastrophe Conclusion accommodate accuracy acquaintance acquisitive adaptiveness adolescent ache agony ample analogous anecdote appliance articulately assumption authentic bacteria bait ballot barn betray burdensome byproduct chamber compel connotation cunning dense depletion deprivation dictate diffusion dormant dreadful dull egalitarian elimination ember enlightened enthrone exotic fallacy feeble fertile hypocrisy impoverished inevitable ingenuity interpret ironic irritating mediocrity narrative nasty saturate scorn senator smog spouse tactic vulgar","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"希尔排序","date":"2018-12-22T06:44:24.000Z","path":"2018/12/22/希尔排序/","text":"希尔排序(Shell Sort) 在研究希尔排序前,要先理清插入排序 希尔排序(Shell Sort)是插入排序的一种,又称“缩小增量排序”（Diminishing Increment Sort). 希尔排序是直接插入排序算法的一种更高效的改进版本. 希尔排序是非稳定排序算法. 希尔排序是把记录按下标的一定增量分组,对每组使用直接插入排序算法排序;随着增量逐渐减少,每组包含的关键词越来越多,当增量减至1时,整个文件恰被分成一组,算法便终止。 相较直接插入排序，希尔排序减少了比较和交换的次数，在中小规模的排序中，性能表现较好。但随着数据量增大，希尔排序与其他更好的排序算法（快排、堆排、并归等）仍有较大差距。 参考下面两张图片,可知实际上 上图有误,希尔排序的平均时间复杂度是n的1.5次方 希尔排序的平均时间复杂度，应该是 待排序元素数量n的1.5次方…网上以讹传讹，整了个迷一般的1.3次方，让我很长一段时间如坠云雾。直接插入排序，其平均时间复杂度应该是1/4*n的平方，虽然同样是n²级别，但因为前面聊胜于无的1/4，其性能稍好于冒泡排序和简单选择排序。而升级版的直接插入排序，即希尔排序，是第一个使排序算法平均时间复杂度突破n²这一关隘的算法，即便在问世一年后，便被快速排序抢了风头。如果说快速排序pivot即枢轴值的选取，三值取中或九值取中，其后涉及复杂的数学运算。那希尔排序这个增量increment(也被称为Gap值)的选取，竟然还是一门没有确切答案的玄学。希尔排序在不同增量序列下的效率差异, 和素数又有 似隐似现若即若离的关联 相比于冒泡排序和(直接)插入排序,希尔排序 可以很大程度优化算法的时间复杂度.在快速排序出现前,Shell Sort算是最先进的排序~ 希尔排序是 D.L.Shell 于 1959 年提出, 快速排序则是 Tony Hoare 在1960年提出. 两者都是不稳定排序 具体算法 一般情况下,初次取序列的一半为增量,以后每次减半,直到增量为1. 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\")func main() &#123; list := []int&#123;3, 7, 2, 3, 8, 0, 1, 9, 6, 5&#125; shellSort(list, len(list)/2) fmt.Println(list)&#125;/**希尔排序：把切片分成n个batch，对每个batch进行插入排序；然后减小batch，再对每个batch进行插入排序；直到bathc等于1*/func shellSort(arr []int, batchSize int) &#123; if batchSize &lt; 1 &#123; return &#125; // k : 每个batch中的元素所在batch的index， 介于[0, batchSize) for k := 0; k &lt; batchSize; k++ &#123; // 用到了插入排序 for j := 1; batchSize*j+k &lt; len(arr); j++ &#123; // j: 用来获取每个batch所在的第k个元素，拥有多少个batch for n := j; n &gt; 0; n-- &#123; pre := batchSize*(n-1) + k next := batchSize*n + k if arr[next] &lt; arr[pre] &#123; arr[next], arr[pre] = arr[pre], arr[next] &#125; &#125; &#125; &#125; shellSort(arr, batchSize/2) //以2为步长&#125; 另一种写法: 123456789101112131415161718192021func ShellSort(a []int) &#123; n := len(a) h := 1 for h &lt; n/3 &#123; //寻找合适的间隔h h = 3*h + 1 &#125; for h &gt;= 1 &#123; //将数组变为间隔h个元素有序 for i := h; i &lt; n; i++ &#123; //间隔h插入排序 for j := i; j &gt;= h &amp;&amp; a[j] &lt; a[j-h]; j -= h &#123; swap(a, j, j-h) &#125; &#125; h /= 3 &#125;&#125; func swap(slice []int, i int, j int) &#123; slice[i], slice[j] = slice[j], slice[i]&#125; 参考: 希尔排序（golang实现） 希尔排序(golang实现)-2 golang实现希尔排序","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"康乾三部曲--逝去的二月河 不逝的大河风","date":"2018-12-16T12:16:50.000Z","path":"2018/12/16/康乾三部曲-逝去的二月河-不逝的大河风/","text":"“不愿当官”的作家二月河去世了 在几部&lt;大秦帝国&gt;问世并搬上银幕前，康乾三部曲堪称历史帝王作品之最。 青年福临爱妃早殁一念成佛，少年玄烨被孝庄推上前台，擒鳌拜，削三藩，平云南，收台湾，剿灭葛尔丹，合围雅克萨，从年少无知到精于驭人，成一代圣主。穿插其间的“老祖宗”，苏麻，指代曹寅的魏东亭，小毛子，周培公，姚启圣，李光地，还有争斗一生在狱中又相会的索明二相，大阿哥与太子的互相倾轧，以及让人唏嘘不已的容妃和蓝琪儿（初中时我尊敬不已的那位学识渊博的男性历史老师，认为将康熙众多妃嫔子女具象为容妃和蓝琪儿为败笔，我也这样认为，但局限于主线除此取舍无更佳选择，&lt;贞观长歌&gt;中嫁与夷男的安康公主，和蓝琪儿被迫远嫁葛尔丹剧情如出一辙）。 &lt;雍正王朝&gt;起于康熙末期吏治腐败，焦晃的老年康熙慈眉善目威而不怒，挖掘机学校哪家强的中年雍正老成持重身有城府，兼有被最近些年穿越剧一再刻画的八王，年少有勇的老十四，兄弟情深忠心耿耿的老十三，还有历史上无数次翻版重演的年羹尧（竟然和演侯君集的系同一人，今其子承父业，亦有板有眼）。雍正在民间“得位不正”的质疑声中，在“父以子贵”的看法中登台，焚膏接晷宵衣旰食，短短十几年，却承上启下。 及至乾隆，虽是盛世之巅，同样也是跌落之始，这个“十全老人”和地球那边伟大的华盛顿同年去世，渔阳鞞鼓动地来，半个世纪后，来自西洋英吉利的坚船利炮，敲开了帝国故步自封的自信和自负。 从影响力说，三部曲承下行递减之势，尤其最后，&lt;乾隆王朝&gt;堪称断崖式跌落。但恰恰我认为最经典一句出自最后:痴子，世界原是大戏台，毋须掬泪；傻子，戏台本来小世界，且宜佯疯。","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"预分配map/slice","date":"2018-12-15T15:06:52.000Z","path":"2018/12/15/预分配map-slice/","text":"参考自 聊聊Go内存优化和相关底层机制 预分配主要针对map, slice这类数据结构，当知道它(大概)会有多少元素时，就提前分配，一来可以避免多次内存分配，另则也可以减少space grow带来的数据迁移(map evacuate or slice copy)开销 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainfunc main() &#123;&#125;func noPrepare() &#123; n := 10 src := make([]int, n) // 无预分配: 162 ns/op var dst []int for i := 0; i &lt; n; i++ &#123; // src[i]为默认值0 dst = append(dst, src[i]) &#125;&#125;func prePare() &#123; n := 10 src := make([]int, n) // 预分配，32.3 ns/op，提升了5倍 dst2 := make([]int, 0, n) for i := 0; i &lt; n; i++ &#123; // src[i]为默认值0 dst2 = append(dst2, src[i]) &#125;&#125;func prePareAppend() &#123; n := 10 src := make([]int, n) dst2 := make([]int, 0, n) // 预分配+append...: 30.1 ns/op dst2 = append(dst2, src...)&#125;func prePareCopy() &#123; n := 10 src := make([]int, n) dst2 := make([]int, 0, n) // 预分配+copy: 26.0 ns/op copy(dst2, src)&#125; webbench_test.go: 1234567891011121314151617181920212223242526272829package mainimport ( \"testing\")func BenchmarkTest1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; noPrepare() &#125;&#125;func BenchmarkTest2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; prePare() &#125;&#125;func BenchmarkTest3(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; prePareAppend() &#125;&#125;func BenchmarkTest4(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; prePareCopy() &#125;&#125; 执行 go test --bench=. -benchmem 结果如下： 123456789goos: darwingoarch: arm64pkg: prepareBenchmarkTest1-8 9454321 119.2 ns/op 328 B/op 6 allocs/opBenchmarkTest2-8 32285764 36.72 ns/op 160 B/op 2 allocs/opBenchmarkTest3-8 33689056 35.73 ns/op 160 B/op 2 allocs/opBenchmarkTest4-8 36870369 32.37 ns/op 160 B/op 2 allocs/opPASSok prepare 5.033s 119.2 ns/op 表示每次操作耗时119.2纳秒328 B 表示每次操作 用了328字节(Byte)6 allocs 表示每次操作分配6次内存 很多代码分析工具如prealloc可以帮助检查代码中可做的预分配优化","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"受戒","date":"2018-12-13T15:29:53.000Z","path":"2018/12/13/受戒/","text":"小瞎子和野羊坳里尖声细气的小妮子兰秀儿，小和尚明海和庵赵庄的村姑小英子，可能正是惨惨烈的现世与桃花源里乌托邦。前作写于1985年，史铁生34岁，亦是其瘫痪后的第13年，同时并发肾病。后作写于1980年，汪曾祺60岁，“写四十三年前的一个梦”——这是公认的被认为汪曾祺代表作品，每个人少年时可能都是明海，住着一个小英子（反之亦然）。直到不久前，天天加班的我读到其「职业」，百感并集以之为其最。 几年前读完迅哥儿「在酒楼上」，并仿照其语气口吻驺了篇「在地铁上」，就深刻意识到，相比于世界范围短篇小说的三巨头，许是文化隔阂太巨，许是翻译过程丢了味道，反倒是近现代国内的作家，更能激发我的阅读欲 受戒 汪曾祺 明海出家已经四年了。 他是十三岁来的。 这个地方的地名有点怪，叫庵赵庄。赵，是因为庄上大都姓赵。叫做庄，可是人家住得很分散，这里两三家，那里两三家。一出门，远远可以看到，走起来得走一会，因为没有大路，都是弯弯曲曲的田埂。庵，是因为有一个庵。庵叫苦提庵，可是大家叫讹了，叫成荸荠庵。连庵里的和尚也这样叫。“宝刹何处？”——“荸荠庵。”庵本来是住尼姑的。“和尚庙”、“尼姑庵”嘛。可是荸荠庵住的是和尚。也许因为荸荠庵不大，大者为庙，小者为庵。 明海在家叫小明子。他是从小就确定要出家的。他的家乡不叫“出家”，叫“当和尚”。他的家乡出和尚。就像有的地方出劁猪的，有的地方出织席子的，有的地方出箍桶的，有的地方出弹棉花的，有的地方出画匠，有的地方出婊子，他的家乡出和尚。人家弟兄多，就派一个出去当和尚。当和尚也要通过关系，也有帮。这地方的和尚有的走得很远。有到杭州灵隐寺的、上海静安寺的、镇江金山寺的、扬州天宁寺的。一般的就在本县的寺庙。明海家田少，老大、老二、老三，就足够种的了。他是老四。他七岁那年，他当和尚的舅舅回家，他爹、他娘就和舅舅商议，决定叫他当和尚。他当时在旁边，觉得这实在是在情在理，没有理由反对。当和尚有很多好处。一是可以吃现成饭。哪个庙里都是管饭的。二是可以攒钱。只要学会了放瑜伽焰口，拜梁皇忏，可以按例分到辛苦钱。积攒起来，将来还俗娶亲也可以；不想还俗，买几亩田也可以。当和尚也不容易，一要面如朗月，二要声如钟磬，三要聪明记性好。他舅舅给他相了相面，叫他前走几步，后走几步，又叫他喊了一声赶牛打场的号子：“格当嘚——”，说是“明子准能当个好和尚，我包了！”要当和尚，得下点本，——念几年书。哪有不认字的和尚呢！于是明子就开蒙入学，读了《三字经》、《百家姓》、《四言杂字》、《幼学琼林》、《上论、下论》、《上孟、下孟》，每天还写一张仿。村里都夸他字写得好，很黑。 舅舅按照约定的日期又回了家，带了一件他自己穿的和尚领的短衫，叫明子娘改小一点，给明子穿上。明子穿了这件和尚短衫，下身还是在家穿的紫花裤子，赤脚穿了一双新布鞋，跟他爹、他娘磕了一个头，就随舅舅走了。 他上学时起了个学名，叫明海。舅舅说，不用改了。于是“明海”就从学名变成了法名。 过了一个湖。好大一个湖！穿过一个县城。县城真热闹：官盐店，税务局，肉铺里挂着成边的猪，一个驴子在磨芝麻，满街都是小磨香油的香味，布店，卖茉莉粉、梳头油的什么斋，卖绒花的，卖丝线的，打把式卖膏药的，吹糖人的，耍蛇的，……他什么都想看看。舅舅一劲地推他：“快走！快走！” 到了一个河边，有一只船在等着他们。船上有一个五十来岁的瘦长瘦长的大伯，船头蹲着一个跟明子差不多大的女孩子，在剥一个莲蓬吃。明子和舅舅坐到舱里，船就开了。明子听见有人跟他说话，是那个女孩子。 “是你要到荸荠庵当和尚吗？” 明子点点头。 “当和尚要烧戒疤呕！你不怕？” 明子不知道怎么回答，就含含糊糊地摇了摇头。 “你叫什么？” “明海。” “在家的时候？” “叫明子。” “明子！我叫小英子！我们是邻居。我家挨着荸荠庵。——给你！” 小英子把吃剩的半个莲蓬扔给明海，小明子就剥开莲蓬壳，一颗一颗吃起来。 大伯一桨一桨地划着，只听见船桨拨水的声音： “哗——许！哗——许！” …… 荸荠庵的地势很好，在一片高地上。这一带就数这片地势高，当初建庵的人很会选地方。门前是一条河。门外是一片很大的打谷场。三面都是高大的柳树。山门里是一个穿堂。迎门供着弥勒佛。不知是哪一位名士撰写了一副对联： 大肚能容容天下难容之事 开颜一笑笑世间可笑之人 弥勒佛背后，是韦驮。过穿堂，是一个不小的天井，种着两棵白果树。天井两边各有三间厢房。走过天井，便是大殿，供着三世佛。佛像连龛才四尺来高。大殿东边是方丈，西边是库房。大殿东侧，有一个小小的六角门，白门绿字，刻着一副对联： 一花一世界 三藐三菩提 进门有一个狭长的天井，几块假山石，几盆花，有三间小房。 小和尚的日子清闲得很。一早起来，开山门，扫地。庵里的地铺的都是箩底方砖，好扫得很，给弥勒佛、韦驮烧一炷香，正殿的三世佛面前也烧一炷香、磕三个头、念三声“南无阿弥陀佛”，敲三声磬。这庵里的和尚不兴做什么早课、晚课，明子这三声磬就全都代替了。然后，挑水，喂猪。然后，等当家和尚，即明子的舅舅起来，教他念经。 教念经也跟教书一样，师父面前一本经，徒弟面前一本经，师父唱一句，徒弟跟着唱一句。是唱哎。舅舅一边唱，一边还用手在桌上拍板。一板一眼，拍得很响，就跟教唱戏一样。是跟教唱戏一样，完全一样哎。连用的名词都一样。舅舅说，念经：一要板眼准，二要合工尺。说：当一个好和尚，得有条好嗓子。说：民国二十年闹大水，运河倒了堤，最后在清水潭合龙，因为大水淹死的人很多，放了一台大焰口，十三大师——十三个正座和尚，各大庙的方丈都来了，下面的和尚上百。谁当这个首座？推来推去，还是石桥——善因寺的方丈！他往上一坐，就跟地藏王菩萨一样，这就不用说了；那一声“开香赞”，围看的上千人立时鸦雀无声。说：嗓子要练，夏练三伏，冬练三九，要练丹田气！说：要吃得苦中苦，方为人上人！说：和尚里也有状元、榜眼、探花！要用心，不要贪玩！舅舅这一番大法要说得明海和尚实在是五体投地，于是就一板一眼地跟着舅舅唱起来： “炉香乍爇——” “炉香乍爇——” “法界蒙薰——” “法界蒙薰——” “诸佛现金身……” “诸佛现金身……” …… 等明海学完了早经，——他晚上临睡前还要学一段，叫做晚经，——荸荠庵的师父们就都陆续起床了。 这庵里人口简单，一共六个人。连明海在内，五个和尚。 有一个老和尚，六十几了，是舅舅的师叔，法名普照，但是知道的人很少，因为很少人叫他法名，都称之为老和尚或老师父，明海叫他师爷爷。这是个很枯寂的人，一天关在房里，就是那“一花一世界”里。也看不见他念佛，只是那么一声不响地坐着。他是吃斋的，过年时除外。 下面就是师兄弟三个，仁字排行：仁山、仁海、仁渡。庵里庵外，有的称他们为大师父、二师父；有的称之为山师父、海师父。只有仁渡，没有叫他“渡师父”的，因为听起来不像话，大都直呼之为仁渡。他也只配如此，因为他还年轻，才二十多岁。 仁山，即明子的舅舅，是当家的。不叫“方丈”，也不叫“住持”，却叫“当家的”，是很有道理的，因为他确确实实干的是当家的职务。他屋里摆的是一张帐桌，桌子上放的是帐簿和算盘。帐簿共有三本。一本是经帐，一本是租帐，一本是债帐。和尚要做法事，做法事要收钱，——要不，当和尚干什么？常做的法事是放焰口。正规的焰口是十个人。一个正座，一个敲鼓的，两边一边四个。人少了，八个，一边三个，也凑合了。荸荠庵只有四个和尚，要放整焰口就得和别的庙里合伙。这样的时候也有过，通常只是放半台焰口。一个正座，一个敲鼓，另外一边一个。一来找别的庙里合伙费事；二来这一带放得起整焰口的人家也不多。有的时候，谁家死了人，就只请两个，甚至一个和尚咕噜咕噜念一通经，敲打几声法器就算完事。很多人家的经钱不是当时就给，往往要等秋后才还。这就得记帐。另外，和尚放焰口的辛苦钱不是一样的。就像唱戏一样，有份子。正座第一份。因为他要领唱，而且还要独唱。当中有一大段“叹骷髅”，别的和尚都放下法器休息，只有首座一个人有板有眼地曼声吟唱。第二份是敲鼓的。你以为这容易呀？哼，单是一开头的“发擂”，手上没功夫就敲不出迟疾顿挫！其余的，就一样了。这也得记上：某月某日、谁家焰口半台，谁正座，谁敲鼓……省得到年底结帐时赌咒骂娘。……这庵里有几十亩庙产，租给人种，到时候要收租。庵里还放债。租、债一向倒很少亏欠，因为租佃借钱的人怕菩萨不高兴。这三本帐就够仁山忙的了。另外香烛、灯火、油盐“福食”，这也得随时记记帐呀。除了帐簿之外，山师父的方丈的墙上还挂着一块水牌，上漆四个红字：“勤笔免思”。 仁山所说当一个好和尚的三个条件，他自己其实一条也不具备。他的相貌只要用两个字就说清楚了：黄，胖。声音也不像钟磬，倒像母猪。聪明么？难说，打牌老输。他在庵里从不穿袈裟，连海青直裰也免了。经常是披着件短僧衣，袒露着一个黄色的肚子。下面是光脚趿拉着一对僧鞋，——新鞋他也是趿拉着。他一天就是这样不衫不履地这里走走，那里走走，发出母猪一样的声音：“呣——呣——”。 二师父仁海。他是有老婆的。他老婆每年夏秋之间来住几个月，因为庵里凉快。庵里有六个人，其中之一，就是这位和尚的家眷。仁山、仁渡叫她嫂子，明海叫她师娘。这两口子都很爱干净，整天的洗涮。傍晚的时候，坐在天井里乘凉。白天，闷在屋里不出来。 三师父是个很聪明精干的人。有时一笔帐大师兄扒了半天算盘也算不清，他眼珠子转两转，早算得一清二楚。他打牌赢的时候多，二三十张牌落地，上下家手里有些什么牌，他就差不多都知道了。他打牌时，总有人爱在他后面看歪头胡。谁家约他打牌，就说“想送两个钱给你。”他不但经忏俱通（小庙的和尚能够拜忏的不多），而且身怀绝技，会“飞铙”。七月间有些地方做盂兰会，在旷地上放大焰口，几十个和尚，穿绣花袈裟，飞铙。飞铙就是把十多斤重的大铙钹飞起来。到了一定的时候，全部法器皆停，只几十副大铙紧张急促地敲起来。忽然起手，大铙向半空中飞去，一面飞，一面旋转。然后，又落下来，接住。接住不是平平常常地接住，有各种架势，“犀牛望月”、“苏秦背剑”……这哪是念经，这是耍杂技。也许是地藏王菩萨爱看这个，但真正因此快乐起来的是人，尤其是妇女和孩子。这是年轻漂亮的和尚出风头的机会。一场大焰口过后，也像一个好戏班子过后一样，会有一个两个大姑娘、小媳妇失踪，——跟和尚跑了。他还会放“花焰口”。有的人家，亲戚中多风流子弟，在不是很哀伤的佛事——如做冥寿时，就会提出放花焰口。所谓“花焰口”就是在正焰口之后，叫和尚唱小调，拉丝弦，吹管笛，敲鼓板，而且可以点唱。仁渡一个人可以唱一夜不重头。仁渡前几年一直在外面，近二年才常住在庵里。据说他有相好的，而且不止一个。他平常可是很规矩，看到姑娘媳妇总是老老实实的，连一句玩笑话都不说，一句小调山歌都不唱。有一回，在打谷场上乘凉的时候，一伙人把他围起来，非叫他唱两个不可。他却情不过，说：“好，唱一个。不唱家乡的。家乡的你们都熟，唱个安徽的。” 姐和小郎打大麦， 一转子讲得听不得。 听不得就听不得， 打完了大麦打小麦。 唱完了，大家还嫌不够，他就又唱了一个： 姐儿生得漂漂的，两个xx子翘翘的。 有心上去摸一把， 心里有点跳跳的。 …… 这个庵里无所谓清规，连这两个字也没人提起。 仁山吃水烟，连出门做法事也带着他的水烟袋。 他们经常打牌。这是个打牌的好地方。把大殿上吃饭的方桌往门口一搭，斜放着，就是牌桌。桌子一放好，仁山就从他的方丈里把筹码拿出来，哗啦一声倒在桌上。斗纸牌的时候多，搓麻将的时候少。牌客除了师兄弟三人，常来的是一个收鸭毛的，一个打兔子兼偷鸡的，都是正经人。收鸭毛的担一副竹筐，串乡串镇，拉长了沙哑的声音喊叫： “鸭毛卖钱——！” 偷鸡的有一件家什——铜蜻蜓。看准了一只老母鸡，把铜蜻蜓一丢，鸡婆子上去就是一口。这一啄，铜蜻蜓的硬簧绷开，鸡嘴撑住了，叫不出来了。正在这鸡十分纳闷的时候，上去一把薅住。 明子曾经跟这位正经人要过铜蜻蜓看看。他拿到小英子家门前试了一试，果然！小英的娘知道了，骂明子： “要死了！儿子！你怎么到我家来玩铜蜻蜓了！” 小英子跑过来： “给我！给我！” 她也试了试，真灵，一个黑母鸡一下子就把嘴撑住，傻了眼了！ 下雨阴天，这二位就光临荸荠庵，消磨一天。 有时没有外客，就把老师叔也拉出来，打牌的结局，大都是当家和尚气得鼓鼓的：“×妈妈的！又输了！下回不来了！” 他们吃肉不瞒人。年下也杀猪。杀猪就在大殿上。一切都和在家人一样，开水、木桶、尖刀。捆猪的时候，猪也是没命地叫。跟在家人不同的，是多一道仪式，要给即将升天的猪念一道“往生咒”，并且总是老师叔念，神情很庄重： “……一切胎生、卵生、息生，来从虚空来，还归虚空去往生再世，皆当欢喜。南无阿弥陀佛！” 三师父仁渡一刀子下去，鲜红的猪血就带着很多沫子喷出来。 …… 明子老往小英子家里跑。 小英子的家像一个小岛，三面都是河，西面有一条小路通到荸荠庵。独门独户，岛上只有这一家。岛上有六棵大桑树，夏天都结大桑椹，三棵结白的，三棵结紫的；一个菜园子，瓜豆蔬菜，四时不缺。院墙下半截是砖砌的，上半截是泥夯的。大门是桐油油过的，贴着一副万年红的春联： 向阳门第春常在 积善人家庆有余 门里是一个很宽的院子。院子里一边是牛屋、碓棚；一边是猪圈、鸡窠，还有个关鸭子的栅栏。露天地放着一具石磨。正北面是住房，也是砖基土筑，上面盖的一半是瓦，一半是草。房子翻修了才三年，木料还露着白茬。正中是堂屋，家神菩萨的画像上贴的金还没有发黑。两边是卧房。隔扇窗上各嵌了一块一尺见方的玻璃，明亮亮的，——这在乡下是不多见的。房檐下一边种着一棵石榴树，一边种着一棵栀子花，都齐房檐高了。夏天开了花，一红一白，好看得很。栀子花香得冲鼻子。顺风的时候，在荸荠庵都闻得见。 这家人口不多，他家当然是姓赵。一共四口人：赵大伯、赵大妈，两个女儿，大英子、小英子。老两口没得儿子。因为这些年人不得病，牛不生灾，也没有大旱大水闹蝗虫，日子过得很兴旺。他们家自己有田，本来够吃的了，又租种了庵上的十亩田。自己的田里，一亩种了荸荠，——这一半是小英子的主意，她爱吃荸荠，一亩种了茨菇。家里喂了一大群鸡鸭，单是鸡蛋鸭毛就够一年的油盐了。赵大伯是个能干人。他是一个“全把式”，不但田里场上样样精通，还会罩鱼、洗磨、凿砻、修水车、修船、砌墙、烧砖、箍桶、劈篾、绞麻绳。他不咳嗽，不腰疼，结结实实，像一棵榆树。人很和气，一天不声不响。赵大伯是一棵摇钱树，赵大娘就是个聚宝盆。大娘精神得出奇。五十岁了，两个眼睛还是清亮亮的。不论什么时候，头都是梳得滑溜溜的，身上衣服都是格挣挣的。像老头子一样，她一天不闲着。煮猪食，喂猪，腌咸菜，——她腌的咸萝卜干非常好吃，舂粉子，磨小豆腐，编蓑衣，织芦篚。她还会剪花样子。这里嫁闺女，陪嫁妆，磁坛子、锡罐子，都要用梅红纸剪出吉祥花样，贴在上面，讨个吉利，也才好看：“丹凤朝阳”呀、“白头到老”呀、“子孙万代”呀、“福寿绵长”呀。二三十里的人家都来请她：“大娘，好日子是十六，你哪天去呀？”——“十五，我一大清早就来！” “一定呀！”——“一定！一定！” 两个女儿，长得跟她娘像一个模子里托出来的。眼睛长得尤其像，白眼珠鸭蛋青，黑眼珠棋子黑，定神时如清水，闪动时像星星。浑身上下，头是头，脚是脚。头发滑溜溜的，衣服格挣挣的。——这里的风俗，十五六岁的姑娘就都梳上头了。这两上丫头，这一头的好头发！通红的发根，雪白的簪子！娘女三个去赶集，一集的人都朝她们望。 姐妹俩长得很像，性格不同。大姑娘很文静，话很少，像父亲。小英子比她娘还会说，一天咭咭呱呱地不停。大姐说： “你一天到晚咭咭呱呱——” “像个喜鹊！” “你自己说的！——吵得人心乱！” “心乱？” “心乱！” “你心乱怪我呀！” 二姑娘话里有话。大英子已经有了人家。小人她偷偷地看过，人很敦厚，也不难看，家道也殷实，她满意。已经下过小定，日子还没有定下来。她这二年，很少出房门，整天赶她的嫁妆。大裁大剪，她都会。挑花绣花，不如娘。她可又嫌娘出的样子太老了。她到城里看过新娘子，说人家现在绣的都是活花活草。这可把娘难住了。最后是喜鹊忽然一拍屁股：“我给你保举一个人！” 这人是谁？是明子。明子念“上孟下孟”的时候，不知怎么得了半套《芥子园》，他喜欢得很。到了荸荠庵，他还常翻出来看，有时还把旧帐簿子翻过来，照着描。小英子说： “他会画！画得跟活的一样！” 小英子把明海请到家里来，给他磨墨铺纸，小和尚画了几张，大英子喜欢得了不得： “就是这样！就是这样！这就可以乱孱！”——所谓“乱孱”是绣花的一种针法：绣了第一层，第二层的针脚插进第一层的针缝，这样颜色就可由深到淡，不露痕迹，不像娘那一代绣的花是平针，深浅之间，界限分明，一道一道的。小英子就像个书童，又像个参谋： “画一朵石榴花！” “画一朵栀子花！” 她把花掐来，明海就照着画。 到后来，凤仙花、石竹子、水蓼、淡竹叶，天竺果子、腊梅花，他都能画。 大娘看着也喜欢，搂住明海的和尚头： “你真聪明！你给我当一个干儿子吧！” 小英子捺住他的肩膀，说： “快叫！快叫！” 小明子跪在地下磕了一个头，从此就叫小英子的娘做干娘。 大英子绣的三双鞋，三十里方圆都传遍了。很多姑娘都走路坐船来看。看完了，就说：“啧啧啧，真好看！这哪是绣的，这是一朵鲜花！”她们就拿了纸来央大娘求了小和尚来画。有求画帐檐的，有求画门帘飘带的，有求画鞋头花的。每回明子来画花，小英子就给他做点好吃的，煮两个鸡蛋，蒸一碗芋头，煎几个藕团子。 因为照顾姐姐赶嫁妆，田里的零碎生活小英子就全包了。她的帮手，是明子。 这地方的忙活是栽秧、车高田水，薅头遍草、再就是割稻子、打场子。这几荐重活，自己一家是忙不过来的。这地方兴换工。排好了日期，几家顾一家，轮流转。不收工钱，但是吃好的。一天吃六顿，两头见肉，顿顿有酒。干活时，敲着锣鼓，唱着歌，热闹得很。其余的时候，各顾各，不显得紧张。 薅三遍草的时候，秧已经很高了，低下头看不见人。一听见非常脆亮的嗓子在一片浓绿里唱： 栀子哎开花哎六瓣头哎…… 姐家哎门前哎一道桥哎…… 明海就知道小英子在哪里，三步两步就赶到，赶到就低头薅起草来，傍晚牵牛“打汪”，是明子的事。——水牛怕蚊子。这里的习惯，牛卸了轭，饮了水，就牵到一口和好泥水的“汪”里，由它自己打滚扑腾，弄得全身都是泥浆，这样蚊子就咬不通了。低田上水，只要一挂十四轧的水车，两个人车半天就够了。明子和小英子就伏在车杠上，不紧不慢地踩着车轴上的拐子，轻轻地唱着明海向三师父学来的各处山歌。打场的时候，明子能替赵大伯一会，让他回家吃饭。——赵家自己没有场，每年都在荸荠庵外面的场上打谷子。他一扬鞭子，喊起了打场号子： “格当嘚——” 这打场号子有音无字，可是九转十三弯，比什么山歌号子都好听。赵大娘在家，听见明子的号子，就侧起耳朵： “这孩子这条嗓子！” 连大英子也停下针线： “真好听！” 小英子非常骄傲地说： “一十三省数第一！” 晚上，他们一起看场。——荸荠庵收来的租稻也晒在场上。他们并肩坐在一个石磙子上，听青蛙打鼓，听寒蛇唱歌，——这个地方以为蝼蛄叫是蚯蚓叫，而且叫蚯蚓叫“寒蛇”，听纺纱婆子不停地纺纱，“唦——”，看萤火虫飞来飞去，看天上的流星。 “呀！我忘了在裤带上打一个结！”小英子说。 这里的人相信，在流星掉下来的时候在裤带上打一个结，心里想什么好事，就能如愿。 …… “扌歪”荸荠，这是小英最爱干的生活。秋天过去了，地净场光，荸荠的叶子枯了，——荸荠的笔直的小葱一样的圆叶子里是一格一格的，用手一捋，哔哔地响，小英子最爱捋着玩，——荸荠藏在烂泥里。赤了脚，在凉浸浸滑滑溜的泥里踩着，——哎，一个硬疙瘩！伸手下去，一个红紫红紫的荸荠。她自己爱干这生活，还拉了明子一起去。她老是故意用自己的光脚去踩明子的脚。 她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。 …… 明子常搭赵家的船进城，给庵里买香烛，买油盐。闲时是赵大伯划船；忙时是小英子去，划船的是明子。 从庵赵庄到县城，当中要经过一片很大的芦花荡子。芦苇长得密密的，当中一条水路，四边不见人。划到这里，明子总是无端端地觉得心里很紧张，他就使劲地划桨。 小英子喊起来： “明子！明子！你怎么啦？你发疯啦？为什么划得这么快？” …… 明海到善因寺去受戒。 “你真的要去烧戒疤呀？” “真的。” “好好的头皮上烧十二个洞，那不疼死啦？” “咬咬牙。舅舅说这是当和尚的一大关，总要过的。” “不受戒不行吗？” “不受戒的是野和尚。” “受了戒有啥好处？” “受了戒就可以到处云游，逢寺挂褡。” “什么叫‘挂褡’？” “就是在庙里住。有斋就吃。” “不把钱？” “不把钱。有法事，还得先尽外来的师父。” “怪不得都说‘远来的和尚会念经’。就凭头上这几个戒疤？” “还要有一份戒牒。” “闹半天，受戒就是领一张和尚的合格文凭呀！” “就是！” “我划船送你去。” “好。” 小英子早早就把船划到荸荠庵门前。不知是什么道理，她兴奋得很。她充满了好奇心，想去看看善因寺这座大庙，看看受戒是个啥样子。 善因寺是全县第一大庙，在东门外，面临一条水很深的护城河，三面都是大树，寺在树林子里，远处只能隐隐约约看到一点金碧辉煌的屋顶，不知道有多大。树上到处挂着“谨防恶犬”的牌子。这寺里的狗出名的厉害。平常不大有人进去。放戒期间，任人游看，恶狗都锁起来了。 好大一座庙！庙门的门坎比小英子的肐膝都高。迎门矗着两块大牌，一边一块，一块写着斗大两个大字：“放戒”，一块是：“禁止喧哗”。这庙里果然是气象庄严，到了这里谁也不敢大声咳嗽。明海自去报名办事，小英子就到处看看。好家伙，这哼哈二将、四大天王，有三丈多高，都是簇新的，才装修了不久。天井有二亩地大，铺着青石，种着苍松翠柏。“大雄宝殿”，这才真是个“大殿”！一进去，凉嗖嗖的。到处都是金光耀眼。释迦牟尼佛坐在一个莲花座上，单是莲座，就比小英子还高。抬起头来也看不全他的脸，只看到一个微微闭着的嘴唇和胖敦敦的下巴。两边的两根大红蜡烛，一搂多粗。佛像前的大供桌上供着鲜花、绒花、绢花，还有珊瑚树，玉如意、整根的大象牙。香炉里烧着檀香。小英子出了庙，闻着自己的衣服都是香的。挂了好些幡。这些幡不知是什么缎子的，那么厚重，绣的花真细。这么大一口磬，里头能装五担水！这么大一个木鱼，有一头牛大，漆得通红的。她又去转了转罗汉堂，爬到千佛楼上看了看。真有一千个小佛！她还跟着一些人去看了看藏经楼。藏经楼没有什么看头，都是经书！妈吔！逛了这么一圈，腿都酸了。小英子想起还要给家里打油，替姐姐配丝线，给娘买鞋面布，给自己买两个坠围裙飘带的银蝴蝶，给爹买旱烟，就出庙了。 等把事情办齐，晌午了。她又到庙里看了看，和尚正在吃粥。好大一个“膳堂”，坐得下八百个和尚。吃粥也有这样多讲究：正面法座上摆着两个锡胆瓶，里面插着红绒花，后面盘膝坐着一个穿了大红满金绣袈裟的和尚，手里拿了戒尺。这戒尺是要打人的。哪个和尚吃粥吃出了声音，他下来就是一戒尺。不过他并不真的打人，只是做个样子。真稀奇，那么多的和尚吃粥，竟然不出一点声音！他看见明子也坐在里面，想跟他打个招呼又不好打。想了想，管他禁止不禁止喧哗，就大声喊了一句：“我走啦！”她看见明子目不斜视地微微点了点头，就不管很多人都朝自己看，大摇大摆地走了。 第四天一大清早小英子就去看明子。她知道明子受戒是第三天半夜，——烧戒疤是不许人看的。她知道要请老剃头师傅剃头，要剃得横摸顺摸都摸不出头发茬子，要不然一烧，就会“走”了戒，烧成了一片。她知道是用枣泥子先点在头皮上，然后用香头子点着。她知道烧了戒疤就喝一碗蘑菇汤，让它“发”，还不能躺下，要不停地走动，叫做“散戒”。这些都是明子告诉她的。明子是听舅舅说的。 她一看，和尚真在那里“散戒”，在城墙根底下的荒地里。一个一个，穿了新海青，光光的头皮上都有十二个黑点子。——这黑疤掉了，才会露出白白的、圆圆的“戒疤”。和尚都笑嘻嘻的，好像很高兴。她一眼就看见了明子。隔着一条护城河，就喊他： “明子！” “小英子！” “你受了戒啦？” “受了。” “疼吗？” “疼。” “现在还疼吗？” “现在疼过去了。” “你哪天回去？” “后天。” “上午？下午？” “下午。” “我来接你！” “好！” …… 小英子把明海接上船。 小英子这天穿了一件细白夏布上衣，下边是黑洋纱的裤子，赤脚穿了一双龙须草的细草鞋，头上一边插着一朵栀子花，一边插着一朵石榴花。她看见明子穿了新海青，里面露出短褂子的白领子，就说：“把你那外面的一件脱了，你不热呀！” 他们一人一把桨。小英子在中舱，明子扳艄，在船尾。 她一路问了明子很多话，好像一年没有看见了。 她问，烧戒疤的时候，有人哭吗？喊吗？ 明子说，没有人哭，只是不住地念拂。有个山东和尚骂人： “俺日你奶奶！俺不烧了！” 她问善因寺的方丈石桥是相貌和声音都很出众吗？ “是的。” “说他的方丈比小姐的绣房还讲究？” “讲究。什么东西都是绣花的。” “他屋里很香？” “很香。他烧的是伽楠香，贵得很。” “听说他会做诗，会画画，会写字？” “会。庙里走廊两头的砖额上，都刻着他写的大字。” “他是有个小老婆吗？” “有一个。” “才十九岁？” “听说。” “好看吗？” “都说好看。” “你没看见？” “我怎么会看见？我关在庙里。” 明子告诉她，善因寺一个老和尚告诉他，寺里有意选他当沙弥尾，不过还没有定，要等主事的和尚商议。 “什么叫‘沙弥尾’？” “放一堂戒，要选出一个沙弥头，一个沙弥尾。沙弥头要老成，要会念很多经。沙弥尾要年轻，聪明，相貌好。” “当了沙弥尾跟别的和尚有什么不同？” “沙弥头，沙弥尾，将来都能当方丈。现在的方丈退居了，就当。石桥原来就是沙弥尾。” “你当沙弥尾吗？” “还不一定哪。” “你当方丈，管善因寺？管这么大一个庙？！” “还早呐！” 划了一气，小英子说：“你不要当方丈！” “好，不当。” “你也不要当沙弥尾！” “好，不当。” 又划了一气，看见那一片芦花荡子了。 小英子忽然把桨放下，走到船尾，趴在明子的耳朵旁边，小声地说： “我给你当老婆，你要不要？” 明子眼睛鼓得大大的。 “你说话呀！” 明子说：“嗯。” “什么叫‘嗯’呀！要不要，要不要？” 明子大声地说：“要！” “你喊什么！” 明子小小声说：“要——！” “快点划！” 英子跳到中舱，两只桨飞快地划起来，划进了芦花荡。芦花才吐新穗。紫灰色的芦穗，发着银光，软软的，滑溜溜的，像一串丝线。有的地方结了蒲棒，通红的，像一枝一枝小蜡烛。青浮萍，紫浮萍。长脚蚊子，水蜘蛛。野菱角开着四瓣的小白花。惊起一只青桩（一种水鸟），擦着芦穗，扑鲁鲁鲁飞远了。 …… 一九八○年八月十二日，写四十三年前的一个梦。","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"命若琴弦","date":"2018-12-13T15:05:10.000Z","path":"2018/12/13/命若琴弦/","text":"命若琴弦 史铁生 莽莽苍苍的群山之中走着两个瞎子，一老一少，一前一后，两顶发了黑的黑帽起伏攒动，匆匆忙忙，象是随着一条不安静的河水在漂流。无所谓从哪儿来，也无所谓到哪儿去，每人带一把三弦琴，说书为生。 方圆几百上千里这片大山中，峰峦叠嶂，沟壑纵横，人烟稀疏，走一天才能见一片开阔地，有几个村落。荒草丛中随时会飞起一对山鸡，跳出一只野兔、狐狸、或者其它小野兽。山谷中常有鹞鹰盘旋。寂静的群山没有一点阴影，太阳正热的凶。 “把三弦子抓在手里。”老瞎子喊，在山间震起回声。 “抓在手里呢。”小瞎子回答。 “操心身上的汗把三弦子弄湿了。弄湿了晚上弹你的肋条！” “抓在手里呢。” 老少二人都赤着上身，各自拎了一条木棍探路，缠在腰间的粗布小褂已经被汗水湿润了一大片起来的黄土干的呛人。这正是说书的旺季。天长，村子里的人吃罢晚饭都不呆在家里；有的人晚饭也不在家吃，捧上碗至路边去，或者到场院里。老瞎子想赶着多说书，整个热季领着小瞎子一个村子紧走，一晚一晚紧说。老瞎子一天比一天紧张、激动，心理算定：弹断一千根琴弦的日子就在这个夏天了，说不定就在前面的野羊坳。 暴躁了一整天的太阳这会儿正平静下来，光线开始变得深沉。远远近近的蝉鸣也舒缓了许多。 “小子！你不能走快点吗？”老瞎子在前面喊，不回头也不放慢脚步。小瞎子紧跑几步，吊在屁股上的一 只大挎包叮啷哐啷地响，离老瞎子仍有几丈 “野鸽子都在窝里飞啦。” “什么”小瞎子又紧走几步。 “我说野鸽子都回窝了，你还不快走！” “噢。” “你又鼓捣我那 电匣子呢。” “噫――！鬼动来。” “那耳机子快让你鼓捣坏了。” “鬼动来！” 老瞎子暗笑：你小子才活了几天？“蚂蚁打架我也听得着。”老瞎子说。 小瞎子不争辩了，悄悄把耳机子塞到挎包里去，跟在师父身后闷闷地走路。无尽无休的无聊的 路。 走了一阵子，小瞎子听见有只獾在地里啃庄稼，就使劲学狗叫，那只獾 连滚带爬地逃走了，他觉得有点开心，轻声哼了几句小调儿，哥哥呀妹妹的。师父不让他养狗，怕受村里的狗 欺负，也怕欺负了别人家的狗，误了生意。又走了一会小瞎子又听见不远处有条蛇在游动，弯腰摸了块石头砍过去，“哗啦啦”一阵子高梁叶子响。老瞎子有点可怜他了，停下来等他。 “除了獾就是蛇。”小瞎子赶忙说，担心师父骂他。 “有了庄稼地了，不远了。”老瞎子把一个水壶递给徒弟。 “干咱们这营生的，一辈子就是走。”老瞎子又说，“累不？”小瞎子不回答，知道师父最讨厌他说累。 “我师父才冤呢。就是你师爷，才冤呢。东奔西走一辈子，到了儿没弹够一千根琴弦。” 小瞎子听出师父这会儿心绪好，就问：“什么上绿色的长乙（椅）？” “什么？噢，八成是一把椅子吧。” “曲折的油狼（游廊）呢？” “油狼？什么油狼？” “曲折的油狼。” “不知道。” “匣子里说的。” “你就爱瞎听那 些玩艺儿。听那些玩艺儿有什么用？天底下的好东西多啦，跟咱们有什么关系？” “我就没听您说过，什么跟咱们有关系。”小瞎子把“有”字说得重。 “琴！三弦琴！你爹让你跟了我来，是为了让你弹好三弦子，学会说书。” 小瞎子故意把水喝得咕噜响。 再上路时小瞎子走在前头。 大山的阴影在沟谷里铺开来。地势也 渐渐的平缓，开阔。 接近村子的时候，老瞎子喊住小瞎子，在背阴的山脚下 找到一个小泉眼，细细的泉水从石缝里往外冒，淌下来，积成脸盆大小的水洼，周围的野草长的茂盛，水流出几十米便被干渴的土地吸干。 “过来洗洗吧，洗洗你身臭汗味。” 小瞎子拨开野草在水洼边蹲下，心里还猜想着“曲折的油狼”。 “把浑身都洗洗。你那样儿准象个小叫花子。” “那你不就是个老叫花子了？”小瞎子把手按在水里，嘻嘻的笑。 老瞎子也笑，双手捧起水来往脸上泼。“可咱们不是叫花子，咱们有手艺。” “这地方咱们好象来过。”小瞎子侧耳听着四周的动静。 “可你的心思总不在学艺上。你这小子心太野。老人的话你从不着耳听。” “咱们准是来过这儿。” “别打岔！你那三弦子弹的还差着远呢。咱这命就在几根琴弦上，我师父当年就这么跟我说。” 泉水清凉凉的。小瞎子又哥哥妹妹的哼起来。老瞎子挺来气：“我说什么你听见了吗？” “咱这命就在这几根琴弦上，您师父我师爷说的。我就听过八百遍了。您师父还给您留下一张药方，您得弹断一千根琴弦才能去抓那付药，吃了药您就能看见东西了。我听说过一千遍了。” “你信不信？” 小瞎子不正面回答，说：“干嘛非得弹断一千根琴弦才能去抓那付药呢？” “那是药引子。机灵鬼儿，吃药得有药引子！” “一千根断了的琴弦还不好弄？”小瞎子忍不住嗤嗤地笑。 “笑什么笑！你以为你懂得多少事？得真正是一根一根弹断了的才成。”小瞎子不敢吱声了，听出师父又要动气。每回就是这样，师父 容不得对这件事有怀疑。 老瞎子也没再作声，显得有些激动，双手搭在膝盖上，两颗头一样的眼珠结着苍天，象是一根一根地回忆着那 些弹断的琴弦。盼了多少年了呀，老瞎子想，盼了五十年了！五十年中翻了多少架山，走了多少里路哇。挨了多少回晒，挨了多少回冻，心里受了多少委屈呀。一晚上一晚上地弹，心里总记着，得真正是一根一根尽心地弹断了才成。现在快盼到了，绝出不了这个夏天了。 老瞎子知道 自己又没什么 能要命的病，活过这个夏天一点不成问题。“我比我师父可运气多了，” 他说，“我师父到了儿没能睁开眼睛看一回。” “咳！我知道这地方是哪儿了！”小瞎子忽然喊起来。 老瞎子这才动子动，抓起自己 的琴来摇了摇，叠好的纸片碰在蛇皮上发出细微的响声，那张药方就在琴槽里。 “师父，这儿不是野羊岭吗？”小瞎子问。老瞎子没搭理他，听出这小子又不安稳了。 “前头就是野羊坳，是不是，师父？” “小子，过来给我擦擦背。”老瞎子说，把弓一样的脊背弯给他。 “是不是野羊坳，师父 ？” “是！干什么？你别又闹猫似的。” 小瞎子的心扑通扑通跳，老老实实给师父擦背。老瞎子觉出他擦得很有劲。 “野羊坳怎么了？你别又叫驴似的会闻味儿。” 小瞎子心虚，不吭声，不让自己显出兴奋。 “又想什么呢？别当我不知道你这心思。” “又怎么了，我？” “怎么了你？上回你在这儿疯得不够？那妮子是什么好货！”老瞎子心想，也许不该再带他到野羊坳来。可是野羊坳来。可是野羊坳是个大村子，年年在这儿生意都好，能说上半个多月。老瞎子恨不能立刻弹断最后几根琴弦。小瞎子嘴上嘟嘟囔囔的心却飘飘的，想着野羊坳里那个尖声细气的小妮子。 “听我一句话，不害你。”老瞎子说，“那号事靠不住。” “什么事？” “少跟我贫嘴。你明白我说的什么事。” “我就没听您说过，什么事靠得住。”小瞎子又偷偷地笑。 老瞎子没理他，骨头一样的眼珠又对着苍天。那儿，太阳正变成一汪血。 两面脊背和山是一样的黄褐色。一座已经老了，嶙峋瘦骨象是山根下裸露的基石。另一座正年青。老瞎子七十岁，小瞎子才十七。小瞎子十四岁上父亲把他送到老瞎子这儿来，这是让他学说书，这辈子好有个本事，将来可以独自在世上活下去。 老瞎子说书已经说了五十多年。这一片偏僻荒凉的大山里的人们都知道他：头发一天天变白，背一天天变驼，年年月月背一三弦琴满世界走，逢上有愿出钱的地方就动琴弦唱一晚上，给寂寞的山村带来欢乐。开头常是这么几句：“自从盘古分天地，三皇五帝到如今，有道君王害黎民。轻轻弹响三弦琴，慢慢稍停把歌论，歌有三千七百本，不知哪本动人心。”于是听书的众人喊起来，老的要听董永卖身葬父，小的要听武二郎夜走蜈蚣岭，女人们想听秦得莲。这是老瞎子最知足的一刻，身上的疲劳和心里的孤静全忘却，不慌不忙地喝几口水，待众人的吵嚷声鼎沸，便把琴弦一阵紧拨，唱到：“今日不把别人唱，单表公子小罗成。”或者：“茶也喝来烟也吸，唱一回哭倒长城的孟姜女。”满场立刻鸦雀无声，老瞎子也全心沉到自己所说的书中去。 他会的老书数不尽。他还有一个电匣子， 据说是花了大价钱从一个山外人手里买来，为的是学些新词儿，编些新曲儿。其实山里人倒太在乎他说什么唱什么。人人都称赞他那 三弦子弹得讲究，轻轻漫漫的，飘飘洒洒的，疯颠狂放的，那里头有天上的日月，有地上的生灵。老瞎子的嗓子能学出世上所有的声音。男人、女人、刮风下雨、兽啼禽鸣。不知道他脑子里能呈现出什么景象，他一落生就瞎了眼睛，从没过这个世界。 小瞎子可以算见过世界，但只有三年，那时还不懂事。他对说书和弹琴并无多少兴趣，父亲把他送来的时候费尽了唇舌，好说歹说连哄带骗，最后不如说是那个电匣子把他留住。他抱着电匣子听得入神，甚至发觉父亲以时候离去。 这只神奇的匣子永远令他着迷，遥远的地方和稀奇古怪的事物使他幻想不绝，凭着三年朦胧的记忆，补充着万物的色彩和形象。譬如海，匣子里说蓝天就象大海，他记得蓝天，于是想象出满天排开的水锅。再譬如漂亮的姑娘，匣子里说就象盛开的花朵，他实在不相信会是那样，母亲的灵柩被抬到远山上去的时候，路上正开遍着野花，他永远记得却永远不愿意去想。但他愿意想姑娘，越来越愿意想；尤其是野羊坳的那个尖声细气的小妮子，总让他心里荡起波澜，直到有一回匣子里唱道 ，“姑娘的眼睛就象太阳”，这下他才找到了一个贴切的形象，想起母亲在红透的夕阳中向他走来的样子。其实人人都是根据自己的所知猜测着无穷的未知，以自己的感情勾画出世界。每个人的世界就都不同。 也总有一些东西小瞎子无从想象，譬如“曲折的油狼”。 这天晚上，小瞎子跟着师父在野羊坳说书。又听见那小妮子站在离他不远处尖声细气地说笑。书正说到紧要处――“罗成回马再交战，大胆苏烈又兴兵。苏烈大刀如流水，罗成长枪似腾云，好似海中龙吊宝，犹如深山虎争林。又战七日并牙夜，罗成清茶无点唇……”老瞎子把琴弹得如雨骤风疾，字字句句唱得铿锵，小瞎子却心猿意马，手底下早乱了套数…… 野羊岭上有一座小庙，离野羊坳村二里地，师徒二人就在这里住下。石头砌的院墙已经残断不全，几间小殿堂也歪斜欲倾百孔千疮，唯正中一间尚可遮蔽风雨，大约是因为这一间中毕竟还供奉着神灵。丰尊泥像早脱尽了尘世的彩饰，还一身黄土本色返朴归真了，认不出是佛是道。院里院外、房顶墙头都长满荒藤野草，蓊蓊郁郁倒有生气。老瞎子每日到野羊坳说书都住在这儿。 散了书已经不早，老瞎子在下殿里安顿行李，小瞎子在侧殿的檐下生火烧水。去年砌下的灶火稍加修整就可以用。小瞎子蹶着屁股吹火，柴草不干呛得他满院里转着圈咳嗽。老瞎子在正殿里数叨他：“我看你能干好什么 。” “柴湿嘛。” “我没说这事。我说的是你的琴，今儿晚上的琴你弹成了什么。” 小瞎子不敢接这话茬，吸足了几口气又跪到灶火前去，鼓着腮帮子一通猛吹。“你要是不想干这行，就趁早给你爹捎信把你领回去。老这么闹猫闹狗的可不行，要闹回家闹去。” 小瞎子咳嗽从灶火边跳开，几步蹿到院子另一头，呼嗤呼嗤大喘气，嘴里一边骂。 “说什么呢？” “我骂这火。” “有你那么吹火的？” “那怎么吹？” “怎么吹？哼，”老瞎子顿了顿，又说，“你就当这灶火是那妮子的脸！” 小瞎子又不敢搭腔了， 跪到灶火前去再吹，心想：真的，不知道兰秀儿的脸什么样。那个尖声细气的小妮子叫兰秀儿。 “那 要是妮子的脸，我看你不用教也会吹。”老瞎子说。 小瞎子笑起来，越笑越咳嗽。 “笑什么笑！” “您吹过妮子的脸？” 老瞎子一时语塞。小瞎子笑得坐在地上。“日他妈。”老瞎子骂道，笑笑，然后变了脸色，再不言语。 灶膛里腾的一声，火旺起来。小瞎子再去添柴，一心想着兰秀儿。才散了书的那会儿，兰秀儿挤到他跟前来小声说：“哎，上回你答应我什么来？”师父就在旁边，他没敢吭声。人群挤来挤去，一会儿又把兰秀儿挤到他身边。“噫，上回吃人家的煮鸡蛋倒白吃了？”兰秀儿说，声音比上回大。这时候师父正忙着跟几个老汉拉话。他赶紧说：“嘘――，我记着呢。”兰秀儿又把声音压低：“你答应给我听电匣子你还没给我听。”“嘘――我记着呢。”幸亏那会儿人声嘈杂。 正殿里好半天没有动静。之后，琴声响了，老瞎子又上好了一根新弦，他本来应该高兴的，来野羊坳头一晚 就又弹断一根琴弦，可是那琴声却低沉、零乱。 小瞎子渐渐听出琴声不对，在院里喊：“水开了，师父。” 没有回答。琴声一阵紧似一阵了。 小瞎子端了一盆热 水进来。放在师父跟前，故意嘻嘻笑着说：“您今儿晚还想弹断一根是怎么着？” 老瞎了没听见，这会儿他自己的往事都在心中。琴声烦躁不安，象是年年旷野里的风雨，象是日夜山谷中的溪流，象是奔奔忙忙不知所归的脚步声。小瞎子有点害怕了：师父很久不这样了，师父一这样就要犯病，头疼、心口疼、浑身疼，会几个月爬 不起炕来。 “师父，您先洗脚吧。” 琴声不停。 “师父，您该洗脚了。”小瞎子的声音发抖。 琴声不停。 “师父！” 琴声戛然而止，老瞎子叹了口气。小瞎子松了口 气。老瞎子洗脚，小瞎子乖乖地坐在他身身边。 “睡去吧，”老瞎子说，“今儿格够累的了。” “您呢？” “你先睡，我得好好泡泡脚。人上了岁数毛病多。”老瞎子故意说得轻松。 “我等您 一块儿睡 。” 山深夜静，有一点风，墙头的草叶子响。夜猫子在远处哀哀地叫。听得见野羊坳里偶尔有几声狗吠，又引得孩子哭。月亮升起来，白光透过残损的窗棂进了殿堂，照见两个瞎子和三尊神像。 “等我干嘛，时候不早了。” “你甭担心我，我怎么也不怎么，”老瞎子又说。 “听见没有，小子？” 小瞎子到底年轻，已经睡着。老瞎子推推他让他躺好，他嘴里咕囔了几句倒头睡去。老瞎子给他盖被子时，从那身日渐发育的筋肉上觉出，这孩子到了要想那 些事的年龄，非得有一段苦日子过不可了。唉，这事谁也替不了谁。 老瞎子再把琴抱在怀里，摩挲着根根绷紧的琴弦。心里使劲念叨：又断了一根了，又断了一根了。再摇摇琴槽，有轻微的纸和蛇皮的磨擦声，唯独这事能为他排忧解烦。一辈子的愿望。 小瞎子作了一个好梦。醒来吓了一跳，鸡已经叫了。他一骨碌爬起来听听，师父下睡得香，心说还好。他摸到那个大挎包，悄悄地掏出电匣子，蹑手蹑脚出了门。 往野羊坳方向走了一会儿，他才觉 出不对头，鸡叫声渐渐停歇，野羊坳里还是静静的没有人声。他愣了一会儿，鸡才叫头遍吗？灵机一动扭开电匣子。电匣子里也是静悄悄。现在是半夜。他半夜里听过匣子，什么都没有。这匣子对他来说还是个表。只要扭开一听，便知道是几点钟，什么时候有什么节目都是一定的。 小瞎子回到庙里，老瞎子正翻身。 “干嘛哪？” “撒尿去了。”小瞎子说。 一上午，师父逼着他练琴。直到响午饭后，小瞎子才瞅机会溜出庙来，溜进野羊坳。鸡也在树荫下打盹，猪也在墙根下说着梦话，太阳又热得凶，村子里很安静。 小瞎子踩着磨盘，扒着兰秀儿家的墙头轻声喊：“兰秀儿――兰秀儿――” 屋里传出雷似的鼾声。 他犹豫了片刻，把声音稍稍抬高：“兰秀儿――！兰秀儿！” 狗叫起来。屋里鼾声停了，一个闷声闷气的声音问：“谁呀？” 小瞎子不敢回答，把脑袋从墙 头上缩下来。屋里吧唧了一阵嘴，又响起鼾声。 他叹口气，从靡盘上下来怏怏地往回走。忽听见身后嘎吱一声院门响，随即一阵细碎的脚步声向他跑来。 “猜是谁？”尖声细气。小瞎子的眼睛被一双柔软的小手捂上了。――这才多余呢。兰秀儿不到十五岁，认真说还是孩子。 “兰秀儿！” “电匣子拿来没？” 小瞎子掀开衣襟，匣子挂在腰上。“嘘――，别在这儿，找个没人的地方听去。” “咋啦？” “回头招好些人。” “咋啦？” “那么多人听，费电。” 两个人东拐西弯，来到山背后那 眼小泉边。小瞎子忽然 想起件事，问兰秀儿：“你见过曲折的油狼吗？” “啥？” “曲折的油狼。” “曲折的油狼？” “知道吗？” “你知道？” “当然。还有绿色的长椅。就一把椅子。”“椅子谁不知道。” “那曲折的油狼呢？” 兰秀儿摇摇头，有点崇拜小瞎子了。小瞎子这才郑重其事地扭开电匣子，一支欢快的乐曲在山沟里飘荡。 地方又凉快又没有人来打扰。 “这是‘步步高’。”小瞎子说，跳着哼。一会儿又换了支曲子，叫“旱天雷”，小瞎子还能跟着哼。兰秀儿觉得很惭愧。 “这曲子也叫‘和尚思妻’。” 兰秀儿笑起来：瞎骗人！“ “你信不信？” “不信。” “爱信不信。这匣子里说的古怪事多啦。”小瞎子玩着凉凉的泉水，想了一会儿。“你知道什么叫接吻吗？” “你说什么叫？” 这回轮到小瞎子笑，光笑不答。兰秀儿明白准不是好话，红着脸不再问。 音乐播完了一个女人说，“现在是讲卫生节目。” “啥？”兰秀儿没听清。 “讲卫生。” “是什么？” “嗯――，你头发上有虱子吗？” “去――，别动！” 小瞎子赶忙缩回手来，赶忙解释：“要有就是不讲卫生。” “我才没有。”兰秀儿抓抓 头，觉得有些刺立，“噫――瞧你自个儿吧！”兰秀儿一把搬过小瞎子的头。“看我捉几个大的。” 这时候听见老瞎子在半山上喊：“小子，还不给我回来！该做饭了，吃罢饭还得去说书！”他已经站在那儿听了好一会儿了。 野羊坳里已经昏暗，羊叫、驴叫、狗叫、孩子们叫， 处处起了炊烟，野羊岭上还有一线残阳，小庙正在那淡薄的光中，没有声响。 小瞎子又蹶着屁股烧火。老瞎子坐在一旁淘米，凭着听觉他能把米中的砂子捡出来。 “今天的柴挺干。”小瞎了说。 “嗯。” “还是焖饭？” “嗯。” 小瞎子这会儿精神百倍，很想找些话说，但是知道师父的气还没消，心说还是少找骂。两个人默默地干着自己的事，又默默地一块儿把饭做熟。岭上也没了阳光。 小瞎子盛了一碗小米饭 ，先给师父：“您吃吧。”声音怯怯的，无比驯顺。 老瞎子终于开了腔：“小子，你听我一句行不？” “嗯 。”小瞎子往嘴里扒拉饭，回答得含糊。 “你要是不愿意听，我就不说。” “谁说不愿意听了？我说‘嗯’！” “我是过来人，总比你知道的多。” 小瞎子闷头扒拉饭。 “我经过那 号事。” “什么事？” “又跟我贫嘴！”老瞎子把筷子往灶台上一摔。 “兰秀儿光是想听听电匣子。我们光是一块儿听电匣子来。” “还有呢？” “没有了。” “没有了？” “我还问她见过曲折的油狼。” “我没问你这个。” “后来，后来，”小瞎子不那么气壮了，“不知怎么一下就说起了虱子……” “还有呢？” “没了，真没了！” 两个人又默默地吃饭 。老瞎子带了这徒弟好几年，知道这孩子不会撒谎，这孩子最让人放心的地方就是诚实、厚道。 “听我一句话，保准对你没坏处。以后离她远点好。早年你师爷这么跟我说，我也不相信……” “师爷？说兰秀儿？” “什么兰秀儿，那 会儿还没她呢，那会儿有你们呢……”老瞎子阴郁的脸又转向暮色浓重的天际，骨头一样白色的眼珠不住地转动，不知道在那儿他想能“看”见什么。许久，小瞎子说：“今儿晚上您多半又能弹断一根琴弦，”想让师父高兴些。 这天晚上师徒在野羊坳说书。“上回说到罗成死，三魂七魄赴幽冥，听歌君子莫嘈 嚷，列位蝗我道下文。罗成阴魂出地府，一阵旋风就起身，旋风一阵来得快，长安不远面前存……”老瞎子的琴声也乱，小瞎子的琴声也乱，小瞎子回忆着那比柔软的小手捂在自己脸上的感觉，还有自己 的头被兰秀儿搬过去的滋味。老瞎子想起的事情更多…… 夜里老瞎子翻来覆去睡不安稳，多少往事在他耳边喧器，在他心头动荡，身体里仿佛有什么东西要爆炸。坏了，要犯病，他想。头昏，胸口憋闷，浑身紧巴巴的难受。他坐起来，对自己叨咕：“可别犯病，一犯病今年不甭想弹够那 些琴弦了。”他又摸到琴。要能叮叮当当随心所欲地疯弹一阵，心头的忧伤或许就能平息耳边的往事或许 就会消散。可是小瞎子正睡得香甜。 他只好再全力去想那 张药方和琴弦：还剩下几根，还只剩最后几根了。那时就可以去抓药了，然后就能看见这个世界――他无数次爬过的山，无数次走过的路，无数次感到过她的温暖和炽热的太阳 ，无数次梦想着的蓝天和月亮和星星……还有呢？还有什么？他朦胧中所盼望的东西似乎比这要多得多…… 夜风在山里游荡。 猫头鹰又在凄哀地叫。 不过现在他老了，无论如何没年活头了，失去的，已经永远失去了，他象是刚刚意识到这一点。七十年中所受的全部辛苦就为了最后能看一眼世界，这值得吗？他问自己。 小瞎子在梦里笑，在梦里说：“那是一把椅子，兰秀儿……” 老瞎子静静地坐着，静静地坐着的还有那三尊分不清是佛是道的泥像。 鸡叫头遍的时候老瞎子决定，天一亮就带这孩子离开野羊坳。否则这孩子受不了，他自己也受不了。兰秀儿不坏，可这事会怎么结局，老瞎子比谁都“看”得清楚。鸡叫二遍，老瞎子开始收拾行李。 可是一早起来小瞎子病了，肚子疼，随即又发烧。老瞎子只好把行期推迟。 一连好几天，老瞎子无论是烧火、淘米、捡柴，还是给小瞎子挖药、煎药，心里总在说：“值得，当然值得。”要是不这么反反复复对自己说身上的力气几乎就要垮掉。“我非要最后看一眼不可。”“要不怎么着？就这么死了去？”“再说就只剩下最后几根了。”后面三句都是理由。老瞎子又冷静下来，天天晚还到野羊坳去说书。 这一下小瞎子倒来了福气。每天晚上师父到岭下去了，兰秀儿就猫似的轻轻跳进庙里来听匣子。兰秀儿还带来熟的鸡蛋，条件是得让她亲手去扭那匣子的开关。“往哪边扭？”“往右”“扭不动。”“往右，笨货，不知道哪边是右哇？”？“咔哒”一下，无论是什么便响起来，无论是什么俩人都爱听。 又过了几天，老瞎子又弹断了三根弦。 这一晚，老瞎子在野羊坳里自弹自唱：“不表罗成投胎事，又唱秦王李世民。秦王一听双泪流，可怜 爱卿丧残身，你死一乘风破浪 打紧，缺少扶朝上将军……” 野羊坳上的小庙里这时更热闹。电匣子的音量开得挺大，又是孩子哭，又是大人喊，轰隆隆地又响炮，嘀嘀哒吹地又吹号。月光照进正殿，小瞎子躺着啃鸡蛋，兰秀儿坐在他旁边。两个人都听得兴奋，时而大笑，时而稀里糊涂莫名其妙。 “这匣子你师父哪卖来？” “从一个山外头的人手里。” “你们到山外头去过？”兰秀儿问。 “没。我早晚要去一回就是，坐坐火车。” “火车？” “火车你也不知道？笨货。” “噢，知道知道，冒烟哩是不是？” 过了一会儿兰秀儿又说：“保不准我就得到山外头去。”语调有些惶。 “是吗？”小瞎子一挺坐起来，“那你到底瞧瞧曲折的油狼是什么。” “你说是不是山外头的人都有电匣子？” “谁知道。我说你听清楚没有？曲、折、的、油、狼，这东西就在山外头。” “那我得跟他们要一个电匣子。”兰秀儿自言自语地想心事。 “要一个？”小瞎子笑两声，然后住气，然后大笑：“你干嘛不要俩？你可真本事大。你知道这匣子几千块钱一个？把你卖了吧，怕也换不来。” 兰秀儿心里正委屈，一把揪住小瞎子的耳朵使劲拧，骂道：“好你死瞎子。” 两个人在堂殿里扭打起来。三尊泥像袖手旁观帮不上忙，两个年青的正在发育的身体碰撞在一起 ，纠缠在一起，一个把一个压进身下，一会儿又颠倒过来，骂声变成笑声。匣子在一边唱。 打了好一阵子，两个人都累得住手，心怦怦跳，躺着喘气，不言声儿，谁却也不愿意再拉开距离，兰秀儿呼出的气吹在小瞎子的脸上，小瞎子感到了诱惑，并且想起那天吹火时师父说的话，就往兰秀儿脸上吹气。兰秀儿并不躲。 “嘿，”小瞎子小声说，“你知道接吻是什么了吗？” “是什么？”兰秀儿的声音也小。 小瞎子对着兰秀儿的耳朵告诉她。兰秀儿不说话。老瞎子回来之前，他们试着亲了嘴儿，滋味真不坏…… 就是这天晚上，老瞎子弹断了最后两根琴弦。两根弦一齐断了。他没料到。他几乎是连跑带爬地上了野羊岭，回到小庙里。小瞎子吓了一跳：“怎么了，师父？” 老瞎子喘吁吁地坐在那儿，说不出话。小瞎子有些犯嘀咕：莫非是他和兰秀儿干的事让师父知道了？ 老瞎子这才相信一切都是值得的。一辈子的辛苦是值得的。能看一回，好好看一回，怎么都是值得的。 “小子，明天我就去抓药。” “明天？” “明天。” “又断了一根了？” “两根。两根都断了。” 老瞎子把那 两根弦卸下来，放在手里揉搓了一会儿，然后把他们并到另外的九百九十八根去，绑成一捆。 “明天就走？” “天一亮就动身。” 小瞎子心里一阵发凉。老瞎子开始剥琴槽上的蛇皮。 “可我的病还没好利索。”小瞎子小声叨咕。 “噢，我想过了，你就先留在这儿，我用不了十天就回来。” 小瞎子喜出望外。 “你一个人行不？” “行！”小瞎子紧忙说。 老瞎子早忘了兰秀儿的事。“吃的、喝的、烧的全有。你要是病好利索了，也该学着自个儿出去说回书。行吗？” “行。”小瞎子觉得有点对不住师父。 蛇皮剥开了，老瞎子人琴槽中取出一张叠得方方正正的纸条。他想起这药方进琴槽时，自己才二十岁，便觉得浑身上下都好象冷。 小瞎子也把那药方放在手里摸了一会儿，也有了几分肃穆。 “你师爷一辈子才冤呢。” “他弹断了多少根？” “他本来能弹够一千根，可他记成了八百。要不然他能弹断一千根。” 天不亮老瞎子就上路了。他说最多十天就回来。谁也没想到他竟去了那么久。 老瞎子回到羊坳时已经是冬天。漫 天大雪，灰暗的天空连接着白色的群山。没有声息，处处也没有生气，空旷而沉寂。所以老瞎子那顶发了黑的草帽就尤其躜动得显著。他蹒蹒跚跚地爬上野羊岭，庙院中衰草瑟瑟，窜出一只狐狸，仓惶逃远。 村里人告诉他，小瞎子已经走了些日子。 “我告诉他等我回来。” “不知道他干嘛就走了。” “他没说去哪儿，留下什么话没？” “他说让您甭找他。” “什么时候走的？” 人们想了好久，都说是在兰秀儿嫁到山外去的那天。老瞎子心里便一切全明白。 众人劝老瞎子留下来，这么冰天雪地的上哪去？不如在野羊坳说一冬天书。 老瞎子指指他的琴，人们见琴柄上空荡荡已经没了琴弦。老瞎子面容也憔悴，呼吸也孱弱，嗓音也沙哑了，完全变了个人。他说得去找他的徒弟。 若不是还想着他的徒弟，老瞎子就回不到野羊坳。那张他保存了五十年的药方原来是一张无字的白纸。他不信，请了多少识字而又诚实的人帮他看，人人都说那果真是一张无字的白纸。老瞎子在药铺前的台阶上坐了一会儿，他以为是一会儿，其实已经几天几夜，骨头一样的眼珠在询问苍天，脸色也变成骨头一样的苍白。有人以为他是疯了，安慰他，劝他。老瞎子苦笑：七十岁了再疯还有什么意思？他只是再不想动弹，吸引着他活下去、走下去、唱下去的东西骤然间消失干净。就象一根不能拉紧的琴弦，再难弹出悦耳的曲子。老瞎子的心弦断了，准确地说，是有一端空无所系了。一根琴弦需要两个点才能拉紧。心弦也要两 个点――一头是追求，一头是目的――你才能在中间这紧绷绷的过程上弹响心曲。现在发现那目的原来是空的。老瞎子在一个小客店里住了很久，觉得身体里的一切都在熄灭。他整天躺在炕上，不弹也不唱，一天天迅速地衰老。直到花光了身上所有的钱，直到忽然想起他的徒弟，他知道自己的死期将至，可那孩子在等他回去。 茫茫雪野，皑皑群山，在地之间躜动着一个黑点。走近时，老瞎子的身身影弯得如一痤桥。他去找他的徒弟。他知道那孩子目前的心情、处境。 他想自己先得振作起来，但是不行，前面明明没有了目标。 他一路走，便怀恋起过去的日子，才知道以往那些奔奔忙忙兴致勃勃的翻山、走路、弹琴，乃至心焦、忧虑都是多么欢乐！那时有个东西把心弦扯紧，虽然那东西原是虚设。老瞎妇想起他师父临终时的情景。他师父把那张自己没用上的药方封进他的琴槽。“您别死，再活几年，您就能睁眼看一回了。”说这话时他还是个孩子。他师父久久不言语，最后说：“记住，人的命就象这琴弦，拉紧了才能弹好，弹好了就够了。”……不错，那意思就是说：目的本来没有。不错，他的一辈子都被那虚设的目的拉紧，于是生活中叮叮当当才有了生气。重要的是从那绷紧的过程中得到欢乐，老瞎子知道怎么对自己的徒弟说了。可是他又想：能把一切都告诉小瞎子吗？老瞎子又试着振作起来，可还是不行，总摆脱不掉那无字的白纸…… 在深山里，老瞎子找到了小瞎子。 小瞎子正跌倒在雪地里，一动不动，想那么等死。老瞎子懂得那绝不是装出来的悲衰。老瞎子把他拖进一个山洞，他已无力反抗。老瞎子捡了些柴，打起一堆火。 小瞎子渐渐有了哭声。老瞎子放了心，任他尽情尽意地哭 。只要还能哭就还有救，只要还能哭就有哭够的时候。 小瞎子哭了几天几夜，老瞎子就那么一声不吭地守着。火光和哭声惊动了野免子、山鸡、野羊和狐狸和鹞鹰…… 终于小瞎子说话了：“干嘛咱们是瞎子！” “就因为咱们是瞎子。”老瞎子回答。 终于小瞎子又说：“我想睁开眼看看，师父，我想睁开眼看看！哪怕就看一回。” “你真那么想吗？” “真想，真想――” 老瞎子把篝火拨得更旺些。 雪停了。铅灰色的天空中，太阳象一面闪光的小镜子，鹞鹰在平稳地滑翔。 “那就弹你的琴弦，”老瞎子说，“一根一根尽力地弹吧。” “师父，您的药抓来了？”小瞎子如梦方醒。 “记住，得真正是弹断的才成。” “您已经看见了吗？师父，您现在看得见了？” 小瞎子挣扎着起来，伸手去摸师父的眼窝。老瞎子把他的手抓住。 “记住，得弹断一千二百根。 “一千二？” “把你的琴给我，我把这药方给你封在琴槽里。”老瞎子现在才懂了师父当年对他说的话――你的命就在这琴弦上。 目的虽是虚设的，可非得有不行，不然琴弦怎么拉紧，拉不紧就弹不响。 “怎么是一千二，师父？” “是一千二。我没弹够，我记成了一千。”老瞎子想：这孩子再怎么弹吧，还能弹断一千二百根？永远扯紧欢跳的琴弦，不必去看那无字的白纸…… 这地方偏僻荒凉，群山不断。荒草丛中随时会飞起一对山鸡，跳出一只野免、狐狸，或者其它小野兽。山谷中鹞鹰在盘旋。 现在让我们回到开始： 莽莽苍苍的群山之中走着两个瞎子，一老一少，一前一后，两顶发了黑的草帽起伏躜动，匆匆忙忙，象是随着一条不安静的河水在漂流。无所谓从哪儿来、到哪儿去，也无所谓谁是谁…… 八五年四月二十日","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"空负安邦志,遂吟去国行","date":"2018-11-26T11:57:04.000Z","path":"2018/11/26/空负安邦志-遂吟去国行/","text":"黑云翻墨未遮山，白雨跳珠乱入船。 这本是宋人苏轼乘船巡游西湖，描述所见的诗作。 寓居武林城一年有余，却不曾在西子湖畔见此情境，反倒在3500公里外的北纬八度，在安达曼海犁波破浪的快艇上，乍想到了这行诗句。 在中国古典小说&lt;水浒传&gt;中，如同前朝的李谪仙与郭子仪，苏学士也于一后来平步青云的人物有知遇之恩。但不同之处是他是书中第一奸臣反派，亦是孙继海和武磊这些个射手们的前辈，也便是将人逼上梁山的高俅高太尉。… 征方腊后，梁山泊诸人死伤大半，得善终者，除六和塔下的鲁达武松，还有虚构成为暹罗国主的混江龙李俊（暹罗倒确实是在李俊生活的13世纪开国，至14世纪朱元璋册封阿瑜陀耶为暹罗国王，正式定用此称。1939年改为泰国，1945年复名暹罗，1949年再用泰国，沿用至今）。 在施耐庵将自己名姓刻入中国文化史500多年后，一位新近辞世的嘉兴海宁籍报人，曾在附于报纸边角的武侠专栏中频频致敬。&lt;水浒传&gt;中虚构，作为宋江贴身保镖之一的“赛仁贵”郭盛，有一后人名郭啸天，住在时为南宋行都的临安牛家村，一道人路过，引发了此后一连串反应。…几百年后的明末，面对三尺之冰，朱由检无力回天，猜忌误杀袁督师，更是自毁塞上长城。这位生不逢时的勤勉末代君主，在砍杀妻女后，用一棵歪脖子树了此残生。他幼时铲灭魏氏阉党，丝毫不逊几十年后的圣主康熙擒鳌拜。 “邮差”上位，势如燎原，然山海关一役，吴三桂冲冠一怒，执精锐火拼，两败俱伤之际为“洪太主”渔翁得利。穿连起明末各方势力的人叫袁承志，正是袁督师的儿子。一番遭遇后，他效仿上个朝代临末同样身负绝顶武学的张无忌，远离中土，隐居海岛。 与极北苦寒之地的冰火岛不同，袁承志选择了东南亚加里曼丹岛附近的热带岛屿。曾与袁承志暧昧不已的末代公主，大难不死却断一臂，几十年后，面对扬州丽春院韦春花那个油嘴滑舌儿子的吹捧，已落发为“九难”成武林高手的她大概面朝正南，说出“有一个人称得上武功天下第一”。 而另一条主线，闯王胡苗范田四大侍卫的后人，围绕当年九宫山旧事，引出了&lt;雪山飞狐&gt;和&lt;飞狐外传&gt;","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"},{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"kubectl常用命令","date":"2018-11-11T11:43:28.000Z","path":"2018/11/11/kubectl常用命令/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;shuangcui@~&gt;$ kubectlkubectl controls the Kubernetes cluster manager. Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/Basic Commands (Beginner): create Create a resource from a file or from stdin. expose Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service run Run a particular image on the cluster set Set specific features on objectsBasic Commands (Intermediate): explain Documentation of resources get Display one or many resources edit Edit a resource on the server delete Delete resources by filenames, stdin, resources and names, or by resources and label selectorDeploy Commands: rollout Manage the rollout of a resource scale Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job autoscale Auto-scale a Deployment, ReplicaSet, or ReplicationControllerCluster Management Commands: certificate Modify certificate resources. cluster-info Display cluster info top Display Resource (CPU/Memory/Storage) usage. cordon Mark node as unschedulable uncordon Mark node as schedulable drain Drain node in preparation for maintenance taint Update the taints on one or more nodesTroubleshooting and Debugging Commands: describe Show details of a specific resource or group of resources logs Print the logs for a container in a pod attach Attach to a running container exec Execute a command in a container port-forward Forward one or more local ports to a pod proxy Run a proxy to the Kubernetes API server cp Copy files and directories to and from containers. auth Inspect authorizationAdvanced Commands: diff Diff live version against would-be applied version apply Apply a configuration to a resource by filename or stdin patch Update field(s) of a resource using strategic merge patch replace Replace a resource by filename or stdin wait Experimental: Wait for a specific condition on one or many resources. convert Convert config files between different API versions kustomize Build a kustomization target from a directory or a remote url.Settings Commands: label Update the labels on a resource annotate Update the annotations on a resource completion Output shell completion code for the specified shell (bash or zsh)Other Commands: api-resources Print the supported API resources on the server api-versions Print the supported API versions on the server, in the form of \"group/version\" config Modify kubeconfig files plugin Provides utilities for interacting with plugins. version Print the client and server version informationUsage: kubectl [flags] [options]Use \"kubectl &lt;command&gt; --help\" for more information about a given command.Use \"kubectl options\" for a list of global command-line options (applies to all commands). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;shuangcui@~&gt;$ kubectl get --helpDisplay one or many resources Prints a table of the most important information about the specified resources. You can filter the list using a labelselector and the --selector flag. If the desired resource type is namespaced you will only see results in your currentnamespace unless you pass --all-namespaces. Uninitialized objects are not shown unless --include-uninitialized is passed. By specifying the output as 'template' and providing a Go template as the value of the --template flag, you can filterthe attributes of the fetched resources.Use \"kubectl api-resources\" for a complete list of supported resources.Examples: # List all pods in ps output format. kubectl get pods # List all pods in ps output format with more information (such as node name). kubectl get pods -o wide # List a single replication controller with specified NAME in ps output format. kubectl get replicationcontroller web # List deployments in JSON output format, in the \"v1\" version of the \"apps\" API group: kubectl get deployments.v1.apps -o json # List a single pod in JSON output format. kubectl get -o json pod web-pod-13je7 # List a pod identified by type and name specified in \"pod.yaml\" in JSON output format. kubectl get -f pod.yaml -o json # List resources from a directory with kustomization.yaml - e.g. dir/kustomization.yaml. kubectl get -k dir/ # Return only the phase value of the specified pod. kubectl get -o template pod/web-pod-13je7 --template=&#123;&#123;.status.phase&#125;&#125; # List resource information in custom columns. kubectl get pod test-pod -o custom-columns=CONTAINER:.spec.containers[0].name,IMAGE:.spec.containers[0].image # List all replication controllers and services together in ps output format. kubectl get rc,services # List one or more resources by their type and names. kubectl get rc/web service/frontend pods/web-pod-13je7Options: -A, --all-namespaces=false: If present, list the requested object(s) across all namespaces. Namespace in currentcontext is ignored even if specified with --namespace. --allow-missing-template-keys=true: If true, ignore any errors in templates when a field or map key is missing inthe template. Only applies to golang and jsonpath output formats. --chunk-size=500: Return large lists in chunks rather than all at once. Pass 0 to disable. This flag is beta andmay change in the future. --field-selector='': Selector (field query) to filter on, supports '=', '==', and '!='.(e.g. --field-selectorkey1=value1,key2=value2). The server only supports a limited number of field queries per type. -f, --filename=[]: Filename, directory, or URL to files identifying the resource to get from a server. --ignore-not-found=false: If the requested object does not exist the command will return exit code 0. -k, --kustomize='': Process the kustomization directory. This flag can't be used together with -f or -R. -L, --label-columns=[]: Accepts a comma separated list of labels that are going to be presented as columns. Names arecase-sensitive. You can also use multiple flag options like -L label1 -L label2... --no-headers=false: When using the default or custom-column output format, don't print headers (default printheaders). -o, --output='': Output format. One of:json|yaml|wide|name|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...See custom columns [http://kubernetes.io/docs/user-guide/kubectl-overview/#custom-columns], golang template[http://golang.org/pkg/text/template/#pkg-overview] and jsonpath template[http://kubernetes.io/docs/user-guide/jsonpath]. --raw='': Raw URI to request from the server. Uses the transport specified by the kubeconfig file. -R, --recursive=false: Process the directory used in -f, --filename recursively. Useful when you want to managerelated manifests organized within the same directory. -l, --selector='': Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) --server-print=true: If true, have the server return the appropriate table output. Supports extension APIs andCRDs. --show-kind=false: If present, list the resource type for the requested object(s). --show-labels=false: When printing, show all labels as the last column (default hide labels column) --sort-by='': If non-empty, sort list types using this field specification. The field specification is expressedas a JSONPath expression (e.g. '&#123;.metadata.name&#125;'). The field in the API resource specified by this JSONPath expressionmust be an integer or a string. --template='': Template string or path to template file to use when -o=go-template, -o=go-template-file. Thetemplate format is golang templates [http://golang.org/pkg/text/template/#pkg-overview]. -w, --watch=false: After listing/getting the requested object, watch for changes. Uninitialized objects are excludedif no object name is provided. --watch-only=false: Watch for changes to the requested object(s), without listing/getting first.Usage: kubectl get[(-o|--output=)json|yaml|wide|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...](TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]Use \"kubectl options\" for a list of global command-line options (applies to all commands).","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"暹罗珠玑","date":"2018-11-09T14:40:36.000Z","path":"2018/11/09/暹罗珠玑/","text":"I know the significant significance of this canal. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—2014.03.21 p{ text-indent:2em;} 云中界through the clouds从机场到海滨酒店40km路途，一路能见小米，OV，甚至还有国内并不寻常能有的巨大关公像。中文标注的火锅店，老北京卤肉卷，川菜/滇菜馆，以及各种汉字店名在街头时常出现。宾馆接待人员的普通话，感觉比我几个十里不同音的温州同事还要标准。支付宝/微信支付的标识常常贴在门店最显眼的地方。路途还有覆盖率极高的7-11，次之的全家。这里左向行驶，路上跑的80%是丰田和本田，10%为三菱和马自达，剩下的10%被福特和通用从强劲的日本竞争对手那里艰难获取。————————————中国游客占比颇高，也常见金发白肤的欧美人大腹便便走在街头。可能是旅游岛缘故，物价高于泰国其他区域。餐厅里99%为各地同胞..慢国内一小时(UTC/GMT +7:00)，所以相比之下，看欧冠或西甲，能稍稍少熬那么一会夜。热带气候太容易让人昏昏沉沉。3瓶红牛+1瓶电解质饮料，共需人民币8.4元被中国人炒起来的班扎恩海鲜市场。Night Fair#Shemale Show…#兼顾各国观众，有西方音乐剧，也有中国传统的宫廷歌舞;有邓丽君音色的&lt;梅&gt;，也有如印度电影里的魔性歌舞;有泰国传统舞曲，有台湾高山族风格曲目。但大多应是对口型的假唱，舞蹈却是真的，观众大多为猎奇，本并没有抱太高期待，却发觉水平其实颇高。…对这个已成这个国家特色和标志的群体，如果是当事者自愿那自是无可厚非，当尽量摘下有色眼镜；而如果是情非所愿迫不得已，这发生在21世纪是种悲哀。这些自幼服用雌性激素的“男性”寿命很短，大多不超过40岁。中国过去有“扬州瘦马”一说，几百年前意大利亦为歌剧有阉伶歌手，但而今ta们已因为社会的进步而不被容忍最终趋于消失不见。这里的公共厕所大多收费，且设备相对老旧，这种景象在中国，出现在20年前我还是孩童时的漫漶记忆中。这里时常能收到泰拳格斗的传单，惊讶的是，格斗者除去妇女，还有儿童。去年引起国内舆论上下一致指责的凉山格斗孤儿一事，在此地却是合理合法。大概前去欧美日韩，会觉当地经济发达，一切井然有序，细查之下更会发觉国内差距巨大；而在此，只觉得我们这个有志最优秀的国家，已位在中等偏上。————————————#Similan#两小时车程,复又一个半小时船程犁波破浪，风光大致如此。几颗群岛点缀，白银盘里青螺。Donald Duck Bay,中译为”老鸭湾”————————————机车环岛暮落神仙岛,”海夜吞残日”落日熔金,暮云合璧日晚渔歌唱，风烟满夕阳。想在选购琳琅商品的队队人流中，找到几个非我同胞的“外国人”，比在魔都任何一并不算大的综合体，如百盛/汇金 要难得多的多。“目录一览”比龙湖天街或亲橙里做的还要简明易懂。地道的北伦敦腔英语在此不如四川普通话好使。————————————#攀牙湾#海上有仙山,虚无缥缈间.“五人相对不语，各自想着各人的心事，波涛轻轻打着小舟，只觉清风明月，万古常存，人生忧患，亦复如是，永无断绝”‘忽然之间，一声声极轻柔、极缥缈的歌声散在海上：“到头这一身难逃那一日。百岁光阴，七十者稀。急急流年，滔滔逝水。”却是殷离在睡梦中低声唱着小曲。’‘海鸥应是未忘机，故人今有问归期。’“江西冷”大卖场—————— 幼时在姥爷家，喜食“泰国米仁”雪糕。对这个并非发达却可如“英法德美”同样称国的热带国家充满好奇。也曾笑言，“等我长大，带姥爷和姥娘同去”少时对标安南，各国军力，经济政态，风俗民貌，尽皆了然。胸中有典，笔头千字。慷慨陈言，倚马可待。自负似马幼长，谙熟兵法，冀望世人皆知。年岁渐长却退一步，觉立足华夏通晓四遭便是殊为不易。做一幕僚似郭奉孝荀令公，或如本朝之刘h或王hn，运筹帷幄，致君尧舜，板荡识忠，侯赢一言。纵在高中，沉迷理化，亦对他信下野，对红衫军黄杉军，对帅哥阿皮实退场，美女英拉登台了若指掌。“后来长大了”…不能再四体不勤五谷不分，而对这些烂熟于心也曾津津乐道的内容渐觉索然，关注度远逊房价涨跌利率升降，也不及未来规划技术成长。甚至涉此三缄其口，只听诸人讨论诉说，或正或误随机散落在五指山中的几点。再次“面朝大海”，却不是曾经轻灵少年。姥爷姥娘都不在了，我也再没有幼时天马行空的驰骋。而面对二十年后的“油腻中年”，还是要暗自坚持，为年少时的诸多想法，保留一颗缩龙成寸的星星之火。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---2018.11.08","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"Goland使用&调试技巧","date":"2018-11-04T10:37:55.000Z","path":"2018/11/04/Goland调试技巧/","text":"一些飘红问题 项目名不对导致的飘红 选中项目文件夹–重构–重命名： 重命名目录:是真的改真实的文件名 重命名项目: 是修改虚拟的项目名称(这个是在这里我所需要的~) .proto文件import的路径找不到而飘红 在如下图处，将包含import的.proto的文件夹路径添加进来(需要的一些.proto，如&quot;google/api/annotations.proto&quot;,google/protobuf/timestamp.proto,可以搜索或从此处下载) 配置 一键运行/调试 运行种类共有三个选项,选择哪个视情况而定… 我在三家企业,就因不同的项目结构,分别用到了”文件”,”包”和”目录”, 详情可见参考链接. （当实际run或build的不仅有main.go，还有其他文件时，就不能用”文件”这种形式） 参考: Goland 调试 高阶调试功能 https://blog.jetbrains.com/zh-hans/2019/04/24/goland/ 打断点 步过，就是遇到方法，不进入，直接下一行 步入，就是遇到函数会进入函数 步出，就是运行到退出本函数、返回上一级的下一行 继续（resume）每按一次，都跳向下一个断点。 单步（step over）一行一行执行。 步进（step in）如果在一个函数处步进，可以进入该函数。 步出（step out）如果在一个调用函数中，从此函数退出，回到调用该函数的地方。","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"青衫磊落险峰行(多图慎点)","date":"2018-11-01T14:31:02.000Z","path":"2018/11/01/青衫磊落险峰行/","text":"青衫磊落险峰行，玉璧月华明。谁家子弟谁家院，微步縠纹生，无计悔多情。 剧饮千杯男儿事，剑气碧烟横。梦里真真语真幻，挥洒缚豪英，莽苍踏雪行。 千里茫茫若梦，双眸粲粲如星。悄立雁门，绝壁无余字。红颜弹指老，刹那芳华。塞上牛羊空许约，烛畔鬓云有旧盟。 赤手屠熊缚虎，金戈荡寇鏖兵。输赢成败，又争由人算。奈天昏地暗，斗转星移。草木残生颅铸铁，虫豸凝寒掌作冰。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"武当山顶松柏长(多图慎点)","date":"2018-10-30T15:07:53.000Z","path":"2018/10/30/武当山顶松柏长/","text":"曾引先生笔下文字: 在金华通济桥头，祭奠多年前见义勇为牺牲的老乡。 在唱衰魔都的浪潮声中，表达我不随主流的理解。 用“裘千丈”代指滥竽充数狐假虎威的“技术大牛”“ppt架构师”。 我用&lt;倚天&gt;中言为心声自我写照的这段，在倘求之不得辗转反侧时聊做宽慰。 你写狂喜，写愤怒，写江湖武林，写世道人心，却没有留下一段，让我能用来拾来表达对你的崇敬。 襄阳城外，中年郭靖于少年杨过，用诸葛和老杜作“侠之大者，为国为民”灌输，以“鞠躬尽瘁死而后已”自明。这何尝不是作为现代化的传统知识分子和儒家读书人，对自己的一种特殊期许。 金老若老杜于当代，以笔为剑，借ta人之言，表胸中块垒。想来杜少陵“文章千古事，得失寸心知”，“尔曹身与名俱灭，不废江河万古流”，或便是时隔千载最为贴切的评价。 我也曾将笔下文字，用在先生同样喜爱并热衷的足球。 功勋卓著又谦逊低调的伊涅斯塔，离开了效忠近二十载的巴塞罗那。武林世界如同现实，很难找到一个武功顶级又不慕名利没有弱点的人物，以至于我思来想去，无法匹配到一个与这位让对手亦肃然起敬的足球运动员相谐的人物。 德国被首轮淘汰出局了，这个从巅峰骤至谷底的卫冕冠军，果真如一时黑云压城戏谑调侃的自媒体所说，沦为足坛可有可无的边缘角色？ 我用“王重阳与段智兴互传先天功和一阳指”，代指二人互相切磋互授技艺； 我用“外家招式”，指代被我嗤之以鼻不屑的前端样式，用易筋经和九阳功等内功心法指代数据库及更深层次的数理； 我用龙象波若功，代指logo是蟒蛇和大象的Python和PHP，每每按下Enter键，都似发掌，每招都有十龙十象的巨力； 我用乾坤大挪移，指代必将在云时代大放异彩的golang； 我用“重新练成了蛤蟆功”，指代某项生疏的技艺再次熟练； 我的空间名“风陵渡”，这是郭襄与杨过初见的地方。她的徒弟也即灭绝师太的师傅，名“风陵师太”； … 每赴名山大川，不全为自然景致，亦为人文。 能为那么多山岳海岛赋予特殊意义，盖此一人。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"天涯思君不可忘(多图慎点)","date":"2018-10-30T14:07:42.000Z","path":"2018/10/30/天涯思君不可忘/","text":"","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"},{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"使用sort包对其他数据类型进行排序","date":"2018-10-27T10:34:45.000Z","path":"2018/10/27/使用sort包对其他数据类型进行排序/","text":"对普通其他类型,使用sort.Slice sort包直接支持的只有int/float64/string等寥寥几个数据类型,其他则没有直接的函数供调用. 如sort.Strings()只接收[]string的参数, sort.Ints()只接收[]int类型. 如果要对[]int64排序就不能直接调用了. sort包提供了一个非常灵活的函数sort.Slice(slice interface{}, less func(i, j int) bool),第一个参数是待排序的切片.第二个参数是一个函数,该函数接收两个index值,返回 slice[i] &lt; slice[j]这个bool值,从而控制是asc还是desc 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"math/rand\" \"sort\" \"time\")func main() &#123; var length = 15 var list []int // 以时间戳为种子生成随机数，保证每次生成的数据不重复 r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; length; i++ &#123; list = append(list, r.Intn(1000)) &#125; fmt.Println(\"待排序数组为:\", list) sort.Slice(list, func(i, j int) bool &#123; return list[i] &lt; list[j] &#125;) fmt.Println(\"排序后的数组为:\",list)&#125; 输出为: 12待排序数组为: [357 718 763 394 716 361 384 198 832 189 640 364 776 84 110]排序后的数组为: [84 110 189 198 357 361 364 384 394 640 716 718 763 776 832] 如果要求稳定排序,可使用sort.SliceStable() 对结构体类型,使用sort.Interface http://c.biancheng.net/view/81.html https://www.google.com/search?q=golang+int64+%E6%8E%92%E5%BA%8F&amp;oq=golang+int64+%E6%8E%92%E5%BA%8F&amp;aqs=chrome..69i57j0l7.5142j0j1&amp;sourceid=chrome&amp;ie=UTF-8 更多阅读: 排序算法汇总 sort包源码分析","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"堆排序","date":"2018-10-25T10:46:46.000Z","path":"2018/10/25/堆排序/","text":"堆排序(Heap Sort)是对简单选择排序的一种改进 利用了(设计发明了)堆这种数据结构 堆及堆排序 于1964年由Floyd和Williams共同发明 突然意识到，1978年图灵奖得主Robert W. Floyd，获奖的原因很可能不是因为弗洛伊德算法。而是提出了“堆”这种数据结构，及借此改进了简单快速排序（即堆排序）…堆 这东西竟然是1964年才被提出，有些意想不到…这个“逆袭”实在不够恰当，即便在众多高校中，斯坦福拥有最多图灵奖得主，也不过才28位，略多于mit和ucb。排名前15的学校有12所归属美国。学文科的他发明堆排序，逆袭成为斯坦福终身教授！ 堆是一种比较特殊的完全二叉树,其还有如下特点: 如果每个节点的值都大于等于其左右孩子节点的值,则称为大顶堆;如果每个节点的值都小于等于其左右孩子节点的值,则称为小顶堆; 所以根节点一定是堆中所有节点最大(或最小)的 一定程度上,”堆”这个翻译还是比较贴切的~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport \"fmt\"//堆排序//s[0]不用，实际元素从角标1开始//父节点元素大于子节点元素//左子节点角标为2*k//右子节点角标为2*k+1//父节点角标为k/2func HeapSort(s []int) &#123; N := len(s) - 1 //s[0]不用，实际元素数量和最后一个元素的角标都为N //构造堆 //如果给两个已构造好的堆添加一个共同父节点， //将新添加的节点作一次下沉将构造一个新堆， //由于叶子节点都可看作一个构造好的堆，所以 //可以从最后一个非叶子节点开始下沉，直至 //根节点，最后一个非叶子节点是最后一个叶子 //节点的父节点，角标为N/2 for k := N / 2; k &gt;= 1; k-- &#123; sink(s, k, N) &#125; //下沉排序 for N &gt; 1 &#123; swap(s, 1, N) //将大的放在数组后面，升序排序 N-- sink(s, 1, N) &#125;&#125;//下沉（由上至下的堆有序化）,也被称为堆化(heapify)//给出一个整数数组，堆化操作就是把它变成一个最小堆数组。//对于堆数组A，A[0]是堆的根，并对于每个A[i]，A [i * 2 + 1]是A[i]的左儿子并且A[i * 2 + 2]是A[i]的右儿子。func sink(s []int, k, N int) &#123; for &#123; i := 2 * k if i &gt; N &#123; //保证该节点是非叶子节点 break &#125; if i &lt; N &amp;&amp; s[i+1] &gt; s[i] &#123; //选择较大的子节点 i++ &#125; if s[k] &gt;= s[i] &#123; //没下沉到底就构造好堆了 break &#125; swap(s, k, i) k = i &#125;&#125;func swap(s []int, i int, j int) &#123; s[i], s[j] = s[j], s[i]&#125;func main() &#123; var list []int list = []int&#123;-1, 3, 7, 2, 3, 8, 0, 1, 9, 6, 5&#125; fmt.Println(list[1:]) HeapSort(list) fmt.Println(list[1:])&#125; 输出为: 12[3 7 2 3 8 0 1 9 6 5][0 1 2 3 3 5 6 7 8 9] 或 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; data := []int&#123;10, 1, 23, 24, 7, 8, 9, 6, 4, 288, 99, 3, 34&#125; for i := 0; i &lt; len(data)-2; i++ &#123; //从最后一个父节点开始调整 for j := len(data[i:])/2 - 1; j &gt;= 0; j-- &#123; //把这个二叉树变成可处理的二叉树 heapSort(data[i:], j) &#125; &#125; fmt.Println(data)&#125;//堆，即完全二叉树。所有的父节点都比其子节点大func heapSort(data []int, i int) &#123; child := 2*i + 1 if 2*i+2 &lt; len(data) &#123; //如果存在右孩子并且 if data[2*i+1] &lt; data[2*i+2] &#123; child = 2*i + 2 &#125; &#125; if data[i] &gt; data[child] &#123; return &#125; else &#123; data[i], data[child] = data[child], data[i] //父节点小于子节点换位置 &#125; if child &lt;= (len(data)/2 - 1) &#123; //只要child 的序号还在 //只要当前孩子的索引在所有父节点索引内继续交换 heapSort(data, child) &#125;&#125; 参考: golang之堆排序 todo:Go语言的堆排序实现:https://blog.cyeam.com/golang/2014/08/29/go_heapsort","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"插入排序","date":"2018-10-25T10:18:20.000Z","path":"2018/10/25/插入排序/","text":"概述: 插入排序，一般也被称为直接插入排序。对于少量元素的排序，是一个有效的算法 。 插入排序是一种最简单的排序方法，其基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动 基本思想及代码实现: 插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。 插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; var length = 15 var list []int // 以时间戳为种子生成随机数，保证每次生成的数据不重复 r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; length; i++ &#123; list = append(list, r.Intn(1000)) &#125; fmt.Println(list) insertionSort(list) fmt.Println(list)&#125;func insertionSort(arr []int) &#123; if len(arr) &lt;= 1 &#123; return &#125; for i := 1; i &lt; len(arr); i++ &#123; for j := i; j &gt; 0; j-- &#123; if arr[j] &lt; arr[j-1] &#123; arr[j], arr[j-1] = arr[j-1], arr[j] &#125; &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"武林城外 酒茶肆","date":"2018-10-06T15:58:47.000Z","path":"2018/10/06/武林城外-酒茶肆/","text":"令狐冲自下山来，中途又经几番舟车劳苦，掸去素衣风尘，终在罗刹江滨一夜食店坐定，把酒言肉，大快朵颐。 同行旧友点菜完毕，店家烤炙，不多时便上来。羊腿甚佳，一日山中攀行不进水米，得此天物正欲鼓起腮帮子。却不知有两枚生蚝，见之一时凝噎。令狐冲酷喜海中诸物，见生蚝必想起法兰西人莫泊桑之&lt;我的叔叔于勒&gt;，食前必深呼吸曰“此物有大海之味，黄钟大吕排山倒地，公孙大娘舞剑也”，食时则闭眼，歆享如怡曰“有初恋之感，幸福得睁不开眼”，食罢则鼓噪唇舌曰“此余味无穷也，如闻韩娥奏丝竹管弦”。想必一年多来，是吃进过好些次。乍见之时，却多已不记。只遥遥想到，一年多前，从沪离职北上。时做一口腔手术，几日即可痊愈，父母却餐餐费神，一起张罗饭菜。老夫老妻于海鲜并不热衷，却为我之乐而乐。停留两周，便一路向西，游离古都，攀登高岳。在车站，想及魔都羁旅二载，终不得留，行将随潮去赴杭州，压力或小，赶紧取得户口购置住房。有朝得闲得钱，趁二人身体尚好，带其一同“去看看”。未及再多想，车便隆隆发动，带 其告别了家乡。… 时日如梭，两次面对生蚝，一年又半载。这一年半来，发生好些，让其始料不及感慨连连。…令狐冲思及此，却似有旧伤，一口老血上涌，迸裂喷射不能自己。想当年浔阳江头江州司马，虽一人孤处满腹悯然，却也有他乡沦落人更有知音“满座重闻皆掩泣”，而我，而我，这熙熙往往满满一条街人，却无人可与言及一二。匆匆心不在焉吃罢，令狐冲饮完杯中浊酒，便起身又走，不多时便消失在茫茫夜色与茫茫人海中。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"进程,线程和协程","date":"2018-10-05T12:38:57.000Z","path":"2018/10/05/进程-线程和协程/","text":"姊妹篇: Linux的进程和线程 多进程与多线程 相关章节: CPU及并发 读「Linux/UNIX系统编程手册(上)」 僵尸进程与孤儿进程 使用pstree,查看进程树 Linux的I/O调度算法 Linux内核分析与应用 Linux内核分析与应用2-内存寻址 Linux内核分析与应用3-进程管理 Linux内核分析与应用4-内存管理 进程最早出现,但因为 进程间通信(IPC) 成本较高, 进而有了协程的概念.但实现起来比较困难,后来更易实现的线程出现并得以广泛应用. 协程相比线程轻量多了..每次创建操作系统层级的线程,都会消耗系统资源,在&lt;阿里巴巴Java开发手册&gt;中明确要求,使用线程池,而不允许自己在代码里新建一个线程 协程是用户自定义的线程,不需要进入内核态进入申请计算资源.(这里的用户就是指应用程序及编程语言了..) 参考: 进程、线程和协程之间的区别和联系 进程、线程和协程的概念 进程、线程、轻量级进程、协程和go中的Goroutine","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"咬文嚼字-并发和并行","date":"2018-10-04T00:28:40.000Z","path":"2018/10/04/咬文嚼字-并发和并行/","text":"并发(Concurrency)和并行(Parallelism)的区别参考引用来自知乎 只有当CPU至少有两个核心的时候才有可能并行，而能不能并发与CPU的核心数无关，单核CPU也可以实现并发。并行是一种并发的特殊情况，并行要求必须是时间上的同时，而并发只要求逻辑上同时就可以。(无多核，不并行) 并发是有若干个任务，相互穿插着执行。并行是只有一个任务，同时执行这个任务的不同部分（或者相同部分不同上下文）。 小明排Dota天梯的时候抽空吃水果，排上了就放下水果，叫并发。小明右手操作英雄，左手吃水果，叫并行。 并发是不等待，并行是一起上 假设你需要洗衣服和做饭。串行：先洗完衣服再做饭，或者先做完饭再洗衣服。并发：一会洗衣一会做饭，但疾如闪电。并行：把洗衣盆拿到灶台上，左手挥铲右手搓衣。 并发：指在同一时刻做不止一件事情。比如数据库处理请求时，接受了第一个请求但是未处理完成，此时也可以接受第二个请求。两个请求任务在处理时间节点上可以有交集。并行：指将大量的任务，拆解成多个子任务分配到多个线程上，并发的执行。比如你要计算1到100的和，可以将计算分成两个部分，一个线程计算1到50的和，另一个线程计算51到100的和。简单的说：并行是多线程的一种形式，多线程是并发的一种形式。异步也是并发的一种形式 并行（parallelise）同时刻（某点），并发（concurrency）同时间（某段）并行 是在 某一时刻上 有多个任务在执行并发 是在 某一时段内 有多个任务在执行","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"关于range二三事","date":"2018-10-02T23:57:42.000Z","path":"2018/10/03/关于range二三事/","text":"来源: Shuang discuss 本文被Go夜读项目收录. 1. 以下代码最终的结果是什么? 1234567func main()&#123; sli := []int&#123;6,7,8&#125; for i := range sli &#123; sli = append(sli,666) fmt.Println(i) &#125;&#125; 面试时遇到的一个问题,这段代码会形成死循环吗? 回来之后试了一下出乎意料:输出结果为:123012 看上去 for 循环的次数,在进入循环体前已经确定了,且次数为 range 后 len(sli) 实际上,range 为 golang 的语法糖,其实际执行相当于 12345678func main() &#123; sli := []int&#123;6,7,8&#125; len_sli := len(sli) for index := 0 ; index &lt; len_sli; index++ &#123; sli = append(sli,666) fmt.Println(index) &#125;&#125; 即在进入循环之前,控制循环次数的这个 len_sli 参数已经确定; 在循环体内对原切片进行 append 操作,并不会影响 len_sli 的值 2. 写出以下代码的输出: 123456789101112131415package mainconst N = 3func main()&#123; m := make(map[int]*int) for i := 0; i &lt; N; i++ &#123; m[i] = &amp;i &#125; for _, v := range m &#123; print(*v) &#125;&#125; 初步分析: 在第一个循环中为m赋值,键名0,1,2分别对应着键值0,1,2的内存地址 在第二个循环中迭代m,每次循环用*取出指针键值对应内存地址里存的值 初步分析,结果应该是0,1,2 运行结果为: 123333 结果却是3,3,3 我们加一下注释代码再来看: 123456789101112131415func main() &#123; m := make(map[int]*int) for i := 0; i &lt; 3; i++&#123; m[i] = &amp;i //A fmt.Println(\"&amp;i的值是:\",&amp;i) fmt.Println(\"i的值是:\",i) &#125; for c,v := range m &#123; fmt.Println(c) time.Sleep(1e9) fmt.Println(*v) time.Sleep(1e9) &#125;&#125; 结果如下:123456789101112&amp;i的值是: 0xc420016468i的值是: 0&amp;i的值是: 0xc420016468i的值是: 0&amp;i的值是: 0xc420016468i的值是: 0031323 即在迭代中m的三个元素的指针相同,都指向了最后一个迭代对象的地址,在此即3的值 如果在迭代体中需要访问数组/map元素的指针，那么务必小心.这类 bug 无形极难轻易寻获 改进办法:引入中间变量,如下: 1234567891011121314151617181920func main()&#123; m := make(map[int]*int) for i := 0; i &lt; 3; i++ &#123; x := i fmt.Println(x) fmt.Println(&amp;x) m[i] = &amp;x fmt.Println(\"&amp;i的值是:\",&amp;i) fmt.Println(\"i的值是:\",i) &#125; for c,v := range m &#123; fmt.Println(c) time.Sleep(1e9) fmt.Println(*v) time.Sleep(1e9) &#125;&#125; 输出为: 12345678910111213141516171800xc420016470&amp;i的值是: 0xc420016468i的值是: 010xc420016490&amp;i的值是: 0xc420016468i的值是: 120xc4200164a8&amp;i的值是: 0xc420016468i的值是: 2001122 即此处v其实是一个全局变量,只分配了一次内存地址 总结:关于range,有两点需要注意: 一个是长度在循环之前就已经确定 另一个是迭代出的值是全局变量~ 2021年补记：居然和这一篇如此相似通过两个例子介绍一下 Golang For Range 循环原理","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"explain各字段的含义","date":"2018-09-29T13:10:42.000Z","path":"2018/09/29/explain各字段的含义/","text":"MySQL 5.6.3以前只能EXPLAIN SELECT; 5.6.3以后就可以EXPLAIN SELECT,UPDATE,DELETE 有这样一张user表,300多万行记录,表结构及索引信息如下: 对于sql: 12345678910111213SELECT * FROM `user` WHERE id &gt; 20000 AND country &gt; 1 AND grade IN ( 1, 4 ) AND city IN ( 1, 500, 1000, 1500, 3000 ) ORDER BY update_time DESC LIMIT 30; explain结果如下: 1.id SQL查询中的序列号 id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行。 2.select_type 查询的类型, 可以是如下的任何一种类型： 3.table 查询的表名. 并不一定是实际存在的表名. 可以为如下的值： &lt;unionM,N&gt;: 引用id为M和N UNION后的结果。 &lt;derivedN&gt;: 引用id为N的结果派生出的表。派生表可以是一个结果集，例如派生自FROM中子查询的结果。 &lt;subqueryN&gt;: 引用id为N的子查询结果物化得到的表。即生成一个临时表保存子查询的结果。 4.partitions 5.7以前，该项是explain partitions显示的选项; 5.7以后成为了默认选项. 该列显示的为分区表命中的分区情况, 非分区表该字段为空（NULL）. 5.type 最重要的一个指标, 显示查询使用了何种类型 除ALL之外, 其他type都可以用到索引; 除index_merge外, 其他type只可用到一个索引. 由左到右,性能由差到好: 1ALL,index，range，index_subquery，unique_subquery，index_merge，ref_or_null，fulltext，ref，eq_ref，const，system 从上到下,性能由差到好: (1) ALL 扫描全表,性能最差. &gt;&gt;&gt;&gt;&gt;&gt; (2) index 扫描全部索引树 或称”索引全表扫描”, 即把索引从头到尾扫一遍. 包含两种情况： 查询使用了覆盖索引, 那么只需要扫描索引就可以获得数据. 这个效率要比全表扫描快, 因为索引通常比数据表小, 且还能避免二次查询. 这种情况在extra中显示Using index. 反之, 如果在索引上进行全表扫描,则extra字段没有Using index. 如对于user表,telephone字段建有索引,如果 . explain select telephone from user;,则type字段将为index . explain select amount_coin from user;, 因为amount_coin字段没有建索引, 故而type字段将为ALL . explain select * from user;, 如果包含没有建索引的列, type字段也将为ALL &gt;&gt;&gt;&gt;&gt;&gt; (3) range 扫描部分索引 索引范围扫描, 对索引的扫描开始于某一点, 返回匹配值域的行，常见于 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中 &gt;&gt;&gt;&gt;&gt;&gt; (4) index_subquery 该联接类型类似于下面的unique_subquery 适用于非唯一索引, 可以返回重复值. &gt;&gt;&gt;&gt;&gt;&gt; (5) unique_subquery 用于where中in形式的子查询. 子查询返回不重复值唯一值, 可以完全替换子查询, 效率更高. 该类型替换了下面形式的IN子查询的ref： value IN (SELECT primary_key FROM single_table WHERE some_expr) &gt;&gt;&gt;&gt;&gt;&gt; (6) index_merge 表示查询使用了两个以上的索引, 最后取交集或者并集, 常见and ，or的条件使用了不同的索引. 官方排序这个在下面的ref_or_null之后, 但实际上由于要读取多个索引,性能可能大部分时间都不如更下面的range &gt;&gt;&gt;&gt;&gt;&gt; (7) ref_or_null 跟下面的ref类型类似, 只是增加了null值的比较. 实际用的不多 &gt;&gt;&gt;&gt;&gt;&gt; (8) fulltext 使用全文索引时type会是这个类型. 注意,全文索引的优先级很高,若全文索引和普通索引同时存在时, mysql不管代价, 会优先选择使用全文索引 &gt;&gt;&gt;&gt;&gt;&gt; (9) ref 使用非唯一索引或非唯一索引前缀进行的查找 对于来自前表的每一行,在当前表的索引中可以匹配到多行. 若连接只用到索引的最左前缀或索引不是主键或唯一索引时, 使用ref类型(可以理解成可能出现”一对多”时) ref可用于使用’=’或’&lt;=&gt;’操作符作比较的索引列 &gt;&gt;&gt;&gt;&gt;&gt; (10) eq_ref 唯一性索引扫描, 对于每个索引键, 表中只有一条记录与之匹配. eq_ref和const的区别: eq_ref 出现于多表join时, 对于来自前表的每一行, 在当前表中只能找到一行. 这是除了下面几种类型之外最好的类型. 当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型. eq_ref 可用于使用’=’操作符作比较的索引列, 比较的值可以是常量, 也可以是使用在此表之前读取的表的列的表达式. &gt;&gt;&gt;&gt;&gt;&gt; (11) const const: 单表中最多有一个匹配行, 例如根据主键或唯一索引查询.(如 select * from user where id=100),查询起来非常迅速 &gt;&gt;&gt;&gt;&gt;&gt; (12) system system是const类型的特例,只会出现在Myisam或Memory存储引擎, 当查询的表只有一行或空表的情况下,type字段将是system. 如果是Innodb引擎表, type列在这种情况通常都是ALL或者index. 这种类型可以可以忽略不计 &gt;&gt;&gt;&gt;&gt;&gt; (13) NULL 不用访问表或者索引,直接就能得到结果, 如 explain select NOW() 6.prossible_keys 可能使用到的索引 7.key 真正使用到的索引 select_type为index_merge时, 这里可能出现两个以上的索引; 其他的select_type这里只会出现一个. 8.key_len 查询用到的索引长度（字节数） 如果是单列索引, 那就整个索引长度算进去; 如果是多列索引(即联合索引),那么查询不一定都能使用到所有的列,用多少算多少. 可以留意下这个列的值, 算一下多列索引总长度, 就可知有没有使用到所有的列. 另:key_len只计算where条件用到的索引长度, 而排序和分组就算用到了索引,也不会计算到key_len中. 9.ref 如果使用常数等值查询, 这里会显示const; 如果是连接查询, 被驱动表的执行计划这里会显示驱动表的关联字段, 如果是条件使用了表达式或者函数,或者条件列发生了内部隐式转换, 这里可能显示为func 10.rows 非常重要的一个字段 mysql估算的 需要扫描的行数（不是精确值） 通过这个值,可以非常直观地显示 SQL 的效率好坏. 原则上 rows 越小越好. 当存在limit时,会对rows字段产生影响. 建议在explain时先去除limit 11.filtered 这个字段表示存储引擎返回的数据在server层过滤后, 剩下多少满足查询的记录数量的比例; 注意是百分比,不是具体记录数. 12.Extra 非常重要的一个字段 explain 中的很多额外信息会在 Extra 字段显示, 常见的有以下几种内容: distinct：在select部分使用了distinc关键字 Using filesort： 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作(优先内存,内存空间不够则会在磁盘排序), 不能通过索引顺序达到排序效果. 一般存在 Using filesort, 都建议通过优化去掉, 因为这样的查询对机器的资源消耗很大. Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错. 即不需要进行filesort Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议通过优化去掉. 另外还有 using where：在查找使用索引的情况下，需要回表去查询所需的数据 using index condition：查找使用了索引，但是需要回表查询数据 using index &amp; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 using index 好于 using where 好于 using index condition, 不需要回表查询数据，效率最快 在带有order by子句的sql中,要尽可能使extra字段不要出现Using filesort,而是Using index 举例如何去掉 Using filesort: explain结果每个字段的含义说明 mysql 索引type介绍 MySQL优化：定位慢查询的两种方法以及使用explain分析SQL limit 会对explain的type产生巨大影响 关于order by的优化 具有LIMIT和不具有LIMIT的ORDER BY可能是不同的 file_sort优化器会预先分配固定数量的sort_buffer_size字节。 MySQL 有时会优化具有LIMIT row_count子句而没有HAVING子句的查询： 如果您只选择LIMIT的几行，则在某些情况下，MySQL 通常会选择使用全 table 扫描，而 MySQL 通常会使用索引。 如果将LIMIT row_count和ORDER BY结合使用，MySQL 会在找到排序结果的前 row_count 行后立即停止排序，而不是对整个结果进行排序。如果通过使用索引进行排序，这将非常快。如果必须执行文件排序，则在找到第一个 row_count 之前，将选择与查询匹配的所有行，但不带有LIMIT子句，并对其中的大多数或全部进行排序。找到初始行后，MySQL 不会对结果集的其余部分进行排序。 如果没有为ORDER BY使用索引，但是也存在LIMIT子句，则优化器可能能够避免使用合并文件，并使用内存中filesort操作对内存中的行进行排序。 参考: 优化 Sequences Orderby 排序优化 理解mysql的临时表和文件排序","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"实用小命令","date":"2018-09-19T13:18:43.000Z","path":"2018/09/19/实用小命令/","text":"根据某个端口,杀死该进程 运行某个Go程序,该项目没有设置监听信号而退出,导致用Commamd+C退出无效.每次只能打开活动监视器,搜到二进制文件的名称,执行强制退出. 另外知道该程序监听的端口,lsof -i:端口可知其pid, 再执行kill -9 pid,则可退出. 现在想一行命令搞定这个事 lsof -i:端口号 | sed -n &quot;2,2p&quot; | awk &#39;{print $2}&#39; 这样就可以得到该端口对应进程的pid. 其中, 如 sed -n ‘5,7p’,是列出第 5-7 行.对于 sed -n ‘a,bp’,如果b&lt;a,则只列出第a行 执行 lsof -i:1210 | sed -n &quot;2,2p&quot; | awk &#39;{print $2}&#39; | xargs kill -9则可实现杀死占用该端口的进程 “xargs 是一个强有力的命令,它能够捕获一个命令的输出,然后传递给另外一个命令之所以能用到这个命令,关键是由于很多命令不支持管道符 | 管道来传递参数，而日常工作中又有这个必要，所以就有了xargs命令 ​​​​” 查看使用频率前十的命令 history | awk ‘{CMD[$2]++;count++;}END { for (a in CMD)\\print CMD[a] “ “ CMD[a]/count*100 “% “ a;}’ | grep -v “./“ \\| column -c3 -s “ “ -t | sort -nr | nl | head -n10 12345678910 1 1883 35.026% git 2 718 13.3557% cd 3 654 12.1652% c 4 375 6.97545% go 5 329 6.11979% ll 6 163 3.03199% gr 7 121 2.25074% pwd 8 101 1.87872% hexo 9 96 1.78571% p310 84 1.5625% open 下载整站 wget -r -p -np -k http://URL -r 递归下载-p 下载html里面所有的图片-np 不要追溯到父目录（可能是为了避免重复下载）-k 相对路径转换为绝对路径","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"SSA:静态单一赋值","date":"2018-09-13T13:00:03.000Z","path":"2018/09/13/SSA-静态单一赋值/","text":"静态单一赋值阶段进行的优化: 消除死代码, 删除不使用的分支, 替换一些常量表达式等等 Go SSA https://ggaaooppeenngg.github.io/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/ 高性能 Go 代码工坊（Part4) https://www.google.com/search?q=SSA+%E7%BC%96%E8%AF%91%E5%99%A8&amp;oq=SSA+%E7%BC%96%E8%AF%91%E5%99%A8&amp;aqs=chrome..69i57j69i60.240j0j1&amp;sourceid=chrome&amp;ie=UTF-8","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"}]},{"title":"页面置换算法","date":"2018-09-05T13:10:49.000Z","path":"2018/09/05/页面置换算法/","text":"全文整理自 大厂面试爱问的“调度算法”，20 张图一举拿下, 版权归原作者所有 在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须选择内存中的一个页面将其移出，以便为即将调入内存的页面让出空间。而用来选择淘汰哪一个页面的规则就叫做页面置换算法。 缺页异常（缺页中断） 在了解内存页面置换算法前，需先懂得 缺页异常（缺页中断）。 当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。 其与一般中断的主要区别在于： 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。 缺页中断的处理流程，如下图： 缺页中断的处理流程: 在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。 如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。 操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。 找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。 页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。 最后，CPU 重新执行导致缺页异常的指令。 上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？ 找不到空闲页的话，则说明此时内存已满了，这时，就需要 「页面置换算法」 选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。 页表项通常有如下图的字段： 其中： 状态位：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。 访问字段：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。 修改位：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。 硬盘地址：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。 如下是虚拟内存的管理整个流程，可从下面这张图看到： 所以，页面置换算法 的功能是: 当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。 那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种： 最佳页面置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用置换算法（LRU） 时钟页面置换算法（Clock） 最不常用置换算法（LFU） 最佳置换算法（OPT） 最佳页面置换算法 基本思路是，置换在「未来」最长时间不访问的页面。 故而，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。 举例如下: 假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图： 在这个请求的页面序列中，缺页共发生了 7 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 4 次。 这很理想，但在实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。 所以，最佳页面置换算法作用是为了衡量算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。 先进先出置换算法（FIFO） 既然无法预知页面在下一次访问前所需的等待时间，那可以选择在内存驻留时间很长的页面中进行置换，这就是「先进先出置换」算法的思想。 还是以前面 请求页面序列作为例子，假设使用 先进先出置换算法，则过程如下图： 在这个请求的页面序列中，缺页共发生了 10 次，页面置换共发生了 75 次，跟最佳页面置换算法比较起来，性能明显差了很多。 最近最久未使用置换算法（LRU） 最近最久未使用（LRU）的置换算法的基本思路是，发生缺页时，选择最长时间没有被访问的页面进行置换，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用(局部性原理)。 这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。 还是以前面请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图： 在这个请求的页面序列中，缺页共发生了 9 次，页面置换共发生了 6 次，跟先进先出置换算法比较起来，性能提高了一些。 虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。 困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头，是一个非常费时的操作。 所以，LRU 虽然看上去不错，但由于开销较大，实际比较少使用。 时钟页面置换算法（Clock） 那有没有一种既能优化置换的次数，也能方便实现的算法呢？ 时钟页面置换算法 就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。 该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。 当发生缺页中断时，算法首先检查表针指向的页面： 如果它的访问位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置； 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止； 如下是一副时钟页面置换算法的工作流程图，可在下方看到： 了解了这个算法的工作方式，就明白为什么被称为时钟（Clock）算法了。 最不常用置换算法（LFU） 最不常用（LFU）算法，它的意思不是指这个算法不常用，而是当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。 其实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。 看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，需要考虑效率和硬件成本。 要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。 且还有一个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。 那这个问题的解决办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。 参考: 操作系统中的算法/策略 Linux内核分析与应用4-内存管理 操作系统考点总结 「页面置换算法」五大盘点 操作系统之页面置换算法","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"网路迷踪","date":"2018-09-02T12:20:12.000Z","path":"2018/09/02/网路迷踪/","text":"公司大部分的内部网站,都需要连接权限最高的网络才能访问. (一般公司的无线网络都分为guest/normal/develop----guest供访客使用,normal供内部非IT员工使用, 可以访问公司日常使用的内部网站,而develop还有访问服务器等资源的更高级权限) 但为了使用Google,还需要配置xx软件, 在此我使用ClashX. 但发现一个问题,当连接公司网络, 打开ClashX状态下, 部分内部网站无法访问. ClashX未开全局模式,公司域名也没有被代理规则命中,甚至把代理设置为”直接连接”,内部网站依然无法加载. 关闭ClashX,马上又能正常访问. 初步分析: 可将公司的域名,加入到”忽略这些主机与域的代理设置”中 192.168.0.0/16、10.0.0.0/8、172.16.0.0/12、127.0.0.1、localhost、*.local、timestamp.apple.com 但Mac这个功能好像有bug. 关闭代理软件重新打开后,原本的配置就被抹掉了. 打开ClashX的配置文件,在其中新增一条- DOMAIN-SUFFIX,*.xxxxx.co,DIRECT,此时奏效,可以在ClashX打开状态下,正常访问内网","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"PV操作","date":"2018-09-01T13:01:12.000Z","path":"2018/09/01/PV操作/","text":"什么是信号量 1234567计数信号量具备两种操作动作，称为V（signal()）与P（wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号量S的数值，P操作会减少它。运行方式：初始化信号量，给与它一个非负数的整数值。运行P（wait()），信号量S的值将被减少。企图进入临界区的进程，需要先运行P（wait()）。当信号量S减为负值时，进程会被阻塞住，不能继续；当信号量S不为负值时，进程可以获准进入临界区。运行V（signal()），信号量S的值会被增加。结束离开临界区的进程，将会运行V（signal()）。当信号量S不为负值时，先前被阻塞住的其他进程，将可获准进入临界区。 例题 例1 进程P1、P2、P3、P4和P5的前趋图如下所示： 若用 PV操作 控制进程P1、P2、P3、P4 、P5并发执行的过程，则需要设置5个信号量S1、S2、S3、S4和S5，且信号量S1～S5的初值都等于零。下图中a、b 和c处应分别填写（ &nbsp;）；d和e处应分别填写（ &nbsp;），f和g处应分别填写（ &nbsp;）。 问题1选项 A.V（S1）、P（S1）和V（S2）V（S3）&nbsp; B.P（S1）、V（S1）和V（S2）V（S3）&nbsp; C.V（S1）、V（S2）和P（S1）V（S3）&nbsp; D.P（S1）、V（S2）和V（S1）V（S3）&nbsp; 问题2选项 A.V（S2）和P（S4）&nbsp; B.P（S2）和V（S4）&nbsp; C.P（S2）和P（S4）&nbsp; D.V（S2）和V（S4）&nbsp; 问题3选项 A.P（S3）和V（S4）V（S5）&nbsp; B.V（S3）和P（S4）P（S5）&nbsp; C.P（S3）和P（S4）P（S5）&nbsp; D.V（S3）和V（S4）V（S5）&nbsp; 解: 空 (1) 的正确的选项为 A 。根据前驱图，$P_1$进程执行完需要通知$P_2$进程，故需要利用$V(S_1)$操作通知$P_2$进程，所以空 a 应填$V(S_1)$;$P_2$ 进程需要等待$P_1$进程的结果，故需要利用 $P(S_1)$ 操作测试 $P_1$ 进程是否运行完，所以空 b 应填 $P(S_1)$;又由于$P_2$进程运行结束需要利用$V(S_2)$、$V(S_3)$操作分别通知$P_3$、$P_4$进程，所以空 c应填 $V(S_2)$、$V(S_3)$。 例1-2 进程P1、P2、P3、P4和P5的前趋图如下所示： 用 PV操作 控制这5个进程的同步与互斥的程序如下，程序中的空①和空②处应分别为（&nbsp; ），空③和空④处应分别为（&nbsp; ），空⑤和空⑥处应分别为（&nbsp; ）。 问题1选项 A.V (S1）和P(S2）P (S3)）&nbsp;B.P(S1）和V(S1）V (S2)）&nbsp;C.V (S1）和V (S2）V (S3)）&nbsp;D.P (S1）和V(S1）P (S2)）&nbsp; 问题2选项 A.V (S4）V (S5）和P(S3)&nbsp; B.V (S3) V (S4）和V(S5)&nbsp; C.P (S4）和P (S5）V (S5)&nbsp; D.P(S4）和P(S5) V (S4)&nbsp; 问题3选项 A.P (S6）和P (S5） V (S6)&nbsp;B.V (S5）和V (S5) V (S6)&nbsp;C.P (S6）和P (S5）P (S6)&nbsp;D.V (S6）和P (S5) P(S6)&nbsp; 解: 根据前驱图，P1进程运行完需要利用V操作V(S1）通知P2进程，所以空①应填 V (S1)。P2进程运行完需要利用V操作V(S2)、V(S3）分别通知P3、P4进程，所以空②应填V (S2） V (S3）。 根据前驱图，P3进程运行完需要利用V操作V(S4)、V(S5）分别通知P4、P5 进程，故空③应为填写V(S4）V(S5)。P4需要等待P2和P5进程的通知，需要执行2个Р操作，由于P4进程的程序中执行前有1个Р操作P(S4)，故空④应为填写P(S3)。 根据前驱图，P4进程执行完需要通知P5进程，故P4进程应该执行1个V操作，即空⑤应填V(S6)。P5进程运行前需要等待P3和P4进程的通知，需要执行2个Р操作，故空⑥应填写P(S5）和P(S6)。 根据上述分析，用PV操作控制这6个进程的同步与互斥的程序如下： 例1-3 进程P1、P2、P3、P4、P5的前趋图如下： 若用PV操作控制进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。下图中a和b应分别填写( )，c和d应分别填写( )，e和f应分别填写( )。 A．P(S1)和P(S2)B．P(S1)和V(S2)C．V(S1)和V(S2)D．V(S1)和P(S2) 例1-4 进程P1、P2、P3、P4和P5的前趋图如下： 若用PV操作控制进程P1～P5并发执行的过程，则需要设置6个信号S1、S2、S3、S4、S5和S6，且信号量S1-S6的初值都等于零。下图中a和b处应分别填写（ &nbsp;）；c和d处应分别填写（ &nbsp;），e和f处应分别填写（ &nbsp;）。 问题1选项 A. P（S1）P（S2）和P（S3）P（S4） B. P（S1）V（S2）和P（S2）V（S1） C. V（S1）V（S2）和V（S3）V（S4） D. P（S1）P（S2）和V（S1）V（S2） 问题2选项 A. P（S1）P（S2）和V（S3）V（S4） B. P（S1）P（S3）和V（S5）V（S6） C. V（S1）V（S2）和P（S3）P（S4） D. P（S1）V（S3）和P（S2）V（S4） 解: 本题主要考查用PV操作控制进程的并发执行。首先我们需要弄清楚前驱图中给出的各进制的执行顺序。从图中我们不难看出进程P1和P2没有前驱，也就是可以首先并发执行，而进程P3的前驱是P1和P2，P4的前驱是P1和P3，P5的前驱是P2和P3。那么怎么理解前驱呢？其实前驱就是指只有在前驱进程完成后，该进程才能开始执行 &nbsp; 在本题的前驱图中我们不难看出，有6条路径，分别是P1-&gt;P3，P1-&gt;P4，P2-&gt;P3，P2-&gt;P5，P3-&gt;P4，P3-&gt;P5。而且题目也告诉我们分别有6初值为0个信号量（S1-S6），要我们用PV操作来控制进程P1～P5的并发执行。这里我们就需要清楚P与V这两种操作。&lt; P原语的主要操作是： （1）信号量（sem）减1； （2）若相减结果大于等于零，则进程继续执行； （3）若相减结果小于零，则阻塞一个在该信号量上的进程，然后再返回原进程继续执行或转进程调度。 V原语的主要操作是： （1）信号量（sem）加1； （2）若相加结果大于零，则进程继续执行； （3）若相加结果小于或等于零，则唤醒一阻塞在该信号量上的进程，然后再返回原进程继续执行或转进程调度。 &nbsp; 总而言之，进行P操作的主要目的是阻塞某信号量上的进程，而进行V操作的主要目的是唤醒某信号量上的进程。 &nbsp; 下面我们具体来求解这个题目。a空处，是在进程P1执行完成以后，那么根据题目的前驱图我们可以知道，这个时候它应该唤醒它的后继进程P3和P4，因此需要执行两个V操作，同样的道路，b空处也需要执行两个V操作，因此可以知道第一空答案选C。 &nbsp; 至于C空处，它是在进程P3执行前进行的处理。根据前驱的意义，我们可以知道执行P3要在P1和P2完成后，因此这个时候，它首先需要判断P1和P2进程是否完成，如何它们完成的话，会分别执行唤醒P3的V操作（换句话说就是会给相应的信号量进行加1操作），那么这个时候我们也可以通过同样的信号量来判断，即对相应的信号量进行减1操作，判断它是否大于0，如果大于等于0，则执行P3，也就是需要P操作。从题目给出的答案来看，这两个信号量应该分别是S1和S3。那么执行完P3后，它也需要唤醒它的后继进程P4和P5，因此需要执行两个V操作，因此D空处应该是两个V操作。综上所述，我们可以知道第二空的答案选B。 &nbsp; 分析到这里后，第三空的答案应该就很明显了，P4和P5进程在执行前，都需要做与P3进程执行前一样的判断，因此都需要进行两个P操作。所以本题答案选C。 &nbsp; 其实做这类题也不难，首先需要我们对PV操作要有一个透彻的理解，另外就是能分析出题目执行的逻辑关系。 例2 若用PV操作来管理相关临界区，且信号量的值总是在[-2，1]之间变化，则( ) A.最多只有一个进程在相关临界区执行 B.至少有两个进程在等待进入相关临界区 C.相关临界区的个数最多2个 D.竞争相关临界区执行权的进程最多2个 解: 本题考查进程管理-进程同步。相关临界区：指并发进程中涉及到相同变量的那些临界区。对于若干个并发进程共享某一变量的相关临界区的管理有三个要求：（1）一次最多一个进程能够进入临界区；（2）不能让一个进程无限制地在临界区执行；（3）不能强迫一个进程无限制地等待进入它的临界区。若用PV操作来管理相关临界区，且信号量的值总是在[-2，1]之间变化，则最多只有一个进程在相关临界区执行。故本题选A。 2-2 临界区是（）。 A.一段共享数据区 B.一个缓冲区 C.一段程序 D.一个同步机制 解: 本题考查进程管理-进程同步。临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用。故本题选C。 参考: 软件设计师：第五章：操作系统考点总结 前趋图(Precedence Graph) 是一个有向无环图，记为：→={（Pi，Pj&nbsp;）|Pi&nbsp; &nbsp;must complete before &nbsp;Pj&nbsp; may strat}。假设系统中进程P={P1，P2，P3，P4，P5，P6，P7，P8}，且进程的前驱图如下： 那么前驱图可记为：（ &nbsp;）。 问题1选项 A.→={（P2,P1）,（P3,P1）,（P4,P1）,（P6,P4）,（P7,P5）,（P7,P6）,（P8,P7）} B.→={（P1,P2）,（P1,P3）,（P1,P4）,（P2,P5）,（P5,P7）,（P6,P7）,（P7,P8）} C.→={（P1,P2）,（P1,P3）,（P1,P4）,（P2,P5）,（P3,P5）,（P4,P6）,（P5,P7）,（P6,P7）,（P7,P8）} D.→={（P2,P1）,（P3,P1）,（P4,P1）,（P5,P2）,（P5,P3）,（P6,P4）,（P7,P5）, （P7,P6）,（P8,P7）} 解: 本题考查前趋图，该图的标记方法是将图中各条边的起始记录好，以便描述这个图。以本题的图为例，由于P1有箭头指向P2，所以有（P1，P2），又由于P1有指向P3的箭头，所以有（P1，P3）依次类推可得到完整的集合与C选项一致。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"微服务入门篇","date":"2018-08-28T11:30:38.000Z","path":"2018/08/28/微服务入门篇/","text":"常见的微服务组件及概念： 服务注册：服务提供方将自己调用地址注册到服务注册中心，让服务调用方能够方便地找到自己。 服务发现：服务调用方从服务注册中心找到自己需要调用的服务的地址。 负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，节点选择的工作对服务调用方来说是透明的。 服务网关：服务网关是服务调用的唯一入口，可以在这个组件是实现用户鉴权、动态路由、灰度发布、A/B 测试、负载限流等功能。 配置中心：将本地化的配置信息（properties, xml, yaml 等）注册到配置中心，实现程序包在开发、测试、生产环境的无差别性，方便程序包的迁移。 API 管理：以方便的形式编写及更新 API 文档，并以方便的形式供调用者查看和测试。 集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件（特别是管理端组件）集成到统一的界面框架下，让用户能够在统一的界面中使用系统。 分布式事务：对于重要的业务，需要通过分布式事务技术（TCC、高可用消息服务、最大努力通知）保证数据的一致性。 调用链：记录完成一个业务逻辑时调用到的微服务，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。 支撑平台：系统微服务化后，系统变得更加碎片化，系统的部署、运维、监控等都比单体架构更加复杂，那么，就需要将大部分的工作自动化。现在，可以通过 Docker 等工具来中和这些微服务架构带来的弊端。 例如持续集成、蓝绿发布、健康检查、性能健康等等。严重点，以我们两年的实践经验，可以这么说，如果没有合适的支撑平台或工具，就不要使用微服务架构。 微服务架构的优点： 降低系统复杂度：每个服务都比较简单，只关注于一个业务功能。 松耦合：微服务架构方式是松耦合的，每个微服务可由不同团队独立开发，互不影响。 跨语言：只要符合服务 API 契约，开发人员可以自由选择开发技术。这就意味着开发人员可以采用新技术编写或重构服务，由于服务相对较小，所以这并不会对整体应用造成太大影响。 独立部署：微服务架构可以使每个微服务独立部署。开发人员无需协调对服务升级或更改的部署。这些更改可以在测试通过后立即部署。所以微服务架构也使得 CI／CD 成为可能。 Docker 容器：和 Docker 容器结合的更好。 DDD 领域驱动设计：和 DDD 的概念契合，结合开发会更好。 微服务架构的缺点： 微服务强调了服务大小，但实际上这并没有一个统一的标准：业务逻辑应该按照什么规则划分为微服务，这本身就是一个经验工程。有些开发者主张 10-100 行代码就应该建立一个微服务。虽然建立小型服务是微服务架构崇尚的，但要记住，微服务是达到目的的手段，而不是目标。微服务的目标是充分分解应用程序，以促进敏捷开发和持续集成部署。 微服务的分布式特点带来的复杂性：开发人员需要基于 RPC 或者消息实现微服务之间的调用和通信，而这就使得服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手。 分区的数据库体系和分布式事务：更新多个业务实体的业务交易相当普遍，不同服务可能拥有不同的数据库。CAP 原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性，这个对开发人员来说是一个挑战。 测试挑战：传统的单体WEB应用只需测试单一的 REST API 即可，而对微服务进行测试，需要启动它依赖的所有其他服务。这种复杂性不可低估。 跨多个服务的更改：比如在传统单体应用中，若有 A、B、C 三个服务需要更改，A 依赖 B，B 依赖 C。我们只需更改相应的模块，然后一次性部署即可。但是在微服务架构中，我们需要仔细规划和协调每个服务的变更部署。我们需要先更新 C，然后更新 B，最后更新 A。 部署复杂：微服务由不同的大量服务构成。每种服务可能拥有自己的配置、应用实例数量以及基础服务地址。这里就需要不同的配置、部署、扩展和监控组件。此外，我们还需要服务发现机制，以便服务可以发现与其通信的其他服务的地址。因此，成功部署微服务应用需要开发人员有更好地部署策略和高度自动化的水平。 总的来说（问题和挑战）：API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用。","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"读<软技能-代码之外的生存指南>","date":"2018-08-28T01:25:45.000Z","path":"2018/08/28/读-软技能-代码之外的生存指南/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"show index 中部分字段的含义","date":"2018-08-20T15:36:27.000Z","path":"2018/08/20/show-index-中部分字段的含义/","text":"show index from 表名 查看某张表的索引情况 另:SELECT * FROM information_schema.STATISTICS WHERE TABLE_NAME = &quot;t1&quot; 与 show index from t1 作用相似,且会返回更多的字段信息 创建一张测试表t1: 12345678910111213CREATE TABLE `t1` ( `id` INT ( 11 ) NOT NULL AUTO_INCREMENT, `name` CHAR ( 20 ) CHARACTER SET utf8 NOT NULL DEFAULT '', `age` INT ( 11 ) DEFAULT NULL, `sex` enum ( 'F', 'M' ) CHARACTER SET utf8 DEFAULT NULL, PRIMARY KEY ( `id` ), KEY `idx_name` ( `name` ), KEY `idx_name_age` ( `name`, `age` ), KEY `idx_name_sub` ( `name` ( 5 )) ) ENGINE = INNODB AUTO_INCREMENT = 6 DEFAULT CHARSET = utf8; show index from t1 结果如下: 写入几条数据: 12345INSERT INTO t1 (`name`,age,sex) VALUES ('青莲居士',61,'M'); INSERT INTO t1 (`name`,age,sex) VALUES ('少陵野老',58,'M'); INSERT INTO t1 (`name`,age,sex) VALUES ('铁冠道人',64,'M'); INSERT INTO t1 (`name`,age,sex) VALUES ('易安居士',73,'F'); INSERT INTO t1 (`name`,age,sex) VALUES ('稼轩居士',67,'M'); 1. Table 表名称 2. Non_unique 如果是主键索引或唯一索引, 则为0; 如果是普通索引,则为1 着重注意多列组成的联合索引,可以设置为唯一索引 3. Key_name 索引名称 4. Seq_in_index 该列在索引中的序号,从1开始; 只有当存在(多列组成的)联合索引时,该字段才可能出现2,3,4等.. 如本例中,对”name”和”age”字段建了一个联合索引idx_name_age.在该索引中,name字段排在第一,age字段排在第二,所以age的Seq_in_index值为2 5. Column_name 列名称 6. Collation collation 英[kəˈleɪʃn]美[kəˈleɪʃn]n. 校对，核对；整理; (对书卷号码、编页等的) 核实，配页; 牧师职务的授予;[例句]Have you completed the collation of this book?这本书你校勘完毕没有？ 列以什么方式存储在索引中, 在MySQL 8.0之前, 只有值‘A’（升序,asc）或NULL（无分类）; 8.0之后,增加了对desc的支持 可参考: InnoDB一棵B+树,可以存放多少行数据 ,搜索降序索引 如再新增一个字段作品数量, 12-- 在name字段后新增一个opus_num字段,类型为int(11)alter table t1 add column opus_num INT(11) not null after `name`; opus 英[ˈəʊpəs]美[ˈoʊpəs]n. (按个别作曲家的创作排列的) 编号乐曲，作品编号; 主要(文学等)作品; (尤指) 大作，巨著;[例句]This magnum opus took ten years to complete.这部巨著历时十年始告成。复数：opuses 为该列创建一个普通索引,降序排列 1create index idx_opus on t1(opus_num desc) 此时的 索引信息如下: 7. Cardinality cardinalityn. 基数；集的势;[例句]They have the same cardinality.它们有相同的基数。 该字段 估计索引中不重复记录. 如果这个相对值很小,可能就要评估索引是否有意义. 即可以通过该字段,来评估索引是否合理 cardinality字段是索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。cardinality根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，MySQL使用该索引的机会就越大。 如 性别字段、类型字段，其可取值范围很小，称为低选择性.这类字段一般不需要建索引. 可参考: MySQL中Cardinality值的介绍 8. Sub_part 如果列只是一部分被编入索引(即前缀索引),则该字段将不为NULL,而为被编入索引的字符数目. 如果整列被编入索引, 则为NULL. 可参考: 前缀索引,一种优化索引大小的解决方案 有些类似git的commit_id,全长有几十位.但仅用前6位或前8位,就可以区别和标识 如本例中,对”name”字段建了一个前缀索引idx_name_sub,截取了”name”列的前5个字符作为索引.故而对于该索引 Sub_part的值为5 9. Packed 指示关键字如何被压缩. 如果没有被压缩,则为NULL. 10. Null 如果该列含有NULL值, 则为YES. 11. Index_type 使用的索引类型（BTREE, FULLTEXT, HASH, RTREE之一） 可参考 MySQL的四种索引类型 绝大多数情况下都是 BTREE 12. Comment 相关评注 (以下字段为新增) 13. Index_comment 14. Visible 15. Expression","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"MySQL系统变量sql_safe_updates","date":"2018-08-14T12:59:06.000Z","path":"2018/08/14/MySQL系统变量sql-safe-updates/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Golang的格式化输出","date":"2018-08-14T06:39:49.000Z","path":"2018/08/14/Golang的格式化输出/","text":"格式 描述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 %t 输出bool值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( \"fmt\")type point struct &#123; x, y int&#125;func main() &#123; p := point&#123;1, 2&#125; fmt.Printf(\"%v\\n\", p) fmt.Printf(\"%+v\\n\", p) fmt.Printf(\"%#v\\n\", p) fmt.Printf(\"%T\\n\", p) fmt.Printf(\"%t\\n\", true) fmt.Printf(\"%d\\n\", 123) fmt.Printf(\"%b\\n\", 14) fmt.Printf(\"%c\\n\", 33) fmt.Printf(\"%x\\n\", 456) fmt.Printf(\"%f\\n\", 78.9) fmt.Printf(\"%e\\n\", 123400000.0) fmt.Printf(\"%E\\n\", 123400000.0) fmt.Printf(\"%s\\n\", \"\\\"string\\\"\") fmt.Printf(\"%q\\n\", \"\\\"string\\\"\") fmt.Printf(\"%x\\n\", \"hex this\") fmt.Printf(\"%p\\n\", &amp;p) fmt.Printf(\"|%6d|%6d|\\n\", 12, 345) fmt.Printf(\"|%6.2f|%6.2f|\\n\", 1.2, 3.45) fmt.Printf(\"|%-6.2f|%-6.2f|\\n\", 1.2, 3.45) fmt.Printf(\"|%6s|%6s|\\n\", \"foo\", \"b\") fmt.Printf(\"|%-6s|%-6s|\\n\", \"foo\", \"b\") s := fmt.Sprintf(\"a %s\", \"string\") fmt.Println(s) //fmt.Fprintf(os.Stderr, \"an %s\\n\", \"error\")&#125; 输出为： 12345678910111213141516171819202122&#123;1 2&#125;&#123;x:1 y:2&#125;main.point&#123;x:1, y:2&#125;main.pointtrue1231110!1c878.9000001.234000e+081.234000E+08\"string\"\"\\\"string\\\"\"68657820746869730x1400012a010| 12| 345|| 1.20| 3.45||1.20 |3.45 || foo| b||foo |b |a string","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go安全扫描工具","date":"2018-08-13T13:38:19.000Z","path":"2018/08/13/Go安全扫描工具/","text":"Gosec是一个通过扫描Go AST来检查源代码是否存在安全问题的开源项目 快速安装 在此下载最新的release，如gosec_2.8.1_darwin_amd64.tar.gz，解压后，将二进制文件移动到GOBIN目录下 使用 进入想要扫描的代码目录下， 执行 gosec -fmt=json ./... 该命令的意思是：检测当前目录下的所有的代码，并以Json的格式输出到终端。 出去json，支持的格式还有text, yaml, csv, sonarqube, JUnit XML, html 可使用gosec -fmt=json -out=自定义文件名.json ./...，将扫描结果输出到指定文件 可使用 gosec -include=G101,G203,G401 ./...指定使用某几个规则 可使用 gosec -exclude=G303 ./...排除了某几个规则 具体规则如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859◈ G101：查找硬编码凭证◈ G102：绑定到所有接口◈ G103：审计 unsafe 块的使用◈ G104：审计未检查的错误◈ G106：审计 ssh.InsecureIgnoreHostKey 的使用◈ G107: 提供给 HTTP 请求的 url 作为污点输入◈ G108: /debug/pprof 上自动暴露的剖析端点◈ G109: strconv.Atoi 转换到 int16 或 int32 时潜在的整数溢出◈ G110: 潜在的通过解压炸弹实现的 DoS◈ G201：SQL 查询构造使用格式字符串◈ G202：SQL 查询构造使用字符串连接◈ G203：在 HTML 模板中使用未转义的数据◈ G204：审计命令执行情况◈ G301：创建目录时文件权限分配不合理◈ G302：使用 chmod 时文件权限分配不合理◈ G303：使用可预测的路径创建临时文件◈ G304：通过污点输入提供的文件路径◈ G305：提取 zip/tar 文档时遍历文件◈ G306: 写到新文件时文件权限分配不合理◈ G307: 把返回错误的函数放到 defer 内◈ G401：检测 DES、RC4、MD5 或 SHA1 的使用◈ G402：查找错误的 TLS 连接设置◈ G403：确保最小 RSA 密钥长度为 2048 位◈ G404：不安全的随机数源（rand）◈ G501：导入黑名单列表：crypto/md5◈ G502：导入黑名单列表：crypto/des◈ G503：导入黑名单列表：crypto/rc4◈ G504：导入黑名单列表：net/http/cgi◈ G505：导入黑名单列表：crypto/sha1◈ G601: 在 range 语句中使用隐式的元素别名 参考： 免费开源的代码审计工具 Gosec 入门使用 使用 gosec 检查 Go 代码中的安全问题 golang的一些安全问题","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"golang结构体转json时,结构体中time.Time字段如何转为Y:m:d H:i:s格式","date":"2018-08-13T13:36:37.000Z","path":"2018/08/13/golang结构体转json时-结构体中time-Time字段如何转为Y-m-d-H-i-s格式/","text":"12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"time\" \"fmt\" \"reflect\" \"encoding/json\")type BillInfo struct &#123; Name string `json:\"name\"` Gender string `json:\"gender\"` BirthPlace string `json:\"birthplace\"` BirthDay time.Time `json:\"birthday\"`&#125;func main() &#123; var bill BillInfo bill.Name = \"Bill Gates\" bill.Gender = \"male\" bill.BirthPlace = \"Seattle\" bill.BirthDay = time.Date(1955, 10, 28, 0, 0, 0, 0, time.Local) fmt.Println(bill.BirthDay) fmt.Println(reflect.TypeOf(bill.BirthDay)) rs, err := json.Marshal(bill) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(string(rs))&#125; 输出为: 1231955-10-28 00:00:00 +0800 CSTtime.Time&#123;&quot;name&quot;:&quot;Bill Gates&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;birthplace&quot;:&quot;Seattle&quot;,&quot;birthday&quot;:&quot;1955-10-28T00:00:00+08:00&quot;&#125; 显然,我们更希望的是得到一个Y:m:d H:i:s格式的结果; 可以通过定义一个time.Time类型的别名，然后为这个别名类型实现MarshalJSON方法。 图1 代码做修改如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"time\" \"fmt\" \"reflect\" \"encoding/json\")type BillInfo struct &#123; Name string `json:\"name\"` Gender string `json:\"gender\"` BirthPlace string `json:\"birthplace\"` BirthDay formatTime `json:\"birthday\"`&#125;type formatTime time.Timefunc (cs formatTime) MarshalJSON() ([]byte, error) &#123; var stamp = fmt.Sprintf(\"\\\"%s\\\"\", time.Time(cs).Format(\"2006-01-02 15:04:05\")) return []byte(stamp), nil&#125;func main() &#123; var bill BillInfo bill.Name = \"Bill Gates\" bill.Name = \"male\" bill.BirthPlace = \"Seattle\" bill.BirthDay = formatTime(time.Date(1955, 10, 28, 0, 0, 0, 0, time.Local)) fmt.Println(bill.BirthDay) fmt.Println(reflect.TypeOf(bill.BirthDay)) rs, err := json.Marshal(bill) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(string(rs))&#125; 参考: golang的json的时间格式化解决方案 使用自定义MarshalJSON更改struct中的JSON标记 结果为: 123&#123;0 61688102400 0x11abdc0&#125;main.formatTime&#123;&quot;name&quot;:&quot;Bill Gates&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;birthplace&quot;:&quot;Seattle&quot;,&quot;birthday&quot;:&quot;1955-10-28 00:00:00&quot;&#125; 图2 上面这种方式虽能实现,但侵入了原结构体,将原来的time.Time类型改为了我自定义的formatTime类型 ,参考如下两种方式 参考1 参考2 继续深究此问题,可参见本地note/for目录下的4.go文件 强烈推荐Golang 中使用 JSON 的小技巧 还可以思考下这个问题如何使用自定义MarshalJSON更改struct中的JSON标记 简单总结:可以通过为time.Time定义一个别名,对该别名实现MarshalJSON()方法,在该方法里就行时间格式的转换; 但该方法的不足是需要修改和侵入原结构体; 还有一种方法是为整个结构体实现MarshalJSON()方法,但该方法的不足是需要将原结构体中time.Time类型字段的json标签改为”-“,也侵入了原结构体; 实际上,通过上面的链接,是可以有不侵入原结构体即实现效果的方法,但比较繁琐;一般情况下,第一种依然是权衡之下的首选…","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"潜山--皖国古都&&安徽之源","date":"2018-08-12T15:22:51.000Z","path":"2018/08/12/潜山-皖国古都-安徽之源/","text":"撤县设市 安徽潜山撤县设市，该县以西部天柱山闻名。天柱山为安徽11个5A景区之一，与黄山九华山并称安徽三大名山，又称潜山，皖山，安徽简称即由此来。地处安徽省西南部，濒临长江黄金水道。是皖、鄂、赣三省通衢之地。素有“皖国古都、二乔故里、安徽之源、禅宗之地、京剧之祖、黄梅之乡”的美誉，是安徽省历史文化名城，是京剧的发源地、长篇叙事诗《孔雀东南飞》故事的发生地，是三国佳丽大乔、小乔的生长地，自东汉至南宋先后为州、郡、府治所近800年。 初知天柱山，自是因为李白。渔阳鼙鼓动地，安史之乱爆发，潜心老庄飘逸的青莲居士于此炼丹。此刻避居四川的李隆基，已年过70，夜雨闻铃，感念马嵬坡下土一抔，只遣词造句，而无实权和心力。名动天下的李白此时抱负尚未全死，受玄宗第16子永王李璘集团相邀，政治觉悟薄弱而名动天下的他，就这样成为一支并不合法的军队幕僚。一曲&lt;永王东巡歌&gt;，成为其获罪之源。 继承大统的是玄宗第三子李亨，他于安史之乱次年继位，是为肃宗。年轻李白11岁的老杜，心怀社稷，安顿家人一路西去天水追随朝廷，却中途被俘。幸因位卑而无杀身，只被困居长安。诗人不幸诗家幸，百感之中，能排古往今来五言律诗前三的&lt;春望&gt;，和这个好男人最美情诗的&lt;月夜&gt;先后应运而出。为其作品赢得“诗史”称号的三吏三别，也出自这一时刻。 李璘自幼失母，由其异母兄李亨亲自抚养。李亨常将其抱在怀中同睡。情同手足兄弟，可怜生在皇家。安史之乱尚未结束，肃宗和永王便开始兵戎相向。经那个边塞诗人高适谋段手腕，最终使李璘于今江西大余兵败身死。李白遭流放，刺配夜郎，也渐和原本关系不错的高适不再来往。 李白扬名长安时，曾救一正直而被诬陷的小官免遭断头。20多载后，昔日险作刀下鬼，今时却是抗击安史叛军，拱卫李唐皇祚的擎天白玉柱。他是郭子仪，大概是继程咬金后，有唐一代最知名的福将，权倾朝野朝不忌，功盖一代主不疑。 昔日恩人遭难，郭以官位身家为注，赎李白不死。而后又逢肃宗大赦，李白得以离开川贵一带，沿江东下。在他生命的倒数第三年，已在世上潇洒忐忑走一遭，心境再不是年少出川时的“山随平野尽，江入大荒流”，转而是“两岸猿声啼不住，轻舟已过万重山”。 年幼之时便识，却不解其意，直到读800多年后“天际立法者”，普鲁士人开普勒传记，“我已盗得埃及的金瓶，并已远离埃及国土，木已成舟，瓜熟蒂落”。摆脱劫难之以手抚膺额冠相庆，大抵相似。 在恢复自由之身3年后，已近安史之乱尾声，李白在长江边的安徽马鞍山当涂县，醉酒失足，“上天捉月”溺水而亡（亦说病重而去，此说法可能性更高，时人及后人多希望谪仙人死法亦不同凡人）。 在李白遇赦写下&lt;早发白帝城&gt;这一年，虽然跟对了人，但仍仕途不顺生活无着的老杜，携妻带子举家南下入蜀。说来也是，自司马相如和扬雄起便是中国文学高地，后来又孕育李白和三苏的川蜀，怎么能少了这位最伟大现实主义诗人的浓墨重彩。四年时间，240首诗多有珠玉，甚至1300多年后，一文化水平并不高的浙江商人，在给其建筑公司取名时，依然想到“安得广厦千万间”，但他并没有老杜这样的情怀，几年前曾因官商勾兑被查。 谪仙逝世几个月后，公元763年春，叛军内斗，史思明自缢，安史之乱比预期提早结束了。“剑外忽传收蓟北，初闻涕泪满衣裳”，一向以儒士示人正襟危坐的老杜，喜不自胜，手舞足蹈。 但出川后的杜甫境况也没有好很多，但国家看上去复兴有望，还是老骥伏枥。我实在想象不出，力道千钧的&lt;登岳阳楼&gt;，竟然是这个贫病交加际遇坎坷的“老人”最后的绝唱。 音讯阻隔，他当时大抵是不知道，那个洒脱不羁的李十二郎，已经不在人世了。一生困顿，最后客死在湘江一条小船上的他，更不会想到，当年和李白洛阳相见，竟被后人盛称，是自春秋时儒道两派宗师碰面后，中国文化史上最伟大的相遇。 这个比喻贴切之处，除去四人在中国文化史上地位鲜有人及，还在于一种传承和碰撞，二人可认做儒道两家在唐代的代言人。 姊妹篇: 起承转合–由陈子昂&lt;国殇&gt; 姊妹篇: 盛唐之殇–观&lt;长安十二时辰&gt;记","tags":[{"name":"区域经济","slug":"区域经济","permalink":"http://www.dashen.tech/tags/区域经济/"}]},{"title":"<从零开始学架构>读书笔记","date":"2018-08-10T14:08:43.000Z","path":"2018/08/10/从零开始学结构-读书笔记/","text":"name 111 222 333 444 aaa bbsfsdfsfasdab ccc ddd eee fff ggg hhh iii 000","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"<代码整洁之道>书摘","date":"2018-08-10T14:08:08.000Z","path":"2018/08/10/代码整洁之道-书摘/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"为何MongoDB使用B树作索引","date":"2018-07-26T06:14:26.000Z","path":"2018/07/26/为何MongoDB使用B树作索引/","text":"B树和B+树的区别https://www.cnblogs.com/xueqiuqiu/articles/8779029.html 非叶子节点不存储数据，非叶子节点之间双向链表两两相连 B树的结构是data和关键字都存储在一个节点上，所以检索到目标对象，直接返回即可，而B+树只存key，这样检索命中以后还会继续往下走，直到取到目标所对应的叶子结点上所存储的data才会返回 https://www.cnblogs.com/rjzheng/p/12316685.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"golang之string类型变量操作的原子性","date":"2018-07-19T13:22:20.000Z","path":"2018/07/19/golang之string类型变量操作的原子性/","text":"在并发场景下，string跟map一样，都是需要使用atomic包/sync包来保证读写的原子性。 str_atom.go: 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\" \"time\")var a = \"0\"func main() &#123; ch := make(chan string) go func() &#123; i := 1 for &#123; if i%2 == 0 &#123; a = \"0\" &#125; else &#123; a = \"aa\" &#125; // 如果将sleep去掉，则会读不到脏数据，原因在于编译器做了优化 time.Sleep(1 * time.Millisecond) i++ &#125; &#125;() go func() &#123; for &#123; b := a if b != \"0\" &amp;&amp; b != \"aa\" &#123; ch &lt;- b &#125; &#125; &#125;() for i := 0; i &lt; 10; i++ &#123; fmt.Println(\"Got strange string: \", &lt;-ch) &#125;&#125; 按预期, ch 不可能被写入,因为 b 的值只可能是 “0” 或 “aa”. 但实际运行: (即起两个协程,一个不停对a重新赋值,另一个选出a的值不为”0”或”aa”的,存入一个channel,并打印. 当有10次不为”0”或”aa”后,结束打印,程序运行完成) 12345678910Got strange string: 05Got strange string: aGot strange string: aGot strange string: 05Got strange string: 05Got strange string: aGot strange string: aGot strange string: aGot strange string: aGot strange string: a 在Linux上输出为05,在Mac上05会输出为0: b的值为什么会存在 “a”或者”05”(or”0:”)的情况 ?? 这是因为,string类型并不是并发安全的. string的内部结构： 1234struct &#123; str uintptr len int &#125; 对 string 赋值,并不是原子操作,而是会分为两步,(其实是对上面这个struct ，Go 无法保证原子性地完成赋值) 因此可能会出现 goroutine 1 刚修改完指针（str）、还没来得及修改长度（len），goroutine 2 就读取了这个string 的情况。 str 改了、len 还没来得及改,即 str=&quot;aa&quot;,len=1, 和str=&quot;0&quot;,len=2, 对应”莫名其妙”出现的 “a”和”05”（或”0:”） 1234567891011func main() &#123; var str string = \"0\" p := (*struct &#123; str uintptr len int &#125;)(unsafe.Pointer(&amp;str)) spew.Dump(p)&#125; 输出: 1234(*struct &#123; str uintptr; len int &#125;)(0xc00008e2b0)(&#123; str: (uintptr) 0x1101b01, len: (int) 1&#125;) 思考: str=&quot;aa&quot;,len=1,变为”a”容易理解,但str=&quot;0&quot;,len=2为什么会是”05”(or“0:”)呢? go tool compile -S -S str_atom.go 得到汇编代码：（go 1.17,arm64） 也可将源码复制到该网站，在线查看汇编 go tool compile -S -S str_atom.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438\"\".main&lt;1&gt; STEXT size=304 args=0x0 locals=0x88 funcid=0x0 0x0000 00000 (str_atom.go:10) TEXT \"\".main(SB), ABIInternal, $144-0 0x0000 00000 (str_atom.go:10) MOVD 16(g), R1 0x0004 00004 (str_atom.go:10) PCDATA $0, $-2 0x0004 00004 (str_atom.go:10) SUB $16, RSP, R2 0x0008 00008 (str_atom.go:10) CMP R1, R2 0x000c 00012 (str_atom.go:10) BLS 288 0x0010 00016 (str_atom.go:10) PCDATA $0, $-1 0x0010 00016 (str_atom.go:10) MOVD.W R30, -144(RSP) 0x0014 00020 (str_atom.go:10) MOVD R29, -8(RSP) 0x0018 00024 (str_atom.go:10) SUB $8, RSP, R29 0x001c 00028 (str_atom.go:10) FUNCDATA ZR, gclocals·7d2d5fca80364273fb07d5820a76fef4(SB) 0x001c 00028 (str_atom.go:10) FUNCDATA $1, gclocals·1373f50311b358236be33e875131d17d(SB) 0x001c 00028 (str_atom.go:10) FUNCDATA $2, \"\".main.stkobj(SB) 0x001c 00028 (str_atom.go:12) MOVD $type.chan string(SB), R0 0x0024 00036 (str_atom.go:12) MOVD R0, 8(RSP) 0x0028 00040 (str_atom.go:12) MOVD ZR, 16(RSP) 0x002c 00044 (str_atom.go:12) PCDATA $1, ZR 0x002c 00044 (str_atom.go:12) CALL runtime.makechan(SB) 0x0030 00048 (str_atom.go:12) MOVD 24(RSP), R0 0x0034 00052 (str_atom.go:12) MOVD R0, \"\".ch-56(SP) 0x0038 00056 (str_atom.go:14) MOVW ZR, 8(RSP) 0x003c 00060 (str_atom.go:14) MOVD $\"\".main.func1·f(SB), R1 0x0044 00068 (str_atom.go:14) MOVD R1, 16(RSP) 0x0048 00072 (str_atom.go:14) PCDATA $1, $1 0x0048 00072 (str_atom.go:14) CALL runtime.newproc(SB) 0x004c 00076 (str_atom.go:30) MOVD $8, R0 0x0050 00080 (str_atom.go:30) MOVW R0, 8(RSP) 0x0054 00084 (str_atom.go:30) MOVD $\"\".main.func2·f(SB), R0 0x005c 00092 (str_atom.go:30) MOVD R0, 16(RSP) 0x0060 00096 (str_atom.go:30) MOVD \"\".ch-56(SP), R0 0x0064 00100 (str_atom.go:30) MOVD R0, 24(RSP) 0x0068 00104 (str_atom.go:30) CALL runtime.newproc(SB) 0x006c 00108 (str_atom.go:30) MOVD ZR, R0 0x0070 00112 (str_atom.go:39) JMP 268 0x0074 00116 (str_atom.go:39) MOVD R0, \"\".i-64(SP) 0x0078 00120 (str_atom.go:40) STP (ZR, ZR), \"\"..autotmp_9-48(SP) 0x007c 00124 (str_atom.go:40) MOVD \"\".ch-56(SP), R0 0x0080 00128 (str_atom.go:40) MOVD R0, 8(RSP) 0x0084 00132 (str_atom.go:40) MOVD $\"\"..autotmp_9-48(SP), R1 0x0088 00136 (str_atom.go:40) MOVD R1, 16(RSP) 0x008c 00140 (str_atom.go:40) PCDATA $1, $2 0x008c 00140 (str_atom.go:40) CALL runtime.chanrecv1(SB) 0x0090 00144 (str_atom.go:40) MOVD \"\"..autotmp_9-48(SP), R0 0x0094 00148 (str_atom.go:40) MOVD \"\"..autotmp_9-40(SP), R1 0x0098 00152 (str_atom.go:40) MOVD R0, 8(RSP) 0x009c 00156 (str_atom.go:40) MOVD R1, 16(RSP) 0x00a0 00160 (str_atom.go:40) PCDATA $1, $1 0x00a0 00160 (str_atom.go:40) CALL runtime.convTstring(SB) 0x00a4 00164 (str_atom.go:40) MOVD 24(RSP), R0 0x00a8 00168 (str_atom.go:40) STP (ZR, ZR), \"\"..autotmp_14-32(SP) 0x00ac 00172 (str_atom.go:40) STP (ZR, ZR), \"\"..autotmp_14-16(SP) 0x00b0 00176 (str_atom.go:40) MOVD $type.string(SB), R1 0x00b8 00184 (str_atom.go:40) MOVD R1, \"\"..autotmp_14-32(SP) 0x00bc 00188 (str_atom.go:40) MOVD $\"\"..stmp_0(SB), R2 0x00c4 00196 (str_atom.go:40) MOVD R2, \"\"..autotmp_14-24(SP) 0x00c8 00200 (str_atom.go:40) MOVD R1, \"\"..autotmp_14-16(SP) 0x00cc 00204 (str_atom.go:40) MOVD R0, \"\"..autotmp_14-8(SP) 0x00d0 00208 (&lt;unknown line number&gt;) NOP 0x00d0 00208 (&lt;unknown line number&gt;) PCDATA $0, $-3 0x00d0 00208 (str_atom.go:40) MOVD os.Stdout(SB), R0 0x00dc 00220 (str_atom.go:40) PCDATA $0, $-1 0x00dc 00220 (str_atom.go:40) MOVD $go.itab.*os.File,io.Writer(SB), R3 0x00e4 00228 (str_atom.go:40) MOVD R3, 8(RSP) 0x00e8 00232 (str_atom.go:40) MOVD R0, 16(RSP) 0x00ec 00236 (str_atom.go:40) MOVD $\"\"..autotmp_14-32(SP), R0 0x00f0 00240 (str_atom.go:40) MOVD R0, 24(RSP) 0x00f4 00244 (str_atom.go:40) MOVD $2, R0 0x00f8 00248 (str_atom.go:40) MOVD R0, 32(RSP) 0x00fc 00252 (str_atom.go:40) MOVD R0, 40(RSP) 0x0100 00256 (str_atom.go:40) CALL fmt.Fprintln(SB) 0x0104 00260 (str_atom.go:39) MOVD \"\".i-64(SP), R0 0x0108 00264 (str_atom.go:39) ADD $1, R0, R0 0x010c 00268 (str_atom.go:39) CMP $10, R0 0x0110 00272 (str_atom.go:39) BLT 116 0x0114 00276 (str_atom.go:43) PCDATA $1, $-1 0x0114 00276 (str_atom.go:43) MOVD -8(RSP), R29 0x0118 00280 (str_atom.go:43) MOVD.P 144(RSP), R30 0x011c 00284 (str_atom.go:43) RET (R30) 0x0120 00288 (str_atom.go:43) NOP 0x0120 00288 (str_atom.go:10) PCDATA $1, $-1 0x0120 00288 (str_atom.go:10) PCDATA $0, $-2 0x0120 00288 (str_atom.go:10) MOVD R30, R3 0x0124 00292 (str_atom.go:10) CALL runtime.morestack_noctxt(SB) 0x0128 00296 (str_atom.go:10) PCDATA $0, $-1 0x0128 00296 (str_atom.go:10) JMP 0 0x0000 81 0b 40 f9 e2 43 00 d1 5f 00 01 eb a9 08 00 54 ..@..C.._......T 0x0010 fe 0f 17 f8 fd 83 1f f8 fd 23 00 d1 00 00 00 90 .........#...... 0x0020 00 00 00 91 e0 07 00 f9 ff 0b 00 f9 00 00 00 94 ................ 0x0030 e0 0f 40 f9 e0 2b 00 f9 ff 0b 00 b9 01 00 00 90 ..@..+.......... 0x0040 21 00 00 91 e1 0b 00 f9 00 00 00 94 e0 03 7d b2 !.............&#125;. 0x0050 e0 0b 00 b9 00 00 00 90 00 00 00 91 e0 0b 00 f9 ................ 0x0060 e0 2b 40 f9 e0 0f 00 f9 00 00 00 94 00 00 80 d2 .+@............. 0x0070 27 00 00 14 e0 27 00 f9 ff ff 05 a9 e0 2b 40 f9 '....'.......+@. 0x0080 e0 07 00 f9 e1 63 01 91 e1 0b 00 f9 00 00 00 94 .....c.......... 0x0090 e0 2f 40 f9 e1 33 40 f9 e0 07 00 f9 e1 0b 00 f9 ./@..3@......... 0x00a0 00 00 00 94 e0 0f 40 f9 ff ff 06 a9 ff ff 07 a9 ......@......... 0x00b0 01 00 00 90 21 00 00 91 e1 37 00 f9 02 00 00 90 ....!....7...... 0x00c0 42 00 00 91 e2 3b 00 f9 e1 3f 00 f9 e0 43 00 f9 B....;...?...C.. 0x00d0 1b 00 00 90 7b 03 00 91 60 03 40 f9 03 00 00 90 ....&#123;...`.@..... 0x00e0 63 00 00 91 e3 07 00 f9 e0 0b 00 f9 e0 a3 01 91 c............... 0x00f0 e0 0f 00 f9 e0 03 7f b2 e0 13 00 f9 e0 17 00 f9 ................ 0x0100 00 00 00 94 e0 27 40 f9 00 04 00 91 1f 28 00 f1 .....'@......(.. 0x0110 2b fb ff 54 fd 83 5f f8 fe 07 49 f8 c0 03 5f d6 +..T.._...I..._. 0x0120 e3 03 1e aa 00 00 00 94 b6 ff ff 17 00 00 00 00 ................ rel 0+0 t=24 type.string&lt;0&gt;+0 rel 0+0 t=24 type.string&lt;0&gt;+0 rel 0+0 t=24 type.*os.File&lt;0&gt;+0 rel 28+8 t=3 type.chan string&lt;0&gt;+0 rel 44+4 t=9 runtime.makechan&lt;1&gt;+0 rel 60+8 t=3 \"\".main.func1·f&lt;0&gt;+0 rel 72+4 t=9 runtime.newproc&lt;1&gt;+0 rel 84+8 t=3 \"\".main.func2·f&lt;0&gt;+0 rel 104+4 t=9 runtime.newproc&lt;1&gt;+0 rel 140+4 t=9 runtime.chanrecv1&lt;1&gt;+0 rel 160+4 t=9 runtime.convTstring&lt;1&gt;+0 rel 176+8 t=3 type.string&lt;0&gt;+0 rel 188+8 t=3 \"\"..stmp_0&lt;0&gt;+0 rel 208+8 t=3 os.Stdout&lt;0&gt;+0 rel 220+8 t=3 go.itab.*os.File,io.Writer&lt;0&gt;+0 rel 256+4 t=9 fmt.Fprintln&lt;1&gt;+0 rel 292+4 t=9 runtime.morestack_noctxt&lt;0&gt;+0\"\".main.func2&lt;1&gt; STEXT size=144 args=0x8 locals=0x28 funcid=0x0 0x0000 00000 (str_atom.go:30) TEXT \"\".main.func2(SB), ABIInternal, $48-8 0x0000 00000 (str_atom.go:30) MOVD 16(g), R1 0x0004 00004 (str_atom.go:30) PCDATA $0, $-2 0x0004 00004 (str_atom.go:30) MOVD RSP, R2 0x0008 00008 (str_atom.go:30) CMP R1, R2 0x000c 00012 (str_atom.go:30) BLS 128 0x0010 00016 (str_atom.go:30) PCDATA $0, $-1 0x0010 00016 (str_atom.go:30) MOVD.W R30, -48(RSP) 0x0014 00020 (str_atom.go:30) MOVD R29, -8(RSP) 0x0018 00024 (str_atom.go:30) SUB $8, RSP, R29 0x001c 00028 (str_atom.go:30) FUNCDATA ZR, gclocals·1a65e721a2ccc325b382662e7ffee780(SB) 0x001c 00028 (str_atom.go:30) FUNCDATA $1, gclocals·2589ca35330fc0fce83503f4569854a0(SB) 0x001c 00028 (str_atom.go:30) FUNCDATA $2, \"\".main.func2.stkobj(SB) 0x001c 00028 (str_atom.go:30) FUNCDATA $5, \"\".main.func2.arginfo1(SB) 0x001c 00028 (str_atom.go:30) PCDATA $0, $-3 0x001c 00028 (str_atom.go:32) MOVD \"\".a(SB), R0 0x0028 00040 (str_atom.go:32) PCDATA $0, $-4 0x0028 00040 (str_atom.go:32) MOVD \"\".a+8(SB), R1 0x0034 00052 (str_atom.go:32) PCDATA $0, $-1 0x0034 00052 (str_atom.go:33) CMP $1, R1 0x0038 00056 (str_atom.go:33) BNE 72 0x003c 00060 (str_atom.go:33) MOVBU (R0), R2 0x0040 00064 (str_atom.go:33) CMPW $206158430256, R2 0x0044 00068 (str_atom.go:33) BEQ 28 0x0048 00072 (str_atom.go:33) CMP $2, R1 0x004c 00076 (str_atom.go:33) BNE 96 0x0050 00080 (str_atom.go:33) MOVHU (R0), R2 0x0054 00084 (str_atom.go:33) PCDATA $0, $-3 0x0054 00084 (str_atom.go:33) CMPW $107069239746913, R2 0x005c 00092 (str_atom.go:33) PCDATA $0, $-1 0x005c 00092 (str_atom.go:33) BEQ 28 0x0060 00096 (str_atom.go:34) MOVD R0, \"\"..autotmp_3-16(SP) 0x0064 00100 (str_atom.go:34) MOVD R1, \"\"..autotmp_3-8(SP) 0x0068 00104 (str_atom.go:34) MOVD \"\".ch(FP), R0 0x006c 00108 (str_atom.go:34) MOVD R0, 8(RSP) 0x0070 00112 (str_atom.go:34) MOVD $\"\"..autotmp_3-16(SP), R1 0x0074 00116 (str_atom.go:34) MOVD R1, 16(RSP) 0x0078 00120 (str_atom.go:34) PCDATA $1, ZR 0x0078 00120 (str_atom.go:34) CALL runtime.chansend1(SB) 0x007c 00124 (str_atom.go:34) JMP 28 0x0080 00128 (str_atom.go:34) NOP 0x0080 00128 (str_atom.go:30) PCDATA $1, $-1 0x0080 00128 (str_atom.go:30) PCDATA $0, $-2 0x0080 00128 (str_atom.go:30) MOVD R30, R3 0x0084 00132 (str_atom.go:30) CALL runtime.morestack_noctxt(SB) 0x0088 00136 (str_atom.go:30) PCDATA $0, $-1 0x0088 00136 (str_atom.go:30) JMP 0 0x0000 81 0b 40 f9 e2 03 00 91 5f 00 01 eb a9 03 00 54 ..@....._......T 0x0010 fe 0f 1d f8 fd 83 1f f8 fd 23 00 d1 1b 00 00 90 .........#...... 0x0020 7b 03 00 91 60 03 40 f9 1b 00 00 90 7b 03 00 91 &#123;...`.@.....&#123;... 0x0030 61 03 40 f9 3f 04 00 f1 81 00 00 54 02 00 40 39 a.@.?......T..@9 0x0040 5f c0 00 71 c0 fe ff 54 3f 08 00 f1 a1 00 00 54 _..q...T?......T 0x0050 02 00 40 79 3b 2c 8c 52 5f 00 1b 6b 00 fe ff 54 ..@y;,.R_..k...T 0x0060 e0 0f 00 f9 e1 13 00 f9 e0 1f 40 f9 e0 07 00 f9 ..........@..... 0x0070 e1 63 00 91 e1 0b 00 f9 00 00 00 94 e8 ff ff 17 .c.............. 0x0080 e3 03 1e aa 00 00 00 94 de ff ff 17 00 00 00 00 ................ rel 28+8 t=3 \"\".a&lt;0&gt;+0 rel 40+8 t=3 \"\".a&lt;0&gt;+8 rel 120+4 t=9 runtime.chansend1&lt;1&gt;+0 rel 132+4 t=9 runtime.morestack_noctxt&lt;0&gt;+0\"\".main.func1&lt;1&gt; STEXT size=240 args=0x0 locals=0x18 funcid=0x0 0x0000 00000 (str_atom.go:14) TEXT \"\".main.func1(SB), ABIInternal, $32-0 0x0000 00000 (str_atom.go:14) MOVD 16(g), R1 0x0004 00004 (str_atom.go:14) PCDATA $0, $-2 0x0004 00004 (str_atom.go:14) MOVD RSP, R2 0x0008 00008 (str_atom.go:14) CMP R1, R2 0x000c 00012 (str_atom.go:14) BLS 228 0x0010 00016 (str_atom.go:14) PCDATA $0, $-1 0x0010 00016 (str_atom.go:14) MOVD.W R30, -32(RSP) 0x0014 00020 (str_atom.go:14) MOVD R29, -8(RSP) 0x0018 00024 (str_atom.go:14) SUB $8, RSP, R29 0x001c 00028 (str_atom.go:14) FUNCDATA ZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x001c 00028 (str_atom.go:14) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x001c 00028 (str_atom.go:14) MOVD $1, R0 0x0020 00032 (str_atom.go:17) JMP 60 0x0024 00036 (str_atom.go:25) MOVD $1000000, R0 0x002c 00044 (str_atom.go:25) MOVD R0, 8(RSP) 0x0030 00048 (str_atom.go:25) PCDATA $1, ZR 0x0030 00048 (str_atom.go:25) CALL time.Sleep(SB) 0x0034 00052 (str_atom.go:26) MOVD \"\".i-8(SP), R0 0x0038 00056 (str_atom.go:26) ADD $1, R0, R0 0x003c 00060 (str_atom.go:19) MOVD R0, \"\".i-8(SP) 0x0040 00064 (str_atom.go:19) TBNZ ZR, R0, 148 0x0044 00068 (str_atom.go:20) MOVD $1, R1 0x0048 00072 (str_atom.go:20) PCDATA $0, $-3 0x0048 00072 (str_atom.go:20) MOVD R1, \"\".a+8(SB) 0x0054 00084 (str_atom.go:20) PCDATA $0, $-1 0x0054 00084 (str_atom.go:20) PCDATA ZR, $-2 0x0054 00084 (str_atom.go:20) MOVWU runtime.writeBarrier(SB), R4 0x0060 00096 (str_atom.go:20) CBNZW R4, 124 0x0064 00100 (str_atom.go:20) MOVD $go.string.\"0\"(SB), R2 0x006c 00108 (str_atom.go:20) MOVD R2, \"\".a(SB) 0x0078 00120 (str_atom.go:20) JMP 36 0x007c 00124 (str_atom.go:20) MOVD $\"\".a(SB), R2 0x0084 00132 (str_atom.go:20) MOVD $go.string.\"0\"(SB), R3 0x008c 00140 (str_atom.go:20) CALL runtime.gcWriteBarrier(SB) 0x0090 00144 (str_atom.go:20) JMP 36 0x0094 00148 (str_atom.go:22) PCDATA ZR, $-1 0x0094 00148 (str_atom.go:22) MOVD $2, R1 0x0098 00152 (str_atom.go:22) PCDATA $0, $-4 0x0098 00152 (str_atom.go:22) MOVD R1, \"\".a+8(SB) 0x00a4 00164 (str_atom.go:22) PCDATA $0, $-1 0x00a4 00164 (str_atom.go:22) PCDATA ZR, $-2 0x00a4 00164 (str_atom.go:22) MOVWU runtime.writeBarrier(SB), R4 0x00b0 00176 (str_atom.go:22) CBNZW R4, 204 0x00b4 00180 (str_atom.go:22) MOVD $go.string.\"aa\"(SB), R2 0x00bc 00188 (str_atom.go:22) MOVD R2, \"\".a(SB) 0x00c8 00200 (str_atom.go:22) JMP 36 0x00cc 00204 (str_atom.go:22) MOVD $\"\".a(SB), R2 0x00d4 00212 (str_atom.go:22) MOVD $go.string.\"aa\"(SB), R3 0x00dc 00220 (str_atom.go:22) CALL runtime.gcWriteBarrier(SB) 0x00e0 00224 (str_atom.go:22) JMP 36 0x00e4 00228 (str_atom.go:22) NOP 0x00e4 00228 (str_atom.go:14) PCDATA $1, $-1 0x00e4 00228 (str_atom.go:14) PCDATA $0, $-2 0x00e4 00228 (str_atom.go:14) MOVD R30, R3 0x00e8 00232 (str_atom.go:14) CALL runtime.morestack_noctxt(SB) 0x00ec 00236 (str_atom.go:14) PCDATA $0, $-1 0x00ec 00236 (str_atom.go:14) JMP 0 0x0000 81 0b 40 f9 e2 03 00 91 5f 00 01 eb c9 06 00 54 ..@....._......T 0x0010 fe 0f 1e f8 fd 83 1f f8 fd 23 00 d1 e0 03 40 b2 .........#....@. 0x0020 07 00 00 14 00 48 88 d2 e0 01 a0 f2 e0 07 00 f9 .....H.......... 0x0030 00 00 00 94 e0 0b 40 f9 00 04 00 91 e0 0b 00 f9 ......@......... 0x0040 a0 02 00 37 e1 03 40 b2 1b 00 00 90 7b 03 00 91 ...7..@.....&#123;... 0x0050 61 03 00 f9 1b 00 00 90 7b 03 00 91 64 03 40 b9 a.......&#123;...d.@. 0x0060 e4 00 00 35 02 00 00 90 42 00 00 91 1b 00 00 90 ...5....B....... 0x0070 7b 03 00 91 62 03 00 f9 eb ff ff 17 02 00 00 90 &#123;...b........... 0x0080 42 00 00 91 03 00 00 90 63 00 00 91 00 00 00 94 B.......c....... 0x0090 e5 ff ff 17 e1 03 7f b2 1b 00 00 90 7b 03 00 91 ............&#123;... 0x00a0 61 03 00 f9 1b 00 00 90 7b 03 00 91 64 03 40 b9 a.......&#123;...d.@. 0x00b0 e4 00 00 35 02 00 00 90 42 00 00 91 1b 00 00 90 ...5....B....... 0x00c0 7b 03 00 91 62 03 00 f9 d7 ff ff 17 02 00 00 90 &#123;...b........... 0x00d0 42 00 00 91 03 00 00 90 63 00 00 91 00 00 00 94 B.......c....... 0x00e0 d1 ff ff 17 e3 03 1e aa 00 00 00 94 c5 ff ff 17 ................ rel 48+4 t=9 time.Sleep&lt;1&gt;+0 rel 72+8 t=3 \"\".a&lt;0&gt;+8 rel 84+8 t=3 runtime.writeBarrier&lt;0&gt;+0 rel 100+8 t=3 go.string.\"0\"&lt;0&gt;+0 rel 108+8 t=3 \"\".a&lt;0&gt;+0 rel 124+8 t=3 \"\".a&lt;0&gt;+0 rel 132+8 t=3 go.string.\"0\"&lt;0&gt;+0 rel 140+4 t=9 runtime.gcWriteBarrier&lt;1&gt;+0 rel 152+8 t=3 \"\".a&lt;0&gt;+8 rel 164+8 t=3 runtime.writeBarrier&lt;0&gt;+0 rel 180+8 t=3 go.string.\"aa\"&lt;0&gt;+0 rel 188+8 t=3 \"\".a&lt;0&gt;+0 rel 204+8 t=3 \"\".a&lt;0&gt;+0 rel 212+8 t=3 go.string.\"aa\"&lt;0&gt;+0 rel 220+4 t=9 runtime.gcWriteBarrier&lt;1&gt;+0 rel 232+4 t=9 runtime.morestack_noctxt&lt;0&gt;+0os.(*File).close&lt;1&gt; STEXT dupok size=32 args=0x18 locals=0x0 funcid=0x0 leaf 0x0000 00000 (&lt;autogenerated&gt;:1) TEXT os.(*File).close(SB), DUPOK|LEAF|NOFRAME|ABIInternal, $0-24 0x0000 00000 (&lt;autogenerated&gt;:1) FUNCDATA ZR, gclocals·e6397a44f8e1b6e77d0f200b4fba5269(SB) 0x0000 00000 (&lt;autogenerated&gt;:1) FUNCDATA $1, gclocals·69c1753bd5f81501d95132d08af04464(SB) 0x0000 00000 (&lt;autogenerated&gt;:1) FUNCDATA $5, os.(*File).close.arginfo1(SB) 0x0000 00000 (&lt;autogenerated&gt;:1) MOVD \"\"..this(FP), R0 0x0004 00004 (&lt;autogenerated&gt;:1) MOVD (R0), R0 0x0008 00008 (&lt;autogenerated&gt;:1) MOVD R0, \"\"..this(FP) 0x000c 00012 (&lt;autogenerated&gt;:1) STP (ZR, ZR), \"\".~r0+8(FP) 0x0010 00016 (&lt;autogenerated&gt;:1) JMP os.(*file).close(SB) 0x0000 e0 07 40 f9 00 00 40 f9 e0 07 00 f9 ff 7f 01 a9 ..@...@......... 0x0010 00 00 00 14 00 00 00 00 00 00 00 00 00 00 00 00 ................ rel 16+4 t=9 os.(*file).close&lt;1&gt;+0go.cuinfo.packagename.&lt;0&gt; SDWARFCUINFO dupok size=0 0x0000 6d 61 69 6e maingo.string.\"0\"&lt;0&gt; SRODATA dupok size=1 0x0000 30 0\"\"..inittask&lt;0&gt; SNOPTRDATA size=40 0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 0x0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 fmt..inittask&lt;0&gt;+0 rel 32+8 t=1 time..inittask&lt;0&gt;+0go.info.fmt.Println$abstract&lt;0&gt; SDWARFABSFCN dupok size=42 0x0000 04 66 6d 74 2e 50 72 69 6e 74 6c 6e 00 01 01 11 .fmt.Println.... 0x0010 61 00 00 00 00 00 00 11 6e 00 01 00 00 00 00 11 a.......n....... 0x0020 65 72 72 00 01 00 00 00 00 00 err....... rel 0+0 t=23 type.[]interface &#123;&#125;&lt;0&gt;+0 rel 0+0 t=23 type.error&lt;0&gt;+0 rel 0+0 t=23 type.int&lt;0&gt;+0 rel 19+4 t=31 go.info.[]interface &#123;&#125;&lt;0&gt;+0 rel 27+4 t=31 go.info.int&lt;0&gt;+0 rel 37+4 t=31 go.info.error&lt;0&gt;+0go.string.\"Got strange string: \"&lt;0&gt; SRODATA dupok size=20 0x0000 47 6f 74 20 73 74 72 61 6e 67 65 20 73 74 72 69 Got strange stri 0x0010 6e 67 3a 20 ng: go.string.\"aa\"&lt;0&gt; SRODATA dupok size=2 0x0000 61 61 aa\"\".a&lt;0&gt; SDATA size=16 0x0000 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ rel 0+8 t=1 go.string.\"0\"&lt;0&gt;+0\"\"..stmp_0&lt;0&gt; SRODATA static size=16 0x0000 00 00 00 00 00 00 00 00 14 00 00 00 00 00 00 00 ................ rel 0+8 t=1 go.string.\"Got strange string: \"&lt;0&gt;+0runtime.nilinterequal·f&lt;0&gt; SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 runtime.nilinterequal&lt;1&gt;+0runtime.memequal64·f&lt;0&gt; SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 runtime.memequal64&lt;1&gt;+0runtime.gcbits.01&lt;0&gt; SRODATA dupok size=1 0x0000 01 .type..namedata.*interface &#123;&#125;-&lt;0&gt; SRODATA dupok size=15 0x0000 00 0d 2a 69 6e 74 65 72 66 61 63 65 20 7b 7d ..*interface &#123;&#125;type.*interface &#123;&#125;&lt;0&gt; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 4f 0f 96 9d 08 08 08 36 00 00 00 00 00 00 00 00 O......6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f&lt;0&gt;+0 rel 32+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*interface &#123;&#125;-&lt;0&gt;+0 rel 48+8 t=1 type.interface &#123;&#125;&lt;0&gt;+0runtime.gcbits.02&lt;0&gt; SRODATA dupok size=1 0x0000 02 .type.interface &#123;&#125;&lt;0&gt; SRODATA dupok size=80 0x0000 10 00 00 00 00 00 00 00 10 00 00 00 00 00 00 00 ................ 0x0010 e7 57 a0 18 02 08 08 14 00 00 00 00 00 00 00 00 .W.............. 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ rel 24+8 t=1 runtime.nilinterequal·f&lt;0&gt;+0 rel 32+8 t=1 runtime.gcbits.02&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*interface &#123;&#125;-&lt;0&gt;+0 rel 44+4 t=-32763 type.*interface &#123;&#125;&lt;0&gt;+0 rel 56+8 t=1 type.interface &#123;&#125;&lt;0&gt;+80type..namedata.*[]interface &#123;&#125;-&lt;0&gt; SRODATA dupok size=17 0x0000 00 0f 2a 5b 5d 69 6e 74 65 72 66 61 63 65 20 7b ..*[]interface &#123; 0x0010 7d &#125;type.*[]interface &#123;&#125;&lt;0&gt; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 f3 04 9a e7 08 08 08 36 00 00 00 00 00 00 00 00 .......6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f&lt;0&gt;+0 rel 32+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*[]interface &#123;&#125;-&lt;0&gt;+0 rel 48+8 t=1 type.[]interface &#123;&#125;&lt;0&gt;+0type.[]interface &#123;&#125;&lt;0&gt; SRODATA dupok size=56 0x0000 18 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 70 93 ea 2f 02 08 08 17 00 00 00 00 00 00 00 00 p../............ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 32+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*[]interface &#123;&#125;-&lt;0&gt;+0 rel 44+4 t=-32763 type.*[]interface &#123;&#125;&lt;0&gt;+0 rel 48+8 t=1 type.interface &#123;&#125;&lt;0&gt;+0type..namedata.*chan string-&lt;0&gt; SRODATA dupok size=14 0x0000 00 0c 2a 63 68 61 6e 20 73 74 72 69 6e 67 ..*chan stringtype.*chan string&lt;0&gt; SRODATA dupok size=56 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 f4 25 61 85 08 08 08 36 00 00 00 00 00 00 00 00 .%a....6........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.memequal64·f&lt;0&gt;+0 rel 32+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*chan string-&lt;0&gt;+0 rel 48+8 t=1 type.chan string&lt;0&gt;+0type.chan string&lt;0&gt; SRODATA dupok size=64 0x0000 08 00 00 00 00 00 00 00 08 00 00 00 00 00 00 00 ................ 0x0010 8d 9e 8b c9 0a 08 08 32 00 00 00 00 00 00 00 00 .......2........ 0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0030 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 ................ rel 24+8 t=1 runtime.memequal64·f&lt;0&gt;+0 rel 32+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 40+4 t=5 type..namedata.*chan string-&lt;0&gt;+0 rel 44+4 t=-32763 type.*chan string&lt;0&gt;+0 rel 48+8 t=1 type.string&lt;0&gt;+0runtime.gcbits.0a&lt;0&gt; SRODATA dupok size=1 0x0000 0a .go.itab.*os.File,io.Writer&lt;0&gt; SRODATA dupok size=32 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 44 b5 f3 33 00 00 00 00 00 00 00 00 00 00 00 00 D..3............ rel 0+8 t=1 type.io.Writer&lt;0&gt;+0 rel 8+8 t=1 type.*os.File&lt;0&gt;+0 rel 24+8 t=-32767 os.(*File).Write&lt;1&gt;+0type..importpath.fmt.&lt;0&gt; SRODATA dupok size=5 0x0000 00 03 66 6d 74 ..fmttype..importpath.time.&lt;0&gt; SRODATA dupok size=6 0x0000 00 04 74 69 6d 65 ..time\"\".main.func1·f&lt;0&gt; SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 \"\".main.func1&lt;1&gt;+0\"\".main.func2·f&lt;0&gt; SRODATA dupok size=8 0x0000 00 00 00 00 00 00 00 00 ........ rel 0+8 t=1 \"\".main.func2&lt;1&gt;+0gclocals·7d2d5fca80364273fb07d5820a76fef4&lt;0&gt; SRODATA dupok size=8 0x0000 03 00 00 00 00 00 00 00 ........gclocals·1373f50311b358236be33e875131d17d&lt;0&gt; SRODATA dupok size=11 0x0000 03 00 00 00 07 00 00 00 00 01 03 ...........\"\".main.stkobj&lt;0&gt; SRODATA static size=56 0x0000 02 00 00 00 00 00 00 00 d0 ff ff ff 10 00 00 00 ................ 0x0010 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0020 e0 ff ff ff 20 00 00 00 20 00 00 00 00 00 00 00 .... ... ....... 0x0030 00 00 00 00 00 00 00 00 ........ rel 24+8 t=1 runtime.gcbits.01&lt;0&gt;+0 rel 48+8 t=1 runtime.gcbits.0a&lt;0&gt;+0gclocals·1a65e721a2ccc325b382662e7ffee780&lt;0&gt; SRODATA dupok size=10 0x0000 02 00 00 00 01 00 00 00 01 00 ..........gclocals·2589ca35330fc0fce83503f4569854a0&lt;0&gt; SRODATA dupok size=10 0x0000 02 00 00 00 02 00 00 00 00 00 ..........\"\".main.func2.stkobj&lt;0&gt; SRODATA static size=32 0x0000 01 00 00 00 00 00 00 00 f0 ff ff ff 10 00 00 00 ................ 0x0010 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ rel 24+8 t=1 runtime.gcbits.01&lt;0&gt;+0\"\".main.func2.arginfo1&lt;0&gt; SRODATA static dupok size=3 0x0000 00 08 ff ...gclocals·33cdeccccebe80329f1fdbee7f5874cb&lt;0&gt; SRODATA dupok size=8 0x0000 01 00 00 00 00 00 00 00 ........gclocals·e6397a44f8e1b6e77d0f200b4fba5269&lt;0&gt; SRODATA dupok size=10 0x0000 02 00 00 00 03 00 00 00 01 00 ..........gclocals·69c1753bd5f81501d95132d08af04464&lt;0&gt; SRODATA dupok size=8 0x0000 02 00 00 00 00 00 00 00 ........os.(*File).close.arginfo1&lt;0&gt; SRODATA static dupok size=3 0x0000 00 08 ff ... 参考: Golang string变量操作的原子性 go 字符串string的并发读写的一个坑 golang: 常用数据类型底层结构分析 你不知道的 Go 之 string 更多相关: golang 中 int加一是原子性吗 golang int并发安全 atom 姊妹篇: golang之map并发访问 golang之slice并发访问 str=&quot;aa&quot;,len=1,变为”a”容易理解,但str=&quot;0&quot;,len=2为什么会是”05”呢? string在底层的存储方式如下： 1234type StringHeader struct &#123; Data uintptr // 内容的指针地址 Len int // 长度&#125; 在上面的并发读写过程中，即发生了 123456789s1 := StringHeader&#123; Data: `指向\"aa\"的那个内存地址，记为x`, Len: 1,&#125;s2 := StringHeader&#123; Data: `指向\"0\"的那个内存地址，记为y`, Len: 2,&#125; 可以打印出y的内容，就一目了然了 先看如下例子： 12345678910111213141516171819202122232425262728293031package mainimport ( \"encoding/hex\" \"fmt\" \"strings\" \"unsafe\")func main() &#123; demoStr := \"abcdefghijklmnop1234567887654321\" dump(\"demoStr\", &amp;demoStr)&#125;func dump(name string, strPtr *string) &#123; // 分隔符 fmt.Println(strings.Repeat(\"-\", 30)) // 打印strPtr这个指针类型的变量的内存地址 fmt.Printf(\"&amp;%s:%p\\n\", name, strPtr) // 强制转换为16字节的byte数组 （*[0x10]byte)(unsafe.Pointer(strPtr)），是个指针类型。再用*取指针内容； 然后将数组转为切片，[:] fmt.Println(hex.Dump((*(*[0x10]byte)(unsafe.Pointer(strPtr)))[:])) // 获取上面这个指针所指向的内存地址 p := *(*int)(unsafe.Pointer(strPtr)) // 当成int型(需要C经验更好理解) fmt.Printf(\"%s:0x%x\\n\", name, p) fmt.Println(hex.Dump((*(*[0x20]byte)(unsafe.Pointer(uintptr(p))))[:]))&#125; 输出为: 1234567------------------------------&amp;demoStr:0x1400001024000000000 82 34 ea 00 01 00 00 00 20 00 00 00 00 00 00 00 |.4...... .......|demoStr:0x100ea348200000000 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 |abcdefghijklmnop|00000010 31 32 33 34 35 36 37 38 38 37 36 35 34 33 32 31 |1234567887654321| （内存地址对应的内容也是16进制格式） 比对ASCII码表， 可以看出一一对应 而对于”0”: 12345678910111213141516171819202122232425262728293031package mainimport ( \"encoding/hex\" \"fmt\" \"strings\" \"unsafe\")func main() &#123; demoStr := \"0\" dump(\"demoStr\", &amp;demoStr)&#125;func dump(name string, strPtr *string) &#123; // 分隔符 fmt.Println(strings.Repeat(\"-\", 30)) // 打印strPtr这个指针类型的变量的内存地址 fmt.Printf(\"&amp;%s:%p\\n\", name, strPtr) // 强制转换为16字节的byte数组 （*[0x10]byte)(unsafe.Pointer(strPtr)），是个指针类型。再用*取指针内容； 然后将数组转为切片，[:] fmt.Println(hex.Dump((*(*[0x10]byte)(unsafe.Pointer(strPtr)))[:])) // 获取上面这个指针所指向的内存地址 p := *(*int)(unsafe.Pointer(strPtr)) // 当成int型(需要C经验更好理解) fmt.Printf(\"%s:0x%x\\n\", name, p) fmt.Println(hex.Dump((*(*[0x20]byte)(unsafe.Pointer(uintptr(p))))[:]))&#125; 输出： 1234567------------------------------&amp;demoStr:0x1400011006000000000 a7 a6 d1 02 01 00 00 00 01 00 00 00 00 00 00 00 |................|demoStr:0x102d1a6a700000000 30 3a 3c 3d 3e 43 4c 4d 50 53 55 5a 5b 5d 5f 60 |0:&lt;=&gt;CLMPSUZ[]_`|00000010 68 6d 73 7b 7d 20 2b 20 40 20 50 20 5b 25 21 28 |hms&#123;&#125; + @ P [%!(| 可以看出，当长度为2，但实际存的内容为1时是咋填充的 在该场景下，对于Mac，会填充为0x3a，即对应: 对于Linux，则会填充0x35,即对应5","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"解决Hash冲突的几种方法","date":"2018-07-18T11:02:30.000Z","path":"2018/07/18/解决Hash冲突的几种方法/","text":"开放定址法(开放地址法) 一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 再哈希法(双哈希法) 有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。 链表法 (链地址法, 拉链法) 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来..最后就像一个拉链 建立公共溢出区 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Protobuf入门","date":"2018-07-16T14:03:13.000Z","path":"2018/07/16/Protobuf入门/","text":"字段格式：限定修饰符① | 数据类型② | 字段名称③ | = | 字段编码值④ | [字段默认值⑤] ①．限定修饰符包含 required\\optional\\repeated Required: 表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃。 Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。 Repeated：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值。 ②．数据类型 Protobuf定义了一套基本数据类型。几乎都可以映射到C++\\Java等语言的基础数据类型. 例如int32，如果数值比较小，在0~127时，使用一个字节打包。N 表示打包的字节并不是固定。而是根据数据的大小或者长度。 关于枚举的打包方式和uint32相同。 关于message，类似于C语言中的结构包含另外一个结构作为数据成员一样。 关于 fixed32 和int32的区别。fixed32的打包效率比int32的效率高，但是使用的空间一般比int32多。因此一个属于时间效率高，一个属于空间效率高。根据项目的实际情况，一般选择fixed32，如果遇到对传输数据量要求比较苛刻的环境，可以选择int32. ③．字段名称 字段名称的命名与C、C++、Java等语言的变量命名方式几乎是相同的。 protobuf建议字段的命名采用以下划线分割的驼峰式。例如 first_name 而不是firstName. ④．字段编码值 有了该值，通信双方才能互相识别对方的字段。当然相同的编码值，其限定修饰符和数据类型必须相同。 编码值的取值范围为 1~2^32（4294967296）。 其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于1-15），当然一般情况下相邻的2个值编码效率的是相同的，除非2个值恰好实在4字节，12字节，20字节等的临界区。比如15和16. 1900~2000编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用。 protobuf 还建议把经常要传递的值把其字段编码设置为1-15之间的值。 消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值。 建议：项目投入运营以后涉及到版本升级时的新增消息字段全部使用optional或者repeated，尽量不实用required。如果使用了required，需要全网统一升级，如果使用optional或者repeated可以平滑升级。 ⑤．默认值。当在传递数据时，对于required数据类型，如果用户没有设置值，则使用默认值传递到对端。当接受数据是，对于optional字段，如果没有接收到optional字段，则设置为默认值。 关于import protobuf 接口文件可以像C语言的h文件一个，分离为多个，在需要的时候通过 import导入需要对文件。其行为和C语言的#include或者java的import的行为大致相同。 关于package 避免名称冲突，可以给每个文件指定一个package名称，对于java解析为java中的包。对于C++则解析为名称空间。 关于message 支持嵌套消息，消息可以包含另一个消息作为其字段。也可以在消息内定义一个新的消息。 关于enum 枚举的定义和C++相同，但是有一些限制。 枚举值必须大于等于0的整数。 使用分号(;)分隔枚举变量而不是C++语言中的逗号(,) eg. enum VoipProtocol { H323 = 1; SIP = 2; MGCP = 3; H248 = 4; } l 生成访问类 可以通过定义好的.proto文件来生成Java、Python、C++代码，需要基于.proto文件运行protocol buffer编译器protoc。运行的命令如下所示： protoc –proto_path=IMPORT_PATH –cpp_out=DST_DIR –java_out=DST_DIR –python_out=DST_DIR path/to/file.proto · IMPORT_PATH声明了一个.proto文件所在的具体目录。如果忽略该值，则使用当前目录。如果有多个目录则可以 对–proto_path 写多次，它们将会顺序的被访问并执行导入。-I=IMPORT_PATH是它的简化形式。 · 当然也可以提供一个或多个输出路径： o –cpp_out 在目标目录DST_DIR中产生C++代码，可以在 http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference /cpp-generated.html中查看更多。 o –java_out 在目标目录DST_DIR中产生Java代码，可以在 http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/reference /java-generated.html中查看更多。 o –python_out 在目标目录 DST_DIR 中产生Python代码，可以在http://code.google.com/intl/zh-CN/apis/protocolbuffers /docs/reference/python-generated.html中查看更多。 更多参考: Protobuf 终极教程","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"使用bitset","date":"2018-07-08T12:14:35.000Z","path":"2018/07/08/使用bitset/","text":"面试常见问题： 对有50亿整数的大文件，怎么排？(文件大小超过了机器内存) (假设数字都不大，在0-64之间) 概念 biset 有时也会被叫做 Bitmap，译作 位图，也称栅格图或点阵图 https://blog.cyeam.com/golang/2017/01/18/go-optimize-bitset https://blog.csdn.net/qmqm011/article/details/104442187 https://www.baidu.com/s?tn=50000021_hao_pg&amp;ie=utf-8&amp;sc=UWd1pgw-pA7EnHc1FMfqnHmzP1fYPWnYnHn1PiuW5y99U1Dznzu9m1Y1PjfLnWT3rj0v&amp;ssl_sample=normal&amp;srcqid=5502503891774932676&amp;H123Tmp=nunew7&amp;word=%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F 使用对包含50亿整数的大文件排序的其他办法 5亿整数的大文件，怎么排？ 中，使用内部(存)排序，如果文件足够大，是不可行的~需使用外部排序 但可以借鉴归并排序的分治思想，把大文件切成多个小文件，对小文件排好序后，再进行合并 Github 中的对象清点算法阮一峰-Github 的清点对象算法 ###","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"使用Cantor pair","date":"2018-07-08T02:15:47.000Z","path":"2018/07/08/使用Cantor-pair/","text":"https://blog.cyeam.com/golang/2017/02/07/go-optimize-pair","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"用go重构上篇代码","date":"2018-07-05T12:00:01.000Z","path":"2018/07/05/用go重构上篇代码/","text":"上篇使用php获取了776个两位纯字母/数字.com域名,程序为顺序执行,用时较长,在此考虑使用golang,借助其协程等特性,并发执行; 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package mainimport ( \"net/http\" \"net\" \"time\" \"fmt\" \"unicode\" \"io/ioutil\" \"os\" \"strings\")func main() &#123; sli := []string&#123;&#125; for i := 'a'; i &lt;= 'z'; i++ &#123; for j := 'a'; j &lt;= 'z'; j++ &#123; sli = append(sli, string(i)+string(j)+\".com\") &#125; &#125; f, err := os.Create(\"letter.txt\") defer f.Close() if err != nil &#123; panic(err) &#125; t := time.Now() ch := make(chan string) for _, v := range sli &#123; go curl(v, ch) &#125; for i := 0; i &lt; len(sli); i++ &#123; str := &lt;-ch s := strings.Split(str, \"||||||\") for _, r := range s[1] &#123; if unicode.Is(unicode.Scripts[\"Han\"], r) &#123; _, err = f.Write([]byte(\"域名\" + s[0] + \"为中文网站\\n\")) fmt.Println(\"域名\" + s[0] + \"为中文网站\") if err != nil &#123; panic(err) &#125; break &#125; &#125; &#125; elapsed := time.Since(t) fmt.Println(\"消耗时间:\", elapsed)&#125;/** 会自动重定向,可参考https://my.oschina.net/fdhay/blog/690798部分网站检测到区域为中文,会跳转到对应的中文网站,但如果在header里设置为英文后,部分原属中国的网站也可能会转为英文;在此不加设置 */func curl(domain string, ch chan string) string &#123; c := http.Client&#123; Transport: &amp;http.Transport&#123; Dial: func(network, addr string) (net.Conn, error) &#123; deadline := time.Now().Add(60 * time.Second) c, err := net.DialTimeout(network, addr, time.Second*50) if err != nil &#123; return nil, err &#125; c.SetDeadline(deadline) return c, nil &#125;, &#125;, &#125; res, err := c.Get(\"http://\" + domain) if err != nil &#123; fmt.Println(\"出现错误:\", err) &#125; if res != nil &#123; body, _ := ioutil.ReadAll(res.Body) str := domain + \"||||||\" + string(body) //可考虑使用map优化 ch &lt;- str return str defer res.Body.Close() &#125; //如果61.com无返回,尝试请求www.61.com if res == nil &#123; res2, _ := c.Get(\"http://www.\" + domain) if res2 != nil &#123; body, _ := ioutil.ReadAll(res2.Body) str := domain + \"||||||\" + string(body) ch &lt;- str return str defer res2.Body.Close() &#125; &#125; ch &lt;- domain + \"||||||\" + \"\" return \"\"&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"两位的.com域名,有多少在中国人手中?","date":"2018-07-04T13:58:21.000Z","path":"2018/07/04/两位的-com域名-有多少在中国人手中/","text":"域名,是网民接入互联网的桥梁.好的域名,尤其在移动互联网到来之前,形如商业地产中的”金角银边”,是最核心的资产. 普通用户到达目标网站无非有如下几种方式:搜索引擎,网址导航或浏览器收藏夹,直接输入域名.显然,最稳妥方式是最后一种. 这其间有太多的故事,如中华网的上市,开心网的陨落,这也是许多商业网站,不惜血本买入域名的原因. 再加上蔡文胜们的发迹,qq.com,jd.com,mi.com,so.com, 以及”ali家族”的来龙去脉,ms.com 归属大摩(morganstanley)而非微软(microsoft),这些总为人津津乐道的”网事”,都让逐渐不在主流的域名江湖不乏谈资和故事. 因为先入为主的”历史原因”,company后缀.com,是最广泛流行的通用域名,任何一家商业公司,恐怕都梦寐能拥有对应的.com域名.而因为用户输入原因,短域名价值显然悠于长域名,愈短价值愈大. 本文旨在统计所有两位数纯字母和纯数字域名.com域名,也即26*26 + 10 * 10 = 676 + 100 = 776个,有多少个为中国人所有. 几点说明: 1.判断标准:访问该页面,如果源码含中文字符,则认为归属中国人. 2.虽持有者为防止名下价值千金的域名被仲裁,大多做一些内容,表征非投资而在正常使用,但也不乏许多国人持有的域名,就处在闲置未解析状态 关于第2点,可查看kq.com仲裁案,持有该域名的是我一位山东老乡,据称他还持有4-6个二位纯字母.com域名.他曾将 wx.com 做成一个做电器”维修”业务的网站,明显”醉翁之意不在酒”. 开始编码之前,先将人尽皆知的国内两位字母/数字.com的域名列出: bl.comqq.com yy.com jd.com mi.comso.com le.com we.com lu.com ly.com 51.com 58.com 正式编码,选用于我开发效率最高的php,暂不考虑运行效率,因部分网站如bl.com存在主页为二级域名www.bl.com的情况,故添加逻辑,xx.com或www.xx.com,有一者返回值中含中文字符,即认为符合条件 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?phpfunction getLetterDomain()&#123; $arr = []; for ($x = ord('a'); $x &lt;= ord('z'); $x++) &#123; $one = chr($x); for ($y = ord('a'); $y &lt;= ord('z'); $y++) &#123; $two = chr($y); $domain = $one . $two . \".com\"; array_push($arr, $domain); &#125; &#125; $letterFile = \"letter.txt\"; if (($file = fopen($letterFile, \"w+\")) === FALSE) &#123; echo(\"创建可写文件：\" . $letterFile . \"失败\"); exit(); &#125; echo(\"创建可写文件\" . $letterFile . \"成功！\"); foreach ($arr as $k =&gt; $value) &#123; $rs1 = curl($value); if (preg_match('/[\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]/u', $rs1) === 1) &#123; fwrite($file, \"第$k 个域名$value 为中文网站\"); fwrite($file, str_repeat(\"@\", 100)); fwrite($file, \"\\n\"); continue; &#125; $rs2 = curl('www.' . $value); if (preg_match('/[\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]/u', $rs2) === 1) &#123; fwrite($file, \"第$k 个域名$value 为中文网站\"); fwrite($file, str_repeat(\"@\", 100)); fwrite($file, \"\\n\"); &#125; &#125;&#125;function getNumDomain()&#123; $arr = []; for ($x = 0; $x &lt;= 9; $x++) &#123; for ($y = 0; $y &lt;= 9; $y++) &#123; $domain = $x . $y . \".com\"; array_push($arr, $domain); &#125; &#125; $numFile = \"numdomain.txt\"; if (($file = fopen($numFile, \"w+\")) === FALSE) &#123; echo(\"创建可写文件：\" . $numFile . \"失败\"); exit(); &#125; echo(\"创建可写文件\" . $numFile . \"成功！\"); foreach ($arr as $k =&gt; $value) &#123; $rs1 = curl($value); if (preg_match('/[\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]/u', $rs1) === 1) &#123; fwrite($file, \"第$k 个域名$value 为中文网站\"); fwrite($file, str_repeat(\"@\", 100)); fwrite($file, \"\\n\"); continue; &#125; $rs2 = curl('www.' . $value); if (preg_match('/[\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]/u', $rs2) === 1) &#123; fwrite($file, \"第$k 个域名$value 为中文网站\"); fwrite($file, str_repeat(\"@\", 100)); fwrite($file, \"\\n\"); &#125; &#125;&#125;function curl($domain)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $domain); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //若给定url自动跳转到新的url,有了下面参数可自动获取新url内容：302跳转 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); ### 该条设置十分重要,相当于curl的-L参数;但curl -L 61.com依然无法得到预期返回,上面方法中的添加www操作仍然不能少;但添加该设置后,一般可不用再尝试https,基本都会自动跳过去 //可参考http://ju.outofmemory.cn/entry/95924 以及 https://www.cnblogs.com/sien6/p/6964227.html //可以抓取头信息，并对header信息的状态码（301，302）进行判断。如需跳转，则从Location中获取到Location，再次进行抓取，直至状态码为200状态。最后再对目标页面内容进行抓取https://www.jianshu.com/p/2c4e78fb4328 // 在尝试连接时等待的秒数 curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30); // 最大执行时间 curl_setopt($ch, CURLOPT_TIMEOUT, 30); $output = curl_exec($ch); curl_close($ch); return $output;&#125;getLetterDomain();getNumDomain(); 使用go重构,见此 !第0 个域名 aa.com美国航空官网 非中国人持有 !第20 个域名 au.com日本某3C电商网站…日本文字中有相当部分和汉字写法一致,于是很好奇,在编码上,这两个看上去一样的文字,会不会对应相同的编码 非中国人持有 第21 个域名 av.com有些惊讶,没想到第一个为国人持有的二位字母.com域名是这个..在我带着一丝忐忑打开时,还好并没有出现预想中的画面^_^ !第26 个域名 ba.com该网站为一英文网站,会跳转到YouTube.因为油管相关推荐中含中文,故误认为该域名符合条件. !第40 个域名 bo.com英国航空官网 非中国人持有 第48 个域名 bw.com少不了中国人身影的币圈 第51 个域名 bz.com这张图片之后还会出现… 第56 个域名 ce.com返回值中含这个网站可出售 第59 个域名 ch.com春秋航空官网,此域名早知道,但未写在前面 !第62 个域名 ck.comCalvin Klein服装品牌官网,在华有业务,此域名非中国人所有 第76 个域名 cy.com原搜狐的游戏事业部 第83 个域名 df.com或许是马来西亚的网站 第91 个域名 dn.com杭州也有两位字母的.com域名了… 第109 个域名 ef.com英孚英语官网 !第111 个域名 eh.com日本一家造酒的企业~ 仍然是汉语和日语有部分字完全一样 第135 个域名ff.comfaraday future 下周回国贾跃亭.. 第143 个域名 fn.comFINTECH NEWS, 金融科技类资讯 第144 个域名 fo.com泰国 数字资产交易平台,真的是泰国人办的吗.. 第162 个域名 gg.com以为这个理应在对待域名不惜血本的谷歌手里…(谷歌持有g.cn,亚马逊持有z.cn,京东持有3.cn–当时其主域名为360buy.com) 第164 个域名 gi.com跳转到摩托罗拉,鉴于被联想购买,所以此域名也算归属于中国(假定该域名属于摩托) 第179 个域名 gx.com这张图片之后依然会出现… 第181 个域名 gz.com深圳某杀马特公司 第188 个域名 hg.com“欢购”,深圳一家电商网站,”专营酒类和滋补品” 第205 个域名 hx.com微信图片++++ 第218 个域名 ik.com畅联（IKGlobal）,总部位于香港的一家业务”涉及全球数据中心资源、全球网络专线、国际互联网带宽、IP地址、网络安全及防御清洗中心服务、云计算及数据加速、区块链和专业咨询及项目实施等内容”的公司. 第231 个域名 ix.com疑似属于新加坡 第235 个域名 jb.com依然是之前那张出现两次的微信图片…而且还会再出现 第244 个域名 jk.com武汉的一家药品采购网站,界面浓浓山寨风…暴殄这个健康简拼的金字域名 第245 个域名 jl.com微信图片 第247 个域名 jn.com微信图片.. 第249 个域名 jp.com依然是之前那张出现三次的微信图片…而且还会再出现 第262 个域名 kc.com矿池的简拼.之前做P2P的千金买下we.com,现在是链圈币圈的舞台了… 第263 个域名 kd.com微信图片 第264 个域名 ke.com贝壳官网 第265 个域名 kf.com微信图片… 第266 个域名 kg.com区块链+++ 千氪,36kr,钛媒体,化学元素在媒体中的应用… 第270 个域名 kk.com百度的天津子公司,主营游戏业务 第272 个域名 km.com上海的一家公司 第277 个域名 kr.com那张微信图片+.. 第301 个域名 lp.com那张微信图片 ++.. 第305 个域名 lt.com跳到厦门某域名交易商 !第331 个域名 mt.com梅特勒-托利多（METTLER TOLEDO）行业领先的精密仪器及衡器制造商与服务提供商，产品应用于实验室、制造商和零售服务业。 应该又是某跨国企业 !第346个域名 ni.com上海恩艾仪器有限公司,美国国家仪器有限公司(National Instruments Corporation.)在华分公司 第365 个域名 ob.com那张微信图片 +++.. 第395 个域名 pf.com微信图片 +++ 第399 个域名 pj.com又一家P2P… 第409 个域名 pt.com此域名可出售 第417 个域名 qb.com又又一家数字货币… 第419 个域名 qd.com微信图片 第420 个域名 qe.com您正在访问的域名可以转让 第425 个域名 qj.com疑似归王新所有.. 第428 个域名 qm.com确信归王新所有.. 第429 个域名 qn.com微信图片.. 第436 个域名 qu.com此域名有可能可以出售! 英文翻译得蜜汁传神,托儿班水平 第439 个域名 qx.com齐心文具的官网… 一直觉得和”晨光””真彩”甚至”得力”相比,这个品牌一直算二线,然鹅…从域名看绝对的头部企业… 而反观市值近400亿的晨光,求mg.com不得,用的域名是mg-pen.com 和 mg.cn 第456 个域名 ro.com上海的又又又一家游戏公司 第457 个域名 rp.com您正在访问的域名可以转让！ 第467 个域名 rz.com那张微信图片++ 第475 个域名 sh.com不评论,需谨慎 第491 个域名 sx.com这就属于那种随便展示点东西,表明我并不是投资而在使用.. 第495 个域名 tb.com微信图片++ 参考fb.com,vk.com,这个域名阿里不应该买下来吗… !第498 个域名 te.com泰科,是世界上最大的无源电子组件制造商之一. 市值近300亿美刀 跨国公司,此域名非中国人所有 第512 个域名 ts.com微信图片++ 第519 个域名 tz.com 第521 个域名 ub.comUnitedBitcoin Another One… 第564 个域名 vs.com成都的一家互联网金融服务公司,侧重期货 第569 个域名 vx.com也属于那种随便展示点东西,表明我并不是投资而在使用.. 第581 个域名 wj.com疑似又属王新所有 第598 个域名 xa.com广州的一家做农业无人机的公司..但为啥在最下面的友链中有一个”山东生活网”?空让我一阵瞎激动 第601 个域名 xd.com上海的一家游戏公司 第603 个域名 xf.com苏州的一家游戏公司 第605 个域名 xh.com 第608 个域名 xk.com一口价出售中！ 域名Domain Name:xk.com 售价Listing Price:CNY 17777777.00 第611 个域名 xn.com跳到某博彩网站.. 第614 个域名 xq.com个人网站,属于之前所说”随便做点东西,表明我在使用”~ 第617 个域名 xt.com数字货币,agggggain.. 第618 个域名 xu.com福建某电商公司 第620 个域名 xw.com数字货币+3 第622 个域名 xy.com上海的又一家游戏公司.. 第625 个域名 yb.com微信图片++ 第632 个域名 yi.com不评论 第636 个域名 ym.com然鹅,还是不如4.cn知名度更大 第640 个域名 yq.com此域名有可能可以出售! 第646 个域名 yw.com与之前的xq.com系出一人.. 第649 个域名 yz.com微信图片 !第655 个域名 zf.com采埃孚(ZF Friedrichshafen AG),是德国的一家汽车零部件生产商 此域名非中国人持有 第656 个域名 zg.com币圈+++ 第658 个域名 zi.com字.com, 这个我喜欢,多给几个展示位~ 第659 个域名 zj.com又一个归属杭州的两位.com 第660 个域名 zk.com 第661 个域名 zl.com这个网站可出售。 第666 个域名 zq.com大概也是王新所有 第667 个域名 zr.com您正在访问的域名可以转让！This domain is for sale. 第669 个域名 zt.com数字货币+++ 大概是中通快递梦寐以求的域名… 第674 个域名 zy.com 接下来是两位纯数字.com域名: 17.com17汽车网.. 20.com 23.com 28.com28商机网.. 32.com还是刚才这家 35.com三五互联 37.com 三七互娱,算是上榜的上海一票游戏公司中最知名的了 49.com您正在访问的域名可以转让！This domain is for sale. 54.com重庆的一家游戏公司 56.com56视频,像是人人网时代的产物,还有什么爆米花网,基本都落寞了.. 61.com淘米网,记得是腾讯一离职员工办的,曾多次路过,在漕河泾那两座腾讯大楼旁,和爱奇艺的分公司紧挨着~ 专注于儿童,这个域名也较贴切…但为啥都是游戏! 62.com 63.com以后玩私服传奇时不用搜索了,直接记住这个域名… 想不到,61/62/63.com全在中国人手中 65.com广州的一家游戏公司 67.com 69.com此域名有可能可以出售! 60-69之间的10个域名,6个归中国人,对6的迷恋,可见一斑… 79.com 86.com跳转到http://www.0001.com/ 展示此域名出售中！This Domain Is For Sale! 88.com域名联系QQ: 3254337092点击这里给我发消息 微信:caifu9928 Email: 3254337092@qq.com 90.com跳转到某博彩网站… 91.com百度历史上最大规模收购,19亿美元买下91..而且除却该域名,其他都雨打风吹去了.. 95.com跳转到某网址导航 97.com跳转/可以出售 98.com98.com `数字9，谐音“就”和“久”，数字8，谐音“发”2018年11月份售价：198,000,000 2018年12月份售价：178,000,000 2019年 1月份售价：158,000,000…` 99.com卖掉91的网龙,还有99.com 毕业前几年的薪资,基本都投在这上面了..也算是一段回忆 还有几点值得一记: pc.com归属intel; ti.com归属德州仪器; gi.com归属摩托罗拉; ue.com为Ultimate Ears(罗技旗下高端定制监听入耳式耳机、无线蓝牙音箱品牌， 品牌总部位于美国加州Irvine和Newark市)所有; ko.com为可口可乐所有; fs.com为一家做服务器IDC设备的跨国公司所有,中文名”飞速”,feisu.com亦归其所有; hm.com为HM所有; ua.com为Under Armour所有; ck.com为Calvin Klein所有; hw.com为哈佛西湖中学所有,该校不在波士顿,而在西海岸的加州洛杉矶; bd.com为一家全球化的医疗技术公司所有,其在中国名称为碧迪医疗器械(上海)有限公司所有,如上外资企业在华,大多总部放在上海,但在互联网时代,这些”传统企业”大多不算知名;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.dashen.tech/tags/PHP/"}]},{"title":"冯唐易老,李广难封","date":"2018-07-01T15:13:17.000Z","path":"2018/07/01/冯唐易老-李广难封/","text":"梅西C罗,这对过去十年垄断金球的对手,在过去24小时,携手双双出局. ‘85前’渐渐离开主流赛事赛场,85后也到职业生涯晚期, 前浪逝去,后浪汹涌, 内马尔,格里兹曼,博格巴,姆巴佩,登贝莱,一批90后甚至95后球员,粉墨登场. 阿根廷的出局,让朋友圈遍野哀鸿, 梅西俱乐部荣誉等身,唯在国家队,缺少一个奖杯. 世事不遂人意者十之八九,作为朋友圈出现频率最高的人, 说无悲无喜显然有所修饰. 但也并不悲恸, 4年前巴西缘锵一球, 便是梅西离大力神杯最近的一刻. 4年后,当年抢走大力神杯的卫冕冠军德国, 没能入围淘汰赛,绝杀的格策则是抱病,莫说没来俄罗斯,俱乐部亦多有坎坷. 四年前他用光了平生所有的运气,像导演伊斯坎布尔奇迹的杰拉德 冯唐易老, 攻击线虽老迈却依旧犀利的阿根廷, 中后场近些年鲜有才俊, 异代不同时, 一代中场大师里克尔梅, 大梅西9岁. 法国(非洲)队实力均衡阵容豪华, 公认的夺冠热门, 单看比分,这场比赛阿根廷比我想象的要体面得多. 败给牌面强一级的法国,且把悬念延续到最后, 阿根廷算是站着倒下. “梅西是世界第一,受伤的梅西是世界第二”, “梅西这样的球员,就像博尔特和詹姆斯, 是独立于同时代其他球员存在的,能打败他们的,唯有时间”. 自古名将如美人，不许人间见白头. 对竞技体育尤是如此. 岂能尽如人愿,但求无愧于心. 梅西有无大力神杯,他的粉丝并不是太care. 只是梅黑会在意. 梅罗临幕,喋喋不休的争吵也会有所消减. “球王”是有我国特色的称呼和寓意, 而在西方,”球王”仅指贝利,也只是一个称号, 就像”大鲨鱼”专指奥尼尔. 马拉多纳被称”10号”, 但他二人在足球史上,就如李杜之于诗歌, 虽然也有诗佛诗豪诗鬼, 但他二人是迥然于这些高一级的存在. 已尽全力,接受天命. 胜利成功自然有狂喜, 但并不总成王败寇, 失败遗憾有时也别有韵味, 刘邦项羽,卫青李广,司马诸葛, “飞将无时命，庸奴有战勋”, 缺憾美,成就了一生未能封侯的李广, “但使龙城飞将在,不教胡马度阴山”, “林暗草惊风,将军夜引弓”, “君不见沙场征战苦，至今犹忆李将军”. 许多年后,面对年轻的球迷, 白发苍苍的鲐背老人, 会颤颤巍巍向儿孙们讲述, 他们年轻时陪伴青春的那个追风少年, 以及这个因为遗憾而永远定格的夏天. “我给你我的书中所能蕴含的一切悟力，以及我生活中所能有的男子气概和幽默。 我给你一个从未有过信仰的人的忠诚。 我给你我设法保全的我自己的核心——不营字造句，不和梦交易，不被时间、欢乐和逆境触动的核心。 我给你早在你出生前多年的一个傍晚看到的一朵黄玫瑰的记忆。 我给你关于你生命的诠释，关于你自己的理论，你的真实而惊人的存在。 我给你我的寂寞、我的黑暗、我心的饥渴；我试图用困惑、危险、失败来打动你。” —- “作家们的作家”、阿根廷作家 博尔赫斯 “失败反把失败者变得更崇高了,倒了的波拿巴仿佛比立着的拿破仑还要更高大些。” —-法国作家 维克多·雨果 美洲杯再见! 2018.07.01 清澄秋爽","tags":[{"name":"足球&体育","slug":"足球-体育","permalink":"http://www.dashen.tech/tags/足球-体育/"}]},{"title":"制作jar包并上传maven官方仓库","date":"2018-07-01T11:59:56.000Z","path":"2018/07/01/制作jar包并上传maven官方仓库/","text":"注册及创建Issue 注册sonatype,注:该网站在海外,速度奇慢,耐心等待.. 创建Issue,点击Create -&gt; Issue ①Group Id ，唯一标识，可用自己的域名倒序如tech.dashen,也可用自己的github地址如com.github.xxxxx 如果用自己的域名作为标识，管理员会咨询并验证该网站是不是归属于你，可通过向该域名的解析记录中添加一条TXT记录验证 ② ProjectURL ，填项目源码的地址，如不想公布源码，那填写一个只含README 的项目的地址即可。 管理员主要就是审核Group Id，保证所有权及不会和现有的地址重复 使用gpg生成密钥关于GPG MAC 安装gnuPG 以及生成钥匙串","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"golang中的一些命令行输入函数","date":"2018-06-20T15:34:44.000Z","path":"2018/06/20/golang中的一些命令行输入函数/","text":"最近在刷Nowcoder,和leetcode不同的是,在这个平台上的提交答案,需要从接收入参开始,而不像力扣上只需要完成函数即可. 故而开此篇,整理总结一下Golang中的一些输入函数 Scan,Scanln和Scanf 12345678910111213141516171819202122232425262728package mainimport \"fmt\"//从控制台接收用户信息func main() &#123; var name string var age int var isVip bool fmt.Println(\"请输入姓名: \") n, err := fmt.Scanln(&amp;name)//会停止继续执行,直至用户输入 fmt.Println(n, err) fmt.Println(\"请输入年龄: \") _, _ = fmt.Scanln(&amp;age)//会停止继续执行,直至用户输入 fmt.Println(\"是否为会员: \") _, _ = fmt.Scanln(&amp;isVip)//会停止继续执行,直至用户输入 fmt.Printf(\"姓名是:%s, 年龄:%d,是否为会员:%t\", name, age, isVip)&#125; 关于: 123456789101112131415161718192021222324252627282930// Scan scans text read from standard input, storing successive// space-separated values into successive arguments. Newlines count// as space. It returns the number of items successfully scanned.// If that is less than the number of arguments, err will report why.//Scan会扫描从标准输入读取的文本，并将连续的以空格分隔的值存储到连续的参数中。 换行符算作空格。 它返回成功扫描的项目数。//如果该数目少于参数数目，则err将报告原因。如果该数目少于参数数目，则err将报告原因。func Scan(a ...interface&#123;&#125;) (n int, err error) &#123; return Fscan(os.Stdin, a...)&#125;// Scanln is similar to Scan, but stops scanning at a newline and// after the final item there must be a newline or EOF.func Scanln(a ...interface&#123;&#125;) (n int, err error) &#123; return Fscanln(os.Stdin, a...)&#125;// Scanf scans text read from standard input, storing successive// space-separated values into successive arguments as determined by// the format. It returns the number of items successfully scanned.// If that is less than the number of arguments, err will report why.// Newlines in the input must match newlines in the format.// The one exception: the verb %c always scans the next rune in the// input, even if it is a space (or tab etc.) or newline.func Scanf(format string, a ...interface&#123;&#125;) (n int, err error) &#123; return Fscanf(os.Stdin, format, a...)&#125; bufio.NewReader(os.Stdin) 和 ReadLine 12345678910111213141516171819package mainimport ( \"bufio\" \"fmt\" \"os\")func main() &#123; reader := bufio.NewReader(os.Stdin) data, _, _ := reader.ReadLine() content := string(data) fmt.Println(content)&#125; 会原封不动得到在控制台里输入的内容","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Kafka使用入门","date":"2018-06-19T12:35:29.000Z","path":"2018/06/19/Kafka使用入门/","text":"安装 对于Mac： brew install kafka 如果是 M1，安装zookeeper时会失败。可参考下方的评论： brew install --build-from-source zookeeperm1芯片可以安装！亲测，需要更改一些东西。brew 会先下载资源，然后通过 brew 里面安装的 maven 进行 mvn install，报错是因为 m1 使用 openjdk16 有bug！并不是zookeeper安装不了。解决办法：通过命令 brew install openjdk@11 安装jdk11，然后去homebrew的文件夹里找到mvn 的地址，如 /opt/homebrew/Cellar/maven/3.8.x/bin这个文件夹下有个 mvn 文件。vim mvn 打开，内容如下：12#!/bin/bashJAVA_HOME=\"$&#123;JAVA_HOME:-/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home&#125;\" exec \"/opt/homebrew/Cellar/maven/3.8.1/libexec/bin/mvn\" \"$@\"大概可以看出这个命令是指定了使用brew安装的openjdk（虽然没写明，但是版本是默认的openjdk16）进行 mvn 操作，更改前边的命令把指定的jdk版本换成我们刚才下载的11就行了，jdk11地址根据这个命令的地址，自己模仿着去homebrew文件夹里找。即改为12#!/bin/bashJAVA_HOME=\"$&#123;JAVA_HOME:-/opt/homebrew/opt/openjdk@11/libexec/openjdk.jdk/Contents/Home&#125;\" exec \"/opt/homebrew/Cellar/maven/3.8.2/libexec/bin/mvn\" \"$@\"然后再重新执行brew install --build-from-source zookeeper，这时在报错那一步不会再报错，但是会卡住！只需要等待就好！等了十多分钟，然后就完成了，不要以为卡住是有问题，要等其结束，比较慢。 目录为 /opt/homebrew/Cellar/kafka/2.8.0/bin 配置文件路径为 /opt/homebrew/etc/kafka/server.properties 启动 Zookeeper cd /opt/homebrew/Cellar/kafka/2.8.0/bin sh zookeeper-server-start /opt/homebrew/etc/kafka/zookeeper.properties &amp; 启动 Kafka sh kafka-server-start /opt/homebrew/etc/kafka/server.properties&amp; 创建topic sh kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic shuangTest 查看创建的topic sh kafka-topics --list --zookeeper localhost:2181 带有句点 (‘.’) 或下划线 (‘_’) 的主题可能会发生冲突。 为避免出现问题，最好使用其中之一，但不能同时使用 删除topic sh kafka-topics --zookeeper localhost:2181 --delete --topic shuang_test 发送消息 Kafka提供了一个命令行客户端，从文件或标准输入接收输入，并将其作为消息发送到Kafka集群。 默认情况下，每行都将作为单独的消息发送。 运行生产者，然后在控制台中键入一些消息发送到服务器。 sh kafka-console-producer --broker-list localhost:9092 --topic shuangTest zookeeper的默认端口是2181，kafka的默认端口是9092 消费消息 Kafka还有一个命令行消费者，将消息转储到标准输出 sh kafka-console-consumer --bootstrap-server localhost:9092 --topic shuangTest --from-beginning 使用可视化工具 Kafka Tool Kafka可视化客户端工具（Kafka Tool 2）的安装和使用Kafka可视化客户端工具Kafka Tool 关闭Kafka &amp; Zookeeper sh kafka-server-stop sh zookeeper-server-stop","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Go实现一个判断版本号是否合规的函数","date":"2018-06-19T11:15:40.000Z","path":"2018/06/19/Go实现一个判断版本号是否合规的函数/","text":"写一个判断版本号格式的方法，版本号分3部分，样例为：a1.1.1,第一部分为字母加数字，后面两部分为纯数字（支持扩展性，支持规定数字的范围）. 尽量不要使用正则匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( \"fmt\" \"strconv\" \"strings\" \"unicode\")func main() &#123; str := \"a12.1.1\" intLeft2 := 0 intRight2 := 8 intLeft3 := 0 intRight3 := 8 fmt.Println(\"是否合规:\", tool(str, intLeft2, intRight2, intLeft3, intRight3))&#125;func tool(str string, intLeft2, intRight2, intLeft3, intRight3 int) bool &#123; //是否是以.分割的三部分 a := strings.Split(str, \".\") if len(a) != 3 &#123; return false &#125; //是否第一部分为字母+数字 var sli []int32 firstPart := a[0] firstPartRuneSli := []rune(firstPart) //如果第一部分的首元素不为字母,直接返回false if ! unicode.IsLetter(firstPartRuneSli[0]) &#123; return false &#125; //如果第一部分的最后一个元素不为字母,也直接返回false if ! unicode.IsDigit(firstPartRuneSli[len(firstPartRuneSli)-1]) &#123; return false &#125; //保证不会字符/数字相间分布 for _, v := range firstPart &#123; //fmt.Println(\"v:\",v) if ! unicode.IsLetter(v) &#123; sli = append(sli, v) &#125; &#125; for _, item := range sli &#123; if ! unicode.IsDigit(item) &#123; return false &#125; &#125; //后两部分为数字,且范围在给定范围内 for _, v := range a[1] &#123; if ! unicode.IsDigit(v) &#123; return false &#125; &#125; secondPartInt, err := strconv.Atoi(a[1]) if err != nil &#123; panic(err) &#125; if secondPartInt &lt; intLeft2 || secondPartInt &gt; intRight2 &#123; return false &#125; thirdPartInt, err := strconv.Atoi(a[2]) if err != nil &#123; panic(err) &#125; if thirdPartInt &lt; intLeft3 || secondPartInt &gt; intRight3 &#123; return false &#125; return true&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"消息队列入门","date":"2018-06-11T16:16:22.000Z","path":"2018/06/12/消息队列入门/","text":"几种常见消息队列(了解即可) 多维度对比5款主流分布式MQ消息队列 分布式之消息队列的特点、选型、及应用场景详解 开发语言: 1）Kafka：Scala 2）RabbitMQ：Erlang 3）ZeroMQ：C语言 4）RocketMQ：Java 5）ActiveMQ：Java 支持的协议 1）Kafka：自己定义的一套…（基于TCP） 2）RabbitMQ：AMQP 3）ZeroMQ：TCP、UDP 4）RocketMQ：自己定义的一套… 5）ActiveMQ：OpenWire、STOMP、REST、XMPP、AMQP 负载均衡 Kafka支持负载均衡。 1）一个broker通常就是一台服务器节点。 对于同一个Topic的不同分区，Kafka会尽力将这些分区分布到不同的Broker服务器上，zookeeper保存了broker、主题和分区的元数据信息。 分区首领会处理来自客户端的生产请求，Kafka分区首领会被分配到不同的broker服务器上，让不同的broker服务器共同分担任务。 每一个broker都缓存了元数据信息，客户端可以从任意一个broker获取元数据信息并缓存起来，根据元数据信息知道要往哪里发送请求。 2）Kafka的消费者组订阅同一个topic，会尽可能地使得每一个消费者分配到相同数量的分区，分摊负载。 3）当消费者加入或者退出消费者组的时候，还会触发再均衡，为每一个消费者重新分配分区，分摊负载。 Kafka的负载均衡大部分是自动完成的，分区的创建也是Kafka完成的，隐藏了很多细节，避免了繁琐的配置和人为疏忽造成的负载问题。 4）发送端由topic和key来决定消息发往哪个分区，如果key为null，那么会使用轮询算法将消息均衡地发送到同一个topic的不同分区中。如果key不为null，那么会根据key的hashcode取模计算出要发往的分区。 RabbitMQ对负载均衡的支持不好 ZeroMQ去中心化，不支持负载均衡。 RocketMQ支持负载均衡。 ActiveMQ支持负载均衡。可以基于zookeeper实现负载均衡。 可用性 1）Kafka：非常高（分布式） 2）RabbitMQ：高（主从） 3）ZeroMQ：高 4）RocketMQ：非常高（分布式） 5）ActiveMQ：高（主从） 消息重复 1）Kafka：支持at least once、at most once 2）RabbitMQ：支持at least once、at most once 3）ZeroMQ：只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once 4）RocketMQ：支持at least once 5）ActiveMQ：支持at least once 吞吐量TPS TPS: Transactions Per Second的缩写，即 事务数/秒. 1）Kafka：极大。Kafka按批次发送消息和消费消息。发送端将多个小消息合并，批量发向Broker，消费端每次取出一个批次的消息批量处理。 2）RabbitMQ：比较大 3）ZeroMQ：极大 4）RocketMQ：大。RocketMQ接收端可以批量消费消息，可以配置每次消费的消息数，但是发送端不是批量发送。 5）ActiveMQ：比较大 吞顺序消息 Kafka：支持。 设置生产者的max.in.flight.requests.per.connection为1，可以保证消息是按照发送顺序写入服务器的，即使发生了重试。 Kafka保证同一个分区里的消息是有序的，但是这种有序分两种情况： ①key为null，消息逐个被写入不同主机的分区中，但是对于每个分区依然是有序的 ②key不为null , 消息被写入到同一个分区，这个分区的消息都是有序。 RabbitMQ：不支持 ZeroMQ：不支持 RocketMQ：支持 ActiveMQ：不支持 消息确认 Kafka支持。 1）发送方确认机制： ack=0，不管消息是否成功写入分区 ack=1，消息成功写入首领分区后，返回成功 ack=all，消息成功写入所有分区后，返回成功。 2）接收方确认机制： 自动或者手动提交分区偏移量，早期版本的Kafka偏移量是提交给Zookeeper的，这样使得zookeeper的压力比较大，更新版本的Kafka的偏移量是提交给Kafka服务器的，不再依赖于zookeeper群组，集群的性能更加稳定。 RabbitMQ支持。 1）发送方确认机制，消息被投递到所有匹配的队列后，返回成功。如果消息和队列是可持久化的，那么在写入磁盘后，返回成功。支持批量确认和异步确认。 2）接收方确认机制，设置autoAck为false，需要显式确认，设置autoAck为true，自动确认。 当autoAck为false的时候，RabbitMQ队列会分成两部分，一部分是等待投递给consumer的消息，一部分是已经投递但是没收到确认的消息。 如果一直没有收到确认信号，并且consumer已经断开连接，RabbitMQ会安排这个消息重新进入队列，投递给原来的消费者或者下一个消费者。 未确认的消息不会有过期时间，如果一直没有确认，并且没有断开连接，RabbitMQ会一直等待，RabbitMQ允许一条消息处理的时间可以很久很久。 ZeroMQ支持。 RocketMQ支持。 ActiveMQ支持。 消息回溯 1）Kafka：支持指定分区offset位置的回溯 2）RabbitMQ：不支持 3）ZeroMQ：不支持 4）RocketMQ：支持指定时间点的回溯 5）ActiveMQ：不支持 并发度 Kafka并发度高。 一个线程一个消费者，Kafka限制消费者的个数要小于等于分区数，如果要提高并行度，可以在消费者中再开启多线程，或者增加consumer实例数量。 19.2 RabbitMQ并发度极高。本身是用Erlang语言写的，并发性能高。 可在消费者中开启多线程，最常用的做法是一个channel对应一个消费者，每一个线程把持一个channel，多个线程复用connection的tcp连接，减少性能开销。 当RabbitMQ队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。 这种方式非常适合扩展，而且是专门为并发程序设计的。 如果某些消费者的任务比较繁重，那么可以设置basicQos限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，RabbitMQ不再向这个消费者发送任何消息。 ZeroMQ并发度高。 RocketMQ并发度高。 1）RocketMQ限制消费者的个数少于等于队列数，但是可以在消费者中再开启多线程，这一点和Kafka是一致的，提高并行度的方法相同。 修改消费并行度方法： 同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度，超过订阅队列数的 Consumer实例无效。 提高单个 Consumer 的消费并行线程，通过修改参数consumeThreadMin、consumeThreadMax 2）同一个网络连接connection，客户端多个线程可以同时发送请求，连接会被复用，减少性能开销。 ActiveMQ并发度高。 单个ActiveMQ的接收和消费消息的速度在1万笔/秒（持久化 一般为1-2万， 非持久化 2 万以上），在生产环境中部署10个ActiveMQ就能达到10万笔/秒以上的性能，部署越多的ActiveMQ broker 在MQ上latency也就越低，系统吞吐量也就越高。 Kafka相关 Terminology Broker Kafka集群包含一个或多个服务器，这种服务器被称为 broker Topic 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处） Partition Parition是物理上的概念，每个 Topic 包含一个或多个 Partition. Producer 负责发布消息到 Kafka broker Consumer 消息消费者，向 Kafka broker 读取消息的客户端。 Consumer Group 每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。 Topic &amp; Partition Topic 在逻辑上可以被认为是一个 queue，每条消费都必须指定它的 Topic，可以简单理解为必须指明把这条消息放进哪个 queue 里。为了使得 Kafka 的吞吐率可以线性提高，物理上把 Topic 分成一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。若创建 topic1 和 topic2 两个 topic，且分别有 13 个和 19 个分区，则整个集群上会相应会生成共 32 个文件夹 因为每条消息都被 append 到该 Partition 中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证） 对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。一是基于时间，二是基于 Partition 文件大小。例如可以通过配置 $KAFKA_HOME/config/server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过 1GB 时删除旧数据 Kafka 读取特定消息的时间复杂度为 O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka 会为每一个 Consumer Group 保留一些 metadata 信息——当前消费的消息的 position，也即 offset。这个 offset 由 Consumer 控制。正常情况下 Consumer 会在消费完一条消息后递增该 offset。当然，Consumer 也可将 offset 设成一个较小的值，重新消费一些消息。因为 offet 由 Consumer 控制，所以 Kafka broker 是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过 broker 去保证同一个 Consumer Group 只有一个 Consumer 能消费某一条消息，因此也就不需要锁机制，这也为 Kafka 的高吞吐率提供了有力保障。 Push vs. Pull 作为一个消息系统，Kafka 遵循了传统的方式，选择由 Producer 向 broker push 消息并由 Consumer 从 broker pull 消息。一些 logging-centric system，比如 Facebook 的 Scribe 和 Cloudera 的 Flume ，采用 push 模式。事实上，push 模式和 pull 模式各有优劣。 push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。push 模式的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。 对于 Kafka 而言，pull 模式更合适。pull 模式可简化 broker 的设计，Consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。 Kafka delivery guarantee 有这么几种可能的 delivery guarantee： At most once 消息可能会丢，但绝不会重复传输 At least one 消息绝不会丢，但可能会重复传输 Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。 当 Producer 向 broker 发送消息时，一旦这条消息被 commit，因数 replication 的存在，它就不会丢。但是如果 Producer 发送数据给 broker 后，遇到网络问题而造成通信中断，那 Producer 就无法判断该条消息是否已经 commit。虽然 Kafka 无法确定网络故障期间发生了什么，但是 Producer 可以生成一种类似于主键的东西，发生故障时幂等性的重试多次，这样就做到了 Exactly once。截止到目前 (Kafka 0.8.2 版本，2015-03-04)，这一 Feature 还并未实现，有希望在 Kafka 未来的版本中实现。（所以目前默认情况下一条消息从 Producer 到 broker 是确保了 At least once，可通过设置 Producer 异步发送实现 At most once）。 接下来讨论的是消息从 broker 到 Consumer 的 delivery guarantee 语义。（仅针对 Kafka consumer high level API）。Consumer 在从 broker 读取消息后，可以选择 commit，该操作会在 Zookeeper 中保存该 Consumer 在该 Partition 中读取的消息的 offset。该 Consumer 下一次再读该 Partition 时会从下一条开始读取。如未 commit，下一次读取的开始位置会跟上一次 commit 之后的开始位置相同。当然可以将 Consumer 设置为 autocommit，即 Consumer 一旦读到数据立即自动 commit。如果只讨论这一读取消息的过程，那 Kafka 是确保了 Exactly once。但实际使用中应用程序并非在 Consumer 读取完数据就结束了，而是要进行进一步处理，而数据处理与 commit 的顺序在很大程度上决定了消息从 broker 和 consumer 的 delivery guarantee semantic。 读完消息先 commit 再处理消息。这种模式下，如果 Consumer 在 commit 后还没来得及处理消息就 crash 了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once 读完消息先处理再 commit。这种模式下，如果在处理完消息之后 commit 之前 Consumer crash 了，下次重新开始工作时还会处理刚刚未 commit 的消息，实际上该消息已经被处理过了。这就对应于 At least once。在很多使用场景下，消息都有一个主键，所以消息的处理往往具有幂等性，即多次处理这一条消息跟只处理一次是等效的，那就可以认为是 Exactly once。（笔者认为这种说法比较牵强，毕竟它不是 Kafka 本身提供的机制，主键本身也并不能完全保证操作的幂等性。而且实际上我们说 delivery guarantee 语义是讨论被处理多少次，而非处理结果怎样，因为处理方式多种多样，我们不应该把处理过程的特性——如是否幂等性，当成 Kafka 本身的 Feature） 如果一定要做到 Exactly once，就需要协调 offset 和实际操作的输出。精典的做法是引入两阶段提交。如果能让 offset 和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，Consumer 拿到数据后可能把数据放到 HDFS，如果把最新的 offset 和数据本身一起写到 HDFS，那就可以保证数据的输出和 offset 的更新要么都完成，要么都不完成，间接实现 Exactly once。（目前就 high level API 而言，offset 是存于 Zookeeper 中的，无法存于 HDFS，而 low level API 的 offset 是由自己去维护的，可以将之存于 HDFS 中） 总之，Kafka 默认保证 At least once，并且允许通过设置 Producer 异步提交来实现 At most once。而 Exactly once 要求与外部存储系统协作，幸运的是 Kafka 提供的 offset 可以非常直接非常容易得使用这种方式。 参考: Kafka 背景及架构介绍–力荐 kafka消息分区机制 Kafka分区与消费者的关系 Apache kafka 工作原理介绍 Kafka 入门一篇文章就够了","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"少年子弟江湖老 红粉佳人两鬓斑","date":"2018-06-07T14:23:03.000Z","path":"2018/06/07/少年子弟江湖老-红粉佳人两鬓斑/","text":"补记:姥爷去世一月后,姥姥亦跟随而去,享年92岁 p{ text-indent:2em;} td {text-align:center} 当蜡烛要点燃的那一刻，ta们含情脉脉注视着彼此，仿佛是70年前，他22岁、她21岁的那个夏天。“郎骑竹马来，绕床弄青梅”的美好开始，“执手偕老，白首不离”的岁月，比共和国历史还要绵长。ta们沟壑纵横的脸颊，历经过东北易帜，华北失陷，西安事变，以及抗战胜利和建国后的种种火红岁月。近黄昏的夕阳，终于在这一刻作隐于西山。他有长寿的岁月，有年轻时鸭绿江外，九死一生燕然勒石的不朽伟业，有垂暮之年，四世同堂含饴弄孙的其乐融融。当他身染沉疴，自知时日无多，却不知亦步亦趋，患癌她也要神同步。两个已被医院和现代医学抛弃的老人，淡定安详地度过归流入海的最后时刻。也许“淡定安详”只是看上去那样，滔天炮火他当年未曾退怯，临去却有牵挂愁肠百结几度泪垂：忙碌于各自工作家庭的子女，可有足够时间和耐心，让已在轮椅之上呆了10多年的她，安度最后时光。我原意在6月的末尾回乡迁证，闻听病重，匆匆北上一千五百里。一时的风尘仆仆褪尽，幸得弥留之际相见，余生无憾。两个重外孙女，在为儿童节所得奖励而欣喜欢闹，她们还小，并不懂生离死别。我刹那想到鲁迅“人类的悲欢并不相通”，但我回想年幼种种，是凄入肝脾，泪夺眶而强止。我想将其厉言喝止，却又分明心知：小辈童孩的欢声笑言，而非我辈的泣泣哀声，才是最好的送别曲。身体的痛苦让他在不由自主哀叹，她坐在床头静静看着，不时转头心有戚色。两个外孙女嬉闹，在床角上蹿下跳，她没法用言语表达，唯恐踩到痛苦中的他，只艰难半起身，用仅能活动的一侧躯体愤而驱离，竟力大势急不留情面。我看着她的神情和眼神，胸中有典腹有千言，却只有不言不语。两个女童像被吓散的家雀，仓皇逃离。他闻听声响，让女儿将其扶起，问偏大的重外孙女，你天天来，怎么还认生？我忙解释，他说不会踩到我，老姥娘和你们开玩笑。随即对姨说，给我一支烟。我实在惊讶，想及晚期肺癌，便脱口“姥爷我们不抽吧”。两个姨说，一切遂意，由他抽吧。点燃了烟盒里最后一支烟。我忙问可还有烟？我要去外购最好最好的香烟。得知还有很多，他偏爱此劣烟，若抽好烟，或还不至此。我实知此，只悄悄把烟盒和烟蒂保留。第二日，又是呼吸不顺吁吁气喘。二姨将他扶起，要我喂些香油。他看着我，几秒间隔用于反应辨认，随即说“小爽儿你怎么又来了？不回去工作？”我强忍言没事不忙。倒了一勺喂下复又一勺，他一切的关怀备至，我所相报，竟止他临去时的两勺香油。两重外孙远道来。稍大一个挽着他手说：老姥爷，你病了？快点好起来。我摸着他的头，目眩而慰藉。我要匆匆返程，只说保重，我过几天再来。我原意6月的每周都回家，而他没给我机会。2018年6月5日下午4点，在我埋头探究docker之时，我最深爱挚爱的姥爷，在几日头脑清晰中的痛苦之后，永远永远永远地离开了我。1528185600，这个坐标点，当是我百年弥留回望，不太多的几个分水岭。在它之前，我的世界完整，四老健在且高寿。再它之后，光阴岁月无情的暗箭，直勾勾射向父母一辈，也让我感到丝丝寒意。&lt;时间都去哪了&gt;，此时听来，尽是曲中人。他岁月的年轮划过了高寿的92周，他有相濡以沫的红颜有思念他的儿孙。他在最后心愿尽了未留憾事。悲痛之余，或该为他高兴。福禄寿考，古往今来人之所愿，而得偿者屈指。我时唯物笃信科学，唯止此时，不再对宗教神学一瞥而过。天国安好，如有来世，我们再聚。戊戌年清和月，廿二子时初始，尹公小女外孙，武林城西湖区，闻讯呆坐良久，挥涕沾襟而记。———————落花寂寂草绵绵，云影天光皆宛然。万星不知人事改，闲垂光影落孤台。桃蹊李径渐荒凉，访旧寻微益自伤。惆怅林间中夜月，柔光曾照旧时人。","tags":[]},{"title":"斯人虽远去,思忆永留存","date":"2018-06-06T08:56:52.000Z","path":"2018/06/06/斯人虽远去-精神永留存/","text":"一周前的今天，也即探望回杭的第二天，我至敬至爱的姥爷，永远永远永远离开了。 他一生牙硬，卧床不起时病已膏肓，良医束手，药石罔然。他四世同堂高寿撒手，与其痛苦残延，驾鹤西去或是解脱。 但我还是自私希望，不要这样“猝不及防”，能等我端午再回，还再有一次含笑告别 转身泪目的机会。… 这一周来，当我与众人一道忙碌，谈笑如常诸人多浑然不觉，似与阮籍对弈。而当棋罢孤处，当我趿拉着拖鞋穿过车流不止的文二路，走在盛夏傍晚 绿阴如盖的万塘路，短短一程，想及年幼种种温馨往事，今却只能向一抔黄土哀悼，在云天苍茫暮鸦声声里怀忆，又几要泪落沾襟。 如此天恩我已经永远无法报答，只能更加宽宥，好好待他的女儿。更希望许多年后，当我也旅途渐近尾声，能有足够阅历和文笔，记录旅途一路所见杂思——这一瞬将是浓墨重彩的一笔，它不消畅销流传百代，如若能在我早已化为尘埃的百年之后，有年轻的后人在细雨初歇的闲暇午后，挠有兴致翻看几页嘴角泛起微笑，则实在已经心满意足。 p{ text-indent:2em;} 我终在麦菽千重浪的丰收时节匆匆回乡，而却是为生死离别。1/4个世纪前，我年轻倔强的妈妈，新婚燕尔，便有意以二人之力新建一宅。在21年前，极是要强的她，正式开始了这一旷日持久的复杂工程。于是，甚至还在那之前，我便被寄养在几公里外，却是另一个地级市的外公家。“谢公最小偏怜女”，爱屋及乌，又何况是隔代人，自然视为珍宝，小心翼翼捧于掌心。凡有所求，纵上穷碧落力遂我愿。我一生的宠溺，尽在那时消贻殆尽，往后再不复有。这个67年前曾入朝作战的排雷工兵，在千禧年前后，便有一份已为丰厚的薪酬。常仗义疏财，泽被儿孙乡里。而于己严苛，只抽劣烟，只饮散酒。时年过70，家中闲坐不住，逢孟春夏秋日，走街赶集卖“冰糕”。每日晨起暮归，纱帽里尽是散碎零钱。覆于床头，与之共点，我虽年幼，亦一板一眼，成则箍以橡皮筋，压于一截铁轨之下，是为爷孙二人每日乐事。我时挑食不爱饭菜，公暗愁不已。某日跟其身后，行至大街，见有一新奇玩意，名为“烧烤”，烟火缭绕，香气四溢，驻足观而不动。公见而喜，忙问价格，答为一元三串。时在20年前，静安房价多不逾千，西湖房价甚或几百。公不以为意，购一大把尽于我，己不尝分毫。见我虎咽狼吞 苍啷啷似风卷残云，喜笑颜开。低头侧目相问：“这叫小烤？” 余稍停后槽牙，鼓动腮帮激动纠谬：“什么啊，这叫烧烤”。公听而更喜，喃喃“烧烤，这叫烧烤，俺爽儿喜欢吃烧烤，知道了，知道了”。时曾允诺，每周与我回家一次，以知新居进度，看“有无贴上马赛克”。他用一只手抱起我，对着院子里那棵已深印儿时记忆的梧桐树上碰碰鞋底，象征性地表示已经磕落尘土，便将我塞到车子后座的冰糕箱里，又骑车穿过一条铁路和国道，以满足我小小心愿。如此循环，周而复始，直至新居落成。时蜗在箱底，举目尽天，白云悠悠，似如今日。浮云不曾易，斯人已垂垂。公曾教我“朝鲜语”，并忆当年金戈铁马。时我年幼，并不知此价值，觉无聊寡味。公见此，既不做灌输，更不重复唠叨。而当我年纪更大知其意义，公已耄耋，甲子年前旧事，已作流水，回取不来。公好象棋，常观人对弈。后我进幼儿园，不再如影相伴，改而每周相见。某次父为我购象棋一副，并告知以简单规则，我所知仅限“马日象田”。下次前去，听我自擂“已会下棋”，公兴奋若见卞和捧璧，急拿棋布之与我对弈。却见我不知过河卒子不回头，顷刻知我水平，公亦喜，淳淳指点。然不过三五步又逢险境，数次相告，予我悔棋。更教我“抽将”，时至今日，亦为我最爱之招。后过十五载，大学闲而无事，曾摹&lt;橘中秘&gt;，棋艺飞涨，更悟“自出洞来无敌手，得饶人处且饶人”，公亦教我，万事留一线，江湖好相见，有如此意。公旧日之棋友，已如秋风黄叶，萧索无一。后又高中，闲暇再少。及至大学，远赴他省穷壤，每年得回，只有冬夏。而我年岁增加，相隔两代，竟再难寻共同语言。我常没话找话问些东西。公答然不吐露心事。知我前来，未到便相迎。待我回程，目力之处不见方回屋。…而今卧于病榻，粥饭难进，见桑榆暮景，感草木微情，每思及此，更不觉涟涟。值此深夜，往事尽来。所能忆者，止时光长河吉光片羽；而动笔记之，又止孑遗之一鳞半爪。公于我呵护关怀，事无巨细，无微不至。而所取所图竟无一，不予一丝相报反哺之机。此更致我于今宵锤心泣血，临事涕零，屡不知所云。“野蔬充膳甘长藿，落叶添薪仰古槐。今日奉钱过十万，与君营奠复营斋”，此为唐人元稹，悼念下嫁于他的患难亡妻韦氏所作。元稹百年，尚可与韦丛同穴 窅冥长眠，而公于我咿呀之时，不计成本不索回报。今我近而立，正欲回汪洋以滴水，报皓月以荧光，而你，而你却连药也已吃不下…是夜风静，而我心之汹涌，似有滔天海啸。听雨少年，鬓发星星，悲欢离合总无情。未觉池塘春草梦，阶前梧叶已秋声。——————","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"逆向工程-以破解Charles为例","date":"2018-05-28T12:53:30.000Z","path":"2018/05/28/逆向工程-以破解Charles为例/","text":"安装Charles时,找到Charles 激活码计算器 从官网下载最新版的Charles,利用如下这段Go代码,进行注册码的获取: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package mainimport ( \"bytes\" \"encoding/binary\" \"fmt\" \"math/rand\" \"time\")const ( rounds = 12 roundKeys = 2 * (rounds + 1))func main() &#123; rand.Seed(time.Now().UnixNano()) //name := \"charles\" name := \"cuishuang\" fmt.Println(\"name:\", name, \" key:\", crack(name))&#125;func crack(text string) string &#123; name := []byte(text) length := len(name) + 4 padded := ((-length) &amp; (8 - 1)) + length bs := make([]byte, 4) binary.BigEndian.PutUint32(bs, uint32(len(name))) buff := bytes.Buffer&#123;&#125; buff.Write(bs) buff.Write(name) var ckName int64 = 0x7a21c951691cd470 var ckKey int64 = -5408575981733630035 ck := newCkCipher(ckName) outBuff := bytes.Buffer&#123;&#125; for i := 0; i &lt; padded; i += 8 &#123; bf := buff.Bytes()[i : i+8] buf := bytes.NewBuffer(bf) var nowVar int64 if err := binary.Read(buf, binary.BigEndian, &amp;nowVar); err != nil &#123; panic(err) &#125; dd := ck.encrypt(nowVar) outBuff.WriteByte(byte(dd &gt;&gt; 56)) outBuff.WriteByte(byte(dd &gt;&gt; 48)) outBuff.WriteByte(byte(dd &gt;&gt; 40)) outBuff.WriteByte(byte(dd &gt;&gt; 32)) outBuff.WriteByte(byte(dd &gt;&gt; 24)) outBuff.WriteByte(byte(dd &gt;&gt; 16)) outBuff.WriteByte(byte(dd &gt;&gt; 8)) outBuff.WriteByte(byte(dd)) &#125; var n int32 for _, b := range outBuff.Bytes() &#123; n = rotateLeft(n^int32(int8(b)), 0x3) &#125; prefix := n ^ 0x54882f8a suffix := rand.Int31() in := int64(prefix) &lt;&lt; 32 s := int64(suffix) switch suffix &gt;&gt; 16 &#123; case 0x0401: case 0x0402: case 0x0403: in |= s break default: in |= 0x01000000 | (s &amp; 0xffffff) break &#125; out := newCkCipher(ckKey).decrypt(in) var n2 int64 for i := 56; i &gt;= 0; i -= 8 &#123; n2 ^= int64((uint64(in) &gt;&gt; i) &amp; 0xff) &#125; vv := int32(n2 &amp; 0xff) if vv &lt; 0 &#123; vv = -vv &#125; return fmt.Sprintf(\"%02x%016x\", vv, uint64(out))&#125;type ckCipher struct &#123; rk [roundKeys]int32&#125;func newCkCipher(ckKey int64) ckCipher &#123; ck := ckCipher&#123;&#125; var ld [2]int32 ld[0] = int32(ckKey) ld[1] = int32(uint64(ckKey) &gt;&gt; 32) ck.rk[0] = -1209970333 for i := 1; i &lt; roundKeys; i++ &#123; ck.rk[i] = ck.rk[i-1] + -1640531527 &#125; var a, b int32 var i, j int for k := 0; k &lt; 3*roundKeys; k++ &#123; ck.rk[i] = rotateLeft(ck.rk[i]+(a+b), 3) a = ck.rk[i] ld[j] = rotateLeft(ld[j]+(a+b), a+b) b = ld[j] i = (i + 1) % roundKeys j = (j + 1) % 2 &#125; return ck&#125;func (ck ckCipher) encrypt(in int64) int64 &#123; a := int32(in) + ck.rk[0] b := int32(uint64(in)&gt;&gt;32) + ck.rk[1] for r := 1; r &lt;= rounds; r++ &#123; a = rotateLeft(a^b, b) + ck.rk[2*r] b = rotateLeft(b^a, a) + ck.rk[2*r+1] &#125; return pkLong(a, b)&#125;func (ck ckCipher) decrypt(in int64) int64 &#123; a := int32(in) b := int32(uint64(in) &gt;&gt; 32) for i := rounds; i &gt; 0; i-- &#123; b = rotateRight(b-ck.rk[2*i+1], a) ^ a a = rotateRight(a-ck.rk[2*i], b) ^ b &#125; b -= ck.rk[1] a -= ck.rk[0] return pkLong(a, b)&#125;func rotateLeft(x int32, y int32) int32 &#123; return int32(x&lt;&lt;(y&amp;(32-1))) | int32(uint32(x)&gt;&gt;(32-(y&amp;(32-1))))&#125;func rotateRight(x int32, y int32) int32 &#123; return int32(uint32(x)&gt;&gt;(y&amp;(32-1))) | int32(x&lt;&lt;(32-(y&amp;(32-1))))&#125;func pkLong(a int32, b int32) int64 &#123; return (int64(a) &amp; 0xffffffff) | (int64(b) &lt;&lt; 32)&#125; 确有奇效,仔细看上面这段代码, 好奇 var ckKey int64 = -5408575981733630035的由来,搜索之后发现,是通过 反编译得到的. 更多参考: 通过反编译破解Charles Charles 4.5.1逆向工程 Hopper 今天开始学逆向：反汇编的利器 IDA 和 Hopper 的基本使用","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"golang获取调用者的方法名及所在行数","date":"2018-05-18T13:35:34.000Z","path":"2018/05/18/golang获取调用者的方法名及所在行数/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"fmt\" \"runtime\")import \"log\"func main() &#123; test()&#125;func test() &#123; test2()&#125;func test2() &#123; pc, file, line, ok := runtime.Caller(2) log.Println(pc) log.Println(file) log.Println(line) log.Println(ok) f := runtime.FuncForPC(pc) log.Println(f.Name()) fmt.Println(\"--------------------\") pc, file, line, ok = runtime.Caller(0) log.Println(pc) log.Println(file) log.Println(line) log.Println(ok) f = runtime.FuncForPC(pc) log.Println(f.Name()) fmt.Println(\"--------------------\") pc, file, line, ok = runtime.Caller(1) log.Println(pc) log.Println(file) log.Println(line) log.Println(ok) f = runtime.FuncForPC(pc) log.Println(f.Name())&#125; 输出: 12345678910111213141516172018/05/18 21:25:59 174264482018/05/18 21:25:59 /Users/dashen/go/src/note/b_demo/runtime123.go2018/05/18 21:25:59 102018/05/18 21:25:59 true2018/05/18 21:25:59 main.main--------------------2018/05/18 21:25:59 174271562018/05/18 21:25:59 /Users/dashen/go/src/note/b_demo/runtime123.go2018/05/18 21:25:59 292018/05/18 21:25:59 true2018/05/18 21:25:59 main.test2--------------------2018/05/18 21:25:59 174264472018/05/18 21:25:59 /Users/dashen/go/src/note/b_demo/runtime123.go2018/05/18 21:25:59 142018/05/18 21:25:59 true2018/05/18 21:25:59 main.test 相关代码: src/runtime/extern.go 123456789101112131415// Caller reports file and line number information about function invocations on// the calling goroutine's stack. The argument skip is the number of stack frames// to ascend, with 0 identifying the caller of Caller. (For historical reasons the// meaning of skip differs between Caller and Callers.) The return values report the// program counter, file name, and line number within the file of the corresponding// call. The boolean ok is false if it was not possible to recover the information.func Caller(skip int) (pc uintptr, file string, line int, ok bool) &#123; rpc := make([]uintptr, 1) n := callers(skip+1, rpc[:]) if n &lt; 1 &#123; return &#125; frame, _ := CallersFrames(rpc).Next() return frame.PC, frame.File, frame.Line, frame.PC != 0&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"星际迷航","date":"2018-05-14T12:54:24.000Z","path":"2018/05/14/星际迷航/","text":"矮行星和小行星带中天体的命名及翻译都非常有趣。以让冥王星“下马”的『阋神星』为例，原名Eris，即希腊神话中的“不和女神”，抛出金苹果，导致特洛伊战争的祸首。参考“兄弟阋于墙”，可知此命名翻译贴切。 而曾被认为太阳系第九大行星的冥王星，原称Pluto，普鲁托是罗马神话中的阴神，类似东方神话里的阎王。 而与冥王星组成“双星系统”的卡戎星，迄今扔被视为冥王星的卫星，故也称“冥卫一”。Charon是罗马神话中冥王『普鲁托』的役卒，向亡魂索取金钱摆渡其过冥河。冥河类似于东方神话体系里的忘川河，只是不知道西方有无奈何桥和孟婆汤。 而200多年前人类发现的第一颗小行星Ceres，名『谷神星』，克瑞斯是谷类的女神。 Makemake，该名称源自复活节岛原住民神话中的人类创造者与生殖之神“马奇马奇”。中文译作“鸟神星”。[汗]明明是和女娲职能等同的角色，取了这么个名… Haumea，中文译为哈乌梅亚，2005年发现的天体。又以夏威夷神话中主管生育和生殖的神Haumea作为称谓，中文名“妊神星”。 …… 谷神星是小行星带中最大最重天体，直径不及地球1/12。小行星带剩余还有至少50万颗行星，大小差异巨大。其中除谷神星外最大的三颗，即『智神星』，『灶神星』，『婚神星』，被称为“小行星带三杰”。 其中『智神星』名Pallas，希腊神话中智慧女神雅典娜全名『帕拉斯·雅典娜』。 『灶神星』名Vesta，维斯塔是罗马神话中的女灶神，等同我们的灶王爷。 『婚神星』Juno，罗马神话中的朱诺，等同于希腊神话中的天后赫拉。司掌婚姻。 此外还有『灵神星』，『爱神星』，『花神星』，『虹神星』，『丽神星』，『幸神星』，『希神星』，『亡神星』，『创神星』，『坤神星』，『史神星』，『中神星』，命名亦有趣而具渊源。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"字符串匹配的KMP算法","date":"2018-05-13T13:40:32.000Z","path":"2018/05/13/字符串匹配的KMP算法/","text":"阅读 字符串匹配的KMP算法 leetcode-28 实现strStr() 从头到尾彻底理解KMP（ 帮你把KMP算法学个通透！（求next数组代码篇） https://www.zhihu.com/question/21474082 代码实现","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"实现单机开黑三国杀","date":"2018-05-12T16:22:53.000Z","path":"2018/05/13/实现单机开黑三国杀/","text":"Proxifier是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链 可以使用Proxifier,配置某个浏览器(如Safari)走代理，其他都走正常网络 首先需要开启xx软件，一般其Socks5监听地址及端口为127.0.0.1和1080 在Proxifier中，如下图，为Proxifier进行基础的代理设置 而后，新增一条Rules，设置Safari走代理 另，Default项配置不能移除： The Default rule cannot be removed. Proxifier uses it when all other rules do not match the connection parameters.， 指定所有的应用， 默认Direct直连。如果改为Proxy SOCKS5 127.0.0.1:1080,则所有应用都会走Socks5代理 打开Safari，则可看到，请求走了代理 在Safari中查看iP地址归属： 在Chrome中查看iP地址归属： 一些理论基础 socks代理和Socket有关联吗 没有 socks代理与http代理的比较 相较于http代理而言，socks代理工作在更底一层， 不需要知晓具体请求内容， 直接进行转发， 例如ss软件内部就使用了socks5代理技术。 socks5支持TCP、UDP网络协议，支持http,ftp等网络访问协议。而http代理只支持http/https的网络访问。 虽然看起来socks代理确实比http代理要更好一些， 但其实http代理可以被广大的软件所支持， 而socks代理的支持则稍微差一些， 所以实际上孰优孰劣就还是要根据使用场景. socks4和socks5代理的异同 socks4代理只支持TCP协议，socks5代理支持TCP和UDP协议，还支持各种身份验证机制，服务器端域名解析等。socks4能干的socks5都可以干，反过来就不行了，如ICQ只能用socks5代理，而ftp可以用socks4和socks5。 Chrome浏览器设置socks5代理 1.升级Chrome到最新版本，安装SwitchyOmega扩展程序，右键点击SwitchyOmega扩展程序图标，点击下拉菜单中的”选项”，就进入了SwitchyOmega扩展程序选项设置功能。 2.点击上图中”新建情景模式…”，在新建情景模式名称中输入socks5代理名称，选择”代理服务器”，点”创建”按钮。 3.代理协议选择”socks5”，输入socks5代理服务器的地址和端口，点”应用选项”按钮，应用设置。 4.访问需要使用socks5代理的网站，点击SwitchyOmega扩展程序图标，下拉菜单中点击”自动切换”，然后再点击”添加条件”，设置当前网站的情景模式为socks5代理服务器，点”添加条件”按钮，应用设置。 5.鼠标移动到SwitchyOmega扩展程序图标，信息提示中会显示当前网站使用了sokcs5代理服务器，再次刷新网页，如果socks5代理服务器工作正常地话，就可以正常打开网页了。 参考&amp;扩展: 在Chrome里使用哪种代理最快？ socks/SPDY/HTTP2的多路复用本质上和HTTP 1.1想要解决的问题是一样的：省掉重复建立TCP连接的开销。只是Google在做SPDY时还额外考虑了资源优先级等等之类的问题。理论上来讲多路复用的数据链路利用效率更高。 各种软件设置代理的一些方法","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"模拟一次真实的sql注入","date":"2018-05-08T14:38:58.000Z","path":"2018/05/08/模拟一次真实的sql注入/","text":"Gorm的使用 本地dashen库里有一张表a如下,现在使用Gorm对其进行操作 GORM中文文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" \"time\")func main() &#123; db, err := gorm.Open(\"mysql\", \"root:12345678@/dashen?charset=utf8&amp;parseTime=True&amp;loc=Local\") if err != nil &#123; panic(err) &#125; defer db.Close() var item A db.First(&amp;item) fmt.Println(\"item is:\", item) fmt.Println(\"item.Name is:\", item.Name)&#125;/**CREATE TABLE `a` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT '', `book` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;*/// 可通过该工具,将DDL转为对应的Go结构体 https://www.devtool.com/sql2go.htmltype A struct &#123; Id int `gorm:\"column:id;primary_key;AUTO_INCREMENT\" json:\"id\"` Name string `gorm:\"column:name\" json:\"name\"` Book string `gorm:\"column:book\" json:\"book\"` CreateTime time.Time `gorm:\"column:create_time;default:CURRENT_TIMESTAMP\" json:\"create_time\"`&#125;//func (A) TableName() string &#123;// return \"a\"//&#125; 执行程序,结果为: 12item is: &#123;0 0001-01-01 00:00:00 +0000 UTC&#125;item.Name is: 没有报错,说明连接成功. 但却没有查到数据,是因为表名和结构体没有建立映射关系 在此使用第二种方式,即实现TableName方法,使 表名和结构体建立映射关系, 123func (A) TableName() string &#123; return \"a\"&#125; 再次执行,就可以如愿查到数据: 12item is: &#123;1 晁盖 古典小说 2010-06-10 15:15:05 +0800 CST&#125;item.Name is: 晁盖 Gorm的更多花式操作 模拟sql注入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" \"time\")func main() &#123; db, err := gorm.Open(\"mysql\", \"root:12345678@/dashen?charset=utf8&amp;parseTime=True&amp;loc=Local\") if err != nil &#123; panic(err) &#125; defer db.Close() books, err := GetBooksInfo(db, 0, 10, \"*\", \"\", \"\", \"id &lt; ? \", 126) spew.Println(\"books are:\", books) books2, err2 := GetBooksInfo(db, 0, 10, \"*\", \"\", \",(select*from(select+sleep(2)union/**/select+1)a)\", \"id &lt; ? \", 126) spew.Println(\"books2, err2\", books2, err2)&#125;type A struct &#123; Id int `gorm:\"column:id;primary_key;AUTO_INCREMENT\" json:\"id\"` Name string `gorm:\"column:name\" json:\"name\"` Book string `gorm:\"column:book\" json:\"book\"` CreateTime time.Time `gorm:\"column:create_time;default:CURRENT_TIMESTAMP\" json:\"create_time\"`&#125;func (A) TableName() string &#123; return \"a\"&#125;func GetBooksInfo(db *gorm.DB, offset, limit int, field, order, sort, where string, params ...interface&#123;&#125;) (res []*A, err error) &#123; db = db.Select(field).Where(where, params...) if order == \"\" &#123; order = \"create_time\" &#125; if sort == \"\" &#123; sort = \"DESC\" &#125; db = db.Order(order + \" \" + sort) if limit &gt; 0 &#123; db = db.Limit(limit) &#125; if offset &gt; 0 &#123; db = db.Offset(offset) &#125; err = db.Find(&amp;res).Error if err != nil &#123; fmt.Printf(\"GetBooksInfo error (%+v): where (%s), params (%+v)\\n\", err, where, params) return &#125; if res == nil &#123; fmt.Printf(\"GetBooksInfo empty: where (%s), params (%+v)\\n\", where, params) res = make([]*A, 0) &#125; return&#125; 查询结果为: 12345books are: [&lt;*&gt;&#123;2 玉麒麟 施耐庵作品 2020-09-24 22:44:01 +0800 CST&#125; &lt;*&gt;&#123;3 吴用 &lt;水浒传&gt; 2018-12-06 19:59:53 +0800 CST&#125; &lt;*&gt;&#123;1-06-10 15:15:05 +0800 CST&#125;]GetBooksInfo error (Error 1242: Subquery returns more than 1 row): where (id &lt; ? ), params ([126])books2, err2 [] &lt;*&gt;Error 1242: Subquery returns more than 1 row 实际执行的sql: 1select * from a where id &lt; 126 order by (select*from(select+sleep(2)union/**/select+1)a) 如果后面接的是delete或者drop,那…故而,需要对每一个入参进行校验.或者对sql进行prepare预处理,提前变为二进制编码","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"go tool可选的那些参数","date":"2018-05-04T13:23:25.000Z","path":"2018/05/04/go-tool可选的那些参数/","text":"go tool asm file 将go汇编文件编译为 object（.o） 文件。 go tool compile file 将go文件编译为 .o 文件。 go tool compile -N -l -S file 将文件编译为汇编代码 或者使用：go build -gcflags -S x.go gcflags == go compile flags go tool compile：处理go文件，执行词法分析、语法分析、汇编、编译，输出obj文件 go tool asm：处理汇编文件（.s文件），输出obj文件 go tool pack：打包package下的所有obj文件，输出.a文件 go tool link：链接不同package的.a文件，输出可执行文件 go tool objdump：反汇编obj文件 go tool nm：输出obj文件、.a文件或可执行文件中定义的符号 ˙ Go 语言工具 官方文档 Command compile 得到Go程序的汇编代码的方法","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"go build可选的那些参数","date":"2018-05-03T13:21:02.000Z","path":"2018/05/03/go-build可选的那些参数/","text":"初入门径: go build [-o 输出名] [-i] [编译标记] [包名] -o output, 指定编译输出的名称,代替默认的包名 -i install 安装作为目标的依赖关系的包(用于增量编译提速) 通用的编译标记参数, 在go clean, get, install, list, run, test命令中也可以使用 包名, 可以是一个 .go文件. 本质上需要的是一个路径,让编译器可以找到那些需要编译的go文件.而有了packages这个参数后, go build就可以知道有哪些需要编译的go文件了 这几个都是可选参数,可以只执行go build 对于: 12345678 lltotal 32drwxr-xr-x 6 fliter staff 192 Jun 3 10:20 .drwxr-xr-x 15 fliter staff 480 Jun 2 21:22 ..-rw-r--r-- 1 fliter staff 115 Jun 3 09:31 add.go-rw-r--r-- 1 fliter staff 18 Jun 3 09:25 go.mod-rw-r--r-- 1 fliter staff 110 Jun 3 08:52 m.go-rw-r--r-- 1 fliter staff 166 Jun 3 08:52 sli.go go build和go build .等效,都是使用当前目录编译 (如果有多个 main方法,则会抛错): Go语言任何一个package中,都可以有唯一一个带有main方法的go文件. 也就是说,一个package下,只能有一个main方法,不管是在哪个文件中,但是只能有一个. (将sli.go和m.go中的main方法改掉) 编译同目录的多个源码文件时,执行go build,和在 go build 后提供多个文件名,效果一致: 通用的编译标记参数(即 编译时的附加参数) 附加参数 备注 -v 编译时显示包名 -p n 开启并发编译，默认情况下该值为 CPU 逻辑核数 -a 强制重新构建, 强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建,即使它们已是最新的 -n 打印编译时会用到的所有命令，但不真正执行 -x 打印编译时会用到的所有命令 -race 开启竞态检测 -work 打印出编译时生成的临时工作目录的路径,并在编译结束时保留它;在默认情况下,编译结束时会删除该目录 对add.go: 12345678910package mainimport \"fmt\"func add(x int, y int) int &#123; return x + y&#125;func main() &#123; fmt.Println(add(42, 13))&#125; 执行 go build -a -v add.go : 明明只用到了fmt包,为什么会多编译了这么多的代码包? 这是因为fmt包用到了其他基础包,且每段Go程序都要用到runtime包 从代码包编译的角度来说,如果代码包A依赖代码包B,则称代码包B是代码包A的依赖代码包（以下简称依赖包）,代码包A是代码包B的触发代码包（以下简称触发包） go build命令在执行时, 编译器会先查找目标代码包的所有依赖包,以及这些依赖包的依赖包,直至找到最深层的依赖包为止. 在此过程中,如发现有循环依赖的情况,编译器就会输出错误信息并立即退出. 此过程完成后,所有依赖关系也就形成了一棵含有重复元素的依赖树. 对于依赖树中的一个节点（代码包）来说,它的直接分支节点（前者的依赖包）,是按照代码包导入路径的字典序从左到右排列的. 最左边的分支节点会最先被编译, 编译器会依此设定每个代码包的编译优先级 去掉fmt代码,如下: 12345678package mainfunc add(x int, y int) int &#123; return x + y&#125;func main() &#123;&#125; 即便一个包也不引用,程序依然在底层用到了上面这几个包. 使用- work参数,打印出编译时生成的临时工作目录的路径,并在编译结束时保留它: 执行go build命令的计算机如果拥有多个逻辑CPU核心,那么编译代码包的顺序可能会存在一些不确定性. 但一定会满足这样的约束条件：依赖代码包 -&gt; 当前代码包 -&gt; 触发代码包 标记-p n可以限制编译过程中任务执行的并发数,n默认为当前计算机的CPU逻辑核数. 如果在执行go build命令时加入标记-p 1, 那么就可以保证代码包编译顺序严格按照预先设定好的优先级进行 将如上代码中的fmt加回,再执行go build -a -v -p 1 add.go 可以认为上图显示的代码包的顺序,就是add直接或间接依赖的代码包按照优先级从高到低排列后的排序 另外,如果在命令中加入标记-n,那么编译器只会输出所用到的命令而不会真正运行,在这种情况下,编译过程不会使用并发模式(即 -p 1) 进阶编译标记参数: -asmflags 此标记可以后跟另外一些标记，如-D、-I、-S等。这些后跟的标记用于控制Go语言编译器编译汇编语言文件时的行为。 -buildmode 此标记用于指定编译模式，使用方式如-buildmode=default（这等同于默认情况下的设置）。此标记支持的编译模式目前有6种。借此，我们可以控制编译器在编译完成后生成静态链接库（即.a文件，也就是我们之前说的归档文件）、动态链接库（即.so文件）或/和可执行文件（在Windows下是.exe文件）。 -compiler 此标记用于指定当前使用的编译器的名称。其值可以为gc或gccgo。其中，gc编译器即为Go语言自带的编辑器，而gccgo编译器则为GCC提供的Go语言编译器。而GCC则是GNU项目出品的编译器套件。GNU是一个众所周知的自由软件项目。在开源软件界不应该有人不知道它。好吧，如果你确实不知道它，赶紧去google吧。 -gccgoflags 此标记用于指定需要传递给gccgo编译器或链接器的标记的列表。 -gcflags 此标记用于指定需要传递给go tool compile命令的标记的列表。 -gcflags=”all=-N -l” -N 取消优化 -l 取消内联 -m 逃逸分析，打印逃逸信息 go build -gcflags=-S fmt 仅打印fmt包的反汇编信息 go build -gcflags=all=-S fmt’ 打印fmt以及其依赖包的反汇编信息 得到Go程序的汇编代码的方法 -installsuffix 为了使当前的输出目录与默认的编译输出目录分离，可以使用这个标记。此标记的值会作为结果文件的父目录名称的后缀。其实，如果使用了-race标记，这个标记会被自动追加且其值会为race。如果我们同时使用了-race标记和-installsuffix，那么在-installsuffix标记的值的后面会再被追加_race，并以此来作为实际使用的后缀。 -ldflags 此标记用于指定需要传递给go tool link命令的标记的列表。 -linkshared 此标记用于与-buildmode=shared一同使用。后者会使作为编译目标的非main代码包都被合并到一个动态链接库文件中，而前者则会在此之上进行链接操作。 -pkgdir 使用此标记可以指定一个目录。编译器会只从该目录中加载代码包的归档文件，并会把编译可能会生成的代码包归档文件放置在该目录下。 -tags 此标记用于指定在实际编译期间需要受理的编译标签（也可被称为编译约束）的列表。这些编译标签一般会作为源码文件开始处的注释的一部分，例如，在$GOROOT/src/os/file_posix.go开始处的注释为： 12345// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris windows 最后一行注释即包含了与编译标签有关的内容。可以查看代码包go/build的文档已获得更多的关于编译标签的信息。 -toolexec 此标记可以让我们去自定义在编译期间使用一些Go语言自带工具（如vet、asm等）的方式。 参考: go build go build命令详解","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Mac上Python多版本及包安装的问题","date":"2018-04-28T12:03:50.000Z","path":"2018/04/28/Mac上Python多版本及包安装的问题/","text":"使用PyCharm，可以解决各种版本问题…","tags":[{"name":"Python","slug":"Python","permalink":"http://www.dashen.tech/tags/Python/"}]},{"title":"Rust处理Json","date":"2018-04-26T15:47:33.000Z","path":"2018/04/26/Rust处理Json/","text":"基本操作 Cargo.toml: 123456789101112[package]name = \"json\"version = \"0.1.0\"edition = \"2021\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]serde = &#123; version = \"1\", features = [\"derive\"] &#125;serde_json = \"1\"tokio = &#123; version = \"1\", features = [\"full\"] &#125;warp = \"0.3\" main.rs:1234567891011121314151617181920use serde::&#123;Deserialize, Serialize&#125;;#[derive(Debug, Deserialize, Serialize)]struct Person &#123; name: String, age: i64,&#125;fn main() &#123; let json_str = r#\" &#123; \"name\": \"dashen\", \"age\": 18 &#125; \"#; let person: Person = serde_json::from_str(json_str).unwrap(); println!(\"&#123;:?&#125;\", person)&#125; 输出为： 1Person &#123; name: \"dashen\", age: 18 &#125; 嵌套结构体 warp 1234567891011121314151617181920212223242526272829303132use serde::&#123;Deserialize, Serialize&#125;;use warp::Filter;#[derive(Debug, Deserialize, Serialize)]struct Person &#123; name: String, age: i64,&#125;#[derive(Debug, Deserialize, Serialize)]struct Demo &#123; name: String, person: Person,&#125;#[tokio::main]async fn main() &#123; let hello = warp::path!(\"json\") .map(|| warp::reply::json( &amp;Demo &#123; name: \"geek\".to_string(), person: Person &#123; name: \"dashen\".to_string(), age: 28, &#125;, &#125; )); warp::serve(hello) .run(([127, 0, 0, 1], 3030)).await;&#125; 返回不同的结构(一般用枚举来解决) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use serde::&#123;Deserialize, Serialize&#125;;use warp::Filter;#[derive(Debug, Deserialize, Serialize)]struct Person &#123; name: String, age: i64,&#125;#[derive(Debug, Deserialize, Serialize)]struct Demo &#123; name: String, person: Person, shape: Shape,&#125;#[derive(Debug, Deserialize, Serialize)]#[serde(rename_all = \"lowercase\", tag = \"shape\")] // 处理成小写，同时加一个tag区分啥形状enum Shape &#123; Circle &#123; radius: f64, &#125;, Rectangle &#123; length: f64, width: f64, &#125;,&#125;#[tokio::main]async fn main() &#123; let hello = warp::path!(\"json\") .map(|| warp::reply::json( &amp;Demo &#123; name: \"geek\".to_string(), person: Person &#123; name: \"dashen\".to_string(), age: 28, &#125;, shape: Shape::Circle &#123; radius: 3.5 &#125;, &#125; )); warp::serve(hello) .run(([127, 0, 0, 1], 3030)).await;&#125;","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"详解一行小命令","date":"2018-04-26T13:53:02.000Z","path":"2018/04/26/详解一行小命令/","text":"netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a,S[a]}&#39; 这行命令,可以打印出各个状态的数量 awk是如何做到的呢?一步步分拆来看: netstat -n 如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646&lt;shuangcui@~&gt;$ netstat -nActive Internet connectionsProto Recv-Q Send-Q Local Address Foreign Address (state)tcp4 0 0 127.0.0.1.54490 127.0.0.1.54491 ESTABLISHEDtcp4 0 0 127.0.0.1.54491 127.0.0.1.54490 ESTABLISHEDtcp4 0 0 10.251.12.65.54475 203.208.50.35.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54431 194.147.35.147.15895 ESTABLISHEDtcp4 0 0 127.0.0.1.1080 127.0.0.1.54430 ESTABLISHEDtcp4 0 0 127.0.0.1.54430 127.0.0.1.1080 ESTABLISHEDtcp4 0 0 10.251.12.65.54397 180.76.199.158.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54390 59.111.179.136.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54383 114.80.30.48.80 CLOSE_WAITtcp4 0 0 10.251.12.65.54382 114.80.30.48.80 CLOSE_WAITtcp4 0 0 10.251.12.65.54381 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54380 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54379 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54376 194.147.35.147.15895 ESTABLISHEDtcp4 0 0 127.0.0.1.1080 127.0.0.1.54375 ESTABLISHEDtcp4 0 0 127.0.0.1.54375 127.0.0.1.1080 ESTABLISHEDtcp4 0 0 10.251.12.65.54368 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54367 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54366 122.246.6.14.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54352 212.64.62.174.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54351 212.64.62.174.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54350 212.64.62.174.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54333 59.111.179.136.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54319 194.147.35.147.15895 ESTABLISHEDtcp4 0 0 127.0.0.1.1080 127.0.0.1.54318 ESTABLISHEDtcp4 0 0 127.0.0.1.54318 127.0.0.1.1080 ESTABLISHEDtcp4 0 0 10.251.12.65.54288 104.243.17.131.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54283 118.126.97.71.80 ESTABLISHEDtcp4 0 0 10.251.12.65.54052 10.9.25.53.80 ESTABLISHEDtcp4 0 0 10.251.12.65.53433 140.82.113.25.443 ESTABLISHEDtcp4 0 0 10.251.12.65.53296 122.228.2.250.80 CLOSE_WAITtcp4 0 0 10.251.12.65.53094 113.96.237.18.443 ESTABLISHEDtcp4 31 0 10.251.12.65.52388 110.43.81.8.443 CLOSE_WAITtcp4 31 0 10.251.12.65.52385 110.43.81.8.443 CLOSE_WAITtcp4 0 0 10.251.12.65.52366 101.89.125.232.80 CLOSE_WAITtcp4 31 0 10.251.12.65.52353 114.112.66.45.443 CLOSE_WAITtcp4 0 0 10.251.12.65.51939 10.9.44.194.7001 ESTABLISHEDtcp4 0 0 10.251.12.65.51938 10.9.44.194.7002 ESTABLISHEDtcp4 0 0 10.251.12.65.51937 10.9.44.194.7000 ESTABLISHEDtcp4 0 0 10.251.12.65.51921 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51920 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51919 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51918 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51917 10.9.25.53.80 ESTABLISHEDtcp4 0 0 10.251.12.65.60346 52.11.35.6.443 ESTABLISHEDtcp4 0 0 10.251.12.65.63898 17.188.166.20.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52766 61.151.165.0.80 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52765 fe80::aede:48ff:.52032 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52750 fe80::aede:48ff:.61000 ESTABLISHEDtcp4 0 0 10.251.12.65.52699 17.57.145.6.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52680 114.221.148.67.8080 ESTABLISHEDtcp4 0 0 10.251.12.65.52677 203.119.129.64.443 ESTABLISHEDtcp4 0 0 127.0.0.1.63342 127.0.0.1.52602 ESTABLISHEDtcp4 0 0 127.0.0.1.52602 127.0.0.1.63342 ESTABLISHEDtcp4 0 0 10.251.12.65.52975 118.126.97.71.22 ESTABLISHEDtcp4 0 0 127.0.0.1.54406 127.0.0.1.54405 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54407 TIME_WAITtcp4 0 0 127.0.0.1.54409 127.0.0.1.54408 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54412 TIME_WAITtcp4 0 0 127.0.0.1.54414 127.0.0.1.54413 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54415 TIME_WAITtcp4 0 0 127.0.0.1.54417 127.0.0.1.54416 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54418 TIME_WAITtcp4 0 0 127.0.0.1.54420 127.0.0.1.54419 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54421 TIME_WAITtcp4 0 0 10.251.12.65.54392 59.111.179.136.443 TIME_WAITtcp4 0 0 127.0.0.1.54423 127.0.0.1.54422 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54424 TIME_WAITtcp4 0 0 127.0.0.1.54426 127.0.0.1.54425 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54427 TIME_WAITtcp4 0 0 127.0.0.1.1080 127.0.0.1.54218 TIME_WAITtcp4 0 0 127.0.0.1.54429 127.0.0.1.54428 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54432 TIME_WAITtcp4 0 0 10.251.12.65.54219 194.147.35.147.15895 TIME_WAITtcp4 0 0 127.0.0.1.54434 127.0.0.1.54433 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54435 TIME_WAITtcp4 0 0 127.0.0.1.54437 127.0.0.1.54436 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54440 TIME_WAITtcp4 0 0 127.0.0.1.54442 127.0.0.1.54441 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54443 TIME_WAITtcp4 0 0 127.0.0.1.54445 127.0.0.1.54444 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54446 TIME_WAITtcp4 0 0 127.0.0.1.54448 127.0.0.1.54447 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54449 TIME_WAITtcp4 0 0 127.0.0.1.54451 127.0.0.1.54450 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54452 TIME_WAITtcp4 0 0 127.0.0.1.54454 127.0.0.1.54453 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54455 TIME_WAITtcp4 0 0 127.0.0.1.54457 127.0.0.1.54456 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54458 TIME_WAITtcp4 0 0 127.0.0.1.54460 127.0.0.1.54459 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54461 TIME_WAITtcp4 0 0 127.0.0.1.54463 127.0.0.1.54462 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54466 TIME_WAITtcp4 0 0 127.0.0.1.54468 127.0.0.1.54467 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54469 TIME_WAITtcp4 0 0 127.0.0.1.54471 127.0.0.1.54470 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54472 TIME_WAITtcp4 0 0 127.0.0.1.54474 127.0.0.1.54473 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54476 TIME_WAITtcp4 0 0 127.0.0.1.54478 127.0.0.1.54477 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54479 TIME_WAITtcp4 0 0 127.0.0.1.1080 127.0.0.1.54267 TIME_WAITtcp4 0 0 127.0.0.1.54481 127.0.0.1.54480 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54482 TIME_WAITtcp4 0 0 10.251.12.65.54268 194.147.35.147.15895 TIME_WAITtcp4 0 0 127.0.0.1.54484 127.0.0.1.54483 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54486 TIME_WAITtcp4 0 0 127.0.0.1.54488 127.0.0.1.54487 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54489 TIME_WAITudp4 0 0 127.0.0.1.61294 127.0.0.1.62523udp4 0 0 127.0.0.1.62523 127.0.0.1.61294udp4 0 0 127.0.0.1.56688 *.*udp4 0 0 10.251.12.65.62732 10.9.37.12.6831udp4 0 0 *.59612 *.*udp4 0 0 *.53034 *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp46 0 0 *.5353 *.*udp46 0 0 *.5353 *.*udp46 0 0 *.5353 *.*udp46 0 0 *.5353 *.*udp4 0 0 *.5353 *.*udp46 0 0 *.5353 *.*udp4 0 0 *.5353 *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp6 0 0 *.53532 *.*udp4 0 0 *.53532 *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.51891 *.*udp4 0 0 *.* *.*udp6 0 0 *.61233 *.*udp4 0 0 *.61233 *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp46 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 *.* *.*udp4 0 0 127.0.0.1.60335 127.0.0.1.53411udp4 0 0 127.0.0.1.53411 127.0.0.1.60335udp4 0 0 *.* *.*udp6 0 0 *.5353 *.*udp4 0 0 *.5353 *.*udp4 0 0 *.* *.*udp4 0 0 *.138 *.*udp4 0 0 *.137 *.*Active Multipath Internet connectionsProto/ID Flags Local Address Foreign Address (state)Active LOCAL (UNIX) domain socketsAddress Type Recv-Q Send-Q Inode Conn Refs Nextref Addrcbd0642ad1094d13 stream 0 0 0 cbd0642ad10938c3 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.uUZwd1cbd0642ad10938c3 stream 0 0 0 cbd0642ad1094d13 0 0cbd0642ad1092923 stream 0 0 0 cbd0642ad10929eb 0 0 ./QingBanGong_LocalPushcbd0642ad10929eb stream 0 0 0 cbd0642ad1092923 0 0cbd0642ad1092d0b stream 0 0 0 cbd0642ad1092e9b 0 0cbd0642ad1092e9b stream 0 0 0 cbd0642ad1092d0b 0 0cbd0642ad1094f6b stream 0 0 cbd0642ae0d2d2cb 0 0 0 ./wpsofficecbd0642ad1094c4b stream 0 0 0 cbd0642ad1094b83 0 0 ./recentfile_servercbd0642ad1094b83 stream 0 0 0 cbd0642ad1094c4b 0 0cbd0642ad10931bb stream 0 0 0 cbd0642ad10935a3 0 0 /var/run/mDNSRespondercbd0642ad10935a3 stream 0 0 0 cbd0642ad10931bb 0 0cbd0642ad109447b stream 0 0 0 cbd0642ad10943b3 0 0 ./_Thrift_Qing_IPC_cbd0642ad10943b3 stream 0 0 0 cbd0642ad109447b 0 0cbd0642ad1093a53 stream 0 0 0 cbd0642ad1094abb 0 0 /var/run/mDNSRespondercbd0642ad1094abb stream 0 0 0 cbd0642ad1093a53 0 0cbd0642ad1093413 stream 0 0 0 cbd0642ad1093fcb 0 0 /var/run/mDNSRespondercbd0642ad1093fcb stream 0 0 0 cbd0642ad1093413 0 0cbd0642ad1093283 stream 0 0 0 cbd0642ad10942eb 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.Jx4w3acbd0642ad10942eb stream 0 0 0 cbd0642ad1093283 0 0cbd0642ad10934db stream 0 0 0 cbd0642ad109492b 0 0cbd0642ad109492b stream 0 0 0 cbd0642ad10934db 0 0cbd0642ad10946d3 stream 0 0 0 cbd0642ad109334b 0 0cbd0642ad109334b stream 0 0 0 cbd0642ad10946d3 0 0cbd0642ad10949f3 stream 0 0 0 cbd0642ad109366b 0 0cbd0642ad109366b stream 0 0 0 cbd0642ad10949f3 0 0cbd0642ad1094863 stream 0 0 0 cbd0642ad109415b 0 0cbd0642ad109415b stream 0 0 0 cbd0642ad1094863 0 0cbd0642ad1094223 stream 0 0 0 cbd0642acefba793 0 0cbd0642acefba793 stream 0 0 0 cbd0642ad1094223 0 0cbd0642acefbc093 stream 0 0 0 cbd0642acefbd033 0 0cbd0642acefbd033 stream 0 0 0 cbd0642acefbc093 0 0cbd0642acefbac43 stream 0 0 0 cbd0642acefbc60b 0 0cbd0642acefbc60b stream 0 0 0 cbd0642acefbac43 0 0cbd0642acefbbfcb stream 0 0 0 cbd0642acefba9eb 0 0cbd0642acefba9eb stream 0 0 0 cbd0642acefbbfcb 0 0cbd0642acefbd28b stream 0 0 0 cbd0642acefbd41b 0 0cbd0642acefbd41b stream 0 0 0 cbd0642acefbd28b 0 0cbd0642ac254a4e3 stream 0 0 0 cbd0642ac7b0dabb 0 0cbd0642ac7b0dabb stream 0 0 0 cbd0642ac254a4e3 0 0cbd0642ac7b0c8c3 stream 0 0 0 cbd0642ac7b0c7fb 0 0cbd0642ac7b0c7fb stream 0 0 0 cbd0642ac7b0c8c3 0 0cbd0642ac7b0e1c3 stream 0 0 0 cbd0642ac7b0db83 0 0cbd0642ac7b0db83 stream 0 0 0 cbd0642ac7b0e1c3 0 0cbd0642ac7b0d9f3 stream 0 0 0 cbd0642ac7b0c66b 0 0cbd0642ac7b0c66b stream 0 0 0 cbd0642ac7b0d9f3 0 0cbd0642acc776abb stream 0 0 0 cbd0642acc7769f3 0 0cbd0642acc7769f3 stream 0 0 0 cbd0642acc776abb 0 0cbd0642acc774b7b stream 0 0 0 cbd0642acc7770fb 0 0cbd0642acc7770fb stream 0 0 0 cbd0642acc774b7b 0 0cbd0642ac5fa5923 stream 0 0 0 cbd0642ac5fa5793 0 0cbd0642ac5fa5793 stream 0 0 0 cbd0642ac5fa5923 0 0cbd0642ac5fa6e3b stream 0 0 0 cbd0642ac5fa5f63 0 0cbd0642ac5fa5f63 stream 0 0 0 cbd0642ac5fa6e3b 0 0cbd0642ac5fa779b stream 0 0 0 cbd0642ac5fa7f6b 0 0cbd0642ac5fa7f6b stream 0 0 0 cbd0642ac5fa779b 0 0cbd0642ac5fa760b stream 0 0 0 cbd0642ac5fa73b3 0 0cbd0642ac5fa73b3 stream 0 0 0 cbd0642ac5fa760b 0 0cbd0642ac5fa80fb stream 0 0 0 cbd0642ac5fa85ab 0 0cbd0642ac5fa85ab stream 0 0 0 cbd0642ac5fa80fb 0 0cbd0642ac5fa84e3 stream 0 0 0 cbd0642ac5fa634b 0 0cbd0642ac5fa634b stream 0 0 0 cbd0642ac5fa84e3 0 0cbd0642ac5fa76d3 stream 0 0 0 cbd0642ac5fa64db 0 0cbd0642ac5fa64db stream 0 0 0 cbd0642ac5fa76d3 0 0cbd0642ac5fa6413 stream 0 0 0 cbd0642ac5fa6a53 0 0cbd0642ac5fa6a53 stream 0 0 0 cbd0642ac5fa6413 0 0cbd0642ac5fa715b stream 0 0 0 cbd0642ac5fa7ddb 0 0cbd0642ac5fa7ddb stream 0 0 0 cbd0642ac5fa715b 0 0cbd0642ac5fa5e9b stream 0 0 0 cbd0642ac5fa6283 0 0cbd0642ac5fa6283 stream 0 0 0 cbd0642ac5fa5e9b 0 0cbd0642ac5fa79f3 stream 0 0 0 cbd0642ac5fa7abb 0 0cbd0642ac5fa7abb stream 0 0 0 cbd0642ac5fa79f3 0 0cbd0642ac5fa72eb stream 0 0 0 cbd0642ac5fa6fcb 0 0cbd0642ac5fa6fcb stream 0 0 0 cbd0642ac5fa72eb 0 0cbd0642ac5fa59eb stream 0 0 0 cbd0642ac5fa602b 0 0cbd0642ac5fa602b stream 0 0 0 cbd0642ac5fa59eb 0 0cbd0642ac5fa841b stream 0 0 0 cbd0642ac5fa56cb 0 0cbd0642ac5fa56cb stream 0 0 0 cbd0642ac5fa841b 0 0cbd0642ac5fa7863 stream 0 0 0 cbd0642ac5fa6b1b 0 0cbd0642ac5fa6b1b stream 0 0 0 cbd0642ac5fa7863 0 0cbd0642ac5fa5ab3 stream 0 0 0 cbd0642ac5fa585b 0 0cbd0642ac5fa585b stream 0 0 0 cbd0642ac5fa5ab3 0 0cbd0642ad10926cb stream 0 0 0 cbd0642ad10954e3 0 0cbd0642ad10954e3 stream 0 0 0 cbd0642ad10926cb 0 0cbd0642ad109541b stream 0 0 0 cbd0642ad1092793 0 0 /var/run/mDNSRespondercbd0642ad1092793 stream 0 0 0 cbd0642ad109541b 0 0cbd0642ad109460b stream 0 0 0 cbd0642ad1094543 0 0 /var/run/mDNSRespondercbd0642ad1094543 stream 0 0 0 cbd0642ad109460b 0 0cbd0642ad1094093 stream 0 0 0 cbd0642ad1093b1b 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.uD8BzLcbd0642ad1093b1b stream 0 0 0 cbd0642ad1094093 0 0cbd0642ad1093be3 stream 0 0 0 cbd0642ad1093d73 0 0cbd0642ad1093d73 stream 0 0 0 cbd0642ad1093be3 0 0cbd0642ad1093cab stream 0 0 0 cbd0642ac7b0c733 0 0cbd0642ac7b0c733 stream 0 0 0 cbd0642ad1093cab 0 0cbd0642acc77741b stream 0 0 0 cbd0642acc7754db 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.q4FdtRcbd0642acc7754db stream 0 0 0 cbd0642acc77741b 0 0cbd0642ac5fa7b83 stream 0 0 0 cbd0642ac5fa6cab 0 0 /var/run/mDNSRespondercbd0642ac5fa6cab stream 0 0 0 cbd0642ac5fa7b83 0 0cbd0642ac5fa666b stream 0 0 0 cbd0642ac5fa6be3 0 0 /var/run/mDNSRespondercbd0642ac5fa6be3 stream 0 0 0 cbd0642ac5fa666b 0 0cbd0642ac5fa6733 stream 0 0 0 cbd0642ac5fa6d73 0 0 /var/run/mDNSRespondercbd0642ac5fa6d73 stream 0 0 0 cbd0642ac5fa6733 0 0cbd0642ac5fa6f03 stream 0 0 0 cbd0642ac5fa65a3 0 0 /var/run/mDNSRespondercbd0642ac5fa65a3 stream 0 0 0 cbd0642ac5fa6f03 0 0cbd0642ac5fa7d13 stream 0 0 0 cbd0642ac5fa792b 0 0 /var/run/mDNSRespondercbd0642ac5fa792b stream 0 0 0 cbd0642ac5fa7d13 0 0cbd0642ac5fa7093 stream 0 0 0 cbd0642ac5fa60f3 0 0 /var/run/mDNSRespondercbd0642ac5fa60f3 stream 0 0 0 cbd0642ac5fa7093 0 0cbd0642ac5fa61bb stream 0 0 0 cbd0642ac5fa7223 0 0 ./_Thrift_Qing_IPC_cbd0642ac5fa7223 stream 0 0 0 cbd0642ac5fa61bb 0 0cbd0642ac5fa747b stream 0 0 cbd0642acf09d4cb 0 0 0 ./QingBanGong_LocalPushcbd0642ac5fa5b7b stream 0 0 cbd0642adceb80cb 0 0 0 ./_#_QingBanGong_Server_#_cbd0642ac5fa81c3 stream 0 0 cbd0642ae29746cb 0 0 0 ./ELiveClient_LiveCentercbd0642ac5fa5d0b stream 0 0 cbd0642adceb7fcb 0 0 0 ./_Thrift_Qing_IPC_2_cbd0642ac5fa5dd3 stream 0 0 cbd0642adc0b24cb 0 0 0 ./_Thrift_Qing_IPC_cbd0642ac5fa5c43 stream 0 0 cbd0642ae045fdcb 0 0 0 ./recentfile_servercbd0642ac5fa828b stream 0 0 0 cbd0642ac5fa8353 0 0 /var/run/mDNSRespondercbd0642ac5fa8353 stream 0 0 0 cbd0642ac5fa828b 0 0cbd0642ac5fa7543 stream 0 0 cbd0642ac85022cb 0 0 0 ./WpsCloudSvrcbd0642acefbd0fb stream 0 0 0 cbd0642acefba85b 0 0cbd0642acefba85b stream 0 0 0 cbd0642acefbd0fb 0 0cbd0642acefbcea3 stream 0 0 0 cbd0642acefbab7b 0 0 /var/run/mDNSRespondercbd0642acefbab7b stream 0 0 0 cbd0642acefbcea3 0 0cbd0642acefbcd13 stream 0 0 0 cbd0642acefbcddb 0 0 /var/run/mDNSRespondercbd0642acefbcddb stream 0 0 0 cbd0642acefbcd13 0 0cbd0642acefbc6d3 stream 0 0 0 cbd0642acefbc92b 0 0 /var/run/mDNSRespondercbd0642acefbc92b stream 0 0 0 cbd0642acefbc6d3 0 0cbd0642acefbc79b stream 0 0 cbd0642ad7e7b9cb 0 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/.com.google.Chrome.ss4bAO/SingletonSocketcbd0642acefbae9b stream 0 0 0 cbd0642acefbb4db 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.rBcF2ecbd0642acefbb4db stream 0 0 0 cbd0642acefbae9b 0 0cbd0642acefbb0f3 stream 0 0 0 cbd0642acefbb1bb 0 0 /var/run/mDNSRespondercbd0642acefbb1bb stream 0 0 0 cbd0642acefbb0f3 0 0cbd0642acefbb7fb stream 0 0 0 cbd0642acefbc543 0 0 /var/run/mDNSRespondercbd0642acefbc543 stream 0 0 0 cbd0642acefbb7fb 0 0cbd0642acefbb733 stream 0 0 0 0 0 0cbd0642acefbc15b stream 0 0 0 0 0 0cbd0642acefbb413 stream 0 0 0 cbd0642acefbc3b3 0 0 /var/run/mDNSRespondercbd0642acefbc3b3 stream 0 0 0 cbd0642acefbb413 0 0cbd0642acefbc9f3 stream 0 0 0 cbd0642acefbb66b 0 0 /var/run/mDNSRespondercbd0642acefbb66b stream 0 0 0 cbd0642acefbc9f3 0 0cbd0642acefbb5a3 stream 0 0 0 cbd0642acefbb283 0 0 /var/run/mDNSRespondercbd0642acefbb283 stream 0 0 0 cbd0642acefbb5a3 0 0cbd0642acefbbf03 stream 0 0 0 cbd0642acefbba53 0 0 /var/run/mDNSRespondercbd0642acefbba53 stream 0 0 0 cbd0642acefbbf03 0 0cbd0642acefbbd73 stream 0 0 0 cbd0642acefbbbe3 0 0 /var/run/usbmuxdcbd0642acefbbbe3 stream 0 0 0 cbd0642acefbbd73 0 0cbd0642acefbbb1b stream 0 0 0 cbd0642acefbbe3b 0 0 /var/run/mDNSRespondercbd0642acefbbe3b stream 0 0 0 cbd0642acefbbb1b 0 0cbd0642acefbbcab stream 0 0 0 cbd0642acefbb98b 0 0cbd0642acefbb98b stream 0 0 0 cbd0642acefbbcab 0 0cbd0642acc77728b stream 0 0 0 cbd0642acc7749eb 0 0cbd0642acc7749eb stream 0 0 0 cbd0642acc77728b 0 0cbd0642acc776ddb stream 0 0 0 cbd0642acc774923 0 0cbd0642acc774923 stream 0 0 0 cbd0642acc776ddb 0 0cbd0642acc775733 stream 0 0 0 cbd0642acc776863 0 0 /var/run/mDNSRespondercbd0642acc776863 stream 0 0 0 cbd0642acc775733 0 0cbd0642acc77485b stream 0 0 0 cbd0642acc774793 0 0cbd0642acc774793 stream 0 0 0 cbd0642acc77485b 0 0cbd0642acc774f63 stream 0 0 cbd0642aceea6ecb 0 0 0 /tmp/mysql.sockcbd0642acc774c43 stream 0 0 0 cbd0642acc77534b 0 0cbd0642acc77534b stream 0 0 0 cbd0642acc774c43 0 0cbd0642acc77502b stream 0 0 cbd0642acead4fcb 0 0 0 /Users/shuangcui/Library/Application Support/DingTalkMac/dingtalk-ddcbd0642acc7751bb stream 0 0 cbd0642ace3bb3cb 0 0 0 /tmp/.vnc-501/vncagent.02190c267311edcbcbd0642acc776b83 stream 0 0 0 cbd0642acc7750f3 0 0cbd0642acc7750f3 stream 0 0 0 cbd0642acc776b83 0 0cbd0642acc77679b stream 0 0 0 cbd0642acc7757fb 0 0 /var/run/mDNSRespondercbd0642acc7757fb stream 0 0 0 cbd0642acc77679b 0 0cbd0642acc7766d3 stream 0 0 0 cbd0642acc7758c3 0 0 /var/run/mDNSRespondercbd0642acc7758c3 stream 0 0 0 cbd0642acc7766d3 0 0cbd0642acc77660b stream 0 0 0 cbd0642acc77598b 0 0 /var/run/mDNSRespondercbd0642acc77598b stream 0 0 0 cbd0642acc77660b 0 0cbd0642acc775a53 stream 0 0 0 cbd0642acc775b1b 0 0 /var/run/mDNSRespondercbd0642acc776543 stream 0 0 0 cbd0642acc77647b 0 0 /var/run/mDNSRespondercbd0642acc775b1b stream 0 0 0 cbd0642acc775a53 0 0cbd0642acc77647b stream 0 0 0 cbd0642acc776543 0 0cbd0642acc7763b3 stream 0 0 0 cbd0642acc7762eb 0 0 /var/run/mDNSRespondercbd0642acc775e3b stream 0 0 0 cbd0642acc776223 0 0 /var/run/mDNSRespondercbd0642acc7762eb stream 0 0 0 cbd0642acc7763b3 0 0cbd0642acc776223 stream 0 0 0 cbd0642acc775e3b 0 0cbd0642acc775fcb stream 0 0 0 cbd0642acc775d73 0 0 /var/run/mDNSRespondercbd0642acc775cab stream 0 0 0 cbd0642acc775be3 0 0 /var/run/mDNSRespondercbd0642acc775d73 stream 0 0 0 cbd0642acc775fcb 0 0cbd0642acc775be3 stream 0 0 0 cbd0642acc775cab 0 0cbd0642acc77615b stream 0 0 0 cbd0642acc776093 0 0 /var/run/mDNSRespondercbd0642acc776093 stream 0 0 0 cbd0642acc77615b 0 0cbd0642acc775f03 stream 0 0 0 cbd0642ac254785b 0 0cbd0642ac254785b stream 0 0 0 cbd0642acc775f03 0 0cbd0642ac7b0b6cb stream 0 0 0 cbd0642ac7b0e4e3 0 0 /var/run/mDNSRespondercbd0642ac7b0e4e3 stream 0 0 0 cbd0642ac7b0b6cb 0 0cbd0642ac7b0e28b stream 0 0 0 cbd0642ac7b0e033 0 0 /var/run/mDNSRespondercbd0642ac7b0e033 stream 0 0 0 cbd0642ac7b0e28b 0 0cbd0642ac7b0e353 stream 0 0 0 cbd0642ac7b0dea3 0 0 /var/run/mDNSRespondercbd0642ac7b0dea3 stream 0 0 0 cbd0642ac7b0e353 0 0cbd0642ac7b0bd0b stream 0 0 0 cbd0642ac7b0b923 0 0 /var/run/mDNSRespondercbd0642ac7b0b923 stream 0 0 0 cbd0642ac7b0bd0b 0 0cbd0642ac7b0bab3 stream 0 0 0 cbd0642ac7b0bb7b 0 0 /var/run/mDNSRespondercbd0642ac7b0bb7b stream 0 0 0 cbd0642ac7b0bab3 0 0cbd0642ac7b0b9eb stream 0 0 0 cbd0642ac7b0df6b 0 0 /var/run/mDNSRespondercbd0642ac7b0df6b stream 0 0 0 cbd0642ac7b0b9eb 0 0cbd0642ac7b0dd13 stream 0 0 0 cbd0642ac7b0bdd3 0 0cbd0642ac7b0bdd3 stream 0 0 0 cbd0642ac7b0dd13 0 0cbd0642ac7b0be9b stream 0 0 0 cbd0642ac7b0bf63 0 0cbd0642ac7b0bf63 stream 0 0 0 cbd0642ac7b0be9b 0 0cbd0642ac7b0dc4b stream 0 0 0 cbd0642ac7b0c02b 0 0cbd0642ac7b0c02b stream 0 0 0 cbd0642ac7b0dc4b 0 0cbd0642ac7b0c0f3 stream 0 0 0 cbd0642ac7b0c5a3 0 0cbd0642ac7b0c5a3 stream 0 0 0 cbd0642ac7b0c0f3 0 0cbd0642ac7b0c34b stream 0 0 0 cbd0642ac7b0c413 0 0 /var/run/mDNSRespondercbd0642ac7b0c413 stream 0 0 0 cbd0642ac7b0c34b 0 0cbd0642ac7b0cd73 stream 0 0 0 cbd0642ac7b0d223 0 0 /var/run/mDNSRespondercbd0642ac7b0d223 stream 0 0 0 cbd0642ac7b0cd73 0 0cbd0642ac7b0c98b stream 0 0 0 cbd0642ac7b0d92b 0 0 /var/run/usbmuxdcbd0642ac7b0d92b stream 0 0 0 cbd0642ac7b0c98b 0 0cbd0642ac7b0d47b stream 0 0 0 cbd0642ac7b0d60b 0 0 /var/run/usbmuxdcbd0642ac7b0d60b stream 0 0 0 cbd0642ac7b0d47b 0 0cbd0642ac7b0cfcb stream 0 0 cbd0642ac9a607cb 0 0 0 /var/tmp/filesystemui.socketcbd0642ac7b0d2eb stream 0 0 cbd0642ac9a608cb 0 0 0 /private/tmp/com.apple.launchd.oxVQVCPROT/Listenerscbd0642ac7b0ccab stream 0 0 0 cbd0642ac7b0d543 0 0 /var/run/mDNSRespondercbd0642ac7b0d543 stream 0 0 0 cbd0642ac7b0ccab 0 0cbd0642ac2547923 stream 0 0 0 cbd0642ac254a353 0 0cbd0642ac254a353 stream 0 0 0 cbd0642ac2547923 0 0cbd0642ac25479eb stream 0 0 0 cbd0642ac254a28b 0 0 /var/run/mDNSRespondercbd0642ac254a28b stream 0 0 0 cbd0642ac25479eb 0 0cbd0642ac254a1c3 stream 0 0 0 cbd0642ac254a033 0 0 /var/run/mDNSRespondercbd0642ac254a033 stream 0 0 0 cbd0642ac254a1c3 0 0cbd0642ac2547b7b stream 0 0 0 cbd0642ac2547d0b 0 0cbd0642ac2547d0b stream 5094 0 0 cbd0642ac2547b7b 0 0cbd0642ac2547c43 stream 0 0 0 cbd0642ac2549c4b 0 0cbd0642ac2549c4b stream 0 0 0 cbd0642ac2547c43 0 0cbd0642ac2547dd3 stream 0 0 0 cbd0642ac2549b83 0 0cbd0642ac2549b83 stream 0 0 0 cbd0642ac2547dd3 0 0cbd0642ac2549ddb stream 0 0 cbd0642ac5185ccb 0 0 0 /var/run/displaypolicyd/statecbd0642ac254992b stream 0 0 0 cbd0642ac2549863 0 0cbd0642ac2549863 stream 0 0 0 cbd0642ac254992b 0 0cbd0642ac25496d3 stream 0 0 cbd0642ac3a8edcb 0 0 0 /var/run/pppconfdcbd0642ac2548413 stream 0 0 cbd0642ac292c5cb 0 0 0 /var/run/com.macpaw.CleanMyMac3.Agent.socketcbd0642ac25493b3 stream 0 0 cbd0642ac292c4cb 0 0 0 /var/run/com.docker.vmnetd.sockcbd0642ac25492eb stream 0 0 cbd0642ac292c0cb 0 0 0 /var/run/net.tunnelblick.tunnelblick.tunnelblickd.socketcbd0642ac25484db stream 0 0 cbd0642ac292bbcb 0 0 0 /var/run/com.macpaw.CleanMyMac4.Agent.socketcbd0642ac25485a3 stream 0 0 cbd0642ac28726cb 0 0 0 /var/run/usbmuxdcbd0642ac2549223 stream 0 0 cbd0642ac28727cb 0 0 0 /var/rpc/ncalrpc/srvsvccbd0642ac254866b stream 0 0 cbd0642ac2872bcb 0 0 0 /var/rpc/ncacn_np/srvsvccbd0642ac254915b stream 0 0 cbd0642ac28637cb 0 0 0 /var/rpc/ncalrpc/wkssvccbd0642ac2549093 stream 0 0 cbd0642ac28638cb 0 0 0 /var/rpc/ncacn_np/wkssvccbd0642ac2548733 stream 0 0 cbd0642ac28642cb 0 0 0 /var/rpc/ncacn_np/mdssvccbd0642ac25487fb stream 0 0 cbd0642ac28641cb 0 0 0 /var/rpc/ncalrpc/lsarpccbd0642ac25488c3 stream 0 0 cbd0642ac2863fcb 0 0 0 /var/rpc/ncacn_np/lsarpccbd0642ac2548fcb stream 0 0 cbd0642ac28279cb 0 0 0 /var/run/mDNSRespondercbd0642ac2548f03 stream 0 0 cbd0642ac28244cb 0 0 0 /var/run/systemkeychaincheck.socketcbd0642ac2548e3b stream 0 0 cbd0642ac281f9cb 0 0 0 /private/var/run/.sim_diagnosticd_socketcbd0642ac254898b stream 0 0 cbd0642ac28172cb 0 0 0 /var/run/portmap.socketcbd0642ac2548a53 stream 0 0 cbd0642ac2809bcb 0 0 0 /var/run/vpncontrol.sockcbd0642ac2548d73 stream 0 0 cbd0642ac27fb0cb 0 0 0 /var/rpc/ncalrpc/NETLOGONcbd0642ac2548cab stream 0 0 cbd0642ac27e0acb 0 0 0 /private/var/run/cupsdcbd0642ad1092dd3 dgram 0 0 0 cbd0642ad1092f63 cbd0642ad1092f63 0cbd0642ad1092f63 dgram 0 0 0 cbd0642ad1092dd3 cbd0642ad1092dd3 0cbd0642ad1094ddb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ad1093f03cbd0642ad1093f03 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac5fa7c4bcbd0642ac5fa7c4b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac5fa698bcbd0642ac5fa698b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac5fa8033cbd0642ac5fa68c3 dgram 0 0 0 cbd0642ac5fa7ea3 cbd0642ac5fa7ea3 0cbd0642ac5fa7ea3 dgram 0 0 0 cbd0642ac5fa68c3 cbd0642ac5fa68c3 0cbd0642ac5fa8033 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac5fa67fbcbd0642ac5fa67fb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc775283cbd0642acc775283 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc7774e3cbd0642acc774ab3 dgram 0 0 0 cbd0642acc774e9b cbd0642acc774e9b 0cbd0642acc774e9b dgram 0 0 0 cbd0642acc774ab3 cbd0642acc774ab3 0cbd0642acc7774e3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefba6cbcbd0642acefba6cb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbd1c3cbd0642acefbd1c3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbb34bcbd0642acefbaab3 dgram 0 0 0 cbd0642acefbcf6b cbd0642acefbcf6b 0cbd0642acefbcf6b dgram 0 0 0 cbd0642acefbaab3 cbd0642acefbaab3 0cbd0642acefbad0b dgram 0 0 0 cbd0642acefbadd3 cbd0642acefbadd3 0cbd0642acefbadd3 dgram 0 0 0 cbd0642acefbad0b cbd0642acefbad0b 0cbd0642acefbb34b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbc223cbd0642acefbc223 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbc2ebcbd0642acefbc47b dgram 0 0 0 cbd0642acefbcb83 cbd0642acefbcb83 0cbd0642acefbcb83 dgram 0 0 0 cbd0642acefbc47b cbd0642acefbc47b 0cbd0642acefbc2eb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbcabbcbd0642acefbcabb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbc863cbd0642acefbc863 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbaf63cbd0642acefbaf63 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbcc4bcbd0642acefbcc4b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acefbb8c3cbd0642acefbb8c3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc77566bcbd0642acc7775ab dgram 0 0 0 cbd0642acc77692b cbd0642acc77692b 0cbd0642acc77692b dgram 0 0 0 cbd0642acc7775ab cbd0642acc7775ab 0cbd0642acc77566b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc777353cbd0642acc777353 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc7771c3cbd0642acc7771c3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc7746cbcbd0642acc7746cb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc774d0bcbd0642acc774dd3 dgram 0 0 0 cbd0642acc776f6b cbd0642acc776f6b 0cbd0642acc776f6b dgram 0 0 0 cbd0642acc774dd3 cbd0642acc774dd3 0cbd0642acc774d0b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642acc776c4bcbd0642acc776c4b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0e5abcbd0642acc776ea3 dgram 0 0 0 cbd0642acc777033 cbd0642acc777033 0cbd0642acc777033 dgram 0 0 0 cbd0642acc776ea3 cbd0642acc776ea3 0cbd0642acc7755a3 dgram 0 0 0 cbd0642acc775413 cbd0642acc775413 0cbd0642acc775413 dgram 0 0 0 cbd0642acc7755a3 cbd0642acc7755a3 0cbd0642ac7b0e5ab dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac25476cbcbd0642ac25476cb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0e0fbcbd0642ac7b0e41b dgram 0 0 0 cbd0642ac7b0b793 cbd0642ac7b0b793 0cbd0642ac7b0b793 dgram 0 0 0 cbd0642ac7b0e41b cbd0642ac7b0e41b 0cbd0642ac7b0e0fb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0bc43cbd0642ac7b0bc43 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0b85bcbd0642ac7b0b85b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0dddbcbd0642ac7b0dddb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0c283cbd0642ac7b0c283 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0c4dbcbd0642ac7b0c4db dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0c1bbcbd0642ac7b0c1bb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0d3b3cbd0642ac7b0d3b3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0d15bcbd0642ac7b0cf03 dgram 0 0 0 cbd0642ac7b0d79b cbd0642ac7b0d79b 0cbd0642ac7b0d79b dgram 0 0 0 cbd0642ac7b0cf03 cbd0642ac7b0cf03 0cbd0642ac7b0d15b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0cbe3cbd0642ac7b0cbe3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0ca53cbd0642ac7b0d6d3 dgram 0 0 0 cbd0642ac7b0cb1b cbd0642ac7b0cb1b 0cbd0642ac7b0cb1b dgram 0 0 0 cbd0642ac7b0d6d3 cbd0642ac7b0d6d3 0cbd0642ac7b0ca53 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac7b0d863cbd0642ac7b0d863 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac254a5abcbd0642ac7b0d093 dgram 0 0 0 cbd0642ac7b0ce3b cbd0642ac7b0ce3b 0cbd0642ac7b0ce3b dgram 0 0 0 cbd0642ac7b0d093 cbd0642ac7b0d093 0cbd0642ac254a5ab dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac254a41bcbd0642ac254a41b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac2547ab3cbd0642ac254a0fb dgram 0 0 0 cbd0642ac2549ea3 cbd0642ac2549ea3 0cbd0642ac2549ea3 dgram 0 0 0 cbd0642ac254a0fb cbd0642ac254a0fb 0cbd0642ac2547ab3 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac2549f6bcbd0642ac2549f6b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac254947bcbd0642ac254947b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac25481bbcbd0642ac2549abb dgram 0 0 0 cbd0642ac25499f3 cbd0642ac25499f3 0cbd0642ac25499f3 dgram 0 0 0 cbd0642ac2549abb cbd0642ac2549abb 0cbd0642ac2547e9b dgram 0 0 0 cbd0642ac25480f3 cbd0642ac25480f3 0cbd0642ac25480f3 dgram 0 0 0 cbd0642ac2547e9b cbd0642ac2547e9b 0cbd0642ac2547f63 dgram 0 0 0 cbd0642ac254802b cbd0642ac254802b 0cbd0642ac254802b dgram 0 0 0 cbd0642ac2547f63 cbd0642ac2547f63 0cbd0642ac25481bb dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac2548283cbd0642ac2548283 dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac254834bcbd0642ac254834b dgram 0 0 0 cbd0642ac2548be3 0 cbd0642ac2548b1bcbd0642ac254960b dgram 0 0 0 cbd0642ac2549543 cbd0642ac2549543 0cbd0642ac2549543 dgram 0 0 0 cbd0642ac254960b cbd0642ac254960b 0cbd0642ac2548b1b dgram 0 0 0 cbd0642ac2548be3 0 0cbd0642ac2548be3 dgram 0 0 cbd0642ac24fb6cb 0 cbd0642ad1094ddb 0 /private//var/run/syslogRegistered kernel control modulesid flags pcbcount rcvbuf sndbuf name 1 9 0 131072 131072 com.apple.flow-divert 2 1 0 16384 2048 com.apple.nke.sockwall 3 9 0 524288 524288 com.apple.content-filter 4 1 14 65536 65536 com.apple.net.netagent 5 9 2 524288 524288 com.apple.net.utun_control 6 1 0 65536 65536 com.apple.net.ipsec_control 7 0 54 8192 2048 com.apple.netsrc 8 18 3 8192 2048 com.apple.network.statistics 9 5 0 8192 32768 com.apple.network.tcp_ccdebug a 1 0 8192 2048 com.apple.network.advisory b 4 0 65536 2048 com.apple.uart.SOC c 4 0 8192 2048 com.apple.uart.sk.SOC d 4 0 65536 2048 com.apple.uart.MALS e 4 0 8192 2048 com.apple.uart.sk.MALS f 4 0 65536 2048 com.apple.uart.BLTH 10 4 0 8192 2048 com.apple.uart.sk.BLTH 11 0 0 8192 8192 com.apple.fileutil.kext.stateful.ctl 12 0 0 8192 2048 com.apple.fileutil.kext.stateless.ctlActive kernel event socketsProto Recv-Q Send-Q vendor class subclakevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 1 11kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 1 2kevt 0 0 1 6 1kevt 0 0 1 6 1kevt 0 0 1 1 7kevt 0 0 1 1 1kevt 0 0 1 6 1kevt 0 0 1 1 2kevt 0 0 1 3 3kevt 0 0 1 1 0Active kernel control socketsProto Recv-Q Send-Q unit id namekctl 0 0 1 4 com.apple.net.netagentkctl 0 0 2 4 com.apple.net.netagentkctl 0 0 3 4 com.apple.net.netagentkctl 0 0 4 4 com.apple.net.netagentkctl 0 0 5 4 com.apple.net.netagentkctl 0 0 6 4 com.apple.net.netagentkctl 0 0 7 4 com.apple.net.netagentkctl 0 0 8 4 com.apple.net.netagentkctl 0 0 9 4 com.apple.net.netagentkctl 0 0 10 4 com.apple.net.netagentkctl 0 0 11 4 com.apple.net.netagentkctl 0 0 12 4 com.apple.net.netagentkctl 0 0 13 4 com.apple.net.netagentkctl 0 0 14 4 com.apple.net.netagentkctl 0 0 1 5 com.apple.net.utun_controlkctl 0 0 2 5 com.apple.net.utun_controlkctl 0 0 1 7 com.apple.netsrckctl 0 0 2 7 com.apple.netsrckctl 0 0 3 7 com.apple.netsrckctl 0 0 4 7 com.apple.netsrckctl 0 0 5 7 com.apple.netsrckctl 0 0 6 7 com.apple.netsrckctl 0 0 7 7 com.apple.netsrckctl 0 0 8 7 com.apple.netsrckctl 0 0 9 7 com.apple.netsrckctl 0 0 10 7 com.apple.netsrckctl 0 0 11 7 com.apple.netsrckctl 0 0 12 7 com.apple.netsrckctl 0 0 13 7 com.apple.netsrckctl 0 0 14 7 com.apple.netsrckctl 0 0 15 7 com.apple.netsrckctl 0 0 16 7 com.apple.netsrckctl 0 0 17 7 com.apple.netsrckctl 0 0 18 7 com.apple.netsrckctl 0 0 19 7 com.apple.netsrckctl 0 0 20 7 com.apple.netsrckctl 0 0 21 7 com.apple.netsrckctl 0 0 22 7 com.apple.netsrckctl 0 0 23 7 com.apple.netsrckctl 0 0 24 7 com.apple.netsrckctl 0 0 25 7 com.apple.netsrckctl 0 0 26 7 com.apple.netsrckctl 0 0 27 7 com.apple.netsrckctl 0 0 28 7 com.apple.netsrckctl 0 0 29 7 com.apple.netsrckctl 0 0 30 7 com.apple.netsrckctl 0 0 31 7 com.apple.netsrckctl 0 0 32 7 com.apple.netsrckctl 0 0 33 7 com.apple.netsrckctl 0 0 34 7 com.apple.netsrckctl 0 0 35 7 com.apple.netsrckctl 0 0 36 7 com.apple.netsrckctl 0 0 37 7 com.apple.netsrckctl 0 0 38 7 com.apple.netsrckctl 0 0 39 7 com.apple.netsrckctl 0 0 40 7 com.apple.netsrckctl 0 0 41 7 com.apple.netsrckctl 0 0 42 7 com.apple.netsrckctl 0 0 43 7 com.apple.netsrckctl 0 0 44 7 com.apple.netsrckctl 0 0 45 7 com.apple.netsrckctl 0 0 46 7 com.apple.netsrckctl 0 0 48 7 com.apple.netsrckctl 0 0 49 7 com.apple.netsrckctl 0 0 50 7 com.apple.netsrckctl 0 0 51 7 com.apple.netsrckctl 0 0 52 7 com.apple.netsrckctl 0 0 53 7 com.apple.netsrckctl 0 0 54 7 com.apple.netsrckctl 0 0 55 7 com.apple.netsrckctl 0 0 1 8 com.apple.network.statisticskctl 0 0 2 8 com.apple.network.statisticskctl 0 0 3 8 com.apple.network.statistics netstat -n | awk &#39;/^tcp/&#39; 如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596tcp4 0 0 127.0.0.1.54873 127.0.0.1.54874 ESTABLISHEDtcp4 0 0 127.0.0.1.54874 127.0.0.1.54873 ESTABLISHEDtcp4 0 0 10.251.12.65.54796 194.147.35.147.15895 ESTABLISHEDtcp4 0 0 127.0.0.1.1080 127.0.0.1.54795 ESTABLISHEDtcp4 0 0 127.0.0.1.54795 127.0.0.1.1080 ESTABLISHEDtcp4 31 0 10.251.12.65.54791 59.111.179.136.443 CLOSE_WAITtcp4 31 0 10.251.12.65.54790 59.111.179.136.443 CLOSE_WAITtcp4 0 0 10.251.12.65.54789 59.111.179.136.443 ESTABLISHEDtcp4 31 0 10.251.12.65.54788 59.111.179.136.443 CLOSE_WAITtcp4 0 0 10.251.12.65.54661 59.111.179.136.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54595 13.225.163.77.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54529 114.106.160.91.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54475 203.208.50.35.443 ESTABLISHEDtcp4 31 0 10.251.12.65.54333 59.111.179.136.443 CLOSE_WAITtcp4 0 0 10.251.12.65.54288 104.243.17.131.80 LAST_ACKtcp4 0 0 10.251.12.65.54052 10.9.25.53.80 ESTABLISHEDtcp4 0 0 10.251.12.65.53433 140.82.113.25.443 ESTABLISHEDtcp4 0 0 10.251.12.65.53296 122.228.2.250.80 CLOSE_WAITtcp4 0 0 10.251.12.65.53094 113.96.237.18.443 ESTABLISHEDtcp4 31 0 10.251.12.65.52388 110.43.81.8.443 CLOSE_WAITtcp4 31 0 10.251.12.65.52385 110.43.81.8.443 CLOSE_WAITtcp4 0 0 10.251.12.65.52366 101.89.125.232.80 CLOSE_WAITtcp4 31 0 10.251.12.65.52353 114.112.66.45.443 CLOSE_WAITtcp4 0 0 10.251.12.65.51939 10.9.44.194.7001 ESTABLISHEDtcp4 0 0 10.251.12.65.51938 10.9.44.194.7002 ESTABLISHEDtcp4 0 0 10.251.12.65.51937 10.9.44.194.7000 ESTABLISHEDtcp4 0 0 10.251.12.65.51921 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51920 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51919 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51918 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51917 10.9.25.53.80 ESTABLISHEDtcp4 0 0 10.251.12.65.60346 52.11.35.6.443 ESTABLISHEDtcp4 0 0 10.251.12.65.63898 17.188.166.20.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52766 61.151.165.0.80 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52765 fe80::aede:48ff:.52032 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52750 fe80::aede:48ff:.61000 ESTABLISHEDtcp4 0 0 10.251.12.65.52699 17.57.145.6.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52680 114.221.148.67.8080 ESTABLISHEDtcp4 0 0 10.251.12.65.52677 203.119.129.64.443 ESTABLISHEDtcp4 0 0 127.0.0.1.63342 127.0.0.1.52602 ESTABLISHEDtcp4 0 0 127.0.0.1.52602 127.0.0.1.63342 ESTABLISHEDtcp4 0 0 10.251.12.65.52975 118.126.97.71.22 ESTABLISHEDtcp4 0 0 127.0.0.1.54787 127.0.0.1.54786 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54792 TIME_WAITtcp4 0 0 127.0.0.1.1080 127.0.0.1.54608 TIME_WAITtcp4 0 0 10.251.12.65.54609 194.147.35.147.15895 TIME_WAITtcp4 0 0 127.0.0.1.54794 127.0.0.1.54793 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54797 TIME_WAITtcp4 0 0 127.0.0.1.54799 127.0.0.1.54798 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54800 TIME_WAITtcp4 0 0 127.0.0.1.54802 127.0.0.1.54801 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54803 TIME_WAITtcp4 0 0 127.0.0.1.54805 127.0.0.1.54804 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54806 TIME_WAITtcp4 0 0 127.0.0.1.1080 127.0.0.1.54631 TIME_WAITtcp4 0 0 10.251.12.65.54632 194.147.35.147.15895 TIME_WAITtcp4 0 0 127.0.0.1.54808 127.0.0.1.54807 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54809 TIME_WAITtcp4 0 0 127.0.0.1.54811 127.0.0.1.54810 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54812 TIME_WAITtcp4 0 0 127.0.0.1.54814 127.0.0.1.54813 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54817 TIME_WAITtcp4 0 0 127.0.0.1.54819 127.0.0.1.54818 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54820 TIME_WAITtcp4 0 0 127.0.0.1.54822 127.0.0.1.54821 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54823 TIME_WAITtcp4 0 0 127.0.0.1.54825 127.0.0.1.54824 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54826 TIME_WAITtcp4 0 0 127.0.0.1.54828 127.0.0.1.54827 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54829 TIME_WAITtcp4 0 0 127.0.0.1.54831 127.0.0.1.54830 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54832 TIME_WAITtcp4 0 0 127.0.0.1.54834 127.0.0.1.54833 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54835 TIME_WAITtcp4 0 0 127.0.0.1.54837 127.0.0.1.54836 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54838 TIME_WAITtcp4 0 0 127.0.0.1.54840 127.0.0.1.54839 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54843 TIME_WAITtcp4 0 0 127.0.0.1.54845 127.0.0.1.54844 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54846 TIME_WAITtcp4 0 0 127.0.0.1.54848 127.0.0.1.54847 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54849 TIME_WAITtcp4 0 0 127.0.0.1.54851 127.0.0.1.54850 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54852 TIME_WAITtcp4 0 0 127.0.0.1.54854 127.0.0.1.54853 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54855 TIME_WAITtcp4 0 0 127.0.0.1.54857 127.0.0.1.54856 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54858 TIME_WAITtcp4 0 0 127.0.0.1.54860 127.0.0.1.54859 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54861 TIME_WAITtcp4 0 0 127.0.0.1.54863 127.0.0.1.54862 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54864 TIME_WAITtcp4 0 0 127.0.0.1.54866 127.0.0.1.54865 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54869 TIME_WAITtcp4 0 0 127.0.0.1.54871 127.0.0.1.54870 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.54872 TIME_WAIT 这个’^’的作用是值匹配每行最前面的字符,如果不匹配,就下一行.如 netstat -n | awk &#39;/stream/&#39;: 如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305cbd0642ae7c7ddd3 stream 0 0 0 cbd0642ae7c801c3 0 0 /var/run/mDNSRespondercbd0642ae7c801c3 stream 0 0 0 cbd0642ae7c7ddd3 0 0cbd0642ae7c7e4db stream 0 0 cbd0642ae73f4dcb 0 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/vscode-git-ipc-ed7242e63826e64a90e3d0d38a60aff3fe0ee10cbd0642ae7c7fea3 stream 0 0 0 cbd0642ae7c7e413 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/vscode-lang-522a68475808fd1f1e9a5e59fc8a4a172431b826.scbd0642ae7c7e413 stream 0 0 0 cbd0642ae7c7fea3 0 0cbd0642ae7c7e733 stream 0 0 0 cbd0642ae7c7fd13 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/vscode-lang-cf81ac15856ed6de769a87e6630f555ab18f51a1.scbd0642ae7c7fd13 stream 0 0 0 cbd0642ae7c7e733 0 0cbd0642ae7c7fc4b stream 0 0 0 cbd0642ae7c7e7fb 0 0cbd0642ae7c7e7fb stream 0 0 0 cbd0642ae7c7fc4b 0 0cbd0642ae7c7e8c3 stream 0 0 0 cbd0642ae7c7fb83 0 0cbd0642ae7c7fb83 stream 0 0 0 cbd0642ae7c7e8c3 0 0cbd0642ae7c7fabb stream 0 0 0 cbd0642ae7c7f9f3 0 0cbd0642ae7c7f9f3 stream 0 0 0 cbd0642ae7c7fabb 0 0cbd0642ae7c7e98b stream 0 0 0 cbd0642ae7c7ea53 0 0cbd0642ae7c7ea53 stream 0 0 0 cbd0642ae7c7e98b 0 0cbd0642ae7c7f92b stream 0 0 0 cbd0642ae7c7f863 0 0cbd0642ae7c7f863 stream 0 0 0 cbd0642ae7c7f92b 0 0cbd0642ae7c7f79b stream 0 0 0 cbd0642ae7c7eb1b 0 0cbd0642ae7c7eb1b stream 0 0 0 cbd0642ae7c7f79b 0 0cbd0642ae7c7f6d3 stream 0 0 0 cbd0642ae7c7f60b 0 0cbd0642ae7c7f60b stream 0 0 0 cbd0642ae7c7f6d3 0 0cbd0642ae7c7f543 stream 0 0 0 cbd0642ae7c7ebe3 0 0cbd0642ae7c7ebe3 stream 0 0 0 cbd0642ae7c7f543 0 0cbd0642ae7c7ecab stream 0 0 cbd0642ae73f6ccb 0 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/vscode-lang-cf81ac15856ed6de769a87e6630f555ab18f51a1.scbd0642ae7c7f2eb stream 0 0 0 cbd0642acefbd5ab 0 0cbd0642acefbd5ab stream 0 0 0 cbd0642ae7c7f2eb 0 0cbd0642acefbd353 stream 0 0 0 cbd0642acefbb02b 0 0 /var/run/mDNSRespondercbd0642acefbb02b stream 0 0 0 cbd0642acefbd353 0 0cbd0642acefba923 stream 0 0 0 cbd0642acefbd4e3 0 0 /Users/shuangcui/Library/Application Support/Code/1.44.2-shared.sockcbd0642acefbd4e3 stream 0 0 0 cbd0642acefba923 0 0cbd0642ac254979b stream 0 0 0 cbd0642ac2547793 0 0 /var/run/mDNSRespondercbd0642ac2547793 stream 0 0 0 cbd0642ac254979b 0 0cbd0642ac2549d13 stream 0 0 0 cbd0642acc776d13 0 0 /Users/shuangcui/Library/Application Support/Code/1.44.2-shared.sockcbd0642acc776d13 stream 0 0 0 cbd0642ac2549d13 0 0cbd0642ad10955ab stream 0 0 cbd0642adacd98cb 0 0 0 /Users/shuangcui/Library/Application Support/Code/1.44.2-shared.sockcbd0642ad1093733 stream 0 0 0 cbd0642ad1095033 0 0cbd0642ad1095033 stream 0 0 0 cbd0642ad1093733 0 0cbd0642ad109479b stream 0 0 0 cbd0642ad10950fb 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/vscode-ipc-764473fd-6f90-47a0-a538-95c0805c4581.sockcbd0642ad10950fb stream 0 0 0 cbd0642ad109479b 0 0cbd0642ad1092ab3 stream 0 0 0 cbd0642ad109302b 0 0cbd0642ad109302b stream 0 0 0 cbd0642ad1092ab3 0 0cbd0642ad1094ea3 stream 0 0 0 cbd0642ad1092b7b 0 0cbd0642ad1092b7b stream 0 0 0 cbd0642ad1094ea3 0 0cbd0642ad109528b stream 0 0 0 cbd0642ad109285b 0 0cbd0642ad109285b stream 0 0 0 cbd0642ad109528b 0 0cbd0642ad1095353 stream 0 0 0 cbd0642ad109398b 0 0cbd0642ad109398b stream 0 0 0 cbd0642ad1095353 0 0cbd0642ad1092c43 stream 0 0 cbd0642ae647e8cb 0 0 0 /Users/shuangcui/Library/Application Support/Code/1.44.2-main.sockcbd0642ad10937fb stream 0 0 0 cbd0642ad10951c3 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.WfWndbcbd0642ad10951c3 stream 0 0 0 cbd0642ad10937fb 0 0cbd0642ad10930f3 stream 0 0 0 cbd0642ad1093e3b 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.LBaxrYcbd0642ad1093e3b stream 0 0 0 cbd0642ad10930f3 0 0cbd0642ad1094d13 stream 0 0 0 cbd0642ad10938c3 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.uUZwd1cbd0642ad10938c3 stream 0 0 0 cbd0642ad1094d13 0 0cbd0642ad1092923 stream 0 0 0 cbd0642ad10929eb 0 0 ./QingBanGong_LocalPushcbd0642ad10929eb stream 0 0 0 cbd0642ad1092923 0 0cbd0642ad1092d0b stream 0 0 0 cbd0642ad1092e9b 0 0cbd0642ad1092e9b stream 0 0 0 cbd0642ad1092d0b 0 0cbd0642ad1094f6b stream 0 0 cbd0642ae0d2d2cb 0 0 0 ./wpsofficecbd0642ad1094c4b stream 0 0 0 cbd0642ad1094b83 0 0 ./recentfile_servercbd0642ad1094b83 stream 0 0 0 cbd0642ad1094c4b 0 0cbd0642ad10931bb stream 0 0 0 cbd0642ad10935a3 0 0 /var/run/mDNSRespondercbd0642ad10935a3 stream 0 0 0 cbd0642ad10931bb 0 0cbd0642ad109447b stream 0 0 0 cbd0642ad10943b3 0 0 ./_Thrift_Qing_IPC_cbd0642ad10943b3 stream 0 0 0 cbd0642ad109447b 0 0cbd0642ad1093a53 stream 0 0 0 cbd0642ad1094abb 0 0 /var/run/mDNSRespondercbd0642ad1094abb stream 0 0 0 cbd0642ad1093a53 0 0cbd0642ad1093413 stream 0 0 0 cbd0642ad1093fcb 0 0 /var/run/mDNSRespondercbd0642ad1093fcb stream 0 0 0 cbd0642ad1093413 0 0cbd0642ad1093283 stream 0 0 0 cbd0642ad10942eb 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.Jx4w3acbd0642ad10942eb stream 0 0 0 cbd0642ad1093283 0 0cbd0642ad10934db stream 0 0 0 cbd0642ad109492b 0 0cbd0642ad109492b stream 0 0 0 cbd0642ad10934db 0 0cbd0642ad10946d3 stream 0 0 0 cbd0642ad109334b 0 0cbd0642ad109334b stream 0 0 0 cbd0642ad10946d3 0 0cbd0642ad10949f3 stream 0 0 0 cbd0642ad109366b 0 0cbd0642ad109366b stream 0 0 0 cbd0642ad10949f3 0 0cbd0642ad1094863 stream 0 0 0 cbd0642ad109415b 0 0cbd0642ad109415b stream 0 0 0 cbd0642ad1094863 0 0cbd0642ad1094223 stream 0 0 0 cbd0642acefba793 0 0cbd0642acefba793 stream 0 0 0 cbd0642ad1094223 0 0cbd0642acefbc093 stream 0 0 0 cbd0642acefbd033 0 0cbd0642acefbd033 stream 0 0 0 cbd0642acefbc093 0 0cbd0642acefbac43 stream 0 0 0 cbd0642acefbc60b 0 0cbd0642acefbc60b stream 0 0 0 cbd0642acefbac43 0 0cbd0642acefbbfcb stream 0 0 0 cbd0642acefba9eb 0 0cbd0642acefba9eb stream 0 0 0 cbd0642acefbbfcb 0 0cbd0642acefbd28b stream 0 0 0 cbd0642acefbd41b 0 0cbd0642acefbd41b stream 0 0 0 cbd0642acefbd28b 0 0cbd0642ac254a4e3 stream 0 0 0 cbd0642ac7b0dabb 0 0cbd0642ac7b0dabb stream 0 0 0 cbd0642ac254a4e3 0 0cbd0642ac7b0c8c3 stream 0 0 0 cbd0642ac7b0c7fb 0 0cbd0642ac7b0c7fb stream 0 0 0 cbd0642ac7b0c8c3 0 0cbd0642ac7b0e1c3 stream 0 0 0 cbd0642ac7b0db83 0 0cbd0642ac7b0db83 stream 0 0 0 cbd0642ac7b0e1c3 0 0cbd0642ac7b0d9f3 stream 0 0 0 cbd0642ac7b0c66b 0 0cbd0642ac7b0c66b stream 0 0 0 cbd0642ac7b0d9f3 0 0cbd0642acc776abb stream 0 0 0 cbd0642acc7769f3 0 0cbd0642acc7769f3 stream 0 0 0 cbd0642acc776abb 0 0cbd0642acc774b7b stream 0 0 0 cbd0642acc7770fb 0 0cbd0642acc7770fb stream 0 0 0 cbd0642acc774b7b 0 0cbd0642ac5fa5923 stream 0 0 0 cbd0642ac5fa5793 0 0cbd0642ac5fa5793 stream 0 0 0 cbd0642ac5fa5923 0 0cbd0642ac5fa6e3b stream 0 0 0 cbd0642ac5fa5f63 0 0cbd0642ac5fa5f63 stream 0 0 0 cbd0642ac5fa6e3b 0 0cbd0642ac5fa779b stream 0 0 0 cbd0642ac5fa7f6b 0 0cbd0642ac5fa7f6b stream 0 0 0 cbd0642ac5fa779b 0 0cbd0642ac5fa760b stream 0 0 0 cbd0642ac5fa73b3 0 0cbd0642ac5fa73b3 stream 0 0 0 cbd0642ac5fa760b 0 0cbd0642ac5fa80fb stream 0 0 0 cbd0642ac5fa85ab 0 0cbd0642ac5fa85ab stream 0 0 0 cbd0642ac5fa80fb 0 0cbd0642ac5fa84e3 stream 0 0 0 cbd0642ac5fa634b 0 0cbd0642ac5fa634b stream 0 0 0 cbd0642ac5fa84e3 0 0cbd0642ac5fa76d3 stream 0 0 0 cbd0642ac5fa64db 0 0cbd0642ac5fa64db stream 0 0 0 cbd0642ac5fa76d3 0 0cbd0642ac5fa6413 stream 0 0 0 cbd0642ac5fa6a53 0 0cbd0642ac5fa6a53 stream 0 0 0 cbd0642ac5fa6413 0 0cbd0642ac5fa715b stream 0 0 0 cbd0642ac5fa7ddb 0 0cbd0642ac5fa7ddb stream 0 0 0 cbd0642ac5fa715b 0 0cbd0642ac5fa5e9b stream 0 0 0 cbd0642ac5fa6283 0 0cbd0642ac5fa6283 stream 0 0 0 cbd0642ac5fa5e9b 0 0cbd0642ac5fa79f3 stream 0 0 0 cbd0642ac5fa7abb 0 0cbd0642ac5fa7abb stream 0 0 0 cbd0642ac5fa79f3 0 0cbd0642ac5fa72eb stream 0 0 0 cbd0642ac5fa6fcb 0 0cbd0642ac5fa6fcb stream 0 0 0 cbd0642ac5fa72eb 0 0cbd0642ac5fa59eb stream 0 0 0 cbd0642ac5fa602b 0 0cbd0642ac5fa602b stream 0 0 0 cbd0642ac5fa59eb 0 0cbd0642ac5fa841b stream 0 0 0 cbd0642ac5fa56cb 0 0cbd0642ac5fa56cb stream 0 0 0 cbd0642ac5fa841b 0 0cbd0642ac5fa7863 stream 0 0 0 cbd0642ac5fa6b1b 0 0cbd0642ac5fa6b1b stream 0 0 0 cbd0642ac5fa7863 0 0cbd0642ac5fa5ab3 stream 0 0 0 cbd0642ac5fa585b 0 0cbd0642ac5fa585b stream 0 0 0 cbd0642ac5fa5ab3 0 0cbd0642ad10926cb stream 0 0 0 cbd0642ad10954e3 0 0cbd0642ad10954e3 stream 0 0 0 cbd0642ad10926cb 0 0cbd0642ad109541b stream 0 0 0 cbd0642ad1092793 0 0 /var/run/mDNSRespondercbd0642ad1092793 stream 0 0 0 cbd0642ad109541b 0 0cbd0642ad109460b stream 0 0 0 cbd0642ad1094543 0 0 /var/run/mDNSRespondercbd0642ad1094543 stream 0 0 0 cbd0642ad109460b 0 0cbd0642ad1094093 stream 0 0 0 cbd0642ad1093b1b 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.uD8BzLcbd0642ad1093b1b stream 0 0 0 cbd0642ad1094093 0 0cbd0642ad1093be3 stream 0 0 0 cbd0642ad1093d73 0 0cbd0642ad1093d73 stream 0 0 0 cbd0642ad1093be3 0 0cbd0642ad1093cab stream 0 0 0 cbd0642ac7b0c733 0 0cbd0642ac7b0c733 stream 0 0 0 cbd0642ad1093cab 0 0cbd0642acc77741b stream 0 0 0 cbd0642acc7754db 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.q4FdtRcbd0642acc7754db stream 0 0 0 cbd0642acc77741b 0 0cbd0642ac5fa7b83 stream 0 0 0 cbd0642ac5fa6cab 0 0 /var/run/mDNSRespondercbd0642ac5fa6cab stream 0 0 0 cbd0642ac5fa7b83 0 0cbd0642ac5fa666b stream 0 0 0 cbd0642ac5fa6be3 0 0 /var/run/mDNSRespondercbd0642ac5fa6be3 stream 0 0 0 cbd0642ac5fa666b 0 0cbd0642ac5fa6733 stream 0 0 0 cbd0642ac5fa6d73 0 0 /var/run/mDNSRespondercbd0642ac5fa6d73 stream 0 0 0 cbd0642ac5fa6733 0 0cbd0642ac5fa6f03 stream 0 0 0 cbd0642ac5fa65a3 0 0 /var/run/mDNSRespondercbd0642ac5fa65a3 stream 0 0 0 cbd0642ac5fa6f03 0 0cbd0642ac5fa7d13 stream 0 0 0 cbd0642ac5fa792b 0 0 /var/run/mDNSRespondercbd0642ac5fa792b stream 0 0 0 cbd0642ac5fa7d13 0 0cbd0642ac5fa7093 stream 0 0 0 cbd0642ac5fa60f3 0 0 /var/run/mDNSRespondercbd0642ac5fa60f3 stream 0 0 0 cbd0642ac5fa7093 0 0cbd0642ac5fa61bb stream 0 0 0 cbd0642ac5fa7223 0 0 ./_Thrift_Qing_IPC_cbd0642ac5fa7223 stream 0 0 0 cbd0642ac5fa61bb 0 0cbd0642ac5fa747b stream 0 0 cbd0642acf09d4cb 0 0 0 ./QingBanGong_LocalPushcbd0642ac5fa5b7b stream 0 0 cbd0642adceb80cb 0 0 0 ./_#_QingBanGong_Server_#_cbd0642ac5fa81c3 stream 0 0 cbd0642ae29746cb 0 0 0 ./ELiveClient_LiveCentercbd0642ac5fa5d0b stream 0 0 cbd0642adceb7fcb 0 0 0 ./_Thrift_Qing_IPC_2_cbd0642ac5fa5dd3 stream 0 0 cbd0642adc0b24cb 0 0 0 ./_Thrift_Qing_IPC_cbd0642ac5fa5c43 stream 0 0 cbd0642ae045fdcb 0 0 0 ./recentfile_servercbd0642ac5fa828b stream 0 0 0 cbd0642ac5fa8353 0 0 /var/run/mDNSRespondercbd0642ac5fa8353 stream 0 0 0 cbd0642ac5fa828b 0 0cbd0642ac5fa7543 stream 0 0 cbd0642ac85022cb 0 0 0 ./WpsCloudSvrcbd0642acefbd0fb stream 0 0 0 cbd0642acefba85b 0 0cbd0642acefba85b stream 0 0 0 cbd0642acefbd0fb 0 0cbd0642acefbcea3 stream 0 0 0 cbd0642acefbab7b 0 0 /var/run/mDNSRespondercbd0642acefbab7b stream 0 0 0 cbd0642acefbcea3 0 0cbd0642acefbcd13 stream 0 0 0 cbd0642acefbcddb 0 0 /var/run/mDNSRespondercbd0642acefbcddb stream 0 0 0 cbd0642acefbcd13 0 0cbd0642acefbc6d3 stream 0 0 0 cbd0642acefbc92b 0 0 /var/run/mDNSRespondercbd0642acefbc92b stream 0 0 0 cbd0642acefbc6d3 0 0cbd0642acefbc79b stream 0 0 cbd0642ad7e7b9cb 0 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/.com.google.Chrome.ss4bAO/SingletonSocketcbd0642acefbae9b stream 0 0 0 cbd0642acefbb4db 0 0 /var/folders/0f/46_yf9mx37ndl25v6ypqg3qc0000gn/T/iTerm2-temp-socket.rBcF2ecbd0642acefbb4db stream 0 0 0 cbd0642acefbae9b 0 0cbd0642acefbb0f3 stream 0 0 0 cbd0642acefbb1bb 0 0 /var/run/mDNSRespondercbd0642acefbb1bb stream 0 0 0 cbd0642acefbb0f3 0 0cbd0642acefbb7fb stream 0 0 0 cbd0642acefbc543 0 0 /var/run/mDNSRespondercbd0642acefbc543 stream 0 0 0 cbd0642acefbb7fb 0 0cbd0642acefbb733 stream 0 0 0 0 0 0cbd0642acefbc15b stream 0 0 0 0 0 0cbd0642acefbb413 stream 0 0 0 cbd0642acefbc3b3 0 0 /var/run/mDNSRespondercbd0642acefbc3b3 stream 0 0 0 cbd0642acefbb413 0 0cbd0642acefbc9f3 stream 0 0 0 cbd0642acefbb66b 0 0 /var/run/mDNSRespondercbd0642acefbb66b stream 0 0 0 cbd0642acefbc9f3 0 0cbd0642acefbb5a3 stream 0 0 0 cbd0642acefbb283 0 0 /var/run/mDNSRespondercbd0642acefbb283 stream 0 0 0 cbd0642acefbb5a3 0 0cbd0642acefbbf03 stream 0 0 0 cbd0642acefbba53 0 0 /var/run/mDNSRespondercbd0642acefbba53 stream 0 0 0 cbd0642acefbbf03 0 0cbd0642acefbbd73 stream 0 0 0 cbd0642acefbbbe3 0 0 /var/run/usbmuxdcbd0642acefbbbe3 stream 0 0 0 cbd0642acefbbd73 0 0cbd0642acefbbb1b stream 0 0 0 cbd0642acefbbe3b 0 0 /var/run/mDNSRespondercbd0642acefbbe3b stream 0 0 0 cbd0642acefbbb1b 0 0cbd0642acefbbcab stream 0 0 0 cbd0642acefbb98b 0 0cbd0642acefbb98b stream 0 0 0 cbd0642acefbbcab 0 0cbd0642acc77728b stream 0 0 0 cbd0642acc7749eb 0 0cbd0642acc7749eb stream 0 0 0 cbd0642acc77728b 0 0cbd0642acc776ddb stream 0 0 0 cbd0642acc774923 0 0cbd0642acc774923 stream 0 0 0 cbd0642acc776ddb 0 0cbd0642acc775733 stream 0 0 0 cbd0642acc776863 0 0 /var/run/mDNSRespondercbd0642acc776863 stream 0 0 0 cbd0642acc775733 0 0cbd0642acc77485b stream 0 0 0 cbd0642acc774793 0 0cbd0642acc774793 stream 0 0 0 cbd0642acc77485b 0 0cbd0642acc774f63 stream 0 0 cbd0642aceea6ecb 0 0 0 /tmp/mysql.sockcbd0642acc774c43 stream 0 0 0 cbd0642acc77534b 0 0cbd0642acc77534b stream 0 0 0 cbd0642acc774c43 0 0cbd0642acc77502b stream 0 0 cbd0642acead4fcb 0 0 0 /Users/shuangcui/Library/Application Support/DingTalkMac/dingtalk-ddcbd0642acc7751bb stream 0 0 cbd0642ace3bb3cb 0 0 0 /tmp/.vnc-501/vncagent.02190c267311edcbcbd0642acc776b83 stream 0 0 0 cbd0642acc7750f3 0 0cbd0642acc7750f3 stream 0 0 0 cbd0642acc776b83 0 0cbd0642acc77679b stream 0 0 0 cbd0642acc7757fb 0 0 /var/run/mDNSRespondercbd0642acc7757fb stream 0 0 0 cbd0642acc77679b 0 0cbd0642acc7766d3 stream 0 0 0 cbd0642acc7758c3 0 0 /var/run/mDNSRespondercbd0642acc7758c3 stream 0 0 0 cbd0642acc7766d3 0 0cbd0642acc77660b stream 0 0 0 cbd0642acc77598b 0 0 /var/run/mDNSRespondercbd0642acc77598b stream 0 0 0 cbd0642acc77660b 0 0cbd0642acc775a53 stream 0 0 0 cbd0642acc775b1b 0 0 /var/run/mDNSRespondercbd0642acc776543 stream 0 0 0 cbd0642acc77647b 0 0 /var/run/mDNSRespondercbd0642acc775b1b stream 0 0 0 cbd0642acc775a53 0 0cbd0642acc77647b stream 0 0 0 cbd0642acc776543 0 0cbd0642acc7763b3 stream 0 0 0 cbd0642acc7762eb 0 0 /var/run/mDNSRespondercbd0642acc775e3b stream 0 0 0 cbd0642acc776223 0 0 /var/run/mDNSRespondercbd0642acc7762eb stream 0 0 0 cbd0642acc7763b3 0 0cbd0642acc776223 stream 0 0 0 cbd0642acc775e3b 0 0cbd0642acc775fcb stream 0 0 0 cbd0642acc775d73 0 0 /var/run/mDNSRespondercbd0642acc775cab stream 0 0 0 cbd0642acc775be3 0 0 /var/run/mDNSRespondercbd0642acc775d73 stream 0 0 0 cbd0642acc775fcb 0 0cbd0642acc775be3 stream 0 0 0 cbd0642acc775cab 0 0cbd0642acc77615b stream 0 0 0 cbd0642acc776093 0 0 /var/run/mDNSRespondercbd0642acc776093 stream 0 0 0 cbd0642acc77615b 0 0cbd0642acc775f03 stream 0 0 0 cbd0642ac254785b 0 0cbd0642ac254785b stream 0 0 0 cbd0642acc775f03 0 0cbd0642ac7b0b6cb stream 0 0 0 cbd0642ac7b0e4e3 0 0 /var/run/mDNSRespondercbd0642ac7b0e4e3 stream 0 0 0 cbd0642ac7b0b6cb 0 0cbd0642ac7b0e28b stream 0 0 0 cbd0642ac7b0e033 0 0 /var/run/mDNSRespondercbd0642ac7b0e033 stream 0 0 0 cbd0642ac7b0e28b 0 0cbd0642ac7b0e353 stream 0 0 0 cbd0642ac7b0dea3 0 0 /var/run/mDNSRespondercbd0642ac7b0dea3 stream 0 0 0 cbd0642ac7b0e353 0 0cbd0642ac7b0bd0b stream 0 0 0 cbd0642ac7b0b923 0 0 /var/run/mDNSRespondercbd0642ac7b0b923 stream 0 0 0 cbd0642ac7b0bd0b 0 0cbd0642ac7b0bab3 stream 0 0 0 cbd0642ac7b0bb7b 0 0 /var/run/mDNSRespondercbd0642ac7b0bb7b stream 0 0 0 cbd0642ac7b0bab3 0 0cbd0642ac7b0b9eb stream 0 0 0 cbd0642ac7b0df6b 0 0 /var/run/mDNSRespondercbd0642ac7b0df6b stream 0 0 0 cbd0642ac7b0b9eb 0 0cbd0642ac7b0dd13 stream 0 0 0 cbd0642ac7b0bdd3 0 0cbd0642ac7b0bdd3 stream 0 0 0 cbd0642ac7b0dd13 0 0cbd0642ac7b0be9b stream 0 0 0 cbd0642ac7b0bf63 0 0cbd0642ac7b0bf63 stream 0 0 0 cbd0642ac7b0be9b 0 0cbd0642ac7b0dc4b stream 0 0 0 cbd0642ac7b0c02b 0 0cbd0642ac7b0c02b stream 0 0 0 cbd0642ac7b0dc4b 0 0cbd0642ac7b0c0f3 stream 0 0 0 cbd0642ac7b0c5a3 0 0cbd0642ac7b0c5a3 stream 0 0 0 cbd0642ac7b0c0f3 0 0cbd0642ac7b0c34b stream 0 0 0 cbd0642ac7b0c413 0 0 /var/run/mDNSRespondercbd0642ac7b0c413 stream 0 0 0 cbd0642ac7b0c34b 0 0cbd0642ac7b0cd73 stream 0 0 0 cbd0642ac7b0d223 0 0 /var/run/mDNSRespondercbd0642ac7b0d223 stream 0 0 0 cbd0642ac7b0cd73 0 0cbd0642ac7b0c98b stream 0 0 0 cbd0642ac7b0d92b 0 0 /var/run/usbmuxdcbd0642ac7b0d92b stream 0 0 0 cbd0642ac7b0c98b 0 0cbd0642ac7b0d47b stream 0 0 0 cbd0642ac7b0d60b 0 0 /var/run/usbmuxdcbd0642ac7b0d60b stream 0 0 0 cbd0642ac7b0d47b 0 0cbd0642ac7b0cfcb stream 0 0 cbd0642ac9a607cb 0 0 0 /var/tmp/filesystemui.socketcbd0642ac7b0d2eb stream 0 0 cbd0642ac9a608cb 0 0 0 /private/tmp/com.apple.launchd.oxVQVCPROT/Listenerscbd0642ac7b0ccab stream 0 0 0 cbd0642ac7b0d543 0 0 /var/run/mDNSRespondercbd0642ac7b0d543 stream 0 0 0 cbd0642ac7b0ccab 0 0cbd0642ac2547923 stream 0 0 0 cbd0642ac254a353 0 0cbd0642ac254a353 stream 0 0 0 cbd0642ac2547923 0 0cbd0642ac25479eb stream 0 0 0 cbd0642ac254a28b 0 0 /var/run/mDNSRespondercbd0642ac254a28b stream 0 0 0 cbd0642ac25479eb 0 0cbd0642ac254a1c3 stream 0 0 0 cbd0642ac254a033 0 0 /var/run/mDNSRespondercbd0642ac254a033 stream 0 0 0 cbd0642ac254a1c3 0 0cbd0642ac2547b7b stream 0 0 0 cbd0642ac2547d0b 0 0cbd0642ac2547d0b stream 5248 0 0 cbd0642ac2547b7b 0 0cbd0642ac2547c43 stream 0 0 0 cbd0642ac2549c4b 0 0cbd0642ac2549c4b stream 0 0 0 cbd0642ac2547c43 0 0cbd0642ac2547dd3 stream 0 0 0 cbd0642ac2549b83 0 0cbd0642ac2549b83 stream 0 0 0 cbd0642ac2547dd3 0 0cbd0642ac2549ddb stream 0 0 cbd0642ac5185ccb 0 0 0 /var/run/displaypolicyd/statecbd0642ac254992b stream 0 0 0 cbd0642ac2549863 0 0cbd0642ac2549863 stream 0 0 0 cbd0642ac254992b 0 0cbd0642ac25496d3 stream 0 0 cbd0642ac3a8edcb 0 0 0 /var/run/pppconfdcbd0642ac2548413 stream 0 0 cbd0642ac292c5cb 0 0 0 /var/run/com.macpaw.CleanMyMac3.Agent.socketcbd0642ac25493b3 stream 0 0 cbd0642ac292c4cb 0 0 0 /var/run/com.docker.vmnetd.sockcbd0642ac25492eb stream 0 0 cbd0642ac292c0cb 0 0 0 /var/run/net.tunnelblick.tunnelblick.tunnelblickd.socketcbd0642ac25484db stream 0 0 cbd0642ac292bbcb 0 0 0 /var/run/com.macpaw.CleanMyMac4.Agent.socketcbd0642ac25485a3 stream 0 0 cbd0642ac28726cb 0 0 0 /var/run/usbmuxdcbd0642ac2549223 stream 0 0 cbd0642ac28727cb 0 0 0 /var/rpc/ncalrpc/srvsvccbd0642ac254866b stream 0 0 cbd0642ac2872bcb 0 0 0 /var/rpc/ncacn_np/srvsvccbd0642ac254915b stream 0 0 cbd0642ac28637cb 0 0 0 /var/rpc/ncalrpc/wkssvccbd0642ac2549093 stream 0 0 cbd0642ac28638cb 0 0 0 /var/rpc/ncacn_np/wkssvccbd0642ac2548733 stream 0 0 cbd0642ac28642cb 0 0 0 /var/rpc/ncacn_np/mdssvccbd0642ac25487fb stream 0 0 cbd0642ac28641cb 0 0 0 /var/rpc/ncalrpc/lsarpccbd0642ac25488c3 stream 0 0 cbd0642ac2863fcb 0 0 0 /var/rpc/ncacn_np/lsarpccbd0642ac2548fcb stream 0 0 cbd0642ac28279cb 0 0 0 /var/run/mDNSRespondercbd0642ac2548f03 stream 0 0 cbd0642ac28244cb 0 0 0 /var/run/systemkeychaincheck.socketcbd0642ac2548e3b stream 0 0 cbd0642ac281f9cb 0 0 0 /private/var/run/.sim_diagnosticd_socketcbd0642ac254898b stream 0 0 cbd0642ac28172cb 0 0 0 /var/run/portmap.socketcbd0642ac2548a53 stream 0 0 cbd0642ac2809bcb 0 0 0 /var/run/vpncontrol.sockcbd0642ac2548d73 stream 0 0 cbd0642ac27fb0cb 0 0 0 /var/rpc/ncalrpc/NETLOGONcbd0642ac2548cab stream 0 0 cbd0642ac27e0acb 0 0 0 /private/var/run/cupsd 但 netstat -n | awk &#39;/^stream/&#39;, 则无任何匹配. 如去掉’^’,执行: netstat -n | awk &#39;/tcp/&#39; 如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192tcp4 0 0 127.0.0.1.56560 127.0.0.1.56561 ESTABLISHEDtcp4 0 0 127.0.0.1.56561 127.0.0.1.56560 ESTABLISHEDtcp4 0 0 10.251.12.65.56518 36.110.170.32.80 ESTABLISHEDtcp4 0 0 10.251.12.65.56514 194.147.35.147.15895 ESTABLISHEDtcp4 0 0 127.0.0.1.1080 127.0.0.1.56513 ESTABLISHEDtcp4 0 0 127.0.0.1.56513 127.0.0.1.1080 ESTABLISHEDtcp4 0 0 10.251.12.65.56492 36.110.170.32.80 ESTABLISHEDtcp4 0 0 10.251.12.65.56402 17.250.120.76.443 ESTABLISHEDtcp4 0 0 10.251.12.65.56216 124.236.35.11.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54789 59.111.179.136.443 ESTABLISHEDtcp4 0 0 10.251.12.65.54661 59.111.179.136.443 ESTABLISHEDtcp4 0 0 10.251.12.65.53433 140.82.113.25.443 ESTABLISHEDtcp4 0 0 10.251.12.65.53296 122.228.2.250.80 CLOSE_WAITtcp4 0 0 10.251.12.65.53094 113.96.237.18.443 ESTABLISHEDtcp4 31 0 10.251.12.65.52388 110.43.81.8.443 CLOSE_WAITtcp4 31 0 10.251.12.65.52385 110.43.81.8.443 CLOSE_WAITtcp4 0 0 10.251.12.65.52366 101.89.125.232.80 CLOSE_WAITtcp4 31 0 10.251.12.65.52353 114.112.66.45.443 CLOSE_WAITtcp4 0 0 10.251.12.65.51939 10.9.44.194.7001 ESTABLISHEDtcp4 0 0 10.251.12.65.51938 10.9.44.194.7002 ESTABLISHEDtcp4 0 0 10.251.12.65.51937 10.9.44.194.7000 ESTABLISHEDtcp4 0 0 10.251.12.65.51921 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51920 10.9.37.14.4000 ESTABLISHEDtcp4 0 0 10.251.12.65.51919 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51918 10.9.36.159.2379 ESTABLISHEDtcp4 0 0 10.251.12.65.51917 10.9.25.53.80 ESTABLISHEDtcp4 0 0 10.251.12.65.60346 52.11.35.6.443 ESTABLISHEDtcp4 0 0 10.251.12.65.63898 17.188.166.20.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52766 61.151.165.0.80 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52765 fe80::aede:48ff:.52032 ESTABLISHEDtcp6 0 0 fe80::aede:48ff:.52750 fe80::aede:48ff:.61000 ESTABLISHEDtcp4 0 0 10.251.12.65.52699 17.57.145.6.5223 ESTABLISHEDtcp4 0 0 10.251.12.65.52680 114.221.148.67.8080 ESTABLISHEDtcp4 0 0 10.251.12.65.52677 203.119.129.64.443 ESTABLISHEDtcp4 0 0 127.0.0.1.63342 127.0.0.1.52602 ESTABLISHEDtcp4 0 0 127.0.0.1.52602 127.0.0.1.63342 ESTABLISHEDtcp4 0 0 10.251.12.65.52975 118.126.97.71.22 ESTABLISHEDtcp4 0 0 127.0.0.1.56472 127.0.0.1.56471 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56474 TIME_WAITtcp4 0 0 127.0.0.1.56476 127.0.0.1.56475 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56477 TIME_WAITtcp4 0 0 127.0.0.1.56479 127.0.0.1.56478 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56480 TIME_WAITtcp4 0 0 127.0.0.1.56482 127.0.0.1.56481 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56483 TIME_WAITtcp4 0 0 127.0.0.1.56485 127.0.0.1.56484 TIME_WAITtcp4 0 0 127.0.0.1.56486 127.0.0.1.54530 TIME_WAITtcp4 0 0 127.0.0.1.56488 127.0.0.1.56487 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56489 TIME_WAITtcp4 0 0 127.0.0.1.56491 127.0.0.1.56490 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56493 TIME_WAITtcp4 0 0 127.0.0.1.56495 127.0.0.1.56494 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56498 TIME_WAITtcp4 0 0 127.0.0.1.56500 127.0.0.1.56499 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56501 TIME_WAITtcp4 0 0 127.0.0.1.56503 127.0.0.1.56502 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56504 TIME_WAITtcp4 0 0 127.0.0.1.56506 127.0.0.1.56505 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56507 TIME_WAITtcp4 0 0 127.0.0.1.56509 127.0.0.1.56508 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56510 TIME_WAITtcp4 0 0 127.0.0.1.1080 127.0.0.1.56333 TIME_WAITtcp4 0 0 10.251.12.65.56334 194.147.35.147.15895 TIME_WAITtcp4 0 0 127.0.0.1.56512 127.0.0.1.56511 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56515 TIME_WAITtcp4 0 0 127.0.0.1.56517 127.0.0.1.56516 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56519 TIME_WAITtcp4 0 0 127.0.0.1.56521 127.0.0.1.56520 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56522 TIME_WAITtcp4 0 0 127.0.0.1.56524 127.0.0.1.56523 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56527 TIME_WAITtcp4 0 0 127.0.0.1.56529 127.0.0.1.56528 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56530 TIME_WAITtcp4 0 0 127.0.0.1.56532 127.0.0.1.56531 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56533 TIME_WAITtcp4 0 0 127.0.0.1.56535 127.0.0.1.56534 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56536 TIME_WAITtcp4 0 0 127.0.0.1.56538 127.0.0.1.56537 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56540 TIME_WAITtcp4 0 0 10.251.12.65.56539 183.131.57.100.443 TIME_WAITtcp4 0 0 127.0.0.1.56542 127.0.0.1.56541 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56543 TIME_WAITtcp4 0 0 10.251.12.65.56546 101.89.38.155.80 TIME_WAITtcp4 0 0 127.0.0.1.56545 127.0.0.1.56544 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56547 TIME_WAITtcp4 0 0 127.0.0.1.56549 127.0.0.1.56548 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56550 TIME_WAITtcp4 0 0 127.0.0.1.56552 127.0.0.1.56551 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56556 TIME_WAITtcp4 0 0 127.0.0.1.56558 127.0.0.1.56557 TIME_WAITtcp4 0 0 127.0.0.1.54530 127.0.0.1.56559 TIME_WAIT 9 5 0 8192 32768 com.apple.network.tcp_ccdebug 则最后一行(无用项)无法过滤 awk有两种模式, BEGIN模式类似golang的init,END有些类似defer 再回到netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a,S[a]}&#39;, 先用{++S[$NF]}去操作数据,再处理完后,再做{for(a in S) print a,S[a]}操作. 如果把END去掉,即netstat -n | awk &#39;/^tcp/ {++S[$NF]} {for(a in S) print a,S[a]}&#39;,结果为: 如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960ESTABLISHED 1ESTABLISHED 2ESTABLISHED 3ESTABLISHED 4ESTABLISHED 5ESTABLISHED 6ESTABLISHED 7ESTABLISHED 8ESTABLISHED 9ESTABLISHED 10ESTABLISHED 11ESTABLISHED 12ESTABLISHED 13ESTABLISHED 14ESTABLISHED 15ESTABLISHED 16ESTABLISHED 17ESTABLISHED 18ESTABLISHED 19ESTABLISHED 20ESTABLISHED 21ESTABLISHED 22ESTABLISHED 23CLOSE_WAIT 1ESTABLISHED 23CLOSE_WAIT 2ESTABLISHED 23CLOSE_WAIT 3ESTABLISHED 23CLOSE_WAIT 4ESTABLISHED 23CLOSE_WAIT 5ESTABLISHED 23CLOSE_WAIT 5ESTABLISHED 24CLOSE_WAIT 5ESTABLISHED 25CLOSE_WAIT 5ESTABLISHED 26CLOSE_WAIT 5ESTABLISHED 27CLOSE_WAIT 5ESTABLISHED 28CLOSE_WAIT 5ESTABLISHED 29CLOSE_WAIT 5ESTABLISHED 30CLOSE_WAIT 5ESTABLISHED 31CLOSE_WAIT 5ESTABLISHED 32CLOSE_WAIT 5ESTABLISHED 33CLOSE_WAIT 5ESTABLISHED 34CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 1CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 2CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 3CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 4CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 5CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 6CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 7CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 8CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 9CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 10CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 11CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 12CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 13CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 14CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 15CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 16CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 17CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 18CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 19CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 20CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 21CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 22CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 23CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 24CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 25CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 26CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 27CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 28CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 29CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 30CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 31CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 32CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 33CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 34CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 35CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 36CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 37CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 38CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 39CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 40CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 41CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 42CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 43CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 44CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 45CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 46CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 47CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 48CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 49CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 50CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 51CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 52CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 53CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54CLOSE_WAIT 5ESTABLISHED 34TIME_WAIT 54 $NF 表示的最后一个Field（列），即输出最后一个字段的内容 S只是一个临时变量,换成其它字符表示一样,如: ++和其他编程语言作用一样,可以放在前面即++i,也可以放在后面即i++ 如, 打印九九乘法表: seq 9 | sed &#39;H;g&#39; | awk -v RS=&#39;&#39; &#39;{for(i=1;i&lt;=NF;i++)printf(&quot;%dx%d=%d%s&quot;, i, NR, i*NR, i==NR?&quot;\\n&quot;:&quot;\\t&quot;)}&#39; 参考: 菜鸟教程-awk find . -name &#39;*.go&#39; -exec grep -nHr &#39;inittask&#39; {} \\; -exec 能替换为 | 吗？ ---exec是对匹配到的结果，再执行某项操作，比如更改权限 grep的nHr选项 加不加的区别：","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"尔送冰舸来仙乡","date":"2018-04-20T15:59:26.000Z","path":"2018/04/20/尔送冰舸来仙乡/","text":"终至临安府，这日西湖游荡，却觉甚妙，不负诗魔坡仙之赞誉。段誉之北冥神功，后与星宿派化功大法糅合，成亦正亦邪之吸星大法。这日游梅庄，却不知几百年后的明代，此地会与其庶传后人有若干关联。 临安府市列珠玑，户盈罗绮，开销又自不小。段誉别无他技，这日临暮，忽生一计。于拱宸桥尖，自觉身无长物，哀感不尽，滚滚并来，便奏起在无锡三清殿老道所授乐曲，其声呜呜，如泣如诉，听者为之动声，观者为之泪目。方寸便得数铢。此后多年，三清殿有一私生小道，双目失明，命途多舛，其整合旧传音律，加之自己身世不幸，常对二泉以自诉。此后竟成名曲，与嵇康之&lt;广陵散&gt;，王摩诘之&lt;渭城曲&gt;不分轩轾。夜深人散，段誉收起破碗，掂量所得，颇重。便至一旁牛家村“曲三酒馆”买醉。这武林城名之不虚，尚武者甚众。这小小酒肆，竟也列陈十八般兵刃。 段誉自是不知，这曲三酒馆掌柜有一玄孙，天赋异禀，时海外桃花岛声名鹊起，不辞烟波至此学艺，却不期后来同门事起，一师兄师姐私好，盗师秘籍，逃窜漠北。 其师怪僻，一怒之下，废其身而逐师门。同怜有师兄豪门陆氏，归太湖归云庄；有师弟贫病冯氏，回苏北乡间铸铁为业。曲氏便回牛家村，承继了这间酒馆。近乎同期，牛家村有郭杨二兄弟，梁山好汉/将门之后。乐善好施，打抱不平。二人夫人皆欲产，便指腹曰“若为璋瓦便结连理，若同是男儿便结兄弟金兰”。时靖康之变已久矣，然金人虎视，朝堂无力，南人尽有去国之悲。有一道人路过，定二婴名为“靖康”。却若白云苍狗，此后渡尽劫波，郭姓男童远走大漠，而后与曲氏师傅之女相识于张家口，却不是三言两语所能道清。 曲氏无一日不祈师傅原谅，重回师门，却不思其无过错，却断双腿。知其师喜爱丹青，竟至南宋宫中偷盗。开掘密室，藏匿珍宝。河边常走，终一日为宫中职守发觉，追至此，同西归于密室。此间极有曲折，郭黄二人疗伤，后战死襄阳，草蛇灰线，伏埋千里。酒酣饭足，忽得传信。这蛮荒之地的福建有一古刹名南少林，常年无名。后忽得一绝学，名”red sun cookbook”，据传与数百年后闻名江湖的&lt;九阴真经&gt;一样，为宫中高人所著。却说此时江湖，古刹因武学最盛者，为中州少林寺之&lt;易筋经&gt;，与大理天龙寺之&lt;六脉神剑&gt;。 段誉自是好奇，这南少林得之瑰宝亦或鸡毛。便决定继续南下。后人皆知，这秘籍确非同小可，后来的吸星大法亦是不敌。而纵再有奇遇，得此至宝，以段氏“五罗轻烟掌”之秉性，也自是绝计不会修炼。其实段誉南去，还有一个原因。便是连日行走，鞋已尽破。听闻南少林寺所在的莆田，鞋做的不错，便要去试试","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"浮槎北溟海茫茫","date":"2018-04-20T15:57:20.000Z","path":"2018/04/20/浮槎北溟海茫茫/","text":"却说段誉自无锡杏子林一别乔峰，便沿驿道东进，到了姑苏。自春秋以来，此间便为繁盛之地，待至隋炀开凿运河，千里通波，便更是八街九陌琼楼玉宇。馆娃宫依存，虎丘塔仍在，燕子坞与曼陀山庄，却似蓬莱，青鸟无着。段誉羁旅在外，又兼此，心中愁绪尽起，这日便至寒山寺寻渡。这寺初建于自上而下全民兴佛的南朝梁年间，初名“妙利普明塔院”。太宗贞观年间，由名僧寒山在此修缮扩建，更名“寒山寺”。天宝年间，襄阳人张继科考不第，宿经姑苏，霜天寒夜月落乌啼，孤舟客子见江枫渔火，夙夜难眠，写下诗作流传不朽。寺院住持一番鸡汤劝慰，知是大理世子，谙熟翰墨，便请题诗。段誉提笔欲挥，忽思起前唐武宗，虽位在灭佛的“三武一宗”，却对此诗甚喜，亲为寺题碑并留谶语：复题碑者不得善终。段誉早年偏居大理，曾听天竺人说：西有古国名埃及，其头领曰法老，有一年轻早夭者图坦卡蒙，为防陵寝被盗，尝留诅咒，百试皆应。思及此，段誉便绝笔婉拒。事后来看，却是躲过一劫，及至明清，皆有名流题&lt;枫桥夜泊&gt;碑，倏而皆殒。至20世纪30年代，倭国袭扰，金瓯半丧。扶桑人曾惦此碑，时有爱国者，损身以应，令倭人胆裂而色变。点此查看相关自辞姑苏，顺吴淞江而下，至华亭县。这华庭初是浙东会稽郡某县东面一亭（乡），后吴将陆逊于夷陵大败蜀先主刘备，得赐王侯于此。至玄宗天宝年间，始置县制。全域平坦一览无余，只西南有山亦有水，为浙江天目之余脉。便得之“华亭”。及至元代，方升为府，改名松江。段誉由姑苏大邑乍至小地，青旗沽酒，多有不适。这日在井边饮水，忽听浣纱女“重湖叠巘清嘉。有三秋桂子，十里荷花”，心思运河两岸多处繁华，尤以武林城为最。又听人言，“来了苏杭，忘了爹娘”，姑苏自是不虚行，却不曾至余杭，图虚度至弱冠，岂不可惜，遂折道西南。时有人柳氏名“三变”，科场不遇，混迹烟花柳地，造词谱乐，虽靠歌妓接济度日，然词多有普及，甚或流传千年。华亭与武林城相隔近300里，段誉连日舟车，颇觉劳顿。这日至嘉兴，城中有湖名“南湖”，湖边有酒楼，便停顿数日稍作休整。及至临去，却才觉在无锡与乔峰斗酒十千，自已银两无多，又几日挥霍，临此才知捉襟见肘。酒肆掌柜见段誉有魏晋风度，拓拓之风，便不为难，言道“本楼新开，暂名”未名”，今请公子，抛砖引玉，以启后来人潘江陆海”。段誉极目，见那湖上烟雨濛朦，虽是晴天，却如雨日。便书名为“烟雨楼”。此楼兴隆百年，及至南宋末年，一班武林人士于此斗殴，桌凳楼体，毁损严重。脱身嘉兴方一日，便到海宁。陈氏与查氏为此地望族。近千年后，此地有查姓财主，喜得麟儿，定名“良镛”。此公好足球，好诗书，却两次为学堂除籍。后至上海又远走香江。然多事之秋其父被枪决，愤懑之中百感并集。曾将江湖旧事收纳集结，引为佳话。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"丁公凿井: Rob Pike奥运银牌?","date":"2018-04-20T12:16:08.000Z","path":"2018/04/20/丁公凿井-Rob-Pike奥运银牌/","text":"从一链接来到了“Go语言”三巨头之一，同时也是utf-8设计人和Unix重要开发者之一的Rob Pike词条下。 粗粗一扫，如同其他登峰造极可堪“之父”级的人一样，这位大神并不只在代码领域造诣精深，兴趣爱好广泛且均有不俗成绩。 但扫到还是“1980年奥运会射箭银牌得主”，敏锐生出疑问:1980年莫斯科奥运会不是遭到了我国和欧美多国的联合抵制，这位Rob Pike，难道和Google的Sergey Brin一样，是后来从俄罗斯移民到美国？ 但我又分明模糊地感知，除去Ruby和Lua出自日本人和巴西人之手，其他为我广泛接触并使用的语言或系统，“其父”多为西欧/北欧/北美人。 C语言之父出生于美国（同时也是Unix之父，在乔布斯逝世一周后离开人世，却鲜有人祭奠），C++之父出生于丹麦，Java之父出生于加拿大，PHP之父出生于加拿大，Python之父出生于荷兰，Linux之父生于芬兰 … 我搜索了Rob Pike的国籍，生于加拿大。而加拿大作为西方阵营，妥妥没有参与1980年莫斯科奥运会（且因为1976年为蒙特利尔奥运会，二者交接十分冷清）。 继而又查阅了那届奥运会射箭项目银牌得主，确信非此大牛。 而输入关键词，中文互联网充斥着这一虚假介绍。然后谷歌，得到了也许是整个中文网站唯一一条辟谣的消息。… 那我就纳闷了，这一谣传是是怎样差之毫厘，最后谬以千里以成丁公凿井的..","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"批量清空某个库下所有表,保留空库","date":"2018-04-09T12:47:23.000Z","path":"2018/04/09/批量清空某个库下所有表-保留空库/","text":"first.拼接得到N条drop语句 select concat(‘drop table ‘,table_name,’;’) from information_schema.TABLES where table_schema=’你的库名’; then,执行 复制,执行~","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"沈园凭记","date":"2018-04-06T15:34:43.000Z","path":"2018/04/06/沈园凭记/","text":"陆放翁的一生，少年歌楼，壮年客舟，暮年僧舍，是传奇的一生，多情的一生，壮怀激烈的一生。 与年长他41岁的李清照比，多了些“铁马秋风大散关”“中原北望气如山”“尚思为国戍轮台”的亲身实践，一声临去之时的“家祭无忘告乃翁”，也可和宗泽并称，和800年后“海内尘氛犹未已”一样让后人扼腕唏嘘。而在战乱中青春与幸福一去不返的易安居士，只有对不战而亡的夫婿“至今思项羽”的恨铁不成钢，流离中家破人亡，收藏遗失，又经“二婚”为别有用心的人利用，同是可“深巷明朝卖杏花”的春日，于她是“载不动许多愁”。 而与小他15岁,自小在金占区长大的少年英雄辛弃疾比，他生在临安以南的绍兴，依存些许王羲之贺知章当年的闲适，干戈杀伐离之甚远。他多了“红酥手，黄滕酒”的纠结缠绵，作此词时值科举不第，本是在沈园散心，却看到被恶母拆散的青梅竹马的表妹–也是前妻的唐婉与不弃她的新夫同游，状若春燕双飞。其心中郁结百感并集，时隔千年，依觉分毫不差。唐婉写完同名回复“人成各，今非昨，病魂常似秋千索”，用“难难难，瞒瞒瞒”作答“错错错，莫莫莫”，不久便香消玉殒。 44年后，屡经仕途坎坷人际困顿，已是古稀老翁的陆游重游沈园，佳人梦断香消已四十余年，当年的柳树也年老不再生出纷纷柳絮。但那个小她两岁，28岁便驾鹤西归的明媚少女，那个40多年前的春天，那两首二人“唱和”的&lt;钗头凤&gt;，却纷纷点点浮上这个白首老翁的心头，于是动笔写下了&lt;沈园二首&gt;： 城上斜阳画角哀，沈园非复旧池台。 伤心桥下春波绿，曾是惊鸿照影来。 10年后，85岁的陆游带着未尽的克复中原的雄心大志，与世长辞。 &emsp;&emsp;&emsp;&emsp;2018年清明节,于绍兴","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"mysql数据库主从同步,实现读写分离","date":"2018-04-02T11:34:54.000Z","path":"2018/04/02/mysql数据库主从同步-实现读写分离/","text":"主服务器上的操作1.编辑 master主服务器的 mysql配置文件vim /etc/my.cnf (或/etc/mysql/my.cnf,看编译安装时选择的路径),添加: [mysqld]server-id=1log_bin=master-binlog_bin_index=master-bin.indexbinlog_do_db=shuang #备注: log_bin 启动MySQL二进制日志，即数据同步语句，从数据库会一条一条的执行这些语句。 binlog_do_db 指定记录二进制日志的数据库，即需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可。 binlog_ignore_db 指定不记录二进制日志的数据库，即不需要复制的数据库名，如果有多个数据库，重复设置这个选项即可。 其中需要注意的是，binlog_do_db和binlog_ignore_db为互斥选项，一般只需要一个即可。 shuang为要同步的库名称 #注:此过程可能会报错,有格式问题,经过vim编辑后会变成utf-8格式,而mysql的配置文件需要是ascii格式.点此查看更多 2.创建从服务器的用户和权限进入mysql: mysql -uroot -p 创建从数据库的masterbackup用户和权限 mysql&gt; grant replication slave on . to masterbackup@’192.168.17.%’ identified by ‘123456’; #备注: #192.168.17.%通配符，表示0-255的IP都可访问主服务器，正式环境请配置指定从服务器IP\\ #若将 192.168.17.% 改为 %，则任何ip均可作为其从数据库来访问主服务器 退出mysql: exit; 重启mysql服务: service mysql restart 3.查看主服务器状态进入mysql: mysql -uroot -p mysql&gt; show master status; 从服务器上的操作1.编辑从服务器mysql的配置文件: [mysqld]server-id=2relay-log=slave-relay-binrelay-log-index=slave-relay-bin.indexreplicate-do-db=shuang #备注： server-id 服务器唯一标识。 log_bin 启动MySQL二进制日志，即数据同步语句，从数据库会一条一条的执行这些语句。 binlog_do_db 指定记录二进制日志的数据库，即需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可。 binlog_ignore_db 指定不记录二进制日志的数据库，即不需要复制的数据库名，如果有多个数据库，重复设置这个选项即可。 其中需要注意的是，binlog_do_db和binlog_ignore_db为互斥选项，一般只需要一个即可。 数据库指定为”shuang”,需和主库指定的要同步的库一致 重启mysql服务: service mysql restart 2.(在从服务器上)连接master主服务器:进入mysql: mysql -uroot -p 连接master主服务器: change master to master_host=’主库ip’,master_port=3306,master_user=’主库用户名’,master_password=’主库密码’,master_log_file=’master-bin.000002’,master_log_pos=154; #备注: master_log_file对应show master status显示的File列：master-bin.000002。(需和上图一致) master_log_pos对应show master status显示的Position列：154。(需和上图一致) 3.启动slave数据同步:启动slave数据同步: mysql&gt; start slave; 停止slave数据同步(如有需要): mysql&gt; stop slave; 4.查看slave信息: mysql&gt; show slave status\\G; Slave_IO_Running和Slave_SQL_Running都为yes，则表示同步成功。 测试&amp;验证 经验证,在主库中增删改,会极速影响到从库;在从库中增删改,则不会影响主库,于是实现了主从同步;读写分离可在程序设计中实现:主服务器只用于写,从服务器只用于读 解决错误若在主从同步的过程中，出现其中一条语句同步失败报错了，则后面的语句也肯定不能同步成功了。例如，主库有一条数据，而从库并没有这一条数据，然而，在主库执行了删除这一条数据的操作，那么从库没有这么一条数据就肯定删除不了，从而报错了。在此时的从数据库的数据同步就失败了，因此后面的同步语句就无法继续执行。 在此不再多展开.更多可参见 关于截图中MariaDB和MySql, 点此查看海豚和海豹的渊源\\ 两者技术层面对比","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"「通灵芯片---计算机运作的简单原理」","date":"2018-03-24T15:51:04.000Z","path":"2018/03/24/「通灵芯片-计算机运作的简单原理」/","text":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"添加索引,优化查询","date":"2018-03-24T12:11:25.000Z","path":"2018/03/24/添加索引-优化查询/","text":"配合此工具体验更佳: 查看数据库字段&amp;索引简明信息的工具 简介&amp;优缺点 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要修改和维护索引表的信息。建立索引会占用磁盘空间的索引文件。(索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍) 参考: 添加索引 一些基本操作 1.查看当前表的索引:123SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE table_name = '表名' AND table_schema = '库名' 各字段的含义: 或 1show index from 表名; or 1show keys from 表名; 或 1desc 表名; (不推荐) 几种不同Key值的含义: PRI主键约束；(主键) UNI唯一约束；(唯一键) MUL可以重复 (multiple的简写) 关于mysql：SQL键，MUL，PRI和UNI 2.创建索引: a1. 用create index 给某一列创建普通索引 1create index 索引名 on 表名(字段名(长度,可省略)) a2. 用create index 给某一列创建唯一索引 对于唯一索引,索引列的值必须唯一, 但允许有空值. 如果是组合索引,则列值的组合必须唯一. 1create unique index 索引名 on 表名(字段名(长度,可省略)) 如果该列的值存在重复(且重复的值不是null),则会报错: 1Error : Duplicate entry 'xxxxx' for key 'only_cuishuang' 如果该列的值全都不重复,则: b. 用alter table来创建普通索引/唯一索引/主键索引 123alter table 表名 add index 索引名(字段的列表);alter table 表名 add unique 索引名 (字段的列表);alter table 表名 add primary key (字段的列表); 字段的列表(column_list)即想要对哪些列添加索引, 多列时各列之间用逗号分隔. 索引名(index_name)可选, 缺省时, MySQL将根据第一个索引列为其赋一个名称. 另外, alter table允许在单个语句中更改多个表,因此可以在同时创建多个索引.(不重要) 关于主键索引和唯一索引: 如同正方形是一种特殊的矩形,主键索引是一种特殊的唯一索引. 给某一列创建唯一索引,则该列的值除null外,都必须是唯一的(即每一行都各不相同);对于单列唯一索引，需要该单列不包含除null以外的重复的值; 对于多列唯一性索引, 需要这多个值的组合不重复 而主键索引,该列必须是唯一的,且不能有null值. PRIMARY KEY索引和UNIQUE索引非常类似. 事实上,PRIMARY KEY索引仅是一个名称为PRIMARY的UNIQUE索引(且该列无null值)—-这也决定一个表只能包含一个PRIMARY KEY, 因为一个表中不可能具有两个同名的索引. 注意: 当给某个看似存在许多null值的列,建唯一索引时,可能会出现Duplicate entry &#39;&#39; for key &#39;phone&#39;,这并不是上述结论有误,而是这些看似是null的列中,可能有很多是空值. 多个空值是不能建唯一索引的,会报错如上 这时的办法之一是将空值全部改为null. 参考:mysql 中存在null和空时创建唯一索引的方法 3.删除索引:a. 用drop index 来删除某一列上的索引 1drop index 索引名 on 表名; b. 用alter table 来删除索引 1alter table 表名 drop index 索引名 a,b两种方式等效 c. 删除主键索引 1alter table 表名 drop primary key; 一张表只可能有一个主键索引,且就叫做PRIMARY KEY, 因此不需要也无法指定主键索引的索引名. &nbsp;&nbsp; 如果没有创建PRIMARY KEY索引, 但表具有一个或多个UNIQUE索引, 则执行如上命令, MySQL将删除第一个UNIQUE索引.如果表中删除了某列, 则索引会受到影响. 对于多列组合的索引, 如果删除其中的某列, 则该列也会从索引中删除; 如果删除组成索引的所有列,则整个索引将被删除. 因为主键索引所在的id字段设置了自动递增,故而删除时报错. 对某张主键索引所在字段没有设置自动递增的表,执行该命令可将主键索引删除 12345CREATE TABLE `my_test` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT NULL, `createtime` datetime DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 为该表的name字段添加唯一索引 再执行 1alter table my_test drop primary key 报错:1Error : Can't DROP 'PRIMARY'; check that column/key exists 说明 该结论错误 如果没有创建PRIMARY KEY索引, 但表具有一个或多个UNIQUE索引, 则执行如上命令, MySQL将删除第一个UNIQUE索引. 试验开始 控制变量: &nbsp;&nbsp; 有一份user表,结构如下.分别存在本地mysql的两个不同库中,其一有3万多行记录,9977856 Byte(约9.5MB),记为S表; 另外一个 有294万行记录,1121976320 Byte(约1070MB),记为B表. 分别测试有索引/无索引情况下的查询效率 (上图可忽略) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546CREATE TABLE `user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `wx_openid` varchar(80) DEFAULT NULL COMMENT '微信openid', `class` int(10) unsigned NOT NULL COMMENT '0学生1老师', `vip` bigint(10) unsigned DEFAULT '0' COMMENT '至尊VIP过期时间戳', `kdx_id` varchar(40) DEFAULT NULL COMMENT 'kds_id', `nickname` varchar(32) DEFAULT NULL COMMENT '昵称', `password` varchar(100) DEFAULT NULL, `province` int(10) DEFAULT NULL COMMENT '所属省份', `city` int(11) DEFAULT NULL COMMENT '所属城市', `county` int(11) DEFAULT NULL COMMENT '所属区县', `icon` varchar(255) DEFAULT NULL COMMENT '头像', `gender` tinyint(1) unsigned DEFAULT '2' COMMENT '性别,0女1男2未知', `birthday` date DEFAULT NULL COMMENT '生日', `autograph` varchar(800) DEFAULT '' COMMENT '个性签名', `telephone` varchar(12) DEFAULT NULL COMMENT '手机号码', `amount_coin` double unsigned DEFAULT '0' COMMENT 'S币', `invitation_code` varchar(20) DEFAULT NULL COMMENT '邀请码 表示这个客户是其他人推广发展的会员', `status` tinyint(1) DEFAULT '0' COMMENT '状态，0正常 1禁用', `registered_from` tinyint(1) unsigned DEFAULT NULL COMMENT '注册来源0pc网站 1手机网站 2微信网站 3android 4ios 5.微信小程序', `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '0未删除1已删除', `update_time` int(10) unsigned NOT NULL, `create_time` int(10) unsigned NOT NULL, `education` varchar(255) DEFAULT NULL COMMENT '最高学历', `occupation` varchar(255) DEFAULT NULL COMMENT '职业', `auth_key` varchar(255) DEFAULT NULL, `gt_cid` varchar(32) DEFAULT NULL COMMENT '个推CID', `promo_code` char(20) DEFAULT NULL COMMENT '推广码', `name` varchar(40) DEFAULT NULL COMMENT '真实姓名', `use_video` int(1) NOT NULL DEFAULT '0' COMMENT '可否使用课程视频 0不可 1可以', `use_paper` int(1) NOT NULL DEFAULT '1' COMMENT '可否使用习题功能 0不可 1可以', `use_group` int(1) NOT NULL DEFAULT '1' COMMENT '可否使用班级功能 0不可 1可以', `grade` int(1) DEFAULT '1' COMMENT '年级 2-13年级', `is_show_grade` tinyint(1) DEFAULT '1' COMMENT '是否显示年级选择框, 1显示,0不显示', `education_subject` varchar(512) DEFAULT '' COMMENT '教学科目,#分隔', `total_payment` decimal(10,2) unsigned DEFAULT '0.00' COMMENT '支付总额', `total_recharge` decimal(10,2) unsigned DEFAULT '0.00' COMMENT '充值总额', `last_login_time` int(11) unsigned DEFAULT '0' COMMENT '最后登录时间戳', `question_video_open` tinyint(4) DEFAULT '0' COMMENT '录制题目视频权限,1开启,0关闭', PRIMARY KEY (`id`), UNIQUE KEY `promo_code` (`promo_code`), KEY `country` (`country`), KEY `telephone` (`telephone`), KEY `invitation_code` (`invitation_code`) USING BTREE, KEY `vip` (`vip`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=113715879 DEFAULT CHARSET=utf8 COMMENT='注册用户信息' 此处的Key字段中,PRI即说明该字段上面建有主键索引,UNI则说明该字段上有唯一索引,MUL说明该字段上有普通索引 使用 explain 查看是否使用索引 explain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。简单讲，它的作用就是分析查询性能。explain关键字的使用方法很简单，就是把它放在select查询语句的前面。MySQL查看是否使用索引，简单的看type类型就可以。如果它是all，那说明这条查询语句遍历了所有的行，并没有使用到索引。 MySQL的Explain关键字查看是否使用索引 私有笔记-MySQL 执行计划（即explain） 因为MySQL有缓存机制,为使结果更为直观,建议暂时关闭缓存并重启服务, 12SET GLOBAL query_cache_type = 0;SET GLOBAL query_cache_size=0; (实践发现,以上cache_type和cache_size均需设置,才能生效) 重启服务,再执行 1SHOW VARIABLES LIKE 'query_cache_type'; 或 在每次执行前先执行 reset query cache;, 即: 123reset query cache; explain select * from `user` where telephone=15882814328 (未生效) 也可以 1explain select SQL_NO_CACHE * from `user` where nickname = \"3DdcNw\" (未生效) 更多参考: 清空 MySQL 查询缓存 1234567891011121314type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。index: 扫描全部索引树range: 扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询ref: 非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描const, system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。system是const类型的特例，当查询的表只有一行的情况下， 使用system。NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引 字段telephone上有一个索引, 但 ALL说明扫描了所有294万行记录,即没有使用到索引 参考这篇博客谈谈索引失效,其中有4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引, 再次查询: 此时type变为ref,只扫描了1行. 一般来说，得保证查询至少达到range级别，最好能达到ref。 查询没有建索引的字段 对于没有加索引的字段,在查询时type一定是ALL 当查询涉及多表时,索引效果更加显著 当数据量非常大时添加索引效果极佳, 而查询涉及多个表时, 使用索引往往也能使查询速度加快成千上万倍。 例如，有3个未索引的表t1、t2、t3，分别只包含列c1、c2、c3，每个表分别含有1000行数据组成，指为1～1000的数值，查找对应值相等行的查询如下所示。 SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3 此查询结果应该为1000行，每行包含3个相等的值。在无索引的情况下处理此查询，必须寻找3个表所有的组合，以便得出与WHERE子句相配的那些行。而可能的组合数目为1000×1000×1000（十亿），显然查询将会非常慢。 如果对每个表进行索引，就能极大地加速查询进程。利用索引的查询处理如下。 （1）从表t1中选择第一行，查看此行所包含的数据。 （2）使用表t2上的索引，直接定位t2中与t1的值匹配的行。类似，利用表t3上的索引，直接定位t3中与来自t1的值匹配的行。 （3）扫描表t1的下一行并重复前面的过程，直到遍历t1中所有的行。 在此情形下，仍然对表t1执行了一个完全扫描，但能够在表t2和t3上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。 利用索引，MySQL加速了WHERE子句满足条件行的搜索，而在多表连接查询时，在执行连接时加快了与其他表中的行匹配的速度。 索引的原理 参考: MySQL索引原理及慢查询优化 深入理解MySQL索引原理和实现——为什么索引可以加速查询？ MySQL索引原理及实现 MySQL——索引实现原理 MySQL索引背后的数据结构及算法原理 聚集索引与非聚集索引的总结 mysql关于聚集索引、非聚集索引的总结 聚集索引与非聚集索引的总结 探索更多: Mysql性能调优与测试","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Magic Package:gookit/color--控制台颜色渲染工具库","date":"2018-03-16T15:47:20.000Z","path":"2018/03/16/Magic-Package-gookit-color-控制台颜色渲染工具库/","text":"控制台颜色渲染工具库 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"github.com/gookit/color\")func main() &#123; // quick use like fmt.Print* color.Red.Println(\"Simple to use color\") color.Green.Print(\"Simple to use color\\n\") color.Cyan.Printf(\"Simple to use %s\\n\", \"color\") color.Yellow.Printf(\"Simple to use %s\\n\", \"color\") // use like func red := color.FgRed.Render green := color.FgGreen.Render fmt.Printf(\"%s line %s library\\n\", red(\"Command\"), green(\"color\")) // custom color color.New(color.FgWhite, color.BgBlack).Println(\"custom color style\") // can also: color.Style&#123;color.FgCyan, color.OpBold&#125;.Println(\"custom color style\") // internal theme/style: color.Info.Tips(\"message\") color.Info.Prompt(\"message\") color.Info.Println(\"message\") color.Warn.Println(\"message\") color.Error.Println(\"message\") // use style tag color.Print(\"&lt;suc&gt;he&lt;/&gt;&lt;comment&gt;llo&lt;/&gt;, &lt;cyan&gt;wel&lt;/&gt;&lt;red&gt;come&lt;/&gt;\\n\") // apply a style tag color.Tag(\"info\").Println(\"info style text\") // prompt message color.Info.Prompt(\"prompt style message\") color.Warn.Prompt(\"prompt style message\") // tips message color.Info.Tips(\"tips style message\") color.Warn.Tips(\"tips style message\")&#125; 输出为: 顺便学几个单词: Magenta:品红色 Cyan:青色 顺便提了一个bug","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"我曾测天高，而今量地深。","date":"2018-03-14T06:09:53.000Z","path":"2018/03/14/我曾测天高，而今量地深。/","text":"一年后的今天，这家全球最大搜索引擎和最酷公司的首页，可能将不再是圆周率日，而是纪念一位逝去的残疾科学家——这似是刻意而为又或是冥冥之中注定，他一生是如此传奇，即便离去也与众不同。 我曾无数次想爱因斯坦理论实现成真，一定先回300年前牛顿那个时代，做一个陪读的书童或侍从，而终究飘忽难至渺然已远。 牛顿墓碑上刻着“人类啊，你们应该欢呼，你们应该荣幸，曾经存在并与这样一位伟大的人类之光同处一个时代”。放眼望去，大师去后，在这个“后基础科学”时代，当世能担此厚赞者，寥寥几人而已。 我曾测天高，而今量地深。 灵魂归天国，身影没尘土。 这是许多年前，我对自然科学兴趣正酣，从一本书上读到的开普勒的墓志铭，这与笛卡尔的“大梦谁先觉，我思故我醒”一样让人印象深刻，而今，用在这里同样合适。这位“天际立法者”一生不顺，死后也未得安息，因为战争尸骨无存。而斯人虽去，斯世虽落寞多舛，却在身后逾400年光阴中，活在人类这个物种最优秀人群的头脑中，出现在中学物理课本，几乎会与这个星球同寿。 “人类花费了几千年才从神话的朦胧走向理性的澄明”。 “虽然身体受到许多限制，但精神却能自由探索整个宇宙。即使把我关在果壳之中，仍然自以为无限宇宙之王。” “在我 21 岁时，我的期望值变成了零。自那以后，一切都变成了额外津贴。” “我的手指还能活动，我的大脑还能思维；我有终身追求的理想，我有爱和爱我的亲人朋友；对了，我还有一颗感恩的心。”","tags":[{"name":"星陨","slug":"星陨","permalink":"http://www.dashen.tech/tags/星陨/"}]},{"title":"网络编程基础","date":"2018-03-12T13:34:52.000Z","path":"2018/03/12/网络编程基础/","text":"https://segmentfault.com/a/1190000014044351 https://www.youtube.com/watch?v=Rtn9p6PPkrA https://www.processon.com/view/link/5f5054dc1e08531762bc05d6#map 阮一峰-互联网协议入门（一） 阮一峰-互联网协议入门（二） 阮一峰- TCP协议简介阮一峰- 如何验证 Email 地址：SMTP 协议入门教程","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"跨域问题与9种常见解决方案","date":"2018-03-11T13:28:55.000Z","path":"2018/03/11/跨域问题与9种常见解决方案/","text":"跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。 同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM和JS对象无法获得 AJAX 请求不能发送 9种解决方案: JSONP跨域(只适用于GET请求) 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 document.domain + iframe跨域 location.hash + iframe跨域 window.name + iframe跨域 postMessage跨域 WebSocket协议跨域 jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。 参考自: 9种常见的前端跨域解决方案（详解）, 版权归原作者所有","tags":[{"name":"前端","slug":"前端","permalink":"http://www.dashen.tech/tags/前端/"}]},{"title":"http2.0的改进","date":"2018-03-11T11:35:26.000Z","path":"2018/03/11/http2-0的改进/","text":"Demo: 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。 http 1.1用时接近15秒,http 2.0用时不到2秒. 大概能快4-6倍这个数量级 gRPC底层基于http 2.0 相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化： 单一长连接&amp;多路复用 单一长连接： HTTP/2中，客户端向某个域名的服务器请求页面的过程中，只会创建一条TCP连接，即使这页面可能包含上百个资源。 单一的连接是HTTP2的主要优势，单一的连接能减少TCP握手带来的时延 。HTTP2中用一条单一的长连接，避免了创建多个TCP连接带来的网络开销，提高了吞吐量。 多路复用： 直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完。 HTTP1中，请求就因域名链接数已超过限制，而被挂起等待了一段时间 头部压缩和二进制格式 头部压缩： HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。 HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送； 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 二进制分帧： HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。 HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。 服务端推动Server Push Server Push： 服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。 该功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。 这个功能帮助客户端将Z放进缓存以备将来之需。 参考: HTTP/2 相比 1.0 有哪些重大改进？","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"#诺坎普神迹一周年#","date":"2018-03-09T13:08:35.000Z","path":"2018/03/09/诺坎普神迹一周年/","text":"###诺坎普神迹一周年### 过后的一年里我数次回看这场荡气回肠的经典之战，梅西跳上广告牌挥臂称王的画面，即便事过许久，也多次出现在讲求实效性的体育杂志各大版面。 高潭石落，迸起数丈涟漪，经年不消。主导惊天逆转的内马尔，也是众人期许中的未来世界第一和诺坎普新王，也许在梅西跳上广告牌那刻，已然心有去意。再兼中东土豪的国家战略，为金元足球推波助澜，几个月后，这位25岁的桑巴军团的领军人物远走巴黎，身赴敌场，在遗憾波塞冬的三叉戟自此形如闰土钢叉的同时，也让吃瓜群众惊叹：这个世界太疯狂，耗子给猫当伴娘。 双方晋级或淘汰，直至比赛最后一分钟才见分晓。落寞的大巴黎门将，和主教练揉眼的画面一道，成为这支欧战屡败屡战的球队再次落败的悲情画面。而不久后，有内马尔和姆巴佩，“四亿齐飞”的大巴黎与蓝月亮一道，成为金元足球下的“新豪门”，一场对阵拜仁的大胜，让人惊呼足坛变天。而此刻，作为这艘核动力航母的舰长，埃梅里，再次把航空母舰开翻。 获胜的巴萨创造了历史，中场的塌陷，却没能让这支倚赖传控的球队走得更远。尤文图斯的链式防守，年迈的“老妇人”，在今天能硬生生把“青春风暴”热刺压得脾气全无，也让红蓝军团在一年前，并没有再延续好运。 上赛季的巴萨，如风雨中飘摇的“黑珍珠”，联赛冠军和大耳朵杯皆被死敌拿走。尤是失去内马尔后，赛季之初的“被双杀”，西甲球迷一度认为，几年前巴萨统治全欧的控制力，而今轮到了皇马。红蓝球迷也许要不得不接受，梦三和msn之后，一段长时间的低迷衰落。 足球的迷人和世事的叵测不决也正在此。而今看来，这位小个子教练的变阵试水，竟有扮猪吃虎之奇效。风头无两的齐达内贪天之功，一时头脑发昏。莫拉塔出走英伦，J罗远赴德甲，更为关键，把作为“阵眼”的漏哥扫地出门。…而今，只辉煌一度的银河战舰，已提前告别联赛。而似有天佑的欧冠战场，能否卫冕再创历史，还犹未可知。 是役，卡瓦尼第62分钟的进球，让巴萨球迷心头烛火似如雨浇。这意味着最后30分钟，必须要进三球。而此战能垂名几十载，正在此处。最后时分，将球垫入球网的人，是拉玛西亚新出品的罗贝托。也是他，在上赛季第二回合国家德比中，2:2比分的最后一刻，从后场奔袭50米，助梅西绝杀皇马。…在哈维已去，老白渐老，梅西皮克87黄金一代已届而立，步入职业生涯后半程时，罗贝托的出现，延续了拉玛西亚渐弱的辉光。 白云幻苍狗，沧海成桑田，世事弹指转瞬。在喜怒间，一年又过。一年前，我曾无比希望快快过去，而现在，却有一些怀念。","tags":[{"name":"足球&体育","slug":"足球-体育","permalink":"http://www.dashen.tech/tags/足球-体育/"}]},{"title":"nginx神奇玩法小聚义","date":"2018-02-24T03:42:31.000Z","path":"2018/02/24/nginx神奇玩法小聚义/","text":"location的路由匹配规则 参见: 亲测体验Nginx中location的优先级 参考:(Nginx路由匹配规则的一些理解)[https://www.jianshu.com/p/a7348eded963] 添加访问的权限认证 参见: 搭建gitbook&amp;访问权限认证","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"一道Rust面试题","date":"2018-02-23T13:46:22.000Z","path":"2018/02/23/一道Rust面试题/","text":"开发环境指引 IDE可选择Clion试用版，安装Rust插件，rust编译环境使用官方命令行安装 Rust题目1背景马斯克发布Tweet后，BTC现货币价经常有波动，对于量化交易来说，这是一种风险，也是一种机会 需求 监控马斯克的Twitter账号有新的tweet发布时发送报警事件； 报警事件发出后，每30秒输出一次BTC现货币价和发布时的涨跌幅； 【可选】上述报警事件和涨跌幅如果用web页面实时展示出来，Web开发可参考使用actix_web开发框架+tera模板引擎； 【可选】发送报警事件时，给出是对BTC现价是利空消息还是利多消息的概率估计 Rust题目2需求描述对于给定的kline的离线数据(本空间中文件v3_kline_2021_06_23.tar.gz)，请使用rust写回测，1分钟涨1%之后买入，第二分钟平掉，预期利润是多少？ 1234// 文件说明v3_kline_2021_06_23tar.gz文件解压后得到的文件为6月23日0点到9点按每分钟一聚合的K线数据，文件是文本文件使用lzma压缩算法压缩而成，具体数据格式见下// 数据格式说明dump纳秒时间戳 &apos;\\t&apos; shmId &apos;\\t&apos; 交易所 &apos;\\t&apos; preCoin &apos;\\t&apos; postCoin &apos;\\t&apos; 交易所返回的k线时间 &apos;\\t&apos; 开 &apos;\\t&apos; 高 &apos;\\t&apos; 低 &apos;\\t&apos; 收 &apos;\\t&apos; 量 &apos;\\t&apos; 其他 rust_exercize","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"从0开始Vue","date":"2018-02-22T06:22:03.000Z","path":"2018/02/22/从0开始Vue/","text":"安装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647brew先安装好node和npmnpm install -g cnpm --registry=https://registry.npm.taobao.org# 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project(你想叫的项目名称)# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.? Project name charles_register? Project description A Vue.js project? Author cuishuang &lt;cuishuang@bilibili.com&gt;? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Set up unit tests Yes? Pick a test runner jest? Setup e2e tests with Nightwatch? Yes? Should we run `npm install` for you after the project has been created? (recommended) npm vue-cli · Generated \"charles_register\".# Installing project dependencies ...# ========================安装各种依赖...# Project initialization finished!# ========================To get started: cd charles_register npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 执行: 123$ cd my-project$ cnpm install$ cnpm run dev 熟悉项目目录,配置IDE 先熟悉下目录结构: webstorm中实现vue 项目按住ctrl+引用组件名自动跳转到对应组件 这样就可以直接点过去 组件的内容是：template（构成HTML骨架） 、script（数据交互事件响应）、style scoped（受限作用域的CSS样式）,即所谓的 结构,样式,和行为 Vue.js进阶 进行开发 需求:做一个简单的获取Charles注册码功能,前端只需要拿到用户输入的名称,提交给服务端,再将结果展示给用户即可~ 前端样式,获取用户输入的信息 使用axios发送http请求 cnpm install axios 解决跨域问题: 安装 http-proxy-middleware cnpm install -s http-proxy-middleware 在config/index.js下,将proxyTable做如下配置: 123456789101112proxyTable: &#123; // 配置跨域 '/api': &#123; target: 'http://localhost:8081/register', // ws: true, secure: false, changeOrigin: true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite: &#123; // 路径重写， '^/api': '' // 替换target中的请求地址，也就是说以后你在请求http://localhost:8081/api这个地址的时候直接写成/api即可。 &#125; &#125;&#125;, 几个主要文件的代码如下: src/router/index.js:123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Register from '@/components/Register'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Register', component: Register &#125; ]&#125;) config/main.js:123456789101112131415161718192021// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'import axios from 'axios'Vue.config.productionTip = false// 安装其他插件的时候，可以直接在 main.js 中引入并使用 Vue.use()来注册，但是 axios并不是vue插件，所以不能 使用Vue.use()，所以只能在每个需要发送请求的组件中即时引入。// 为了解决这个问题，我们在引入 axios 之后，通过修改原型链，来更方便的使用。// 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http命令Vue.prototype.$http = axios/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) config/index.js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889'use strict'// Template version: 1.3.1// see http://vuejs-templates.github.io/webpack for documentation.const path = require('path')module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123; // 配置跨域 '/api': &#123; target: 'http://localhost:8088/register', // ws: true, secure: false, changeOrigin: true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite: &#123; // 路径重写， '^/api': '' // 替换target中的请求地址，也就是说以后你在请求http://localhost:8088/api这个地址的时候直接写成/api即可。 &#125; &#125; &#125;, // Various Dev Server settings host: 'localhost', // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined autoOpenBrowser: false, errorOverlay: true, notifyOnErrors: true, poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- // Use Eslint Loader? // If true, your code will be linted during bundling and // linting errors and warnings will be shown in the console. useEslint: true, // If true, eslint errors and warnings will also be shown in the error overlay // in the browser. showEslintErrorsInOverlay: false, /** * Source Maps */ // https://webpack.js.org/configuration/devtool/#development devtool: 'cheap-module-eval-source-map', // If you have problems debugging vue-files in devtools, // set this to false - it *may* help // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, cssSourceMap: true &#125;, build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', /** * Source Maps */ productionSourceMap: true, // https://webpack.js.org/configuration/devtool/#production devtool: '#source-map', // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; src/componets/Register.vue:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;div class=\"registerinfor\"&gt; &lt;p&gt;&lt;font color=\"#6495ed\"&gt;请输入想注册的名称,如 &lt;b&gt;zhangsan&lt;/b&gt;&lt;/font&gt;&lt;/p&gt; &lt;input id=\"cui\" type=\"text\" placeholder=\"输入注册名称\" v-model=\"username\"&gt; &lt;p @click=\"register()\"&gt; &lt;button class=\"shuang_button\"&gt;点击注册&lt;/button&gt; &lt;/p&gt; &lt;p&gt;&lt;font color=\"#6495ed\"&gt;密钥为: &lt;/font&gt;&lt;/p&gt; &lt;input id=\"shuang\" type=\"text\" placeholder=\"密钥\" v-model=\"userpass\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Register', methods: &#123; register () &#123; window.console.log(this.username, this.userpass) this.$http(&#123; method: 'post', url: '/api', data: &#123; name: this.username &#125; &#125;).then((response) =&gt; &#123; // vue中的then方法 https://blog.csdn.net/weixin_39225682/article/details/107254797 console.log(response) this.userpass = response.data &#125;) setTimeout(function () &#123; alert('注册成功,请复制密钥,进行激活') &#125;, 500) &#125; &#125;, data () &#123; return &#123; username: this.username, userpass: this.userpass &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;#cui &#123; width: 200px; height: 30px;&#125;#shuang &#123; width: 200px; height: 30px;&#125;.shuang_button &#123; color: darkred; background: aquamarine; font-size: 20px;&#125;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 全部代码在此https://gitee.com/cuishuang/charles_register 解决项目打包后dist文件夹index.html为空白 &amp; 部署到服务器 cnpm run build 打开dist/index.html,预期应该和 http://localhost:8080/#/ 一样,但发现却是空白. 解决vue-cli2和vue-cli3项目分别打包后dist文件中index.html出现空白 对于Vue 2.x, 将config/index.js中 build部分的 assetsPublicPath由&#39;/&#39;改为&#39;./&#39;即可 此时还是有跨域问题 先将代码push到仓库git@gitee.com:cuishuang/charles_register.git 在gitee新创建一个git仓库,并将项目文件夹初始化为git仓库.参照 git 将本地文件夹初始化为git仓库，并上传到对应的github远程仓库中,push代码到仓库 在服务器上,执行 12cnpm installcnpm run build 执行 1234go build http_register.go// 后台运行nohup ./http_register &amp; 然后进行nginx配置. 将匹配到api的请求,交由Go服务即127.0.0.1:8088处理 ngnix配置如下: /usr/local/openresty/nginx/conf/domains/charles_vue.conf 1234567891011121314151617181920212223242526 server &#123; listen 80; server_name charles.dashen.tech; #server_name localhost; access_log /var/log/charles.access.log main; error_log /var/log/charles.error.log; root /home/ubuntu/lab/charles_register/dist; index index.html index.htm; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; add_header Cache-Control 'no-store, no-cache, must-revalidate, proxy- revalidate, max-age=0'; try_files $uri $uri/ /index.html;&#125; location /api &#123; proxy_pass http://127.0.0.1:8088; &#125; &#125; (关于匹配的优先级,rewrite等,可参考 亲测体验Nginx中location的优先级) 再到域名服务商设置相应的A记录. 这里轻车熟路,不需赘述 访问 http://charles.dashen.tech/,即可注册并得到注册码 参考: 菜鸟教程-Vue.js 20-Vue实战项目：电商管理系统（Element-UI）","tags":[{"name":"前端","slug":"前端","permalink":"http://www.dashen.tech/tags/前端/"}]},{"title":"霸王绝响","date":"2018-02-20T15:45:25.000Z","path":"2018/02/20/霸王绝响/","text":"盯着地图看了半天，在天朝实际有这样的情况，但省级行政单位间应该只此一例：甘肃，内蒙，宁夏，陕西四者是任意三者相互交界。这得益于秦陇二省独特的形状 出生于苏北宿迁，身死于皖北宿州 大运河改道，洛阳开封宿州，皆是大输家，而山东获益 那年冬，积雪未消，徒步穿城宿州。后来和一相识聊起，值得一去的景点尽数略过。我说在不熟的小城街巷间徘徊走动，看凌晨的早餐店和匆匆而过的行人，也是风景的一种 不同于自如每月10%的管理维护费,也有别于链家房东租客各50%的佣金, 巴乐兔,这家房屋中介不对看房的租客收钱,只对房东收取房租价格45%的费用(据我了解 其中11%归公司,34%归个人), 于是很有市场. 带我看房的其中一位,交流中得知当过5年兵,刚刚退伍转业,干这行才几个月…这让我一下肃然起敬又充满好奇,于是交谈许久. 他也养了只猫,小区里捡的,断了尾巴,对枪械已经不感任何兴趣,天天摸习惯了.但我还是忍耐不住, 探讨请教了现役的手枪和步枪.或涉敏感,不做多言. 他96年生人,高中毕业便去从军,自言学习不好,喜欢打游戏. 宿州灵璧人,在海鑫（车晓前夫的企业）所在的运城闻喜县当武警,负责看守大山里的弹药库..不见军人刻板的不苟言笑和拘谨,这兄弟乐天且多言.. 非常开心地进行了逾两个小时聊天. 从烈日当空到夕阳西陲他说就喜欢睡觉,在部队很难受,娱乐活动极少,除了站岗训练,其他时间他都躺床上,现在同样如此,晚上打王者荣耀,晚上10点睡,早上10点起.. 在部队站岗是每2个小时一班,一天3次,每隔15分钟可以走动巡视一下.一般义务兵只能做两年,想继续干,除非表现特别好,否则就要xx….见我惊叹,哈哈一笑,说不要把xx想得太高尚,xxxxxx 我问那你呢,他说当时还比较上进,他没xx…为何不继续做下去,而选择转业呢? -不想青春就耗费在大山,攒了些钱就想回去.每月缴满六险二金后到手6000,因为吃喝住宿全无花费,所以可以存住钱,最后退伍时,还有一个19万的转业费. 所以5年他攒了30多万,在同龄人中算是很多的.但问题是转业回到地方后,一切要从头开始..最对口的工作就是保安,或者私人保镖. 但都不喜欢,也可以去本地的公安做民警,编制要考.. 来上海就为赚快钱,做这行每月1万多,做几年就回去了.. 但他的战友,很多不能适应这种转变..他在部队是副班长,手底下有10几个人,这样一下子进社会,这种落差很多人都接受不了.班长是92年的,听说这行不错,也想来试试,”但他做不了”. 我疑惑军人毅力应该很不错,怎么会坚持不下去? 他说这个班长比他能吃苦的多,但是不会变通,不灵光,不会说话…”他是真本事升的班长,我是靠吹吹打打做的副班长,大多数人也是靠这”…而后咧嘴一笑.成为排长就是干部了,退伍后地方会安排工作.但需要立功,而和平时期这很困难谈及前几年的一些事端, 他说可以理解.很多人退伍后,马上挥霍了那笔转业费,之后又没有好的谋生手段,于是… 我很遗憾一生中缺失这么一段无法弥补的体验（在研究预备役行不行[捂脸]）,愈发有兴趣.但经他所说,现实和我想象,出入实在略大.想及位高如郭,徐,尚且如此,其下这般也不需啧啧称奇… 最后我问,有没有感觉国家亏欠于你? 他说没有.是他自己选择,而且攒了这么多钱. 但我隐隐感觉,5年最好的时光, 这个薪资和数额,确实不算多..当重新进入社会,能接受挑战和适应转变,还要另作别论. 最后作别，很可能不租而去选公寓，心有愧惭。他倒达观哈哈一笑说正常正常无妨无妨。无以为报，只以脉动两瓶，相约有空再聊。 头前还有一位，是连云港东海县，与我同岁。交谈中向我传授了好些并不逾法又蹊径独辟的生财之道，听得我一惊一愣。… 大热天找房很累，但破圈聊天，这种体验和收获，平时着实难以获得。不能框限于日常几点一线的一亩三分地，更要谨防进入闭目塞听的信息茧房。 渐能理解，风陵渡口的郭襄，兴奋何来。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"搭建gitbook&访问权限认证","date":"2018-02-19T13:27:02.000Z","path":"2018/02/19/搭建gitbook-访问权限认证/","text":"当年跟着H哥时,使用gitbook作为文档工具. 维护一个文档项目,提交到gitlab,做好配置后,会将markdown自动重新构建为新的页面. 搭建gitbook 该步骤相对较简单,无甚好写.可参考 搭建gitbook 和 访问权限认证 &amp;和git仓库(github或者公司的gitlab)关联 可将之前写的mylab的接口文档用gitbook部署 新建一个文件夹demo， cd demo gitbook init gitbook serve 执行完用git clone git@github.com:cuishuang/book.git的内容覆盖掉demo文件夹里的现有内容 再次执行gitbook serve即可 可点此预览 利用nginx添加 权限认证 像公司内部文档,不希望对外公开,但也不想局限于仅内网可访问. 可利用nginx的认证模块,实现简单的账号密码登陆. 安装 mini-httpd 1sudo apt-get install mini-httpd 而后执行 sudo htpasswd -bc conf/domains/随意设置一个文件名称如cuishuang 你想要设置的登陆账号 你想设置的登陆密码 如下: 1234567location / &#123; root /home/ubuntu/gitbook/_book; index index.html; auth_basic \"爽哥提示:请输入账号和密码\"; auth_basic_user_file cuishuang; #nginx认证文件目录,即上文中设置的文件的绝对或相对路径 try_files $uri $uri/ =404; &#125; 最终的conf文件如下: 123456789101112131415161718192021server &#123; listen 80; server_name gitbook.dashen.tech; #server_name不要加http或https access_log /var/log/gitbook.access.log main; error_log /var/log/gitbook.error.log; location / &#123; root /home/ubuntu/gitbook/_book; index index.html; auth_basic \"爽哥提示:请输入账号和密码\"; auth_basic_user_file cuishuang; #nginx认证文件目录,即上文中设置的文件的绝对或相对路径 try_files $uri $uri/ =404; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 重启nginx, 然后访问. 输入正确的用户名和密码后,即可进入并正常使用","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"在地铁上","date":"2018-02-10T13:08:59.000Z","path":"2018/02/10/在地铁上/","text":"我从良渚出站一路向西，在如“秋荷”“柳映”“随园嘉树”“玉鸟流苏”“竹径茶语”般别致诗意的依山别墅群间，在苍翠蓊郁的行人道上，潮冷清鲜的湿气扑鼻，评述昆曲发展史的&lt;笛声何处&gt;伴着背景乐盈满耳际，感到十分惬意。时已立春，风物已渐露生机，枝草间横生出红黄不等的梅条，隔许远便嗅到浅浅的凝香。而此间却又不同城区，依有深雪未烬的余痕，著物不去，晶莹而有光。 我来到层峦一角下的美丽洲，寻访居于四水之央，缩印“文明曙光”的良渚博物院，却怏怏发觉，自去年8月始，闭馆修葺，耗时需有10月之长。我望着满园空旷，渐有些孤独，但又不愿有别的人，破坏这幅诗话景致。想此偏居城市西北，以往人便不盛，况复年关，诸人多如候鸟秋去。我再待三四日，也便要回去了。 见不开馆，在园中碎石小径间徘徊几遭，就决定回身，从勾良路过毛家漾港，到东西大道，去杜甫村地铁站四遭的融信澜天和万科未来城看看。一条河划开来的阳光天际和崇福社区，像是许多年前的浦东与浦西。崇福村衰败残破的沿街铺面，破旧的招牌近乎与老建筑同寿，许些门上贴着暂停营业的手写告示，透过玻璃，只看到狭小阴湿的店面。与远处高楼林立的工地间，相隔一大片空地，布满各种焉焉得无精打采的菜叶。如长居于此，会有些失落。而我又知未来城价位，委身此处都极是不易，便不由生出些哀叹。 穿104国道，从澜天和未来城-桂语里的围栏路过，觉此处非我预期，便兴味索然，没去售楼处相询。 杜甫村地铁站有一面积偌大的综合体，名永旺梦乐城，看外立面铭牌信息，多是扶桑岛国资本。其内甚是热闹，装潢新潮，地处结合部却并不见土。相比之下处在闹市的“翠园电影大世界”所在的汇和城，总给人一种90年代，县城百货大楼的既视感。从美团信息看，梦乐城有家同类排名全城第四的烧烤店，阿拉提羊肉串。窄窄一间，没有座位，门台前却挤满了等待的男女饕客，闻之食指大动。我要了10串，裹在袋子里，就决定继续徒步。 没出商场，三串便已下肚。走出遇冷，原本焦烫欲滴的油脂凝固，入口又化，撩起后槽牙咬啮，实是说不出的好滋味。沿古墩路行出不久，便要上坡再下坡，跨过绕城高速，来到名义上的“主城区”。 杜甫村与白洋站相距甚近，虽有一道高速划开“城郊”，实地来看，却没有太多两样。紧邻地铁站的奥克斯缔逸城和越秀 星汇悦城原在查看计划，亲临发现，多以告罄。缘是区位配套不甚满意，也未深究。举目见往前便是去年年末之时看过的“海上海”，自三墩至良渚，沿线多已贯通。我觉察无再看必要，就由白洋站下去了。 安保员对我最后几串竹签串起的羊肉粗粗过目，便放我过去了。至入口前，见一年纪不大的妇女正慌，原是几秒钟前，她支付宝刷码欲进，她带的男童倒先一溜烟进去，闸机关闭，再刷码却很显然刷不开了。电光火石让她预料不迭，便问可带有现金，她支付宝转我。我耸耸肩，并未携带。她一面几次嘱咐已在站内的男童呆那别动，同时要去服务中心。我承诺代其照看，至其归来。 这男童不到十岁年纪，胖墩墩的，直角梯形一般的大脑袋，额鼻颔像梯形斜边，依次下坡。双颊冻红，上唇和鼻间未擦净的鼻涕格外显眼。真是一“皮猴子”，却也毫不认生，说着各种网络用语，如用“我也是醉了”表示对他妈方才一波操作之无语。双手撑在闸机墩上，贴来跳去。 待了有几分钟，他妈妈远远走来。多是转账给服务中心工作人员，又用现金购临时票。未至进来，她先言谢。我点头转身离开，是不想其入内再谢或无言之尴尬。扶梯很长，缓缓向下。不料那男童蹦跳着来我身旁，嬉笑着问我。此时列车入站，他妈催促其快走几步，我也胡乱应答几句，与其母子告别。有意走几个车厢，独自静坐。 却不料他上车后，跑过几个车厢，来到我旁边。其母一路紧随，也坐到一旁。他言说了些他是班机歌王问我6不6之类的，其母笑着与我说了几句。便说来由去路，要去三墩他外婆家吃饭。我说到学院路，此行来这边看房。她说现在房子很贵了，不易购买。我叹口气表示认同，并把几个楼面与其交流。她便在奥克斯缔逸城，说除去商铺，与近旁的越秀均已无新房。并说奥克斯商铺除去公摊面积，只得35平，不值入手。… 我直抒此行只觉这边为睡城，白洋虽在绕城路内，却也没什么产业，远不及上周前去的未来科技城。她说几年前他们本地人并不觉未来科技城会成如此热门板块，时其看一140平米新盘，只1万稍多。其夫以之不值购入，现已近4万，已要贷款才能够数，颇有懊悔。笑问其本地人，可都家有数套？其不好意思笑说，还可以，有4套，这方面不用愁。我笑回，那岂不需要愁的顷刻少了多半。而后又笑谈种种，从白洋到三墩，地铁片刻之时。这刻这个顽童不再叨念车厢里的站名，与我挥手道别。 望其背影，听其谈吐，多从事简单事务性劳作，数千薪水。而我累死累活，工薪是其数倍，却要背负未来30年，得一尺寸之地。而我所租xxxxx，又何尝不更是如此。 从xx路出站，傍晚将近，街道全是穿梭的行人车辆。我取出最后两串已凉的羊肉，大口吞进了嘴里。 天色又暗，同时起了风。我双手合抱插在袖口，裹得紧紧的，低头独自一步步挪回了出租房。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"小论sql count(*)","date":"2018-02-03T03:49:30.000Z","path":"2018/02/03/小论sql-count/","text":"那为什么InnoDB不跟MyISAM一样，也把数字存起来呢？ 这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的 count(*)这么慢，我该怎么办？ 高性能MySQL——Count(1) OR Count(*)？ 如果问一个程序员MySQL中SELECT COUNT(1)和SELECT COUNT(*)有什么区别，会有很多人给出这样的答案“SELECT COUNT(*)”最终会转化成“SELECT COUNT(1)，而SELECT COUNT(1)省略了转换的这一步，所以SELECT COUNT(1)效率更高“，甚至有一些面试官也会给出类似的答案。最近在看一些历史遗留代码，绝大多数统计数量的SQL都在用SELECT COUNT(1)，觉得有必要搞清楚这个问题。 首先，以我们最常见的两种数据库表引擎MyISAM和Innodb来讲。 可先参阅:MySQL查看修改存储引擎总结 MyISAM MyISAM在统计表的总行数的时候会很快，但是有个大前提，不能加有任何WHERE条件。这是因为：MyISAM对于表的行数做了优化，具体做法是有一个变量存储了表的行数，如果查询条件没有WHERE条件则是查询表中一共有多少条数据，MyISAM可以做到迅速返回，所以也解释了如果加WHERE条件，则该优化就不起作用了。细心的同学会发现，innodb的表也有这么一个存储了表行数的变量，但是很遗憾这个值是一个估计值，没有什么实际意义。 Innodb的这个行数并不准确 Innodb&amp;原理 如果该表只有一个主键索引，没有任何二级索引的情况下，那么COUNT(*)通过主键索引来统计行数。如果该表有二级索引，则COUNT(*)会通过占用空间最小的字段的二级索引进行统计 . 目前基于磁盘的数据库或者搜索引擎（比如Lucene）的性能瓶颈主要都是在IO阶段，相比于CPU和RAM，IO操作实在太慢了，所以这类系统的优化方向也都都是类似的——尽一切可能减少IO的次数（所以很多用ES的程序在性能优化到极限的时候选择直接上SSD）。这里统计行数的操作，查询优化器的优化方向就是选择能够让IO次数最少的索引，也就是基于占用空间最小的字段所建的索引（每次IO读取的数据量是固定的，索引占用的空间越小所需的IO次数也就越少）。而Innodb的主键索引是聚簇索引（包含了KEY，除了KEY之外的其他字段值，事务ID和MVCC回滚指针）所以主键索引一定会比二级索引（包含KEY和对应的主键ID）大，也就是说在有二级索引的情况下，一般COUNT()都不会通过主键索引来统计行数，在有多个二级索引的情况下选择占用空间最小的。 如果说有张Innodb的表只有主键索引，而且记录还比较大（比如30K），则统计行的操作会非常慢，因为IO次数会很多（这里就不做实验截图了，有兴趣可以自己试一下）。一个优化方案就是预先建一个小字段并建二级索引专门用来统计行数，极端情况下这种优化速度提高上千倍也是正常的。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"索引使用策略","date":"2018-01-27T11:34:30.000Z","path":"2018/01/27/索引使用策略/","text":"何时要使用索引？ 主键自动建立唯一索引(其实是主键索引)；经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；作为排序的列要建立索引；查询中与其他表关联的字段，外键关系建立索引;高并发条件下倾向组合索引；用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引 何时不要使用索引？ 经常增删改的列不要建立索引；有大量重复的列不建立索引；表记录太少不要建立索引。 只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快–不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。 建索引的几大原则 1.最左前缀匹配原则 非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2.=和in可以乱序 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 3.尽量选择区分度高的列作为索引 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 4.索引列不能参与计算 保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。 5.尽量的扩展索引，不要新建索引。 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 索引失效的情况: 可参考谈谈索引失效 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。 LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。 在索引的列上使用表达式或者函数会使索引失效 例如：select from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select from users where adddate&lt;’2007-01-01′。其它通配符同样，也就是说，在查询条件中使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。 在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。 特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（其实, 不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效） 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。 字符串不加单引号会导致索引失效。 更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败，应该改为WHERE email=’99999’。 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引, 则select * 不会导致索引失效。 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引； 索引的优化 1、最左前缀 索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引&lt;col1,col2,col3&gt;那么以下3中情况可以使用索引：col1，&lt;col1,col2&gt;，&lt;col1,col2,col3&gt;，其它的列，比如&lt;col2,col3&gt;，&lt;col1,col3&gt;，col2，col3等等都是不能使用索引的。 根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。 2、带索引的模糊查询优化 在上面已经提到，使用LIKE进行模糊查询的时候，’%aaa%’不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化。 为检索的条件构建全文索引，然后使用 1SELECT * FROM tablename MATCH(index_colum) ANGAINST(‘word’); 3、使用短索引 对某列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"'索引'之索引","date":"2018-01-22T10:59:38.000Z","path":"2018/01/22/索引-之索引/","text":"姊妹篇: 谈谈索引失效 索引使用策略 其各种索引 主键索引 非主键索引 聚集索引 非聚集索引 一级索引 二级索引 正排索引 倒排索引 联合索引,覆盖索引,组合索引,多列索引 单列索引 前置索引 全文索引 其聚集索引 &amp; 非聚集索引，正排索引 &amp; 倒排索引SQL主流的索引结构有B+树和Hash,聚集索引及非聚集索引基于B+树索引 而正排索引和倒排索引,是Lucene中的概念,Lucene用的是倒排索引 (暂不需深入探究) MySQL和Lucene索引对比分析 更多关于 Inverted-index 另外,必须要先明确是哪种存储引擎,然后才能再谈索引. 其聚集索引 &amp; 非聚集索引聚集（clustered）索引，也叫聚簇索引, 定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。 聚集索引=主键索引?参见stackoverflow上这个问答:The relationship of Primary Key and Clustered Index 一张表是否可以有主键,但主键上没有聚集索引? 一张表是否可以有聚集索引,但不是主键字段? 答案是: 都可以! A primary key is a logical concept - it’s the unique identifier for a row in a table. As such, it has a bunch of attributes - it may not be null, and it must be unique. Of course, as you’re likely to be searching for records by their unique identifier a lot, it would be good to have an index on the primary key.A clustered index is a physical concept - it’s an index that affects the order in which records are stored on disk. This makes it a very fast index when accessing data, though it may slow down writes if your primary key is not a sequential number.Yes, you can have a primary key without a clustered index - and sometimes, you may want to (for instance when your primary key is a combination of foreign keys on a joining table, and you don’t want to incur the disk shuffle overhead when writing).Yes, you can create a clustered index on columns that aren’t a primary key. 主键是一个逻辑概念---它是表中一行的唯一标识符。 因此，它具有许多属性—如不能为null，并且必须唯一。 当然，由于很可能会通过该唯一标识符来搜索相关记录(数据)，因此在主键上有一个索引会很好。聚簇索引是一个物理概念---它是一个影响记录(数据)在磁盘上存储顺序的索引。 这使它成为访问数据时非常快的索引，但是如果您的主键不是序列号，它可能会减慢写入速度。是的，一张表可以拥有一个不带聚集索引的主键。是的，也可以在不是主键的列上创建聚簇索引。 A primary key is a unique index that is clustered by default. By default means that when you create a primary key, if the table is not clustered yet, the primary key will be created as a clustered unique index. Unless you explicitly specify the nonclustered option. 主键是默认情况下聚集的唯一索引。 “默认情况”意味着在创建主键时，如果表尚未聚集，则主键将被创建为聚集的唯一索引。 除非明确指定非聚集选项。 在mysql的InnoDB存储引擎下, 如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择其作为聚集索引； 如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引； 如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 总结一下就是: 123451) 有主键时，根据主键创建聚簇索引2) 没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引3) 如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引 一张表中主键最多只能有一个,聚集索引有且只能有一个,在SQLServer默认主键就是聚焦索引,但说”主键就是聚焦索引”其实是不太正确的..但大多数情况下,聚集索引就在主键这个字段上,所以在 InnoDB中: 主键索引也称为一级索引,主索引（Primary key） 非主键索引也被称为二级索引（secondary index）,也称为辅助索引,辅索引,可能又包括如”唯一索引”,”普通索引”等 对于 MyISAM,其主索引和辅索引结构是完全一样的,只是主索引要求字段的值不重复,而辅索引字段的值可以重复. 二者都是索引文件仅仅保存数据记录的行号, 然后通过此行号回表查询需要的数据; 其叶子节点存储的是数据的物理地址,而Innodb的叶子节点存储的是数据本身. 123MyISAM同样也是使用B+树作为索引结构，叶子节点data域存储的是数据记录的地址,(Innodb直接存数据记录本身);MyISAM的数据文件和索引文件是分别存储在xxx.MYD和xxx.MYI（xxx表示数据表名），索引文件xxx.MYI保存数据记录的地址 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。(很大原因也是因为MyISAM存储引擎下,数据文件和索引文件是分开的) 参考以及 这篇 非聚集（unclustered）索引, 其实除了聚集索引以外的索引都是非聚集索引，只是人们想再细分一下非聚集索引，又将非聚集索引 分成普通索引，唯一索引，全文索引 定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。 1234567MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。非聚簇索引的数据表和索引表是分开存储的。非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。只有在MyISAM中才能使用FULLTEXT索引。(mysql5.6以后innoDB也支持全文索引) 最开始我一直不懂既然非聚簇索引的主索引和辅助索引指向相同的内容，为什么还要辅助索引这个东西呢，后来才明白索引不就是用来查询的吗，用在那些地方呢，不就是WHERE和ORDER BY 语句后面吗，那么如果查询的条件不是主键怎么办呢，这个时候就需要辅助索引了。 深入理解MySQL索引原理和实现——为什么索引可以加速查询？ Innodb存储引擎下,没有非聚集索引 引自: MySQL索引背后的数据结构及算法原理版权归原作者所有,强烈推荐! InnoDB的二级索引和聚簇索引很不相同。InnoDB的二级索引的叶子节点存储的不是行号（行指针），而是主键列。这种策略的缺点是二级索引需要两次索引查找，第一次在二级索引中查找主键，第二次在聚簇索引中通过主键查找需要的数据行。 画外音：可以通过我们前面提到过的索引覆盖来避免回表查询，这样就只需要一次回表查询，对于InnoDB而言，就是只需要一次索引查找就可以查询到需要的数据记录，因为需要的数据记录已经被索引到二级索引中，直接就可以找到。 参考自: MySQL——索引实现原理,强烈推荐! 另外:123InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；Memory支持 Hash 索引 聚集索引使用主键索引和二级索引 查询的区别 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚集索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 如果语句是 select * from T where ID=500，即 主键查询方式，则只需要搜索 ID 这棵 B+树 ； 如果语句是 select * from T where k=5， 即 普通索引查询方式，则需要先搜索 k 的 索引树，得到 ID的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。 B+树为了维护索引有序性,在插入新值的时候需要做必要的维护,故而索引会提升读操作的效率,降低写入操作. 如何解决Innodb二级索引的二次查询问题(回表) — 建立复合索引 复合索引,也称覆盖索引,联合索引,多列索引,组合索引, 与之对应的是单列索引 参见: 亲测体验mysql联合索引的失效 MySQL优化：如何避免回表查询？什么是索引覆盖？ 其他索引 前缀索引参见: 前缀索引,一种优化索引大小的解决方案 全文索引 fulltext 某个字段含有大量文本,要找寻其中的某些内容, 用like + %匹配效率较差,而用全文索引可以比 like + %快很多倍. 12345MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。MySQL 的全文索引最开始仅支持英语，因为英语的词与词之间有空格，使用空格作为分词的分隔符是很方便的。亚洲文字，比如汉语、日语、汉语等，是没有空格的，这就造成了一定的限制。不过 MySQL 5.7.6 开始，引入了一个 ngram 全文分析器来解决这个问题，并且对 MyISAM 和 InnoDB 引擎都有效。 哈希索引 hash index 只有 Memory 存储引擎显式支持哈希索引, 哈希所有也是 Memory 引擎的默认索引. 123哈希索引数据并不是按照索引值顺序存储的，所以无法用来进行排序。哈希索引只支持等值比较查询，包括 = 、IN()、 &lt;=&gt;。不支持范围查询。 因为这些限制, 哈希索引只适用于某些特殊的场合; 但一旦适合使用哈希索引, 带来的性能提升将非常显著. 参见 MySQL哈希索引 建索引的几大原则 1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。 5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Mysql中的乐观锁和悲观锁","date":"2018-01-12T10:59:08.000Z","path":"2018/01/12/Mysql中的乐观锁和悲观锁/","text":"综述： 共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 “如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。即其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。” “排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的锁。获准排他锁的事务既能读数据，又能修改数据。” “对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过“lock in share mode”及“for update”语句给显示加共享锁或排他锁。” 参考自MySQL中的共享锁与排他锁 即 对于一行数据，可以有多个共享锁同时读取；对于一行数据，只能有一个排他锁进行读写。 数据库只有”悲观锁”,”乐观锁”概念需自行实现(一般是通过增加version或timestamp字段来实现); 悲观锁分两种,共享锁和排他锁;前者在sql语句后加lock in share mode,后者加for update 乐观锁一般会使用版本号机制或CAS算法实现 私有笔记-乐观锁与悲观锁 乐观锁不是数据库自带的，需要我们自己去实现。 乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。 除了自己手动实现乐观锁之外，现在网上许多框架已经封装好了乐观锁的实现，如hibernate， 悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。 说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。 对于悲观锁，(一般/大多数)数据库都已经实现了. 锁必须在事务之中才能生效 另: 几种事务 开始/提交/回滚的 命令是完全等效的 12345678事务的开始：BEGIN或START TRANSACTION 都是显式开启一个事务；事务的提交：COMMIT或COMMIT WORK 都是等价的；事务回滚:ROLLBACK或ROLLBACK WORK 也是等价的； 没有commit,即这个事务还未被提交,会一直锁着选定的资源;分两种锁,共享锁和排它锁 共享锁共享锁属于悲观锁的一种. 在mysql中通过在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。 共享锁【S锁】又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 共享锁事务之间的读取 更新id=3的会失败,但更新id!=3的可以成功 可见是行级锁,可以更新未加锁的行的记录 可以查询这条加锁的记录(如果加的是排它锁,这时select是查不到的,会超时) 正常的sql语句,默认是不加锁的 ! 如果用排它锁去查询,则: 共享锁事务之间的修改在一个窗口中执行12begin;SELECT * from our_user where id = 3 lock in share mode; 上图中的语句执行后,因为没有commit, 此时这条数据会被一直锁定 再在一个新的窗口执行: update our_user setname=&quot;爽哥&quot; where id=3; 这时去update这条数据,会报 锁等待超时错误. 结论：1234567mysql 共享锁 (lock in share mode)允许其它事务也增加共享锁读取不允许其它事物增加排它锁 (for update)当事务同时增加共享锁时候，事务的更新必须等待先执行的事务 commit 后才行，如果同时并发太大可能很容易造成死锁在共享锁释放之前,任何方式都无法对其锁住的数据进行写操作 排它锁当一个事物加入排他锁后，不允许其他事务加共享锁或者排它锁读取，更加不允许其他事务修改加锁的行。 排他锁【X锁】又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。 排他锁事务之间的读取 加排它锁读取后, 这时再有新的读取,只有不加锁才能读取成功,加共享锁或排他锁都会失败: 排它锁事务之间的修改结束之前的事务,进行如下操作: 即排它锁事务未commit时,不允许有针对该条记录的任何update操作. 结论：1234总结(排它锁的)事务之间不允许其它排它锁或共享锁读取，修改更不可能一次只能有一个排它锁执行 commit 之后，其它事务才可执行不允许其它事务增加共享或排它锁读取。修改是惟一的，必须等待前一个事务 commit，才可 a.共享锁和排它锁是InnoDB存储引擎的概念. 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排它锁（X)；对于普通SELECT语句，InnoDB不会加任何锁； b. 表级锁不会产生死锁. MySQL有三种锁的级别：页级、表级、行级。 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。MyISAM存储引擎 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。InnoDB存储引擎 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 所以解决死锁主要还是针对于InnoDB。 12345MyISAM和MEMORY采用表级锁(table-level locking)BDB采用页面锁(page-level locking)或表级锁，默认为页面锁InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁 c. 何时会是行级锁,何时会变成表级锁,和where后面的字段有没有加索引有关,可以另开一篇专门讨论 延伸阅读: 一条简单的更新语句，MySQL是如何加锁的？ mysql死锁-产生原因和解决方法 mysql的行级锁和表级锁","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"WebSocket小试","date":"2018-01-08T14:32:13.000Z","path":"2018/01/08/WebSocket小试/","text":"WebSocket是一种在单个TCP连接上进行全双工通信的协议.使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输 本文是对gin 框架中结合 gorilla 实现 webSocket的实验与记录 1. 先用Gin框架快速搭建一个restful服务 123456789101112131415package mainimport ( \"github.com/gin-gonic/gin\")func main() &#123; bindAddress := \"localhost:2233\" r := gin.Default() //监听 get请求 /test路径 r.GET(\"/test\", func(c *gin.Context) &#123; c.JSON(200, []string&#123;\"123\", \"321\"&#125;) &#125;) r.Run(bindAddress)&#125; 2.集成gorilla/websocket库 github.com/gorilla 下有很多go的库，gorilla/websocket是其中针对websocket的库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"github.com/gin-gonic/gin\" \"github.com/gorilla/websocket\" \"net/http\")func main() &#123; bindAddress := \"localhost:2233\" r := gin.Default() //监听 get请求 /test路径 r.GET(\"/test\", func(c *gin.Context) &#123; c.JSON(200, []string&#123;\"123\", \"321\"&#125;) &#125;) r.GET(\"/ping\", ping) r.Run(bindAddress)&#125;var upGrader = websocket.Upgrader&#123; CheckOrigin: func(r *http.Request) bool &#123; return true &#125;,&#125;//webSocket请求ping 返回pongfunc ping(c *gin.Context) &#123; //升级get请求为webSocket协议 ws, err := upGrader.Upgrade(c.Writer, c.Request, nil) if err != nil &#123; fmt.Println(\"Upgrade err:\", err) return &#125; defer ws.Close() for &#123; //读取ws中的数据 mt, message, err := ws.ReadMessage() if err != nil &#123; fmt.Println(\"ReadMessage err:\", err) break &#125; if string(message) == \"ping\" &#123; message = []byte(\"pong\") &#125; //写入ws数据 err = ws.WriteMessage(mt, message) if err != nil &#123; fmt.Println(\"WriteMessage err:\", err) break &#125; &#125;&#125; 此时如果直接去请求http://localhost:2233/ping，则会报400 (Bad Request) websocket: the client is not using the websocket protocol: &#39;upgrade&#39; token not found in &#39;Connection&#39; header 2.js代码连接ws 启动第2步中的服务， 然后在浏览器控制台，输入 1234567891011121314var ws = new WebSocket(\"ws://localhost:2233/ping\");//连接打开时触发ws.onopen = function (evt) &#123; console.log(\"Connection open ...\"); ws.send(\"Hello WebSockets!\");&#125;;//接收到消息时触发ws.onmessage = function (evt) &#123; console.log(\"Received Message: \" + evt.data);&#125;;//连接关闭时触发ws.onclose = function (evt) &#123; console.log(\"Connection closed.\");&#125;; 回车后可以收到 12Connection open ...Received Message: Hello WebSockets!","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"那一世","date":"2018-01-07T12:25:22.000Z","path":"2018/01/07/那一世/","text":"那一天 我闭目在经殿香雾中 蓦然听见你颂经中的真言 Once for a whole day in a temple with burning incense I meditated suddenly I seemed to hear the resonance of your recitation in my ear 那一夜 我听了一宿梵唱 不为参悟 只为寻你的一丝气息 Once for a whole eve I listened to the soulful chant in relief not for enlightment in quest but to feel your living breath 那一月 我摇动所有的转经筒 不为超度 只为触摸你的指尖 Once for a whole month I turned all prayer wheels in earnest not for repenting sins but to touch your fingerprins 那一年 我磕长头匍匐在山路 不为觐见 只为贴着你的温暖 Once for a whole year on all fours to dust I came near not for worshipping gods but to feel your warmth in love 那一世 我转山转水转佛塔 不为修来生 只为途中与你相见 Once for a whole life I journeyed through ten thousand spries not for rebirth to complete but to meet you in destiny 那一瞬 我飞升成仙 不为长生 只为佑你喜乐平安 Once in a split second I may ascend as a spirit not for eternity but to bless with joy and security","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"大神之路","date":"2018-01-01T11:01:15.000Z","path":"2018/01/01/大神之路/","text":"","tags":[]},{"title":"时节如流","date":"2017-12-31T15:46:58.000Z","path":"2017/12/31/时节如流/","text":"我在滨江的塑料道上慢跑，看到一群年轻的男男女女，在欢声笑语中放飞孔明灯。刹那便想到了&lt;万箭穿心&gt;中，儿子和其断绝关系后，李宝莉在江边的经闻感悟。 灯盞飘过的江那岸，残破的爱巢，失去妻儿的男人林生斌，并不会因跨年短暂忘却锥心，而会在旁人的热闹中，更显无边孤独。这夜色，并不能吞噬所有苦痛。也许没有互联网，便不会让地下赌场如雨后春笋，也或无此农夫与蛇的悲剧。 在青岛，江秋莲将度过第二个没有女儿陪伴的新年。这个倔强要强离异多年的女人，一手将女儿拉扯成人。没有什么，比失去24岁的孤女更让其撕心裂肺不能接受。 两年多前，在这个国家最豪华的地方，一所校园里，一个胖女孩拦路祈求与我相拥。在我惊讶狐疑的眼神中，她不太伶俐地做出解释：脑中长瘤，所剩无多，不会传染，从未抱过异性，希望今生无憾。我在犹豫中点头，在屏息闭眼中接受了这非比一般的拥抱。她眼已漫涣，在点头称谢中转身，哭笑着离开。我呆呆矗在原地，望其背影瞠目结舌，欲言“再见”至嘴角又止。 通过一款互联网众筹产品的微薄捐赠，我目睹了一位患病同龄人的日常。我看到他的许多动态，有深夜难眠，拍下病房里陪同他的母亲，蜷缩在木板一角潦草睡下的画面。为人子的辛酸与无奈，莫不过此。尝曾以些许鼓励，泛泛祝语，太过单薄；物质相助，可出有限。几个月前，我的这位未曾谋面的网友，带着痛苦离开了这个世界。 君子不立于危墙之下，初时我多有不解，想年轻血气方刚，缘何年岁再大却“贪生怕死”？ 纪录片&lt;人间世&gt;中，一位独子下水救人，不幸溺水身亡的42岁农村妇女徐喜娣，选择了再次尝试孕育生命。一次次千里往返上海，成为生活日常，住在80一晚的宾馆地下室，“移植胚胎后住一个稍好一点的”。 看罢这段，我登时明白。90还不至“油腻中年”，却也全部告别少年，悄悄变得“越来越重要”。而这“重要”，更多由自责任。 我在平安喜乐中迎来2018，却知道，并不是所有人都如你我好运。并不知，如此好运是否能相伴一生。“安得广厦千万间”，这是千年前贫病交加的最伟大诗人，垂暮之年的浩叹。也是几小时前，领导人新年贺词的引用。 我们总是高估一两年的进步，而低估十年后的进展。2018年，希望能更加和谐，更加法治，更加公平一些。但深知，相比2017，不会有特大突破。处身其间，我们也当能力之内略尽绵薄，10年后看，或会为我们滴水捐埃垒积出的进步脱帽致敬。这或许也是时代赋予的没有明言的使命。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"Millennium Prize Problems","date":"2017-12-31T07:57:14.000Z","path":"2017/12/31/Millennium-Prize-Problems/","text":"千禧年大奖难题(Millennium Prize Problems), 又称世界七大数学难题， 是七个由美国克雷数学研究所(Clay Mathematics Institute,CMI) 于2000年5月24日公布的数学猜想。 拟定这7个问题的数学家之一是怀尔斯，费马大定理这个有300多年历史的难题没被选入的唯一理由就是已经被他解决了。还有19年去世的迈克尔·阿蒂亚 这些难题是呼应1900年德国数学家大卫·希尔伯特在巴黎提出的23个数学问题 NP完全问题 大多数倾向于P != NP，但都证明不了 NP完全问题： 逻辑电路问题，汉密尔顿回路问题，旅行商问题 谈谈计算机中的NP，NP-Hard，NP完全以及”NP=P？”问题 代码验证斯特林公式的准确性 P类问题是可以在多项式时间内解决并验证的一类问题，NP类问题是可以多项式时间验证但是不确定能否在多项式时间内解决的一类问题。 什么是 P = NP 问题？ 逻辑大结局——直觉、复杂度和终极悖论，统治一切的程序 在编译器优化领域，理论上已经表明有一些代码优化存在NP难题，这意味着随着代码增加，优化的难度将越来越大，需要花费的时间呈指数增长。 因为这些原因，编译器无法进行最佳的优化，故而通常需要采用一种折中方案 霍奇猜想 庞加莱猜想 黎曼假设 杨-米尔斯存在性和质量缺口 纳维-斯托克斯方程 BSD猜想 参考： 世界七大数学难题 千禧年大奖难题之始与未终","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"原生日志操作法","date":"2017-12-26T15:40:29.000Z","path":"2017/12/26/原生日志操作法/","text":"命令行里的复制/粘贴命令 Mac： 可使用自带的pbcopy和pbpaste命令 来实现复制粘贴 Linux： 需安装xclip/xsel 使用： pbcopy &lt; /Users/fliter/xxxxxxx/xxxx/logs/servicedebug.202110280800 pbpaste &gt; service_log.txt grep查找关键字所在行以及其上下几行 test_grep.txt： 1234567891011121314151617181920212223242526272829303132333435111122223333444455556666777788889999aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllllmmmmnnnnooooppppqqqqrrrrssssttttuuuuvvvvwwwwxxxxyyyyzzzz 打印匹配行的前后5行: grep -5 &quot;aa&quot; test_grep.txt 或 grep -C 5 &quot;aa&quot; test_grep.txt 打印匹配行的后5行: grep -A 5 &quot;aa&quot; test_grep.txt 打印匹配行的前5行 grep -B 5 &quot;aa&quot; test_grep.txt iTerm2快捷键设置https://cnbin.github.io/blog/2015/06/20/iterm2-kuai-jie-jian-da-quan/","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"git奇技淫巧","date":"2017-12-26T12:39:36.000Z","path":"2017/12/26/git奇技淫巧/","text":"收集一些有趣&amp;好用的git命令 git commit 多行提交信息 git commit -m &quot;commit title&quot; -m &quot;commit description&quot; git commit accepts several message flags (-m) to allow multiline commits 只回退某个文件（已经提交） 谢谢。 如果您可以还原 /docs Git 子树中的更改，我将合并。 历史内容的文档编辑需要在 hugoDocs 存储库中完成。 git log fileName (如果文件修改记录太多，则使用 git log -number fileName) 找到想要还原的版本的commit_id git checkout ${commit} fileName 即 git checkout 8f7891e70c51163185fbbd878b4925d11b6a2a93 docs/content/en/news/0.82.0-relnotes/index.md 提交了.idea怎么办 git rm -rf .idea git config –global url.”https://“.insteadOf git:// git config –global url.”https://“.insteadOf git:// 之后.gitconfig中会多出一行参数设置： 12[url &quot;https://&quot;] insteadOf = git:// 设置之后，使用git://，或者https:// 两种方式都会默认变成https://的形式 Git中设置代理和取消代理git config –global http.proxy ‘socks5://127.0.0.1:1080’ &amp;&amp; git config –global https.proxy ‘socks5://127.0.0.1:1080’ tag自动递增 如 2.0到2.1 1234567891011121314#!/bin/bashset -e# Add tag, auto incr taglatest_tag=$(git describe --tags `git rev-list --tags --max-count=1`)echo \"tag为：\"echo $latest_tagnew_tag=$(echo $latest_tag | awk -F. -v OFS=. '&#123;++$NF;print&#125;;')echo \"新的tag为:\"echo $new_taggit tag -a \"$new_tag\" -m \"$commit_msg\" 关于 awk -v OFS git tag 和git tag -a的细微区别： -a必须要有tag说明，而不带-a即直接git tag不会强制要求写说明。当使用git tag -m时，效果和git tag -a -m是一样的 修改远程仓库地址 git remote rm origin git remote add origin 新的远程仓库地址 将两个commit合并为一个 git log git rebase -i HEAD~2 （如果想合并之前N个commit，则将2改为N） -i 即 interactivegit rebase –interactive HEAD~[N]即交互式 rebase。简写为git rebase -i HEAD~[N]N 为想要合并的提交的数量，从最近的一次提交往前数 (N &gt;= 2)通过将多个临时的小的提交合并成一次提交，然后将整理好的代码 push 给远端 (历史记录是按照时间排序的，时间近的排在前面) 将第二行的pick改为squash（即压缩此提交） 然后wq保存 再 git log查看： git push -f 合并多个commit 同上 git rebase -i 想合并在一起的最后一次提交的再前一次提交 （或 git rebase -i HEAD~n, n为要合并的提交次数） 将第一行之后的pick改为s或squash （挤压，压进 之意） wq保存退出，git会压缩提交历史 若有冲突，需进行修改修改完成后，需要保存git add .git rebase –continue若想退出放弃此次压缩，执行命令：git rebase –abort 若没有冲突（或 冲突已解决), 则会出现一个 commit message 编辑页面，修改 commit message,然后 输入：wq 之后 git push -f 或 git push –force，推送到远程 Git 合并多个 commit，保持历史简洁","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"读「Go语言并发之道」","date":"2017-12-17T11:43:08.000Z","path":"2017/12/17/读「Go语言并发之道」/","text":"并发概述 12345678910111213141516package mainimport \"fmt\"func main() &#123; var data int go func() &#123; data++ &#125;() if data == 0 &#123; fmt.Println(\"the value is %v.\\n\", data) &#125;&#125; 实际上,大多数时候的输出为:12the value is %v. 0 金句: 原子的东西将被完整地运行,而不会同时发生任何事情.使一个操作变为原子操作,取决于你将它放在哪个上下文中.如果某个东西是原子的,隐含的意思是它在并发环境中是安全的.atomic包的操作是原子操作 建模: 通信顺序进程 并发与并行的区别 金句 当开发者们讨论代码的时候,他们真的应该使用”并发”这个词.并发属于代码; 并行属于一个运行中的程序.在只有一个核心的机器上运行(两部分可以并行运行的程序). 你们中的某些人会认为程序会并行运行, 但事实并不是这样的!并行是我们程序运行时的属性,而不是我们的代码.(即并行取决于机器) 作者的这些个解释堪称灾难,更容易使人如坠云雾. 可参考: 咬文嚼字-并发和并行 简而言之:123并发 : 逻辑上同时处理多个任务。并行 : 物理上同时处理多个任务。 什么是CSP 通信顺序进程 金句 Go语言的运行时自动将goroutine映射到系统的线程上,并为我们管理它们之间的调度. 参考:Go调度器GPM在Go 1.5中,goroutine的调度顺序发生了改变. 参考:Golang调度器源码分析,搜索调度器的设计除了基于CSP的goroutine/channel/select等,Go语言还是提供了通过内存访问同步来编写并发代码的传统加锁方式,见sync包channel本质上比sync包锁的方式更具可组合性.将锁分散在整个对象图中听起来像是一场噩梦,但是,channel在代码中随处可见,是被鼓励以及期待的.. Go语言的并发处理参考了CSP（Communicating Sequential Process）模型。CSP并发模型不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。Don’t communicate by sharing memory; share memory by communicating.不要以共享内存的方式来通信，要通过通信来共享内存。golang的CSP模型实现与原始的CSP实现有点差别：原始的CSP中channel里的任务都是立即执行的，而go语言为其增加了一个缓存，即任务可以先暂存起来，等待执行线程准备好再顺序执行。 CSP理论之父，和快速排序之父竟然系同一人… Tony Hoare，牛津大学古典学学士毕业，后来出于“机器翻译”，投身计算机。1980年图灵奖得主，2000年获英国王室爵士头衔——和牛顿，开尔文，霍金同享此殊荣——前两人名字成为物理量单位，霍金也几乎名撒寰宇。 快速排序是合格程序员必备算法，也闻知CSP大名，甚至还曾不自量尝试看一下上百页的论文，却没想到竟然同出一人机杼, 惭愧不识这尊大神 协程相比线程轻量多了..每次创建操作系统层级的线程,都会消耗系统资源,在&lt;阿里巴巴Java开发手册&gt;中明确要求,使用线程池,而不允许自己在代码里新建一个线程 参考: Goroutine与GMP模型 Go语言并发组件 Go语言的并发模式 大规模并发 goroutine和Go语言runtime","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"golang之map入门","date":"2017-12-06T11:23:03.000Z","path":"2017/12/06/golang之map入门/","text":"0.如何确定key是否存在? 如果访问了不存在的key会如何？ 确定key是否存在,用ok判别式 12345if _,ok := m[key]; ok &#123; print(\"key存在\")&#125; else &#123; print(\"key不存在\")&#125; 参考: ok判别式 在Go中操作map,, 无论key是否存在,都不会panic或者返回error!即可以访问不存在的key, 得到的值是对应 value 类型的零值 如下: 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; m := make(map[int]int) m[0] = 111 m[1] = 1313 m[2] = 9876 fmt.Println(m[4]) m2 := make(map[string]string) fmt.Println(m2[\"cuishuang\"]) var m3 map[string]string fmt.Println(m3[\"dashen\"])&#125; 输出为: 10 1.key的类型可以是哪些 简言之,可以判断(==)的类型,都可以作为map的键名. 如 bool, 数字，string, 指针, channel , 还有 只包含前面几个类型的 interface , struct, array; 显然，slice， map 以及 function 是不可以的，因为这几种类型无法用 == 来判断; 原文如下: As mentioned earlier(如前所述), map keys may be of any type that is comparable. The language spec defines this precisely, but in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types. Notably absent from the list are slices, maps, and functions; these types cannot be compared using ==, and may not be used as map keys. comparable types, 即可比较类型,可判等类型 2.map键值互换 o := map[string]int{&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 2} 如果原map的值不唯一如上，会导致新map无法完全包含原map的键值对。该问题可以采用多值map来解决,即将新map的键值定义为一个切片类型 123456789101112131415var ( o = map[string]int&#123;\"a\": 0, \"b\": 0, \"c\": 2&#125;)func main() &#123; fmt.Println(o) n := map[int][]string&#123;&#125; for k, v := range o &#123; n[v] = append(n[v], k) &#125; fmt.Println(n)&#125; 输出:12map[a:0 b:0 c:2]map[0:[a b] 2:[c]] 3.可以对map的键值取指针吗? 不可以! map 中的元素并不是一个变量，而是一个值。因此，我们不能对 map 的元素进行取址操作。 1234567891011121314package mainimport ( \"fmt\")func main() &#123; m := make(map[string]int) m[\"age\"] = 27 fmt.Println(&amp;m[\"age\"])&#125; 报错: 1cannot take the address of m[\"age\"] 4.当 map 的键值为结构体类型的值，那么无法直接修改结构体中的字段值 https://blog.csdn.net/k346k346/article/details/90729484 5.map之间能否直接判等? 不可以! 直接将使用 map1 == map2 是错误的。 map后面直接用 == 比较,只能用来判断 map 是否为 nil, 即只可以 “m == nil” 可以通过reflect.DeepEqual来”深度比较”两个slice/struct/map 是否相等 参考: 如何比较两个 map 相等 比较两个 slice/struct/map 是否相等 6.实现key有序的map //TODOhttps://juejin.im/entry/5bbd9282e51d450ea246cd43 7.map 的并发读写问题 参见: golang之map并发访问","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之channel入门","date":"2017-12-04T13:38:38.000Z","path":"2017/12/04/golang之channel入门/","text":"姊妹篇: Golang中select的四大用法 golang之channel并发访问 channel是goroutine之间进行通信的桥梁; 借助于 channel, 不同的 goroutine 之间可以相互通信。 channel 是有类型的，而且有方向，可以把 channel 类比成 unix 中的 pipe。 Go 通过 &lt;- 操作符来实现 channel 的写和读，向管道 中send value时 &lt;- 在 channel 右侧，管道receive value时 &lt;- 在左侧，receive value 不赋值给任何变量是合法的。 Channel 最重要的作用就是传递消息。 理解 Go channel 关闭一个为nil的channel 关闭一个nil channel 会导致程序panic 所谓nil channel,即如var c chan int这样声明的channel (与 c := make(chan int, 0)相对应) 12345678910package mainimport \"fmt\"func main()&#123; var c chan int fmt.Println(c) close(c)&#125; 执行结果:12345678&lt;nil&gt;panic: close of nil channelgoroutine 1 [running]:main.main() /Users/shuangcui/xxxxx/channel.go:25 +0x80exit status 2 而 123456789package mainimport \"fmt\"func main()&#123; c := make(chan int, 0) fmt.Println(c) close(c)&#125; 执行结果为: 10xc000064060 不会报错 go 关闭channel分析 而对于ch := make(chan int, 0)这种方式创建的channel,在close时不会panic; 但如果定义后便读取而无写入,则会死锁fatal error: all goroutines are asleep - deadlock!; 对于无缓存的channel,只有写入操作也会发生死锁; 对于有缓存的channel,在写入元素数量未达到缓存数时,不会发生报错,代码如下: 123456789101112package mainimport ( \"fmt\")func main()&#123; ch := make(chan int, 3) fmt.Println(ch) ch &lt;- 678 close(ch)&#125; 输出: 10xc000096000 读/写一个已经关闭的channel有两种读取channel的方式,range和&lt;-ch channel关闭之后，仍然可以从channel中读取剩余的数据，直到数据全部读取完成。读取完后继续读,得到的将是对应类型的零值. 而 如果继续向已关闭的channel发送数据，会引起panic 读写nil channel 会永久阻塞从而报fatal error; 12345678910package mainimport \"fmt\"func main()&#123; var c chan int fmt.Println(c) &lt;- c&#125; 执行结果:123456789&lt;nil&gt;fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive (nil chan)]:main.main() /Users/shuangcui/xxxxx/channel.go:21 +0x7fexit status 2 12345678910package mainimport \"fmt\"func main()&#123; var c chan int fmt.Println(c) c &lt;- 678&#125; 执行结果:12345678&lt;nil&gt;fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send (nil chan)]:main.main() /Users/shuangcui/xxxxxx/channel.go:23 +0x90exit status 2 123456789101112131415161718192021package mainimport ( \"fmt\")func main()&#123; ch := make(chan int, 3) ch &lt;-1 ch &lt;-2 ch &lt;-3 close(ch) for value := range ch &#123; fmt.Println(\"value:\", value) &#125;&#125; 输出为: 123value: 1value: 2value: 3 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")func main() &#123; ch := make(chan int, 3) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 close(ch) rs := &lt;-ch fmt.Println(rs) for value := range ch &#123; fmt.Println(\"value:\", value) &#125; rs1 := &lt;-ch fmt.Println(rs1)&#125; 输出为:12341value: 2value: 30 判断channel是否关闭的方式有两种: value, ok := &lt;- ch,如果ok为false,即说明此ch已关闭 for value := range ch {},如果channel被外部关闭,for循环会退出,即range可以识别出channel被关闭 但对一个已关闭的channel，如果继续向channel发送数据，会引起panic。 channel不能关闭两次 1234567package mainfunc main() &#123; ch := make(chan bool) close(ch) close(ch) // 会panic的，channel不能close两次&#125; 结果: 1panic: close of closed channel 使用 123456789101112131415package mainimport ( \"fmt\")func main() &#123; c := make(chan int) go func() &#123; time.Sleep(10e9) fmt.Println(\"goroutine message\") c &lt;- 666 //1 &#125;() &lt;-c //2 fmt.Println(\"main function message\")&#125; 在 goroutine 中, 在代码 #1 处向 channel 发送了数据 666 ，在 main 中 #2 处等待数据的接收，如果 c 中没有数据，代码的执行将发生阻塞，直到有 goroutine 开始往 c 中 send value。 因为有&lt;-c存在,故而在向c写入数据前,程序不会退出;用sync包的WaitGroup可以起到同样的阻塞效果; 这是 channel 最简单的用法之一：同步，这种类型的 channel 容量是 0，称之为 unbuffered channel。 “对 unbuffered channel 执行 读 操作 value := &lt;-ch, 会一直阻塞直到有数据可接收，执行 写 操作 ch &lt;- value, 也会一直阻塞 直到有 goroutine 对 channel 开始执行接收，正因为如此在同一个 goroutine 中使用 unbuffered channel 会造成 deadlock。” 1234567891011package mainimport ( \"fmt\")func main() &#123; c := make(chan int) c &lt;- 1 &lt;-c fmt.Println(\"main function message\")&#125; 执行报 fatal error: all goroutines are asleep - deadlock! ，读和写相互等待对方从而导致死锁发生。 关于带缓存的通道,IO阻塞问题,参见此文后半部分 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; c := make(chan int, 3) go func() &#123; for i := 0; i &lt; 4; i++ &#123; c &lt;- i fmt.Println(\"write to c \", i) &#125; &#125;() for i := 0; i &lt; 4; i++ &#123; fmt.Println(\"reading\", &lt;-c) &#125;&#125; “问题在哪里？问题其实是在 fmt.Println ，一次输出就导致 goroutine 的执行发生了切换(相当于发生了 IO 阻塞)，因而即使 c 没有发生阻塞 goroutine 也会让出执行” 即在协程里c&lt;-i的下一行,这个fmt.Println()会发生IO阻塞,当第一次循环,即i=0时,将0写入了c,此时虽然因为未达到缓存的容量3,不会发生阻塞,但fmt.Println()会发生IO阻塞,会向下继续执行 “Channel 可以被close关闭 ，channel 关闭之后仍然可以读取，但是向被关闭的 channel send 会 panic。如果 channel 关闭之前有值写入，关闭之后将依次读取 channel 中的消息，读完完毕之后再次读取将会返回 channel 的类型的 zero value” 无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。 Go Channel 详解","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"亲测体验关系型数据库事务的隔离级别","date":"2017-12-03T13:39:47.000Z","path":"2017/12/03/亲测体验关系型数据库事务的隔离级别/","text":"姊妹篇: 事物的四种隔离级别 Mysql中的乐观锁和悲观锁 前言 &amp; mysql默认存储引擎的默认隔离级别 从MySQL 5.x开始, 默认的存储引擎已经由MyISAM换为了InnoDB MySQL存储引擎详解 查看存储引擎信息: 1show engines 查看mysql版本: 1select version(); 返回值: 12version()5.7.28 InnoDB默认的隔离级别是RR（Repeatable read, 可重复读），但还可能存在幻读现象; 依据隔离级别逐级升高,mysql提供了如下四种隔离级别: 1234567891011a) Read uncommitted（未提交读）：最低级别，任何情况都无法保证b) Read committed（已提交读）：可避免脏读的发生 `Orancle等多数数据库的默认级别`c) Repeateable read（可重复读）：可避免脏读、不可重复读的发生`mysql的默认级别`d) Serializable（可串行化）：可避免脏读、不可重复读、幻读的发生 查看表使用的存储引擎: 1show table status from future where name='our_user' 查看&amp;设置 全局or会话 的事务隔离级别 复现’幻读’ 副标题: 以InnoDB存储引擎下默认的隔离级别RR（Repeatable read, 可重复读）为例 mysql 幻读的详解、实例及解决办法 幻读会在 RU / RC / RR 级别下出现，SERIALIZABLE 则杜绝了幻读，但 RU / RC 下还会存在脏读，不可重复读，故我们就以 RR 级别来研究幻读，排除其他干扰。注意：RR 级别下存在幻读的可能，但也是可以使用对记录手动加 X锁 的方法消除幻读。SERIALIZABLE 正是对所有事务都加 X锁 才杜绝了幻读，但很多场景下我们的业务sql并不会存在幻读的风险。SERIALIZABLE 的一刀切虽然事务绝对安全，但性能会有很多不必要的损失。故可以在 RR 下根据业务需求决定是否加锁，存在幻读风险我们加锁，不存在就不加锁，事务安全与性能兼备，这也是 RR 作为mysql默认隔是个事务离级别的原因，所以需要正确的理解幻读。 mysql默认的隔离级别Repeateable read（可重复读）,是无法防止”幻读”现象出现的,复现如下: 执行事务1: 此时另起一个窗口,执行(干扰)事务2: 这时在事务1中,继续执行 insert into our_user values (5,&quot;爱因斯坦&quot;,&quot;男&quot;);, 报错 Error : Duplicate entry &#39;5&#39; for key &#39;PRIMARY&#39; 即事务1查到没有id=5的记录,同时有一个其他事物(事务2)执行对id=5进行了写入.事务1继续进行insert操作,报主键冲突….事务1就很疑惑:不对啊,我刚才查了,明明没有id=5的记录啊.. 解决方案: 给事务1的查询语句加排它锁,这样事务2就无法进行写入 在 SERIALIZABLE 隔离级别下，事务1的查询语句 执行时是会隐式的添加 行(X)锁 / gap(X)锁，从而 事务2 会被阻塞，事务1的 插入语句 会正常执行，待 事务1 提交后，事务2 才能继续执行（报错:主键冲突执行失败），对于 事务1 来说业务是正确的，成功的阻塞扼杀了扰乱业务的事务2，对于事务1来说其前期读取的结果是可以支撑其后续业务的。 MySQL的可重复读级别能解决幻读吗—给select语句加排它锁,这也是SERIALIZABLE隔离级别做的事 实际MySQL在默认的RR隔离级别下,并不是通过给第一个事务加排它锁的形式防止幻读,而是通过MMVC的一些机制(如间隙锁), 参见: Innodb间隙锁,以及RR隔离级别下防止幻读现象 复现’脏读’ 复现’不可重复读’","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"CNCF中的知名项目","date":"2017-12-02T02:14:00.000Z","path":"2017/12/02/CNCF中的知名项目/","text":"https://cloudnative.to/blog/envoy-oss-5-year/ https://space.bilibili.com/1094957548/video","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"深入探究map迭代时的乱序","date":"2017-11-30T11:12:50.000Z","path":"2017/11/30/深入探究map迭代时的乱序/","text":"为什么遍历 Go map 是无序的？ xorshift算法生成随机数的原理是什么？ Go语言中的Map和List实现有序Map Golang map有序化","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Golang中的密码学","date":"2017-11-29T02:53:59.000Z","path":"2017/11/29/Golang中的密码学/","text":"Go中与加密算法相关的package,一个是官方SDK下Standard library中的crypto包),内含aes,des,dsa,ecdsa,md5,rc4,sha256等知名算法, 另一个是官方SDK下[Sub-repositories]中的crypto包中,内含bcrypt,chacha10,md4,sha3,ssh,scrypt,tea,twofish等算法 有关 Sub-repositories: These packages are part of the Go Project but outside the main Go tree. They are developed under looser compatibility requirements than the Go core. Install them with “go get”. AESAES加密算法动画演示","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"密码学","slug":"密码学","permalink":"http://www.dashen.tech/tags/密码学/"}]},{"title":"MVCC--多版本并发控制","date":"2017-11-26T13:57:51.000Z","path":"2017/11/26/MVCC-多版本并发控制/","text":"MVCC,全称Multi-Version Concurrency Control,即多版本并发控制。MVCC是一种并发控制的方法,一般在数据库管理系统中,实现对数据库的并发访问,在编程语言中实现事务内存。","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"golang之struct入门","date":"2017-11-26T10:52:02.000Z","path":"2017/11/26/golang之struct入门/","text":"起步基础起步点此 结构体判等 只有在结构体的所有字段类型全部支持直接判等时，才可做判断操作。 map，slice不支持直接判等，需借助reflect.DeepEqual来比较(map整个是一个指针(*hmap), slice是SliceHeader的Data字段是个指针) 123456789101112131415161718package mainimport \"fmt\"func main() &#123; type data struct &#123; x int &#125; d1 := data&#123; x: 100, &#125; d2 := data&#123; x: 100, &#125; fmt.Println(d1 == d2)&#125; 执行结果为:true 12345678910111213141516171819package mainimport \"fmt\"func main() &#123; type data struct &#123; x int y map[string]int //字典类型不支持==, &#125; d1 := data&#123; x: 100, &#125; d2 := data&#123; x: 100, &#125; fmt.Println(d1 == d2) //struct containing map[string]int cannot be compared&#125; 编译不通过:invalid operation: d1 == d2 (struct containing map[string]int cannot be compared) 空结构体 空结构struct{}是指没有字段的结构类型。可作为通道元素类型，用于事件通知。 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"time\")func main() &#123; exit := make(chan struct&#123;&#125;) go func() &#123; for &#123; fmt.Println(\"hello, world!\") exit &lt;- struct&#123;&#125;&#123;&#125; &#125; &#125;() &lt;-exit time.Sleep(2e9) fmt.Println(\"end.\")&#125; 输出为:123hello, world!hello, world!end. 指针操作可使用指针直接操作(取值/赋值等)结构体字段，但不能是多级指针。 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"reflect\")func main() &#123; type user struct &#123; name string age int &#125; p := &amp;user&#123; //获取指针 name: \"fliter\", age: 26, &#125; fmt.Println(p) //&amp;&#123;fliter 26&#125; p.name = \"jack\" //通过指针找到对应的程序实体 p.age-- fmt.Println(p) //&amp;&#123;jack 25&#125; fmt.Println(*p) //&#123;jack 25&#125; p2 := &amp;p //&amp;p属于二级指针 fmt.Println(p2) //0xc00000e020 fmt.Println(reflect.TypeOf(p2)) //**main.user //*p2.name = \"john\" //p2.name undefined (type **user has no field or method name)&#125; 输出为:12345&amp;&#123;fliter 26&#125;&amp;&#123;jack 25&#125;&#123;jack 25&#125;0xc00007c010**main.user Struct中的tag 可以为struct中的每个字段，加一个tag。这个tag可以通过反射机制获取到，最常用场景(包括但绝不仅限于此,如还常用于格式校验,数据库关系映射等)就是 json序列化和反序列化. 12345678910111213141516171819202122package mainimport ( \"fmt\" \"reflect\")type User struct &#123; name string `姓名` sex string `性别` age int `年龄`&#125;func main() &#123; u := User&#123;\"Messi\", \"男\", 32&#125; v := reflect.ValueOf(u) t := v.Type() for i, n := 0, t.NumField(); i &lt; n; i++ &#123; fmt.Printf(\"%s为: %v\\n\", t.Field(i).Tag, v.Field(i)) &#125;&#125; 输出为: 123姓名为: Messi性别为: 男年龄为: 32 用于json序列化注意: struct转json时,struct里的字段名首字母必须大写,否则无法正常解析;如果想让struct转json后字段名首字母小写,可以通过tag指定 更多可点击 123456789101112131415161718192021222324252627282930313233package mainimport ( \"encoding/json\" \"fmt\")type FiveAlevelArea struct &#123; Name string `json:\"name\"` Location string `json:\"address\"` Price float32 `json:\"entrance ticket\"` englishName string `json:\"english_name\"`&#125;func main() &#123; heBei := FiveAlevelArea&#123; \"承德市双桥区承德避暑山庄及周围寺庙景区\", \"承德市山庄南路\", 100.00, \"Chengde Imperial Summer Resort\", &#125; j, err := json.Marshal(heBei) if err != nil &#123; fmt.Println(\"报错如下:\", err) return &#125; fmt.Println(\"json字符串为:\", string(j))&#125; 输出为:1json字符串为: &#123;&quot;name&quot;:&quot;承德市双桥区承德避暑山庄及周围寺庙景区&quot;,&quot;address&quot;:&quot;承德市山庄南路&quot;,&quot;entrance ticket&quot;:100&#125; 可见首字母不为大写的字段名,没有被解析出来;最后json字符串中展示出的键名,是tag标签里指定的名称 匿名字段 所谓匿名字段是指没有名字，仅有类型的字段，也称作嵌入字段或嵌入类型。从编译器角度看，这只是隐式地以类型名作为字段名称。可直接引用匿名字段的成员，但初始化时必须当作独立字段。 匿名字段不仅仅可以是结构体，除”接口指针”和”多级指针”以外的任何命名类型都可以作为匿名字段。 严格说来，Go并不是传统意义上的面向对象编程语言，或者说仅实现了最小面向对象的机制。匿名嵌入不是继承，无法实现多态处理。虽然配合方法集，可用接口来显现一些类似的操作，但其本质完全不同。 1234567891011121314151617181920212223242526272829303132333435package mainimport \"fmt\"type attr struct &#123; perm int&#125;type file struct &#123; name string attr //匿名字段,仅有类型名(但IDE在格式化此字段时,不会和其他字段的类型对齐,而会和其他字段的名称对齐)&#125;func main() &#123; //方式1: var c file c.name = \"my.txt\" var a attr a.perm = 777 c.attr = a fmt.Println(c, c.perm) //直接读取匿名字段成员 //方式2: //如果使用这种方式给包含匿名字段的结构体赋值,须将类型名当作字段名 f := file&#123; name: \"test.dat\", attr: attr&#123; //将类型名当作字段名 perm: 755, &#125;, &#125; f.perm = 500 //直接设置匿名字段成员 fmt.Println(f, f.perm) //直接读取匿名字段成员&#125; 利用匿名字段实现所谓的”继承” 结构体中字段可以没有名字(只有类型)，即匿名字段; 如果一个struct(记为A)嵌套了另一个匿名结构体(记为B)，那么A结构体可以直接访问匿名结构体B的方法，从而实现了继承。 参见前文,golang利用组合实现继承,和php或java面向对象的继承有何不同 方法Golang中的方法作用在特定类型的变量上，因此自定义类型都可以有方法，而不仅仅是struct 定义：func (recevier type) methodName(参数列表)(返回值列表){} 方法和函数 golang中的”方法”与”函数”的关系,与其他语言有所差别. 方法 给用户定义的类型添加新的行为。方法和函数相比，声明时在关键字func和方法名之间增加了一个参数 12345678910111213141516171819202122232425262728package mainimport \"fmt\"type user struct &#123; name string age int&#125;func (u user) say() &#123; fmt.Println(\"hello\", u.name) fmt.Println(\"十年后你的年龄是:\", u.age+10)&#125;func (u *user) run() &#123; fmt.Printf(\"%s是跑步名将\\n\", u.name)&#125;func main() &#123; c := user&#123;\"Trump\", 73&#125; c.say() s := &amp;user&#123;\"Bolt\", 0&#125; s.run()&#125; 输出: 123hello Trump十年后你的年龄是: 83Bolt是跑步名将 一个基础类型前面加&amp;后,会变为指针类型; *作动词时, 后面必须是一个指针类型,叫做解引用~ 即 *(&amp;a) = a *作形容词时,表示这个类型是指针类型 方法作用在结构体上 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\")type FiveAlevelArea struct &#123; Name string `json:\"name\"` Location string `json:\"address\"` Price float32 `json:\"entrance ticket\"` englishName string `json:\"english_name\"`&#125;func (cs FiveAlevelArea) set(Name, Location, englishName string, Price float32) &#123; cs.Name = Name cs.Location = Location cs.Price = Price cs.englishName = englishName fmt.Println(\"当前结构体的值为:\", cs)&#125;func (shuang FiveAlevelArea) get() FiveAlevelArea &#123; return shuang&#125;func main() &#123; var heBei FiveAlevelArea heBei.set(\"保定市安新县白洋淀景区\", \"保定市安新县\", \"Bai-yang Lake\", 40.00) heBei2 := heBei.get() fmt.Println(heBei) fmt.Println(heBei2)&#125; 输出为: 123当前结构体的值为: &#123;保定市安新县白洋淀景区 保定市安新县 40 Bai-yang Lake&#125;&#123; 0 &#125;&#123; 0 &#125; 因为是值传递,故而原来变量的值没有被修改; 改为指针传递:将第14行set()方法作用的变量(类型)修改为cs *FiveAlevelArea,此时程序的执行结果为: 123当前结构体的值为: &amp;&#123;保定市安新县白洋淀景区 保定市安新县 40 Bai-yang Lake&#125;&#123;保定市安新县白洋淀景区 保定市安新县 40 Bai-yang Lake&#125;&#123;保定市安新县白洋淀景区 保定市安新县 40 Bai-yang Lake&#125; 可能会疑惑,第32行调用set()方法的变量类型为FiveAlevelArea,并不是指针,为何还能编译通过呢?实际上是go自动加了取指针符号&amp;,即第32行: heBei.init(&quot;保定市安新县白洋淀景区&quot;, &quot;保定市安新县&quot;, &quot;Bai-yang Lake&quot;, 40.00) 等同于: (&amp;heBei).init(&quot;保定市安新县白洋淀景区&quot;, &quot;保定市安新县&quot;, &quot;Bai-yang Lake&quot;, 40.00) 方法作用在其他变量上 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport \"fmt\"type cInt intfunc (cui cInt) f1() &#123; fmt.Println(\"变量值为:\", cui)&#125;func (c *cInt) f2(args cInt) &#123; *c = args + 6&#125;func main() &#123; var a1 cInt = 10086 fmt.Println(a1) //调用cInt类型的f1()方法 a1.f1() var a2 cInt //&amp;a2是获取变量a2的内存地址值即指针，如果对一个参数需要接收指针(*后面必须要是指针类型)的方法如此处的f2()传值a2,go会自动将a2转换成&amp;a2即变量a2的内存地址,所以以下两种写法都是可以的 a2.f2(12300) fmt.Println(a2) (&amp;a2).f2(12300) fmt.Println(a2) //指针传递可以改变原来变量的值 var a3 cInt = 12360 a3.f2(a3) fmt.Println(a3) (&amp;a3).f2(a3) fmt.Println(a3)&#125; 输出为: 12345610086变量值为: 1008612306123061236612372 String()方法 如果一个变量实现了String()这个方法，那么fmt.Println在输出时，会默认调用这个变量的String()方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport \"fmt\"type Transportation struct &#123; name string speed string&#125;func (o *Transportation) Run() &#123; fmt.Printf(\"交通工具%s跑起来啦!\\n\", (*o).name) //此处\"o.name\"同样可以通过编译(o是一个指针,*o解引用为这个内存地址对应的变量),go会自动转化为(*o).name&#125;//火车继承交通工具type Train struct &#123; Transportation InventedTime int //发明时间&#125;func (cs *Train) String() string &#123; str := fmt.Sprintf(\"%s的速度可以达到%s\\n\", cs.name, cs.speed) return str&#125;func main() &#123; var train Train train.name = \"火车\" train.speed = \"350km/h\" train.InventedTime = 1804 fmt.Println(train) fmt.Println(\"------------------\") train.Run() fmt.Println(\"******************\") fmt.Printf(\"%s\", &amp;train) fmt.Println(\"##################\") fmt.Println(\"会自动调用String()方法\\n\", &amp;train)&#125; 输出为: 12345678&#123;&#123;火车 350km/h&#125; 1804&#125;------------------交通工具火车跑起来啦!******************火车的速度可以达到350km/h##################会自动调用String()方法 火车的速度可以达到350km/h 更多关于struct使用中的小tips,可点击","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"「编译原理」书摘","date":"2017-11-24T15:51:21.000Z","path":"2017/11/24/「编译原理」书摘/","text":"三.文法定义 3.1 文法类型 3.2 语法推导树 例: 3.3 有限自动机 例: 某有限自动机的状态转换图如下图所示，与该自动机等价的正规式是（&nbsp; ）。 问题1选项 A.(0|1) B.(0|10) C.0(10) D.0(1|0) 解: 从题中的自动机可分析出，初态q0同时是终态，从q0到q0的弧(标记0)表明该 自动机识别零个或多个0构成的串，路径q0→q1→q0的循环表明“10”的多次重复，因此该自动机识别的字符串是“0|10”的无穷多次，表示为(0|10)*。 https://www.educity.cn/tiku/20986222.html 3.4 正规式 例: 四.表达式 例 参考: 编译原理","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Compiler","slug":"Compiler","permalink":"http://www.dashen.tech/tags/Compiler/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"Wireshark抓包手机","date":"2017-11-23T02:03:08.000Z","path":"2017/11/23/Wireshark抓包手机/","text":"https://www.baidu.com/s?tn=50000021_hao_pg&amp;ie=utf-8&amp;sc=UWd1pgw-pA7EnHc1FMfqnHmzPW6Ln1fsn1n3rauW5y99U1Dznzu9m1Ydn1fzP1c4P1T&amp;ssl_sample=normal&amp;srcqid=5482817894475453453&amp;H123Tmp=nunew7&amp;word=wireshark%E6%80%8E%E4%B9%88%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA https://www.google.com/search?q=mac+wireshark%E6%80%8E%E4%B9%88%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA&amp;oq=mac+wireshark%E6%80%8E%E4%B9%88%E6%8A%93%E5%8C%85%E6%89%8B%E6%9C%BA&amp;aqs=chrome..69i57.192j0j1&amp;sourceid=chrome&amp;ie=UTF-8 https://www.jianshu.com/p/82bcdb1decf7","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"LRU算法浅析","date":"2017-11-18T13:06:34.000Z","path":"2017/11/18/LRU算法浅析/","text":"使用 LRU即Least Recently Used的缩写, 即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的资源予以淘汰 或者说是 一种内存管理方法，最早应用于Linux系统 如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小(局部性原理) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\" lru \"github.com/hashicorp/golang-lru\")func main() &#123; l, _ := lru.New(128) for i := 0; i &lt; 256; i++ &#123; l.Add(i, fmt.Sprintf(\"这是第%d号元素的值\", i)) &#125; v10, ok := l.Get(10) if ok &#123; fmt.Println(\"第10号key对应的值为：\", v10) &#125; else &#123; fmt.Println(\"缓存中没有10号key\") &#125; v128, ok := l.Get(128) if ok &#123; fmt.Println(\"第128号key对应的值为：\", v128) &#125; else &#123; fmt.Println(\"缓存中没有128号key\") &#125; if l.Len() != 128 &#123; panic(fmt.Sprintf(\"bad len: %v\", l.Len())) &#125; // 此时会\"挤出\"一个key l.Add(300, fmt.Sprintf(\"这是第%d号元素的值\", 300)) // 但不会是第128号key，因为在上面刚刚被get； 第129号key就成了排在队列最前面的key v128, ok = l.Get(128) if ok &#123; fmt.Println(\"第128号key对应的值为：\", v128) &#125; else &#123; fmt.Println(\"缓存中没有128号key\") &#125; v129, ok := l.Get(129) if ok &#123; fmt.Println(\"第129号key对应的值为：\", v129) &#125; else &#123; fmt.Println(\"缓存中没有129号key\") &#125;&#125; 输出为： 1234缓存中没有10号key第128号key对应的值为： 这是第128号元素的值第128号key对应的值为： 这是第128号元素的值缓存中没有129号key 原理 以下内容来自 漫画：什么是 LRU 算法？ 哈希链表 （Java中的LinkedHashMap） LRU算法四种实现方式介绍 代码实现 可参考 go实现LRU cache 知名项目中的使用 XORM Redis底层也实现了类似LRU的回收算法 substrate以及N多个项目中，都广泛使用到LRU Golang官方提供了一个groupcache库，其中包含LRU。使用可参考Golang groupcache LRU 缓存简介与用法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"Go omitempty关键字","date":"2017-11-13T12:42:58.000Z","path":"2017/11/13/Go-omitempty关键字/","text":"omitempty的使用 将结构体转成json作为参数，请求某个服务。希望结构体某字段为空时，解析成的json没有该字段。 这就是omitempty关键字的作用，即忽略空值 如： 12345678910111213141516171819202122232425262728package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"男\", &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 执行结果为： 1json of s = &#123;\"id\":15,\"string\":\"XiaoMing\",\"gender\":\"男\"&#125; 如果gender字段为空，即 12345678910111213141516171819202122232425262728package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 则执行结果为： 1json of s = &#123;\"id\":15,\"string\":\"XiaoMing\"&#125; 而如果去掉omitempty标签，则执行结果为 json of s = {&quot;id&quot;:15,&quot;string&quot;:&quot;XiaoMing&quot;,&quot;gender&quot;:&quot;&quot;} omitempty的陷阱 不过该关键字有几个注意事项，或称之为”小坑” 如再增加一个address字段，为一个结构体 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"` Address address `json:\"address,omitempty\"`&#125;type address struct &#123; Country string `json:\"country\"` Province string `json:\"province\"` City string `json:\"accessKey\"` Street string `json:\"street\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", address&#123;&#125;, &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 执行结果为： 1json of s = &#123;\"id\":15,\"string\":\"XiaoMing\",\"address\":&#123;\"country\":\"\",\"province\":\"\",\"accessKey\":\"\",\"street\":\"\"&#125;&#125; 为什么明明Address字段加了omitempty，当其为空值时，json.Marshal时还是有这个字段？ 这是因为，omitempty关键字无法忽略掉嵌套结构体 那该如何解决？ 可以把Address字段定义为指针类型，这样 Golang 就能知道一个指针的“空值”是多少了，否则面对一个我们自定义的结构， Golang 是猜不出我们想要的空值的… 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"` Address *address `json:\"address,omitempty\"`&#125;type address struct &#123; Country string `json:\"country\"` Province string `json:\"province\"` City string `json:\"accessKey\"` Street string `json:\"street\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", nil, &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 输出为 json of s = {&quot;id&quot;:15,&quot;string&quot;:&quot;XiaoMing&quot;} 但如果是 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"` Address *address `json:\"address,omitempty\"`&#125;type address struct &#123; Country string `json:\"country\"` Province string `json:\"province\"` City string `json:\"accessKey\"` Street string `json:\"street\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", &amp;address&#123;&#125;, &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 则输出还是 1json of s = &#123;\"id\":15,\"string\":\"XiaoMing\",\"address\":&#123;\"country\":\"\",\"province\":\"\",\"accessKey\":\"\",\"street\":\"\"&#125;&#125; 另一个陷阱，是对于用 omitempty 定义的 field ，如果给它赋的值恰好等于默认空值的话，在转为 json 之后也不会输出这个 field 参考 Golang 的 “omitempty” 关键字略解 omitempty源码 其源码位于src/encoding/asn1/common.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Given a tag string with the format specified in the package comment,// parseFieldParameters will parse it into a fieldParameters structure,// ignoring unknown parts of the string.func parseFieldParameters(str string) (ret fieldParameters) &#123; var part string for len(str) &gt; 0 &#123; // This loop uses IndexByte and explicit slicing // instead of strings.Split(str, \",\") to reduce allocations. i := strings.IndexByte(str, ',') if i &lt; 0 &#123; part, str = str, \"\" &#125; else &#123; part, str = str[:i], str[i+1:] &#125; switch &#123; case part == \"optional\": ret.optional = true case part == \"explicit\": ret.explicit = true if ret.tag == nil &#123; ret.tag = new(int) &#125; case part == \"generalized\": ret.timeType = TagGeneralizedTime case part == \"utc\": ret.timeType = TagUTCTime case part == \"ia5\": ret.stringType = TagIA5String case part == \"printable\": ret.stringType = TagPrintableString case part == \"numeric\": ret.stringType = TagNumericString case part == \"utf8\": ret.stringType = TagUTF8String case strings.HasPrefix(part, \"default:\"): i, err := strconv.ParseInt(part[8:], 10, 64) if err == nil &#123; ret.defaultValue = new(int64) *ret.defaultValue = i &#125; case strings.HasPrefix(part, \"tag:\"): i, err := strconv.Atoi(part[4:]) if err == nil &#123; ret.tag = new(int) *ret.tag = i &#125; case part == \"set\": ret.set = true case part == \"application\": ret.application = true if ret.tag == nil &#123; ret.tag = new(int) &#125; case part == \"private\": ret.private = true if ret.tag == nil &#123; ret.tag = new(int) &#125; case part == \"omitempty\": ret.omitEmpty = true &#125; &#125; return&#125; json.Rawmessage，也许是这种场景更好的方案 另外，这种场景其实可以用json.Rawmessage： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"` //Address *address `json:\"address,omitempty\"` Address json.RawMessage `json:\"address,omitempty\"`&#125;type address struct &#123; Country string `json:\"country\"` Province string `json:\"province\"` City string `json:\"accessKey\"` Street string `json:\"street\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", nil, &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 输出为： json of s = {&quot;id&quot;:15,&quot;string&quot;:&quot;XiaoMing&quot;} interface{}也可以 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"encoding/json\" \"fmt\")type User struct &#123; ID int64 `json:\"id\"` Name string `json:\"string\"` Gender string `json:\"gender,omitempty\"` //Address *address `json:\"address,omitempty\"` //Address json.RawMessage `json:\"address,omitempty\"` Address interface&#123;&#125; `json:\"address,omitempty\"`&#125;type address struct &#123; Country string `json:\"country\"` Province string `json:\"province\"` City string `json:\"accessKey\"` Street string `json:\"street\"`&#125;func main() &#123; s := User&#123; 15, \"XiaoMing\", \"\", nil, &#125; sJson, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(\"json of s = \", string(sJson))&#125; 输出为： json of s = {&quot;id&quot;:15,&quot;string&quot;:&quot;XiaoMing&quot;}","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"可视化监控Go的垃圾回收","date":"2017-11-09T12:25:01.000Z","path":"2017/11/09/可视化监控Go的垃圾回收/","text":"1234567891011package main// 1&lt;&lt;10 即2的10次方，即1K。 1&lt;&lt;20即1M 2的8次方为256，1&lt;&lt;28即256Mfunc allocate() &#123; _ = make([]byte, 1&lt;&lt;28)&#125;func main() &#123; for n := 1; n &lt; 10; n++ &#123; allocate() &#125;&#125; 自带方式 该部分来自 Go 语言问题集(Go Questions)-6. 如何观察 Go GC？ GODEBUG=gctrace=1 go build xxx.go GODEBUG=gctrace=1 ./xxx 123456789101112131415gc 1 @0.002s 1%: 0.020+0.11+0.002 ms clock, 0.16+0.052/0.10/0.038+0.019 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 2 @0.041s 0%: 0.022+0.11+0.002 ms clock, 0.18+0.049/0.051/0.028+0.019 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 3 @0.049s 0%: 0.020+0.073+0.001 ms clock, 0.16+0.042/0.030/0.051+0.014 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 4 @0.054s 0%: 0.017+0.087+0.001 ms clock, 0.13+0.038/0.034/0.019+0.012 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 5 @0.058s 0%: 0.018+0.061+0.001 ms clock, 0.14+0.030/0.025/0.012+0.012 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 6 @0.063s 0%: 0.018+0.042+0.001 ms clock, 0.14+0.027/0.026/0.024+0.012 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 7 @0.069s 0%: 0.016+0.033+0.001 ms clock, 0.13+0.024/0.027/0.012+0.012 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 Pgc 8 @0.073s 0%: 0.016+0.071+0 ms clock, 0.13+0.034/0.017/0.005+0.005 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 P 上方记录属于 用户代码向运行时申请内存产生的垃圾回收 以 gc 2 @0.041s 0%: 0.022+0.11+0.002 ms clock, 0.18+0.049/0.051/ 0.028+0.019 ms cpu, 256-&gt;256-&gt;0 MB, 257 MB goal, 8 P 为例： gc 2@0.001s2%:0.018+1.1+0.029 ms clock,0.22+0.047/0.074/ 0.048+0.34 ms cpu,4-&gt;7-&gt;3 MB,5 MB goal,12 P 字段 含义 gc 2 第二个 GC 周期 0% 该 GC 周期中 CPU 的使用率 — — 0.022 标记开始时， STW 所花费的时间（wall clock） 0.11 标记过程中，并发标记所花费的时间（wall clock） 0.002 标记终止时， STW 所花费的时间（wall clock） — — 0.18 标记开始时， STW 所花费的时间（cpu time） 0.049 标记过程中，标记辅助所花费的时间（cpu time） 0.051 标记过程中，并发标记所花费的时间（cpu time） 0.028 标记过程中，GC 空闲的时间（cpu time） 0.019 标记终止时， STW 所花费的时间（cpu time） — — 256 标记开始时，堆的大小的实际值 256 标记结束时，堆的大小的实际值 0 标记结束时，标记为存活的对象大小 257 标记结束时，堆大小的预测值 — — 8 P 的数量 wall clock 是指开始执行到完成所经历的实际时间，包括其他程序和本程序所消耗的时间；cpu time 是指特定程序使用 CPU 的时间；二者存在如下关系：- wall clock &lt; cpu time: 充分利用多核- wall clock ≈ cpu time: 未并行执行- wall clock &gt; cpu time: 多核优势不明显 以上程序执行还有一种可能的返回值： 12scvg:8 KB releasedscvg: inuse:3, idle:60, sys:63, released:57, consumed:6(MB) 含义如下： 字段 含义 8 KB released 向操作系统归还了 8 KB 内存 3 已经分配给用户代码、正在使用的总内存大小 (MB) 60 空闲以及等待归还给操作系统的总内存大小（MB） 63 通知操作系统中保留的内存大小（MB） 57 已经归还给操作系统的（或者说还未正式申请）的内存大小（MB） 6 已经从操作系统中申请的内存大小（MB） go tool trace 123456789101112131415161718192021package mainimport ( \"os\" \"runtime/trace\")// 1&lt;&lt;10 即2的10次方，即1Kfunc allocate() &#123; _ = make([]byte, 1&lt;&lt;28)&#125;func main() &#123; f, _ := os.Create(\"trace_256m.out\") defer f.Close() trace.Start(f) defer trace.Stop() for n := 1; n &lt; 10; n++ &#123; allocate() &#125;&#125; 运行如上代码，将生成一个trace_256m.out文件 使用 go tool trace trace_256m.out, 将自动打开浏览器 更详细使用可参考 性能分析工具 debug.ReadGCStats 此方式可直接实现对感兴趣指标的监控，如每隔一秒钟监控一次 GC 的状态： 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"runtime\" \"runtime/debug\" \"time\")func printGCStats() &#123; t := time.NewTicker(time.Second) s := debug.GCStats&#123;&#125; for &#123; select &#123; case &lt;-t.C: debug.ReadGCStats(&amp;s) fmt.Printf(\"gc %d last@%v, PauseTotal %v\\n\", s.NumGC, s.LastGC, s.PauseTotal) &#125; &#125;&#125;func main() &#123; go printGCStats() for n := 1; n &lt; 100000; n++ &#123; allocate() &#125;&#125;// 1&lt;&lt;10 即2的10次方，即1K。 1&lt;&lt;20即1M. 1&lt;&lt;28=256Mfunc allocate() &#123; _ = make([]byte, 1&lt;&lt;28)&#125; 输出为： 12345678910111213gc 193 last@20xx-xx-xx 21:28:00.687708 +0800 CST, PauseTotal 4.099753msgc 404 last@20xx-xx-xx 21:28:01.689369 +0800 CST, PauseTotal 8.10266msgc 617 last@20xx-xx-xx 21:28:02.689289 +0800 CST, PauseTotal 12.034994msgc 828 last@20xx-xx-xx 21:28:03.688104 +0800 CST, PauseTotal 16.030454msgc 1029 last@20xx-xx-xx 21:28:04.689737 +0800 CST, PauseTotal 20.737255msgc 1238 last@20xx-xx-xx 21:28:05.68598 +0800 CST, PauseTotal 24.46508msgc 1451 last@20xx-xx-xx 21:28:06.689495 +0800 CST, PauseTotal 28.538742msgc 1660 last@20xx-xx-xx 21:28:07.685889 +0800 CST, PauseTotal 32.635618msgc 1865 last@20xx-xx-xx 21:28:08.687902 +0800 CST, PauseTotal 37.071374msgc 2076 last@20xx-xx-xx 21:28:09.688949 +0800 CST, PauseTotal 41.0627msgc 2285 last@20xx-xx-xx 21:28:10.688493 +0800 CST, PauseTotal 45.44829msgc 2496 last@20xx-xx-xx 21:28:11.689987 +0800 CST, PauseTotal 49.741249msgc 2702 last@20xx-xx-xx 21:28:12.689267 +0800 CST, PauseTotal 54.465249ms runtime.ReadMemStats 直接通过运行时的内存相关的 API 进行监控 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\" \"runtime\" \"runtime/debug\" \"time\")func main() &#123; go printMemStats() for n := 1; n &lt; 100000; n++ &#123; allocate() &#125;&#125;// 1&lt;&lt;10 即2的10次方，即1K。 1&lt;&lt;20即1M. 1&lt;&lt;28=256Mfunc allocate() &#123; _ = make([]byte, 1&lt;&lt;28)&#125;func printMemStats() &#123; t := time.NewTicker(time.Second) s := runtime.MemStats&#123;&#125; for &#123; select &#123; case &lt;-t.C: runtime.ReadMemStats(&amp;s) fmt.Printf(\"gc %d last@%v, next_heap_size@%vMB\\n\", s.NumGC, time.Unix(int64(time.Duration(s.LastGC).Seconds()), 0), s.NextGC/(1&lt;&lt;20)) &#125; &#125;&#125; 输出为： 123456789101112gc 200 last@20xx-xx-xx21:30:07 +0800 CST, next_heap_size@4MBgc 411 last@20xx-xx-xx21:30:08 +0800 CST, next_heap_size@4MBgc 616 last@20xx-xx-xx21:30:09 +0800 CST, next_heap_size@4MBgc 827 last@20xx-xx-xx21:30:10 +0800 CST, next_heap_size@257MBgc 1037 last@20xx-xx-xx21:30:11 +0800 CST, next_heap_size@4MBgc 1227 last@20xx-xx-xx21:30:12 +0800 CST, next_heap_size@4MBgc 1417 last@20xx-xx-xx21:30:13 +0800 CST, next_heap_size@4MBgc 1610 last@20xx-xx-xx21:30:14 +0800 CST, next_heap_size@4MBgc 1812 last@20xx-xx-xx21:30:15 +0800 CST, next_heap_size@4MBgc 1994 last@20xx-xx-xx21:30:16 +0800 CST, next_heap_size@4MBgc 2167 last@20xx-xx-xx21:30:17 +0800 CST, next_heap_size@4MBgc 2352 last@20xx-xx-xx21:30:18 +0800 CST, next_heap_size@4MB 第三方包 https://toutiao.io/posts/494797/app_preview https://www.google.com.hk/search?q=golang+scavenge&amp;oq=golang+scavenge&amp;aqs=chrome..69i57j0i512j0i8i30l2.1659j0j1&amp;sourceid=chrome&amp;ie=UTF-8 https://github.com/bmhatfield/go-runtime-metrics https://github.com/pkujhd/goloader https://github.com/coldnight/go-memory-allocator-visual-guide","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go可视化工具","date":"2017-11-01T12:10:19.000Z","path":"2017/11/01/Go可视化工具/","text":"statsviz 实时查看 Go 应用程序运行时统计信息(GC，MemStats 等) 1234567891011121314151617181920package mainimport ( \"fmt\" \"github.com/arl/statsviz\" \"log\" \"net/http\" \"time\")func main() &#123; statsviz.RegisterDefault() go func() &#123; log.Println(http.ListenAndServe(\"localhost:6060\", nil)) &#125;() for &#123; fmt.Println(time.Now().UnixNano()) &#125;&#125; 运行后，打开http://localhost:6060/debug/statsviz/ 原理是使用 WebSocket 协议，定时将runtime数据发送给浏览器，浏览器接收到之后，利用 JS 绘制图表，展示出来。Go 核心代码如下： 用了gorilla这个websocket库 12345678910111213141516// sendStats indefinitely send runtime statistics on the websocket connection.func sendStats(conn *websocket.Conn, frequency time.Duration) error &#123; tick := time.NewTicker(frequency) defer tick.Stop() stats := stats&#123;GoVersion: runtime.Version()&#125; for range tick.C &#123; runtime.ReadMemStats(&amp;stats.Mem) stats.NumGoroutine = runtime.NumGoroutine() if err := conn.WriteJSON(stats); err != nil &#123; return err &#125; &#125; panic(\"unreachable\")&#125; 参考自 为项目集成可视化实时运行时统计 statsview 通过这个 Runtime 统计信息可视化库学到了什么？ 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"github.com/go-echarts/statsview\" \"math/rand\" \"strconv\" \"time\")func main() &#123; go work() mgr := statsview.New() // Start() runs a HTTP server at `localhost:18066` by default. mgr.Start() // Stop() will shutdown the http server gracefully // mgr.Stop()&#125;func work() &#123; // Generate some allocations m := map[string][]byte&#123;&#125; for &#123; b := make([]byte, 512+rand.Intn(16*1024)) m[strconv.Itoa(len(m)%(10*100))] = b if len(m)%(10*100) == 0 &#123; m = make(map[string][]byte) &#125; time.Sleep(10 * time.Millisecond) &#125;&#125; gmchart,go mod graph 可视化工具 go get -u github.com/PaulXu-cn/go-mod-graph-chart/gmchart cd goProject 然后 go mod graph | gmchart 即可 如kratos项目： go mod graph 可视化——gmchart gomod,分析 Go项目三方依赖仓库 Star 、Fork 的工具 go install github.com/cfanbo/gomod@latest cd goProject 然后 gomod 即可 Star 仓库的 Star 数量；如果统计数据超时则显示为 ?Fork 仓库的 Fork 数量；如果统计数据超时则显示为 ?Share 是否存在相同的仓库；如果引用了同一个仓库的多个包，则此列将显示 YModule 当前项目依赖的三方库名称GitHub 三方库在 github.com 上的托管地址可以通过多次按 s、 f、m 或g 键查看效果，如果要退出查看模式按 q 或 Esc键即可。如果要访问仓库在 github.com 上的托管地址，直接 Enter 键即可; 如果要访问在 pkg.go.dev 网站的地址，直接按空格键 即可。 还可通过gomod github项目地址查看托管在 github.com 上的任何项目的信息","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"出师表","date":"2017-10-28T10:45:21.000Z","path":"2017/10/28/出师表/","text":"臣亮言：先帝创业未半而中道崩殂，Permit me to observe: the late emperor was taken from us before he could finish his life`s work, the restoration of Han.今天下三分，益州疲弊，此诚危急存亡之秋也。Today, the empire is still divided in three, and our very survival is threatened.然侍卫之臣不懈于内，忠志之士忘身于外者，Yet still the officials at court and the soldiers throughout the realm remain loyal to you, your majesty.盖追先帝之殊遇，欲报之于陛下也。Because they remember the late emperor, all of them, and they wish to repay his kindness in service to you.诚宜开张圣听，以光先帝遗德，恢弘志士之气，This is the moment to extend your divine influence, to honour the memory of the late Emperor and strengthen the morale of your officers.不宜妄自菲薄，引喻失义，以塞忠谏之路也。It is not time to listen to bad advice, or close your ears to the suggestions of loyal men.宫中府中，俱为一体，陟罚臧否，不宜异同。The court and the administration are as one. Both must be judged by one standard.若有作奸犯科及为忠善者，宜付有司论其刑赏，Those who are loyal and good must get what they deserve, but so must the evil-doers who break the law.以昭陛下平明之理，不宜偏私，使内外异法也。This will demonstrate the justice of your rule. There cannot be one law for the court and another for the administration.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。Counselors and attendants like Guo Youzhi, Fei Yi, and Dong Yun are all reliable men, loyal of purpose and pure in motive. The late Emperor selected them for office so that they would serve you after his death.These are the men who should be consulted on all palace affairs.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。Xiang Chong has proved himself a fine general in battle, and the late Emperor believed in him. That is why the assembly has recommended him for overall command. It will keep the troops happy if he is consulted on all military matters.亲贤臣，远小人，此先汉所以兴隆也；The emperors of the Western Han chose their courtiers wisely, and their dynasty flourished.亲小人，远贤臣，此后汉所以倾颓也。The emperors of the Eastern Han chose poorly, and they doomed the empire to ruin.先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。Whenever the late Emperor discussed this problem with me, he lamented the failings of Emperors Huan and Ling.侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。Advisors like Guo Youzhi, Fei Yi, Chen Zhen, Zhang Yi, and Jiang Wan – these are all men of great integrity and devotion. I encourage you to trust them, your majesty, if the house of Han is to rise again.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。I begin as a common man, farming in my fields in Nanyang, doing what I could to survive in an age of chaos. I never had any interest in making a name for myself as a noble.先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，The late Emperor was not ashamed to visit my cottage and seek my advice.由是感激，遂许先帝以驱驰。Grateful for his regard, I responded to his appeal and threw myself into his service.后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。Now twenty-one years has passed, the late Emperor always appreciated my caution and, in his final days, entrusted me with his cause.受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，Since that moment, I have been tormented day and night by the fear that I might let him down.故五月渡泸，深入不毛。That is why I crossed the Lu river at the height of summer, and entered the wastelands beyond.今南方已定，甲兵已足，Now the south has been subdued, and our forces are fully armed.当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。I should lead our soldiers to conquer the northern heartland and attempt to remove the hateful traitors, restore the house of Han, and return it to the former capital.此臣所以报先帝而忠陛下之职分也。This the way I mean to honor my debt to the late Emperor and fulfill my duty to you.至于斟酌损益，进尽忠言，则攸之、祎、允之任也。Guo Youzhi, Fei Yi, and Dong Yun are the ones who should be making policy decisions and recommendations.愿陛下托臣以讨贼兴复之效，My only desire is to be permitted to drive out the traitors and restore the Han.不效，则治臣之罪，以告先帝之灵。If I should let you down, punish my offense and report it to the spirit of the late Emperor.若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；If those three advisors should fail in their duties, then they should be punished for their negligence.陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，Your Majesty, consider your course of action carefully. Seek out good advice, and never forget the late Emperor.臣不胜受恩感激。今当远离，I depart now on a long expedition, and I will be forever grateful if you heed my advice.临表涕零，不知所言。Blinded by my own tears, I know not what I write.","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"},{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"葛底斯堡演说","date":"2017-10-28T02:56:21.000Z","path":"2017/10/28/葛底斯堡演说/","text":".one{ color:#2F4F4F; font-family: Arial; font-weight:bold; } #p1{ color:#8B4513; font-family: Arial; font-weight:bold; } Four score and seven years ago our fathers brought forth ,on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.八十七年前，我们的祖先在这个大陆上建立了一个新的国家，它受孕于自由的理念，并献身于一切人生来平等的理想。Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war. We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that nation might live. It is altogether fitting and proper that we should do this.如今我们正在从事一场伟大的内战，以考验我们或任何一个受孕于自由和献身于上述理想的国家是否能够长久生存下去。我们聚集在那场战争中的一个伟大的战场上，我们来到这里，是要把这个战场土地的一部分作为最终安息之所奉献给那些献出了自己的生命的烈士们，他们牺牲了自己以使这个国家可能生存下去。奉献这块土地作为他们的安息之所是完全恰当的和合适的，我们应该这么做。But, in a larger sense, we can not dedicate – we can not consecrate – we can not hallow – this ground. The brave men, living and dead, who struggled here, have consecrated it, far above our poor power to add or detract. The world will little note, nor long remember what we say here, but it can never forget what they did here. It is for us the living, rather, to be dedicated here to the unfinished work which they who fought here have thus far so nobly advanced. It is rather for us to be here dedicated to the great task remaining before us – that from these honored dead we take increased devotion to that cause for which they gave the last full measure of devotion – that we here highly resolve that these dead shall not have died in vain – that this nation, under God, shall have a new birth of freedom – and that government of the people, by the people, for the people, shall not perish from the earth.但是，从更广泛的意义上来说，我们无从奉献——我们无从圣化——我们无从神化，这块土地。那些在这里战斗过的勇士，活着的和死去的，已经圣化了这里，它的神圣远非我们的微弱之力可以使其增减丝毫。世人不大会注意，更不会长久记得我们在这里所说的话，然而他们将永远无法忘记那些英雄们在这里所做的事。这更要求我们这些活着的人去献身于那些英雄们为之战斗的未尽事业。我们应该在此献身于仍然留在我们面前的伟大任务——要从这些光荣的死者身上汲取更多的奉献精神来完成他们已经完全彻底为之献身的事业——我们要在此下定最大的决心决不让这些死者白白牺牲——要让这个国家在上帝庇佑下获得自由的新生——要让那个民有、民治、民享的政府不从地球上消失 《葛底斯堡演讲》的赏析，从翻译的角度解析伟大的演讲 《葛底斯堡演讲》及其译文赏析","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"},{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"sync.Cond-让一系列Goroutine在满足特定条件时被唤醒","date":"2017-10-27T13:55:23.000Z","path":"2017/10/27/sync-Cond-让一系列Goroutine在满足特定条件时被唤醒/","text":"初入门径 cond是sync包下面的一种数据类型，相当于线程间通信的条件变量方式。 参考自 这一次，彻底搞懂 Go Cond sync.Cond 是sync包中, 用的最少的控制并发的手段, 因为其在大部分场景下都被 Channel 代替了. 如以下两段代码等效 12345678910111213141516171819package mainimport ( \"fmt\" \"time\")func main() &#123; done := make(chan int, 1) go func() &#123; time.Sleep(5 * time.Second) done &lt;- 1 &#125;() fmt.Println(\"waiting\") &lt;-done fmt.Println(\"done\")&#125; 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"sync\" \"time\")func main() &#123; cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;) var flag bool go func() &#123; time.Sleep(time.Second * 5) cond.L.Lock() flag = true cond.Signal() cond.L.Unlock() &#125;() fmt.Println(\"waiting\") cond.L.Lock() for !flag &#123; cond.Wait() &#125; cond.L.Unlock() fmt.Println(\"done\")&#125; 参考自 Go中多协程协作之sync.Cond 大部分场景下使用 channel 比 sync.Cond 要方便. 不过 sync.Cond 提供了 Broadcast 方法, 可以通知所有的等待者. 而想利用 channel 实现这个功能还是不容易的, 这应该是 sync.Cond 唯一有用武之地的地方 协程间通信方式，官方推荐使用channel，channel在一对一的协程之间进行数据交换与通信十分便捷。但是，一对多的广播场景中，则显得有点无力，此时就需要sync.Cond来辅助。 编程中的广播可以理解为：多个操作流程依赖于一个操作流程完成后才能进行某种动作，这个被依赖的操作流程在唤醒所有依赖者时使用的一种通知方式。 在Go语言中，则可以使用sync.Cond来实现多个协程之间的广播通知功能。 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\" \"sync\" \"time\")var locker sync.Mutexvar cond = sync.NewCond(&amp;locker)// NewCond(l Locker)里面定义的是一个接口,拥有lock和unlock方法。// 看到sync.Mutex的方法,func (m *Mutex) Lock(),可以看到是指针有这两个方法,所以应该传递的是指针func main() &#123; // 启动多个协程 for i := 0; i &lt; 10; i++ &#123; go func(x int) &#123; cond.L.Lock() // 获取锁 defer cond.L.Unlock() // 释放锁 cond.Wait() // 等待通知，阻塞当前 goroutine // 通知到来的时候, cond.Wait()就会结束阻塞, do something. 这里仅打印 fmt.Println(x) &#125;(i) &#125; time.Sleep(time.Second * 1) // 睡眠 1 秒，等待所有 goroutine 进入 Wait 阻塞状态 fmt.Println(\"Signal...\") cond.Signal() // 1 秒后下发一个通知给已经获取锁的 goroutine time.Sleep(time.Second * 1) fmt.Println(\"Signal...\") cond.Signal() // 1 秒后下发下一个通知给已经获取锁的 goroutine time.Sleep(time.Second * 1) cond.Broadcast() // 1 秒后下发广播给所有等待的goroutine fmt.Println(\"Broadcast...\") time.Sleep(time.Second * 1) // 等待所有 goroutine 执行完毕&#125; 输出为: 12345678910111213Signal...0Signal...4Broadcast...62358791 在go中协程间通信的方式有多种，最常用的是channel。如果牵扯多个协程的通知，可以使用sync.Cond。 源码实现 查看channel、sync.Cond源码会发现，它们有相似之处： 阻塞协程统一被封装在 sudog 结构里面 channel 阻塞读/写时，用双向链表存储被阻塞导致等待唤醒的协程 sync.Cond 使用带有头尾指针的单向链表存储被阻塞导致等待唤醒的协程 阻塞时都是使用gopark()进行协程的挂起操作 虽说有相似之处，但却有本质区别： channel 可用来在协程间传递数据 sync.Cond 不可用来在协程间传递数据，主要用来进行协程的阻塞唤醒操作。如需要传递数据，则需要使用全局变量进行传递 官方库或知名项目中的使用 sync.Cond日常开发中用的不对,但以上这些项目,包括k8s,都有使用到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239/*Copyright 2019 The Kubernetes Authors.Licensed under the Apache License, Version 2.0 (the \"License\");you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.*/// Package interrupts exposes helpers for graceful handling of interrupt signalspackage interruptsimport ( \"context\" \"net/http\" \"os\" \"os/signal\" \"sync\" \"syscall\" \"time\" \"github.com/sirupsen/logrus\")// only one instance of the manager ever existsvar single *managerfunc init() &#123; m := sync.Mutex&#123;&#125; single = &amp;manager&#123; c: sync.NewCond(&amp;m), wg: sync.WaitGroup&#123;&#125;, &#125; go handleInterrupt()&#125;type manager struct &#123; // only one signal handler should be installed, so we use a cond to // broadcast to workers that an interrupt has occurred c *sync.Cond // we record whether we've broadcast in the past seenSignal bool // we want to ensure that all registered servers and workers get a // change to gracefully shut down wg sync.WaitGroup&#125;// handleInterrupt turns an interrupt into a broadcast for our condition.// This must be called _first_ before any work is registered with the// manager, or there will be a deadlock.func handleInterrupt() &#123; signalsLock.Lock() sigChan := signals() signalsLock.Unlock() s := &lt;-sigChan logrus.WithField(\"signal\", s).Info(\"Received signal.\") single.c.L.Lock() single.seenSignal = true single.c.Broadcast() single.c.L.Unlock()&#125;// test initialization will set the signals channel in another goroutine// so we need to synchronize that in order to not trigger the race detector// even though we know that init() calls will be serial and the test init()// will fire firstvar signalsLock = sync.Mutex&#123;&#125;// signals allows for injection of mock signals in testingvar signals = func() &lt;-chan os.Signal &#123; sig := make(chan os.Signal, 1) signal.Notify(sig, os.Interrupt, syscall.SIGTERM, syscall.SIGABRT) return sig&#125;// wait executes the cancel when an interrupt is seen or if one has already// been handledfunc wait(cancel func()) &#123; single.c.L.Lock() if !single.seenSignal &#123; single.c.Wait() &#125; single.c.L.Unlock() cancel()&#125;var gracePeriod = 1 * time.Minute// WaitForGracefulShutdown waits until all registered servers and workers// have had time to gracefully shut down, or times out. This function is// blocking.func WaitForGracefulShutdown() &#123; wait(func() &#123; logrus.Info(\"Interrupt received.\") &#125;) finished := make(chan struct&#123;&#125;) go func() &#123; single.wg.Wait() close(finished) &#125;() select &#123; case &lt;-finished: logrus.Info(\"All workers gracefully terminated, exiting.\") case &lt;-time.After(gracePeriod): logrus.Warn(\"Timed out waiting for workers to gracefully terminate, exiting.\") &#125;&#125;// Context returns a context that stays is cancelled when an interrupt hits.// Using this context is a weak guarantee that your work will finish before// process exit as callers cannot signal that they are finished. Prefer to use// Run().func Context() context.Context &#123; ctx, cancel := context.WithCancel(context.Background()) single.wg.Add(1) go wait(func() &#123; cancel() single.wg.Done() &#125;) return ctx&#125;// Run will do work until an interrupt is received, then signal the// worker. This function is not blocking. Callers are expected to exit// only after WaitForGracefulShutdown returns to ensure all workers have// had time to shut down. This is preferable to getting the raw Context// as we can ensure that the work is finished before releasing our share// of the wait group on shutdown.func Run(work func(ctx context.Context)) &#123; ctx, cancel := context.WithCancel(context.Background()) single.wg.Add(1) go func() &#123; defer single.wg.Done() work(ctx) &#125;() go wait(cancel)&#125;// ListenAndServe runs the HTTP server and handles shutting it down// gracefully on interrupts. This function is not blocking. Callers// are expected to exit only after WaitForGracefulShutdown returns to// ensure all servers have had time to shut down.func ListenAndServe(server *http.Server, gracePeriod time.Duration) &#123; single.wg.Add(1) go func() &#123; defer single.wg.Done() logrus.WithError(server.ListenAndServe()).Info(\"Server exited.\") &#125;() go wait(shutdown(server, gracePeriod))&#125;// ListenAndServe runs the HTTP server and handles shutting it down// gracefully on interrupts. This function is not blocking. Callers// are expected to exit only after WaitForGracefulShutdown returns to// ensure all servers have had time to shut down.func ListenAndServeTLS(server *http.Server, certFile, keyFile string, gracePeriod time.Duration) &#123; single.wg.Add(1) go func() &#123; defer single.wg.Done() logrus.WithError(server.ListenAndServeTLS(certFile, keyFile)).Info(\"Server exited.\") &#125;() go wait(shutdown(server, gracePeriod))&#125;// shutdown will shut down the serverfunc shutdown(server *http.Server, gracePeriod time.Duration) func() &#123; return func() &#123; logrus.Info(\"Server shutting down...\") ctx, cancel := context.WithTimeout(context.Background(), gracePeriod) if err := server.Shutdown(ctx); err != nil &#123; logrus.WithError(err).Info(\"Error shutting down server...\") &#125; cancel() &#125;&#125;// Tick will do work on a dynamically determined interval until an// interrupt is received. This function is not blocking. Callers are// expected to exit only after WaitForGracefulShutdown returns to// ensure all workers have had time to shut down.func Tick(work func(), interval func() time.Duration) &#123; before := time.Time&#123;&#125; // we want to do work right away sig := make(chan int, 1) single.wg.Add(1) go func() &#123; defer single.wg.Done() for &#123; nextInterval := interval() nextTick := before.Add(nextInterval) sleep := time.Until(nextTick) logrus.WithFields(logrus.Fields&#123; \"before\": before, \"interval\": nextInterval, \"sleep\": sleep, &#125;).Debug(\"Resolved next tick interval.\") select &#123; case &lt;-time.After(sleep): before = time.Now() work() case &lt;-sig: logrus.Info(\"Worker shutting down...\") return &#125; &#125; &#125;() go wait(func() &#123; sig &lt;- 1 &#125;)&#125;// TickLiteral runs Tick with an unchanging interval.func TickLiteral(work func(), interval time.Duration) &#123; Tick(work, func() time.Duration &#123; return interval &#125;)&#125;// OnInterrupt ensures that work is done when an interrupt is fired// and that we wait for the work to be finished before we consider// the process cleaned up. This function is not blocking.func OnInterrupt(work func()) &#123; single.wg.Add(1) go wait(func() &#123; work() single.wg.Done() &#125;)&#125; 参考自 源码剖析sync.cond(条件变量的实现机制） Cond 是condition的缩写,即条件. 在Java中有Condition类,实现线程间的协作. (Java的Condition类用来更安全和高效的实现 等待/通知(wait/notify)机制. 在Go语言使用Cond也可达到同样的效果, 可利用等待/通知机制实现阻塞或者唤醒) sync.Cond原语, 为等待/通知场景下的并发问题提供支持。Cond可以让一组Goroutine都在满足特定条件(这个等待条件有很多,可以是某个时间点或者某个变量或一组变量达到了某个阈值, 也可以是某个对象的状态满足了特定条件)时被唤醒, Cond和某个条件相关,这个条件需要一组goroutine协作共同完成,在条件还没有满足的时候,所有等待这个条件的goroutine都会被阻塞住,只有这一组goroutine通过协作达到了这个条件,等待的goroutine才可以继续进行下去。 signal和Broadcast: signal和Broadcast都会唤醒等待队列，不过signal是唤醒链表最前面的Goroutine，Broadcast会唤醒队列中全部的Goroutine。 注意事项 调用wait方法的时候一定要加锁，否则会导致程序发生panic. wait调用时需要检查等待条件是否满足，也就说goroutine被唤醒了不等于等待条件被满足，等待者被唤醒，只是得到了一次检查的机会而已，推荐写法如下： 123456c.L.Lock()for !condition() &#123; c.Wait()`&#125;`... make use of condition ...c.L.Unlock() Signal 和 Broadcast 两个唤醒操作不需要加锁 更多参考: 手摸手Go 深入理解sync.Cond","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"源码辅助阅读工具","date":"2017-10-23T12:52:10.000Z","path":"2017/10/23/源码辅助阅读工具/","text":"https://zhuanlan.zhihu.com/p/378684243","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"MySQL根据某张表复制新表","date":"2017-10-21T05:50:46.000Z","path":"2017/10/21/MySQL根据某张表复制新表/","text":"在InnoDB一棵B+树,可以存放多少行数据中,探讨了在B+数深度为3的前提下, mysql单表的数据上限: 如果单条记录大小为1k,能存1170*1170*16=21902400行数据. 实践中,可能单条记录会小于1k,从而单表上限可以稍稍增大,但一般也不超过5000万. 当某张表数据过大,就需要考虑从业务上进行分表,即将原来的单表a,拆成n张(如拆成100张a_00,a_01…a_99), 再根据业务的某项标识(如用户的uid),在代码中先决定写或读落到哪张表. 在单表扩容过程中,如下几条sql,将很有用处: 复制一张新的user表,命名为user6. 仅复制表结构,不复制表数据 1create table user6 like user 或 1create table user6 select * from user where 1=2 如果去掉where条件,即 1create table user6 select * from user 则将会连原来user表的数据一同复制 将某张表(user)的数据,复制写入另一张新表(user5) 1INSERT INTO user5 SELECT * FROM user;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"sync包-Pool","date":"2017-10-20T11:09:09.000Z","path":"2017/10/20/sync包-Pool/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344// A Pool is a set of temporary objects that may be individually saved and// retrieved.//// Any item stored in the Pool may be removed automatically at any time without// notification. If the Pool holds the only reference when this happens, the// item might be deallocated.//// A Pool is safe for use by multiple goroutines simultaneously.//// Pool's purpose is to cache allocated but unused items for later reuse,// relieving pressure on the garbage collector. That is, it makes it easy to// build efficient, thread-safe free lists. However, it is not suitable for all// free lists.//// An appropriate use of a Pool is to manage a group of temporary items// silently shared among and potentially reused by concurrent independent// clients of a package. Pool provides a way to amortize allocation overhead// across many clients.//// An example of good use of a Pool is in the fmt package, which maintains a// dynamically-sized store of temporary output buffers. The store scales under// load (when many goroutines are actively printing) and shrinks when// quiescent.//// On the other hand, a free list maintained as part of a short-lived object is// not a suitable use for a Pool, since the overhead does not amortize well in// that scenario. It is more efficient to have such objects implement their own// free list.//// A Pool must not be copied after first use.type Pool struct &#123; noCopy noCopy local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. New func() interface&#123;&#125;&#125; 源码分析: 深度解密Go语言之sync.pool Go sync.Pool 浅析 理解Go 1.13中sync.Pool的设计与实现 Go 1.13中 sync.Pool 是如何优化的?","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Github的Actions,可以用来做哪些事儿","date":"2017-10-14T13:18:14.000Z","path":"2017/10/14/Github的Actions-可以用来做哪些事儿/","text":"有很多借助Actions，实现自动签到功能的项目。 （所有放到.github/workflows文件夹里的.yml文件都会被视为Actions的配置文件） 一般操作是，先fork，然后Settings--&gt;Secrets,点击右上角的New repository secret 添加需要的K-V配置。 而后就会按设定的频次自动执行； 当然也可以手动触发：点击Actions，点allow，enable –&gt; Run workflow 进行触发。 还可以结合 Server酱，将执行信息推送到微信或钉钉等 如： 自动领取京豆 有道云笔记每天自动签到 更多 白嫖Github Action学习CI/CD","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"楚都四面","date":"2017-10-08T14:39:10.000Z","path":"2017/10/08/楚都四面/","text":"坐上一列绿皮车，经过四小时颠簸，从泗洙河畔的圣人故里，来到兵家必争的徐州。路途注定难熬：拥挤的人群和无处安放的各种大件行李，黝黑发亮的座椅散发独特气味，再兼各种脱鞋脱袜，密不透风的车厢，摩肩擦踵的人群，加上金立和蓝绿机外放的口水歌和王者荣耀，雷打亦不动的呼噜声，以及总会有的因为空间因为行李而起的或大或小的争执，便是风景独到的绿皮车乘坐体验。… 而我却是放空心态，以身处其中的旁观者身份，不动声色细细观察，ta们有的已沟壑深深 布满黄褐色的脸庞，衣装穿的破旧邋遢如我; 有的正年轻，沉醉手机头也不抬。ta们的终点，可能是昆山的工厂，可能是接收上海外卖店的订单。ta们不讨喜甚至让人厌烦，更是绝少共同语言，却与我一样都是进城务工，没再多差别。 在这里，有镁光灯不多关注的更广大更真实的中国。 出站后，明月在天，常被飘荡着的乌云遮没。此时中秋已过，寒意四起，我却分明看到，站外的许多处地方，三三两两横七竖八躺着些和衣而卧的旅人，即便四遭咫尺，便是各式各样的宾馆客房。 我一个人前去云龙湖，看到凌晨两点送餐的外卖小哥，有些犹豫地瞅着红绿灯，旋即点亮手机，查看超时时间。 当我酣畅淋漓围湖骑行近20公里，在湖中路，停车走至木质围栏，看到远方或明或暗的稀疏星辰，月尚圆，人已远。我跑跑跳跳走动着，惊扰了未发觉的不远处，一位带着口罩捂得严严实实的老人家翻动垃圾桶。望着她匆匆远去的身影，便又有些不知从何而来的叹息。 如同全国所有大中城市，这里红旗正招展，宣传俯拾可见。40年来，这个国家从世界第八追赶为第二，并会在不会太久的将来成为世界第一大经济体，成绩瞩目，惊耀世人。然而，这惊世之功，有数以亿万进城务工者的血汗，无数多个留守老人和留守儿童并不美满的晚年和并不幸福的童年。 腾讯阿里对垒，像楚汉时刘项鏖战荥阳。而微信，就是北上伐齐的韩信，它绝不再只是QQ的延伸或替身，其迥然不同的产品理念和对各圈层各年龄人群极尽囊括，以及自成生态的半开放体系，正“在陆地，在空中，在水里；在街上，在桥下，在田野中”，对妄图“火烧南极洲”的来犯之敌给以全方位打击。 “互联网就是社交网络”，这是20年前互联网起步之初，BBS、IM、SNS尚处襁褓时许多人的认为。时至今日，掌握牢不可破的社交圈子，仍让腾讯固若金汤，如占据关中或蜀中，易守难攻，却可悄无声息，对对手蚕食鲸吞，今日下一城，明日占一邑。… 而作为阿里主业的电商，则没有排他性这个迈不过去的门槛，相反是块肥肉，众目虎视，如孤处平原易攻难守的四战之地，楚都彭城。 西楚也有一支未上市的生力军，以支付宝为核心资产的蚂蚁金服，如同霸王手下第一勇将龙且，率同锐不可当的楼兰铁骑，在第三方支付领域一争高下。 而今的情形是，或许在一二线城市支付宝依然占优，但在数以万计的县镇和无数的场景，“像水和空气”一样无孔不入的微信，把支付宝拉入了汪洋大海一般的人民战争。 也许垓下合围景象永远不会出现，但不消几年，两者在各自传统领域的进退就将见分晓。阿里很可能会多元化，发展为一家电商业务收入占比不超过50%的互联网综合服务商。 2017.05.09 于洛阳龙门 能清晰记得1997发生总共不多的三五事，而10年前的2007，却有些漫漶模糊。… 眼前的总进缓存，以为想起时随时可以找到。而把更久远的以前放进硬盘持久化。 还有不到80天，人类纪元里的2017也将从时间刻度划过。而我却还依稀记得，10年前雨雪冰冻，打砸抢烧，动车相撞，特大地震，以及8月8号，我在夜幕沉沉下的人工湖野泳，被湖底的锐物轻轻划伤脚趾。我看到岸边垂柳依依如昔，却不见一人，雾气弥漫，不禁有些孤单。我在8点钟回到家，看到电视屏幕里，几百公里外的北京烟火闪耀。那正是我结束中考，将开始高中的最后一个悠闲假期。而后成绩尚好却并不快乐，以至于近十年后依然心有余悸。可能从那时起，便失去了微笑作为常态的生活，转而是不知因何的闷闷不乐，只有偶现的一些时刻，可以强打精神稍动嘴角。 这不能只归因于“家庭”归因于“长大”，还有分化导致的孤独，孤独引发的迷惘。我再不能像10多年前那样自命不凡，不能再被两个小姑娘满学校追着不亦乐乎的打闹，不能再为一餐盛宴或一次远行而憧憬期待许久。 半个月前，我在凌晨三点的徐州云龙湖，一轮明月辉映下的万顷湖面，透着令人可怖的静谧。我在湖中路一条座椅旁停下，把公共自行车放倒在一旁，和自动售货的机器交互，直到它吐出一瓶凉嗖嗖的维C饮料。我拧开瓶盖，坐在椅上，翘起腿，听着近处潮打岸边寂寞而回，望着远方天水相接的地方。月色和夜色冷冷的，那一刻，我有一种明晰感到的超脱于物外的孤独。而在日常琐屑工作间，在聚会撸串小龙虾时，在许多个日复一日的清晨和深夜，都未曾能感到。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"乙醇化醛","date":"2017-10-03T03:15:38.000Z","path":"2017/10/03/乙醇化醛/","text":"时从沪来杭不久,满心欣喜归家.不喜饮酒,不胜杯杓;然一家团聚,破例为之.清宵酒醒,数感并集,予以一记.彼时,外公外婆尚在,爷爷奶奶康健;过后一年多,落户买房,跳槽加薪,浮沉起伏,一再不表;幼时种种事,都到眼前来,然故人暌违永隔.观此旧文,真如隔世. 2019.02.19补记. 我在深宵漆黑的夜里酒醒，不眠中思绪纷飞。复又点亮手机，机械划过上百篇新闻，感觉这世界的一切都好无聊。我隐约听到了远方传来的鸡响，过一会儿草草洗漱，便又要强打精神，微笑面对生活。 “陈王昔时宴平乐，斗酒十千恣欢谑”，曹植刘伶阮籍李白们，依靠酒精的麻醉暂时逃离了纷扰的尘世，有片刻之机独对内心。 “当风轻借力，一举入高空”。只疑远赴蟾宫，凌万顷茫然的飘飘欲仙感美妙不可言，而当乙醇化醛，又分明感到超脱物外的身体重重落回凡间，想到此后60年要面对的许些欢颜和更多的泪目，直至病榻之上弥留之际的释怀一笑，想长舒口气却用尽全力不得，便与山川草木泯为一体。怜我世人，忧患实多。思虑至此，竟悲从中来，不知所往。 “古来圣贤皆寂寞，惟有饮者留其名”，这些历史上的顶级文人们，用大段文字记叙“起”和“承”的美妙，却吝惜笔墨对随即必然而来的“转”及“合”不肯多言。 释家物空一切的恬淡释然，会悄无声息，把任何儒家再热辣强烈的出世大志消弭无形，像经过小浪底的黄河水，依然眼高于顶，却不在肆虐呼啸，只是静默安稳地淌过河道，等待归流入海。我想到晚年的王摩诘和白乐天，想到传说身未死而落发为僧的骆宾王和李自成，想到小说里一笑泯恩仇的萧远山和慕容博。 我想到一甲子后，我连同这一刻几乎所有风头无两豪气干云的人物，都要不带一锱化归尘土，便觉平素许些压在心底的梦想，也如尘土，更像饮下的原浆竹叶青——酒精借酶，分解化成乙醛复又乙酸，终成二氧化碳与水，不经意间，离你远去。纵使年少之时，以此为毕生夙愿，像刚刚吞咽下肚的烈酒，片刻不得忘。 梦想和雄图大志，即便再高尚，却也是许多时刻困扰人的执念，或如沙之于蚌，久病成珠惊耀于世，抑是如茧于蝶，自缚其中不得解脱。 许多年前，我分明隐约地意识到，人尤是我这类人，大概都要经历一个从年少时格外喜欢“李白”，到长大尤其景仰崇拜“杜甫”，再到年岁渐长又欣赏“李白”的过程。 天地者万物之逆旅，光阴者百代之过客。恍惚间，仿佛看到了千年前湖北黄冈，那个远眺漄岸看潮水卷起千堆雪的失意文人，他似是完美践行了我的观点。宦海沉浮，乌台诗案，中途求死而不得，一盆冷水，终脱离笼罩在所有儒家读书人心上挥之不去的阴影，自此更有许多醉酒被拒之家门外，更少苦大仇深更多随心随性，更多与佛印和尚常相往来的日记流。客死在湘水扁舟之上无人问的老杜，成为千年以来不是最后却是最高的绝响。 “老僧已死成新塔，坏壁无由见旧题。往日崎岖还记否，路长人困蹇驴嘶” 梁城崔颠，于丁酉八月几望。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"MySQL常用表级操作","date":"2017-09-29T13:16:09.000Z","path":"2017/09/29/MySQL常用表级操作/","text":"基础信息相关 1.修改表名： rename table 旧表名 to 新表名; 2、修改字段类型： alter table 表名 modify column 字段名 字段类型(长度) 3、修改字段名称和类型： alter table 表名 change 现有字段名称 修改后字段名称 数据类型 4、增加字段： alter table 表名 add 字段名 字段类型（长度） 批量增加字段 alter table 表名 add (字段名1 字段类型（长度）,字段名2 字段类型（长度）,...) 5、删除字段： alter table 表名 drop column 字段名 批量删除字段 alter table 表名 drop column 字段名1，drop column 字段名2 6、修改字段默认值： alter table 表名 alter column 字段 set default 默认值 7、添加字段备注： alter table 表名 add modify 字段名 字段类型（长度）default null comment ‘备注’ 为表添加注释 alter table 表名 comment &#39;注释&#39; 索引相关 注: 索引名称是可选字段~ 1.普通索引 添加index alter table表名add index 索引名称 (字段名) 2.主键索引 添加primary key alter table表名add primary key (字段名) 3.唯一索引 添加unique alter table表名add unique 索引名称 (字段名) 4.全文索引 添加fulltext alter table表名add fulltext 索引名称 (字段名) 5.如何添加多列索引 alter table表名add index 索引名称 (字段名,字段名,字段名)","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"sysctl.conf 系统参数详解","date":"2017-09-23T14:46:41.000Z","path":"2017/09/23/sysctl-conf-系统参数详解/","text":"vim /etc/sysctl.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364## /etc/sysctl.conf - Configuration file for setting system variables# See /etc/sysctl.d/ for additional system variables.# See sysctl.conf (5) for information.##kernel.domainname = example.com# Uncomment the following to stop low-level messages on console#kernel.printk = 3 4 1 3##############################################################3# Functions previously found in netbase## Uncomment the next two lines to enable Spoof protection (reverse-path filter)# Turn on Source Address Verification in all interfaces to# prevent some spoofing attacks#net.ipv4.conf.default.rp_filter=1#net.ipv4.conf.all.rp_filter=1# Uncomment the next line to enable TCP/IP SYN cookies# See http://lwn.net/Articles/277146/# Note: This may impact IPv6 TCP sessions too#net.ipv4.tcp_syncookies=1# Uncomment the next line to enable packet forwarding for IPv4# 爽哥于2019.10.31修改,为了能搭建k8snet.ipv4.ip_forward=1# Uncomment the next line to enable packet forwarding for IPv6# Enabling this option disables Stateless Address Autoconfiguration# based on Router Advertisements for this host#net.ipv6.conf.all.forwarding=1#################################################################### Additional settings - these settings can improve the network# security of the host and prevent against some network attacks# including spoofing attacks and man in the middle attacks through# redirection. Some network environments, however, require that these# settings are disabled so review and enable them as needed.## Do not accept ICMP redirects (prevent MITM attacks)#net.ipv4.conf.all.accept_redirects = 0#net.ipv6.conf.all.accept_redirects = 0# _or_# Accept ICMP redirects only for gateways listed in our default# gateway list (enabled by default)# net.ipv4.conf.all.secure_redirects = 1## Do not send ICMP redirects (we are not a router)#net.ipv4.conf.all.send_redirects = 0## Do not accept IP source route packets (we are not a router)#net.ipv4.conf.all.accept_source_route = 0#net.ipv6.conf.all.accept_source_route = 0## Log Martian Packets#net.ipv4.conf.all.log_martians = 1#kernel.sysrq = 1net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1kernel.printk = 5 https://blog.csdn.net/weixin_40901788/article/details/83586965","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"golang 包引用","date":"2017-09-23T12:49:52.000Z","path":"2017/09/23/golang-包引用/","text":"golang中, 1.同一个文件夹(package)下,一个文件如何引用另一个文件里的内容?即 同一个包下 不同文件如何互相调用? Go 一个目录为一个包(package), 包里面的函数、结构体、 变量、常量, 这个包中所有文件里的代码都可以随意访问, 也不需要首字母大写 main.go 12345package mainfunc main()&#123; printSth(\"爽哥\")&#125; tool.go 12345678package mainimport \"fmt\"func printSth(str string) string &#123; fmt.Println(\"传入内容为:\",str) return \"返回内容是:\" + str&#125; 执行 go run main.go或go build main.go,报错如下: 12# command-line-arguments./main.go:xx行:x行: undefined: printSth ??? 这是因为只选择了main.go来进行构建，而其他文件没有构建进工程，自然也无法调用.. 不能认为你去跑main，然后IDE会将你需要的所有文件都编译，所以这个时候我们需要动手改下命令行来运行, go build main.go tool.go或go run main.go tool.go 对于同一package下不同文件里的结构体,也可以直接引用,而不用关注结构体字段首字母的大小写: main.go: 1234567891011121314package mainimport \"fmt\"func main() &#123; var cs transaction cs.amount = 13579 cs.from = \"first-block\" cs.to = \"next-block\" fmt.Println(cs)&#125; strcut_my.go: 123456789package maintype transaction struct &#123; amount uint64 from string to string hash []byte signature string&#125; 执行go run main.go, 12# command-line-arguments./main.go:7:9: undefined: transaction 执行 go run main.go struct_my.go, 1&#123;13579 first-block next-block [] &#125; 2.不同文件夹(package)下,一个文件如何引用另一个文件里的内容? eight/main.go: 123456789101112131415161718package mainimport ( \"../nine\" \"fmt\")func main() &#123; fmt.Println(utils.Speak(\"太后\")) //引用其他包里的结构体,需被引用的结构体首字母大写,且该首字母为大写的结构体中大写的字段才可以被调用到 var my utils.Role my.Name = \"江湖郎中汤元元\" fmt.Println(my)&#125; nine/say.go 123456789101112package utilsfunc Speak(str string) string &#123; return str + \"吉祥\"&#125;type Role struct &#123; Name string gender string age int&#125; 执行go run eight/main.go, 12太后吉祥&#123;江湖郎中汤元元 0&#125; 文件名(say.go)/包名(utils)可以不一致,大小写都可以.但被调用的包里的方法,必须要首字符大写,才能被其他包调用. 引用其他包里的结构体,需被引用的结构体首字母大写,且该首字母为大写的结构体中大写的字段才可以被调用到 可参考","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"冒泡排序","date":"2017-09-17T04:36:00.000Z","path":"2017/09/17/冒泡排序/","text":"BubbleSort,即冒泡排序是一种交换排序。 什么是交换排序呢？ 交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。 相关参考可点击 1234567891011121314151617181920212223242526272829303132333435package mainimport \"fmt\"func main() &#123; sli := []int&#123;4, 93, 84, 85, 80, 37, 81, 93, 27, 12&#125; fmt.Println(sli) BubbleAsort(sli) BubbleZsort(sli)&#125;func BubbleAsort(target []int) &#123; length := len(target) for i := 0; i &lt;= length-1; i++ &#123; //因为j=i+1,故而i这一层不需要遍历n次,而只需要n-1次 for j := i + 1; j &lt; length; j++ &#123; //j则是从第2个元素遍历到最后一个,所以也是n-1次遍历;冒牌排序时间复杂度为O(n2),但要说实际执行的次数,最差为(n-1)的平方 if target[i] &gt; target[j] &#123; target[i], target[j] = target[j], target[i] &#125; &#125; &#125; fmt.Println(target)&#125;func BubbleZsort(target []int) &#123; length := len(target) for i := 0; i &lt; length-1; i++ &#123; for j := i + 1; j &lt; length; j++ &#123; if target[i] &lt; target[j] &#123; target[i], target[j] = target[j], target[i] &#125; &#125; &#125; fmt.Println(target)&#125; 输出为: 123[4 93 84 85 80 37 81 93 27 12][4 12 27 37 80 81 84 85 93 93][93 93 85 84 81 80 37 27 12 4]","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"缓存世界中的三大问题","date":"2017-09-14T14:19:12.000Z","path":"2017/09/14/缓存世界中的三大问题/","text":"缓存穿透 (Cache Penetration) 穿透形象一点就是：请求过来了 转了一圈 一无所获 就像穿过透明地带一样 用户查询数据库，返回的结果为空(未查到数据),并且结果不会在缓存中存储。 假设用户不断发起这样的请求，它将永远不会访问缓存，导致所有查询都落在数据库上，从而导致数据库被打死。 解决方案： 1） 通过用户认证、参数验证等，在上层拦截这些不合理的请求； 2） 当数据库查询结果为空时，数据也被缓存，但缓存有效期设置较短，以免影响正常数据的缓存。 3) 另外一种思路，转换为查找问题，类似于在海量数据中查找某个key是否存在，考虑空间复杂度和时间复杂度，一般选用布隆过滤器来实现 缓存击穿 (Hotspot Invalid) 英文名即 “热点失效” 当热点数据存储到期时，多个线程同时请求热点数据。因为缓存刚过期，所有并发请求都会到数据库查询数据。 解决方案： 实际上，在大多数实际业务场景中，缓存击穿是实时发生的，但不会对数据库造成太大压力，因为一般的公司业务，并发量不会那么高。当然如果你不幸有这种情况，可以通过设置这些热点键，使其永远不会过期。 另一种方法是通过互斥锁来控制查询数据库的线程访问，但这种会导致系统的吞吐率下降，需要实际情况使用。 (golang扩展原语包里有 singleflight方法，参见SingleFlight-抑制对下游多次重复请求,防止缓存击穿的利器) 缓存雪崩（Cache Avalanche） Avalanche: n/v. 雪崩 数据未加载到缓存中，或者缓存同时大范围失效，导致所有请求都请求到数据库，导致数据库、CPU 和内存过载，甚至停机。 一个简单的雪崩过程： 1） Redis 集群的大面积故障； 2） 缓存失败，但仍有大量请求访问缓存服务 Redis； 3） 在大量 Redis 请求失败后，请求转向数据库； 4） 数据库请求急剧增加，导致数据库被打死； 5） 由于应用程序服务大部分都依赖于数据库和 Redis 服务，它很快就会导致服务器集群的雪崩，最后整个系统将彻底崩溃。 解决方案： 事前：高可用的缓存 高可用的缓存是防止出现整个缓存故障。即使个别节点，机器甚甚至机房都关闭，系统仍然可以提供服务，Redis 哨兵(Sentinel) 和 Redis 集群(Cluster) 都可以做到高可用。 事中：缓存降级（临时支持 当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用?在国内使用比较多的是 Hystrix，它通过熔断、降级、限流三个手段来降低雪崩发生后的损失。只要确保数据库不挂，系统总可以响应请求， 事后：Redis 备份和快速预热 1） Redis 数据备份和恢复 2） 快速缓存预热 参考： 缓存世界中的三大问题及解决方案 缓存雪崩 Cache Avalanche / 缓存穿透 Cache Penetration / 缓存击穿 Hotspot Invalid","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"秒杀业务场景中的超卖问题","date":"2017-09-11T16:17:15.000Z","path":"2017/09/12/秒杀业务场景中的超卖问题/","text":"最朴素想法，把数据库表商品数量字段设置为unsigned，这样在为负数时就会报错。 当秒杀一般都伴随高并发，直接操作数据库，DB压力会非常大，( 减库存操作是一个事务操作，需先select，然后insert，最后update -1,可能会产生死锁 ） 库存超卖问题是有很多种技术解决方案的，如悲观锁，分布式锁，乐观锁，队列串行化，Redis原子操作 Redis分布式锁解决超卖问题 比较常用， 即 SetNX+Expire Redis分布式锁解决超卖问题 如何解决秒杀的性能问题和超卖的讨论 如何利用 redis 分布式锁，解决秒杀场景下的订单超卖问题？ 面试必问的关于商品超买问题的解决方案","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Hex-Rays IDA与Hopper Disassembler","date":"2017-09-08T13:21:58.000Z","path":"2017/09/08/Hex-Rays-IDA与Hopper-Disassembler/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Mutex vs Atomic","date":"2017-08-25T12:02:35.000Z","path":"2017/08/25/Mutex-vs-Atomic/","text":"本篇是对Golang中的CAS原子操作 和 锁的学习与记录 概况： 在高并发场景下，对同一变量并发写操作时，需要使用 锁 或 CAS原子操作来保证最终结果的正确。此文比较二者的差异 比如起10000个协程，对同一变量进行+1操作。如果不采取任何措施(无锁&amp;&amp;无CAS操作)，则会出现问题 (与预期结果不一致，且每次执行的结果都不同) 无锁&amp;无CAS： noLockandCas.go12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"sync\")func main() &#123; var count int64 var wg sync.WaitGroup for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func(wg *sync.WaitGroup) &#123; defer wg.Done() count = count + 1 &#125;(&amp;wg) &#125; wg.Wait() fmt.Println(\"count is:\", count) //count != 10000&#125; 多次执行，结果为： 123count is: 8820count is: 9336count is: 8976 加锁的实现方式 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"sync\")func main() &#123; var count int64 var wg sync.WaitGroup var mu sync.Mutex for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func(wg *sync.WaitGroup) &#123; defer wg.Done() mu.Lock() count = count + 1 mu.Unlock() &#125;(&amp;wg) &#125; wg.Wait() fmt.Println(\"count is:\",count) //count = 10000&#125; 多次执行，结果为： 123count is: 10000count is: 10000count is: 10000 atomic CAS 原子操作 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"sync\" \"sync/atomic\")func main() &#123; var count int64 var wg sync.WaitGroup for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func(wg *sync.WaitGroup) &#123; defer wg.Done() // 失败一直重试 for &#123; old := atomic.LoadInt64(&amp;count) if atomic.CompareAndSwapInt64(&amp;count, old, old+1) &#123; break &#125; &#125; &#125;(&amp;wg) &#125; wg.Wait() fmt.Println(\"count is:\", count) //count = 10000&#125; 多次执行，结果为： 123count is: 10000count is: 10000count is: 10000 性能差异： 可以看到，加锁或使用CAS，都可以达到目的。 来比较下二者的性能差异 lockandcat_test.go: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"sync\" \"sync/atomic\" \"testing\")func lockTest() &#123; var count int64 var wg sync.WaitGroup var mu sync.Mutex for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func(wg *sync.WaitGroup) &#123; defer wg.Done() mu.Lock() count = count + 1 mu.Unlock() &#125;(&amp;wg) &#125; wg.Wait()&#125;func atomicTest() &#123; var count int64 var wg sync.WaitGroup for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func(wg *sync.WaitGroup) &#123; defer wg.Done() // 失败一直重试 for &#123; old := atomic.LoadInt64(&amp;count) if atomic.CompareAndSwapInt64(&amp;count, old, old+1) &#123; break &#125; &#125; &#125;(&amp;wg) &#125; wg.Wait()&#125;func BenchmarkLock(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; lockTest() &#125;&#125;func BenchmarkAtomic(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; atomicTest() &#125;&#125; 单个CPU go test -bench=&quot;.*&quot; -v -benchmem -cpu=1 123456789goos: darwingoarch: arm64pkg: xxxxxBenchmarkLockBenchmarkLock 548 2002265 ns/op 32 B/op 3 allocs/opBenchmarkAtomicBenchmarkAtomic 608 2003293 ns/op 24 B/op 2 allocs/opPASSok ben 3.239s 单个CPU情况下，每次操作内存分配， atomic 比 lock 少了1/3，但总的看差别不太大 不同写法的性能差异 Go测试 两个CPU go test -bench=&quot;.*&quot; -v -benchmem -cpu=2 123456789goos: darwingoarch: arm64pkg: xxxxxBenchmarkLockBenchmarkLock-2 825 1363475 ns/op 441 B/op 3 allocs/opBenchmarkAtomicBenchmarkAtomic-2 831 1440089 ns/op 24 B/op 2 allocs/opPASSok ben 2.711s 相比单个CPU，每次操作耗时有所减少 四个CPU go test -bench=&quot;.*&quot; -v -benchmem -cpu=4 123456789goos: darwingoarch: arm64pkg: xxxxxBenchmarkLockBenchmarkLock-4 567 2020170 ns/op 442 B/op 4 allocs/opBenchmarkAtomicBenchmarkAtomic-4 589 2011578 ns/op 33 B/op 2 allocs/opPASSok ben 2.841s 在arm架构的机器上，改变也不太大 总结 从结果看，当使用多个CPU时，差距较为明显的是分配内存次数(如 4 allocs/op)和每次操作分配的内存大小(如 442B/op)。 总体来看使用 atomic 要比使用 lock 的性能要好 所以在只修改一个变量值的场景下，优先使用 atomic ，而不是 lock 锁 原理 原子操作一般是由 硬件底层 支持的，而锁则是由操作系统层面来实现的。比起使用锁，使用 CAS原子操作这个过程不会形成临界区和创建临界区，大大减少了同步对程序性能的影响，所以性能要高效一些。但原子操作也有一定的弊端，在被操作值频繁变更的情况下，很可能失败，需要一直重试直到成功为止，这种重试行为也可以理解为自旋spinning，长时间处于spinning将浪费CPU 【os浅尝】实现自旋锁 原子操作 硬件层面实现。几乎所有的现代CPU指令都支持CAS的原子操作(X86下对应的是 CMPXCHG 汇编指令) 有了这个原子操作，就可以用其来实现各种无锁（lock free）的数据结构,如最常见的 无锁队列 CAS 在Golang中是以共享内存的方式来实现的一种同步机制，它是一个原子操作，一般格式如下: 12345678func addValue(delta int32)&#123; for&#123; oldValue := atomic.LoadInt32(&amp;addr) if atomic.CompareAndSwapInt32(&amp;addr, oldValue, oldValue+delta)&#123; break; &#125; &#125;&#125; “先从一个内存地址 &amp;addr 读取出来当前存储的值，假如读取完以后，没有其它线程对此变量 进行修改的话，则下面的 atomic.CompareAndSwapInt32 语句会在执行时先再判断一次它的值是否与上次的相等，这时必须是相等的，则直接更新它的值；如果在读取值后，有其它线程对变量值进行了修改，发现值不相等，这时就再重新开始下一轮的判断，直到修改成功为止。 对于 atomic.CompareAndSwapIntxx() 之类函数，其声明在sync/atomic/doc.go ，实现在 src/sync/atomic/asm.s，真正对应的汇编文件位于 src/runtime/internal/atomic/*.s，如64架构对应的文件为 asm_amd64.s“ arm架构下atomic.CompareAndSwapInt64 和 atomic.CompareAndSwapUint64 对应的汇编是 runtime∕internal∕atomic·Cas64； 12345678910111213141516171819202122// bool runtime∕internal∕atomic·Cas64(uint64 *ptr, uint64 old, uint64 new)// Atomically:// if(*val == *old)&#123;// *val = new;// return 1;// &#125; else &#123;// return 0;// &#125;TEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, $0-25 MOVD ptr+0(FP), R0 MOVD old+8(FP), R1 MOVD new+16(FP), R2again: LDAXR (R0), R3 CMP R1, R3 BNE ok STLXR R2, (R0), R3 CBNZ R3, againok: CSET EQ, R0 MOVB R0, ret+24(FP) RET 锁 可以保证一段代码的原子性，由操作系统来实现。锁的粒度越小越好 对比 mutex 由操作系统实现，而 atomic 包中的原子操作则由底层硬件直接提供支持。在 CPU 实现的指令集里，有一些指令被封装进了 atomic 包，这些指令在执行的过程中是不允许中断（interrupt）的，因此原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。若实现相同的功能，后者通常会更有效率，并且更能利用计算机多核的优势。所以，以后当我们想并发安全的更新一些变量的时候，我们应该优先选择用 atomic 来实现。 到底啥是原子性–Mutex vs Atomic 更多参考: sync/atomic - 原子操作 Go是如何实现乐观锁（CAS理论）","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"MySQL事务隔离级别的实现原理","date":"2017-08-23T14:58:07.000Z","path":"2017/08/23/MySQL事务隔离级别的实现原理/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"索引下推","date":"2017-08-22T03:11:26.000Z","path":"2017/08/22/索引下推/","text":"回表与覆盖索引，索引下推","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"并发编程中的ABA问题","date":"2017-08-21T14:13:20.000Z","path":"2017/08/21/并发编程中的ABA问题/","text":"ABA 表面看起来没什么问题，但如果结合实际应用场景，就可以看出其问题所在 真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。 漫画：什么是CAS机制？（进阶篇） 风险指针(Hazard Pointer), 也称 冒险指针","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"WebHook及其在github中的使用","date":"2017-08-16T12:52:09.000Z","path":"2017/08/16/WebHook及其在github中的使用/","text":"钩子Hooks和回调Callback，是指在执行一系列操作过程中，触发了某个条件，会去执行某项操作。 如在GORM中，想要在执行查询后，上报一下执行的时间,则可以1db.Callback().Query().After(\"gorm:query\").Register(\"endRead\", completeRead)其中endRead为自定义的事件名称，completeRead为自定义的触发时要执行的方法(在GROM中，Hooks仅针对当前场景有效，Callback则针对全局有效)在日志库 github.com/sirupsen/logrus，redis go客户端[github.com/go-redis/redis/v8]等库中，也都支持钩子/回调 Webhook大致与hook类似，一般称为反向 API。 和传统的 客户端请求，服务器响应相比，客户端提供一个URL，在事件发生时，服务端会向这个配置好的 URL 发送一条信息。 即与请求-响应不同,使用 Webhook 你可以实时接受到变化 （原本是主动拉取，现在是被动被push； 印象里支付宝/微信支付等都有类似功能，要求你提供一个接口，支付成功后向该接口push信息） 在github/gitlab/gitee中，WebHook 用于在项目发生相关事件时通知外部服务器 （与监听事件、触发器之类的东西类似） 我写完一篇新博客，执行make之后，代码会自动构建并push到github的对应仓库(详见Makefile书写小结). 但还需要登录服务器，手动git push一下 (为提升速度，没有使用github的pages功能)。 之前有通过脚本，在完成push后自动登录服务器，切换到项目目录进行git push 1234567891011121314151617181920#!/usr/bin/expect set timeout 30spawn ssh -l ubuntu 118.xxx.xx.xxxexpect \"password:\"send \"密码\\r\"#interact#https://blog.csdn.net/houmou/article/details/53102051expect \"Last login:\" #send \"pwd\\r\"send \"cd 项目目录\\r\"#expect \"项目目录\"send \"git pull\\r\"send \"pwd\\r\"send \"exit\\r\"expect eof% 但每次换电脑，需要将公钥上传服务器； 再加上项目目录也有改变。 这两种场景下均需要去修改脚本。 有没有更好的方式呢？ 当探测到有新的push，服务器主动去pull代码？ （其实未必比上面通过脚本的方式好…此处只为试一下webhook这个功能） github提供了这样的hooks。我提供一个接口，每当有push事件时，这个hooks会去请求所提供的接口。 该接口收到请求，执行方法（切换到项目目录，执行git pull） 提供一个接口，代码如下： 12 另外： 如果用gitee， 还可以集成进钉钉/企业微信/飞书/slack, 无需自己提供接口 以飞书为例， 当有事件发生时， 参考： 配置git的webhook 什么是 Webhook？ 钩子(hooks)—webhook-使用钩子自动触发部署 gitee-WebHook 推送数据格式说明 Gitee WebHook 文档","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"go-echarts: an adorable charts library for Golang","date":"2017-08-09T16:19:06.000Z","path":"2017/08/10/go-echarts-an-adorable-charts-library-for-Golang/","text":"电脑&amp;大脑里存有许些数据，零散又不够直观。一直想找趁手好用的工具，将其承载，能实时更新，可高度定制。 早些年用过ECharts，但受限于不算太高的JS水平，迟迟悬于楼阁不敢下手。 直至发现go-echarts这个简易强大的package。探索过程中，学到了许多不太熟悉的图表类型，如“水球图”，“桑基图”“主题河流图”等。 准备将各国/各省份/各城市/县域 的历年GDP&amp;人口，所关注的公司市值，个人旅途行迹等逐步呈现。 官方文档 可预览并请提供宝贵建议 http://chart.dashen.tech/gallery-of-shuang 探索过程记录&amp;服务器部署","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"前端","slug":"前端","permalink":"http://www.dashen.tech/tags/前端/"}]},{"title":"ok判别式","date":"2017-07-31T14:47:52.000Z","path":"2017/07/31/ok判别式/","text":"类似 123if _, ok := map[key]; ok &#123;//存在&#125; 这样的编译器简化后的判断代码(实际应该是一种语法糖),在Go中非常常用. 一般称为称 “ok判别式”,但其实这个变量的名称可以随意取,不一定是”ok” 检测map中是否存在某个key 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; isVip := make(map[string]bool) isVip[\"张三\"] = true isVip[\"李四\"] = false if val, ok := isVip[\"王五\"]; ok &#123; fmt.Printf(\"王五是否为vip:%t\\n\", val) &#125; else &#123; fmt.Println(\"王五不是注册用户\") &#125; if val, ok := isVip[\"李四\"]; ok &#123; fmt.Printf(\"李四是否为vip:%t\\n\", val) &#125; else &#123; fmt.Println(\"李四不是注册用户\") &#125;&#125; 输出为: 12王五不是注册用户李四是否为vip:false 类型断言:检测一个接口类型的变量i,是否包含了类型T 12345if value, ok := i.(T); ok &#123; fmt.Println(value)&#125; else&#123; // 接口类型i没有包含类型T&#125; 更多可参见: Golang类型断言 检测一个通道是否关闭 更确切说,实际是检测一个通道还能否继续读取. 即对于有缓存的通道ch,在close(ch)之后,如果还有未读取出的变量,ok判别式的值为true. 即改为: 检测一个通道能否继续读取更为合适 检测是否还能从通道中读取出传递的值 可参考: golang之channel入门 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"func main() &#123; ch := make(chan int, 2) fmt.Println(ch) ch &lt;- 271828 fmt.Println(&lt;-ch) //这样也相当于进行了读取,channel里的缓存空间又会增加1个单位 ch &lt;- 271828 //#1 ch &lt;- 271828 //#2 //channel&lt;-271828 //如果继续写入,超过缓存值2,则会报fatal error: all goroutines are asleep - deadlock! close(ch) //关闭之后尝试进行读取 //channel关闭之后，仍然可以从channel中读取剩余的数据，直到数据全部读取完成。 //读取完后继续读,得到的将是对应类型的零值. if val, ok := &lt;-ch; ok &#123; fmt.Println(\"值为:\", val) &#125; else &#123; fmt.Println(\"通道已被关闭,无法再进行读取\") &#125;&#125; 输出为i:1230xc00009a000271828值为: 271828 而如果将两行写缓存的代码注释掉,即注释掉#1和#2,则输出结果为: 1230xc000090000271828通道已被关闭,无法再进行读取 即如果还能读出缓存的值,即便通道已经被关闭,ok的值依然会是true 参考: golang中逗号ok模式_转 Go语言那些返回值数量变化的语句？","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Golang类型断言","date":"2017-07-26T15:30:30.000Z","path":"2017/07/26/Golang类型断言/","text":"系列文章： golang实现多态 golang利用组合实现继承,和php或java面向对象的继承有何不同 Golang类型断言 golang之interface入门 interface,鸭子类型与泛型 所谓 类型断言(type assertion): cannot convert a (type interface{}) to type string: need type assertion 直接转换 如果明确知道a的类型,可以直接转换: 123456789101112131415package mainimport \"fmt\"func main() &#123; var i interface&#123;&#125; i = \"cuishuang\" f(i)&#125;func f(a interface&#123;&#125;) string &#123; fmt.Println(a) return a.(string)&#125; 则编译通过. 格式为 a.(对应的类型) 但如果”()”里面的类型不对,则会直接panic 123456789101112131415package mainimport \"fmt\"func main() &#123; var i interface&#123;&#125; i = \"cuishuang\" f(i)&#125;func f(a interface&#123;&#125;) string &#123; fmt.Println(a.(int)) return \"\"&#125; 输出为: 123panic: interface conversion: interface &#123;&#125; is string, not intgoroutine 1 [running]: OK判别式 在断言时进行判断: 如果断言失败,那么ok的值将会是false. 如果断言成功, ok的值将会是true, 同时value就是所期待的正确的值 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; var i interface&#123;&#125; i = \"cuishuang\" f(i)&#125;func f(a interface&#123;&#125;) string &#123; value,ok := a.(int) if ok &#123; fmt.Println(a.(int)) //a.(int) 即 value fmt.Println(value) &#125; else &#123; fmt.Println(\"i中不是int类型\") &#125; return \"\"&#125; 输出为: 1i中不是int类型 配合switch语句进行判断 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"func main() &#123; var i interface&#123;&#125; i = \"cuishuang\" f(i)&#125;func f(a interface&#123;&#125;) string &#123; switch val := a.(type) &#123; default: fmt.Printf(\"unexpected type %T\", val) // %T prints whatever type t has break case bool: fmt.Printf(\"boolean: %t\\n\", val) // t has type bool break case int: fmt.Printf(\"integer: %d\\n\", val) // t has type int break case string: fmt.Printf(\"string: %s\\n\", val) // t has type string break case *bool: fmt.Printf(\"pointer to boolean: %t\\n\", *val) // t has type *bool break case *int: fmt.Printf(\"pointer to integer: %d\\n\", *val) // t has type *int case *string: fmt.Printf(\"pointer to string: %s\\n\", *val) // t has type *string break &#125; return \"\"&#125; 输出为: 1string: cuishuang 参考: 深入Go语言 - 6 golang类型断言的使用（Type Assertion）","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"sync包-Waitgroup实现原理","date":"2017-07-25T10:27:29.000Z","path":"2017/07/25/sync包-Waitgroup实现原理/","text":"初入门径 可以等待一组 Goroutine 的返回，一个比较常见的使用场景是批量发出 RPC 或者 HTTP 请求. sync.WaitGroup实现很简单，只有100多行的代码; 底层使用计数器和信号量来实现同步。 123456789101112131415Semaphoren. 信号标; 旗语;v. 打旗语; (用其他类似的信号系统) 发信号;[例句]The definition of a shared memory and process shared data structure and built-in semaphore support.有一个共享的内存定义和进程共享数据结构和内置的信号量的支持。acquire v. 获得; 购得; 获得; 得到;release v. 释放; 放出; 放走; 放开; 松开; 发泄; 宣泄; 如 php中的sem_acquire函数 参考: sync.WaitGroup实现原理详解 Golang的sync.WaitGroup 实现逻辑和源码解析 golang sync.WaitGroup 底层实现 &gt;&gt;&gt; 源码实现 sync.WaitGroup对外暴露了三个方法 — sync.WaitGroup.Add、sync.WaitGroup.Wait 和 sync.WaitGroup.Done 1234567891011121314151617181920212223// A WaitGroup waits for a collection of goroutines to finish.// The main goroutine calls Add to set the number of// goroutines to wait for. Then each of the goroutines// runs and calls Done when finished. At the same time,// Wait can be used to block until all goroutines have finished.//// A WaitGroup must not be copied after first use.// WaitGroup等待goroutine的集合完成。主goroutine调用Add来设置等待的goroutines。 然后每goroutines运行并在完成后调用完成。 同时，等待可用于阻塞，直到所有goroutine完成。//首次使用后不得复制WaitGroup。type WaitGroup struct &#123; noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema. // 64位值：高32位为计数器，低32位为waiter计数。 64位原子操作需要64位对齐，但是32位编译器不能确保对齐。 因此，我们分配12个字节，然后将对齐的8个字节用作状态，并将其他4个用作存储信号。 state1 [3]uint32&#125; noCopy — 保证 sync.WaitGroup 不会被开发者通过再赋值的方式拷贝； state1 — 存储着状态和信号量； 源码地址 123456789// state returns pointers to the state and sema fields stored within wg.state1.// state返回指向存储在wg.state1中的state和sema字段的指针。func (wg *WaitGroup) state() (statep *uint64, semap *uint32) &#123; if uintptr(unsafe.Pointer(&amp;wg.state1))%8 == 0 &#123; return (*uint64)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[2] &#125; else &#123; return (*uint64)(unsafe.Pointer(&amp;wg.state1[1])), &amp;wg.state1[0] &#125;&#125; sync.WaitGroup.Add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Add adds delta, which may be negative, to the WaitGroup counter.// If the counter becomes zero, all goroutines blocked on Wait are released.// If the counter goes negative, Add panics.//// Note that calls with a positive delta that occur when the counter is zero// must happen before a Wait. Calls with a negative delta, or calls with a// positive delta that start when the counter is greater than zero, may happen// at any time.// Typically this means the calls to Add should execute before the statement// creating the goroutine or other event to be waited for.// If a WaitGroup is reused to wait for several independent sets of events,// new Add calls must happen after all previous Wait calls have returned.// See the WaitGroup example.// Add将增量（可能为负）添加到WaitGroup计数器中。//如果计数器变为零，则释放处于等待阻塞状态的所有goroutine。//如果计数器变为负数，则抛出panic。//// 请注意，当计数器为零时发生的增量为正的调用必须在等待之前发生。 在计数器大于零时开始的负增量呼叫或正增量呼叫可能随时发生。// 通常，这意味着对Add的调用应在创建goroutine或要等待的其他事件的语句之前执行。// 如果重新使用WaitGroup来等待几个独立的事件集，则必须在所有先前的Wait调用返回之后再进行新的Add调用。// 请参见WaitGroup示例。func (wg *WaitGroup) Add(delta int) &#123; statep, semap := wg.state() if race.Enabled &#123; _ = *statep // trigger nil deref early if delta &lt; 0 &#123; // Synchronize decrements with Wait. //和Wait同步减少量 race.ReleaseMerge(unsafe.Pointer(wg)) &#125; race.Disable() defer race.Enable() &#125; state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) v := int32(state &gt;&gt; 32) w := uint32(state) if race.Enabled &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) &#123; // The first increment must be synchronized with Wait. // Need to model this as a read, because there can be // several concurrent wg.counter transitions from 0. //第一个增量必须与Wait同步。 //需要将此模型建模为读取，因为从0开始可能会有多个并发的wg.counter转换。 race.Read(unsafe.Pointer(semap)) &#125; //sync.WaitGroup.Add 方法可以更新 sync.WaitGroup 中的计数器 counter。 //sync.WaitGroup.Add 方法传入的参数可以为负数，但是计数器只能是非负数，一旦出现负数就会发生程序崩溃 if v &lt; 0 &#123; panic(\"sync: negative WaitGroup counter\") &#125; if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) &#123; //WaitGroup滥用：Add与Wait被并发调用 panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") &#125; if v &gt; 0 || w == 0 &#123; return &#125; // This goroutine has set counter to 0 when waiters &gt; 0. // Now there can't be concurrent mutations of state: // - Adds must not happen concurrently with Wait, // - Wait does not increment waiters if it sees counter == 0. // Still do a cheap sanity check to detect WaitGroup misuse. //当waiters&gt;0时，此goroutine已将计数器设置为0。 //现在不可能有并发的状态突变： // -添加不得与等待同时进行， // -Wait看到counter == 0时，Wait不会增加waiters的数量。 //仍然进行了一次廉价且高效的检查以检测防止WaitGroup的滥用。 if *statep != state &#123; panic(\"sync: WaitGroup misuse: Add called concurrently with Wait\") &#125; // Reset waiters count to 0. // 重置waiters的数量为0 //当调用计数器归零，也就是所有任务都执行完成时，就会通过 sync.runtime_Semrelease 唤醒处于等待状态的所有 Goroutine。 *statep = 0 for ; w != 0; w-- &#123; runtime_Semrelease(semap, false, 0) //release 释放,宣泄 &#125;&#125; sync.WaitGroup.Done sync.WaitGroup.Done 只是向 sync.WaitGroup.Add 方法传入了 -1 1234// Done decrements the WaitGroup counter by one.func (wg *WaitGroup) Done() &#123; wg.Add(-1)&#125; sync.WaitGroup.Wait sync.WaitGroup 的另一个方法 sync.WaitGroup.Wait 会在计数器大于 0 并且不存在等待的 Goroutine 时，调用 sync.runtime_Semacquire 陷入睡眠状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Wait blocks until the WaitGroup counter is zero.func (wg *WaitGroup) Wait() &#123; statep, semap := wg.state() if race.Enabled &#123; _ = *statep // trigger nil deref early race.Disable() &#125; for &#123; state := atomic.LoadUint64(statep) v := int32(state &gt;&gt; 32) w := uint32(state) if v == 0 &#123; // Counter is 0, no need to wait. if race.Enabled &#123; race.Enable() race.Acquire(unsafe.Pointer(wg)) &#125; return &#125; // Increment waiters count. if atomic.CompareAndSwapUint64(statep, state, state+1) &#123; if race.Enabled &amp;&amp; w == 0 &#123; // Wait must be synchronized with the first Add. // Need to model this is as a write to race with the read in Add. // As a consequence, can do the write only for the first waiter, // otherwise concurrent Waits will race with each other. //Wait必须与第一个Add同步。 //需要将此建模为与Add中的读取竞争的写入。 //因此，只能为第一个waiter执行写操作，否则并发的Waits将相互竞争。 race.Write(unsafe.Pointer(semap)) &#125; runtime_Semacquire(semap) //acquire 获取,获得 if *statep != 0 &#123; panic(\"sync: WaitGroup is reused before previous Wait has returned\") &#125; if race.Enabled &#123; race.Enable() race.Acquire(unsafe.Pointer(wg)) &#125; return &#125; &#125;&#125; 当 sync.WaitGroup 的计数器归零时，当陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。 注意事项 sync.WaitGroup 必须在 sync.WaitGroup.Wait 方法返回之后才能被重新使用； sync.WaitGroup.Done 只是对 sync.WaitGroup.Add 方法的简单封装，我们可以向 sync.WaitGroup.Add 方法传入任意负数（需要保证计数器非负）快速将计数器归零以唤醒其他等待的 Goroutine； 可以同时有多个 Goroutine 等待当前 sync.WaitGroup 计数器的归零，这些 Goroutine 会被同时唤醒； 参考: 图解Go里面的WaitGroup了解编程语言核心实现源码 同步原语与锁","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"事务的四种隔离级别","date":"2017-07-21T10:02:22.000Z","path":"2017/07/21/事务的四种隔离级别/","text":"关于ACID中的I即隔离性（Isolation）,配合姊妹篇事务的四大基本要素(即ACID原则)效果更佳 亲测体验关系型数据库事务的隔离级别,演示了mysql默认隔离级别可重复读情形下, 幻读的情况 这篇文章讲解十分清晰 例子很赞 从上到下,隔离级别逐渐增强 第一级隔离级别: 未提交读: Read uncommitted 另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）( 隔离级别最低，并发性能高 ) 事务A用来修改某条记录,事务B包含查询该记录的操作; (如A是修改余额,B是查询当前余额,进行判断,如果大于某个值,则再进行查询,将结果写入另外的一张日志表) 当事务A修改记录但还未执行,事务B执行读取到了事务A修改后的记录; 这就是 脏读(Dirty Read): 当前事务读到的数据, 是别的事务想要修改但没有修改成功的数据 亲测体验: 参考 查看全局的事务隔离级别: show global variables like &#39;%tx_isolation%&#39;; (查看当前session的事务隔离级别: show session variables like &#39;%tx_isolation%&#39;; 在此不用 ) 设置全局的事务隔离级别 set global isolation level 四种隔离级别之一; 即其全集为: 1234set global transaction isolation level READ UNCOMMITTED;set global transaction isolation level READ COMMITTED;set global transaction isolation level REPEATABLE READ;set global transaction isolation level SERIALIZABLE; 在此将全局的隔离级别,由mysql默认的REPEATABLE READ修改为READ UNCOMMITTED 123set global transaction isolation level READ COMMITTED;show global variables like '%tx_isolation%'; 注意: 执行命令后,并不会对当前session(窗口)生效。 当前表的内容为: 新开两个窗口,模拟两个事务: 123456789set global transaction isolation level READ UNCOMMITTED;show global variables like '%tx_isolation%';set autocommit = 0;start transaction;insert into historical_figure (`sex`,`name`,`is_beauty`) values (\"男\",\"范蠡\",\"0\") 12345678910set global transaction isolation level READ UNCOMMITTED;show global variables like '%tx_isolation%';-- begin;select * from historical_figure;-- commit; 此时表为:(等同于事务2的select * 操作,读到了一条可能并没有成功提交的”脏数据”) 将事务1关闭,则变为: ( 如果事务1执行的是update操作 关闭事务1后,依然被未提交的事务1进行了修改..可以只以insert为例记忆即可 ) 第二级隔离级别: 已提交读: Read committed (绝大多数数据库,包括Sql Server/Oracle的默认隔离级别) 将上例中的全局隔离级别改为READ COMMITTED,重复之前操作,发现在已提交读隔离级别下,脏读现象被杜绝 1234567891011set global transaction isolation level READ COMMITTED;show global variables like '%tx_isolation%';set autocommit = 0;start transaction;insert into historical_figure (`sex`,`name`,`is_beauty`) values (\"女\",\"赵飞燕\",\"1\");-- commit 12345678910set global transaction isolation level READ COMMITTED;show global variables like '%tx_isolation%';-- begin;select * from historical_figure;-- commit; 但会出现不可重复读的问题: 在事务1里，前后两次相同的SELECT会读到不同的结果（即不重复读）,因为有一个干扰事务2,在事务2提交前和提交后,事务1得到的两次查询结果是不同的。 事务B要等事务A提交后才能读取数据,这样就能解决上面的脏读问题,但引入了新的问题: 事务B执行,查询出该条记录(第一次),进行判断,符合条件;这时事务A执行,修改(扣减)余额,这个过程中B想再次查询该记录(第二次),必须等A执行完才能再读;等A执行结束B再去读取时,发现查出来的数据与第一次竟然不同 “这就是已提交读,若有事务对数据进行更新（UPDATE）操作时,读操作事务要等待这个更新操作事务提交后才能读取数据,这样可以解决脏读问题; 但却可能出现”一个事务范围内“的两次相同的查询却返回了不同数据,这带来了新问题,也就是 不可重复读(NonRepeatable Read): 考虑如下情况: 此时查到的数据为6条. 但当insert的事务 commit后,查到了7条数据! 即同一个事务,两次查询得到的结果不一致. 第三级隔离级别: 可重复读: Repeatable read (MySql的默认隔离级别) 将上例中的全局隔离级别改为REPEATABLE READ;,重复之前操作,发现在可重复读隔离级别下,不可重复读现象被杜绝 提交有insert的事务后,发现查询事务得到的结果,和insert事务提交之前结果一致. 在”查询事务”未commit前,不管”insert事务”是否提交,得到的内容都是一致的,不管执行几次查询,结果都是最开始查询的结果. 当”查询事务”提交后,再次查询,才得到insert之后最新的数据.. 但会出现幻读的问题: 在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。 可重复读,即在开始读取数据（事务开启）时,不再允许修改(update)操作; 即事务B开启后,不允许其他事务(此处即A)的UPDATE操作; 可重复读可以解决不可重复读问题; “不可重复读对应的是修改，即update操作。但是可能还会有幻读问题。 因为幻读问题对应的是插入insert操作(或删除操作)，而非update操作。“ **解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表** 幻读(Phantom Read): 事务A第一次查询取到的数据,比后来读取到数据条目少或者增加,仅针对数据的删与增 如事务1先查询id=5的数据有没有,如果没有,进行insert操作,但是没有commit; 这时有一个(干扰)事务2,insert了id=5的数据,且进行了提交; 而后,事务1进行提交,却发现报错,说id=5的key重复了…事务1就以为出现了”幻觉”:不对啊,我明明查询过,查询id=5返回的是空啊.. 该隔离级别下,会有幻读现象的发生,参见亲测体验关系型数据库事务的隔离级别,有详尽实例及解述 第四级隔离级别: 串行化: Serializable 读操作会隐式获取共享锁，可以保证不同事务间的互斥（锁表) 在开始读取数据（事务开启）时,不再允许修改(update)操作,但还可以进行insert和delete操作; 假设事务C需要扫描全表,进行判断,将其中符合条件的写入另外一张表; 开启事务,第一次查询时,扫到全表有100条记录;这时恰巧有一个insert操作,新插入了一条数据,该次事务C执行到第二次查询时,发现成了101条记录,似乎出现了幻觉,这就是幻读; Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。 参考亲测体验关系型数据库事务的隔离级别该文中构造的幻读实例,当将隔离级别改为SERIALIZABLE时,将杜绝幻读现象的存在,但一般为效率起见,很少用此隔离级别,在此不做演示","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"事务的四大基本要素(即ACID原则)","date":"2017-07-20T13:24:16.000Z","path":"2017/07/20/事务的四大基本要素-即ACID原则/","text":"配合姊妹篇事物的四种隔离级别效果更佳 基础 1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 指一个事务要么全部执行，要么完全不执行。 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。 事务在开始和结束时，应该始终满足一致性约束。如系统要求A+B=100,那么事务如果改变了A的数值，则B的数值也要相应修改来满足这样一致性要求；与CAP中的C代表的含义是不同的。 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 (也称独立性) &nbsp;&nbsp;如果有多个事务同时执行，彼此之间不需要知晓对方的存在，而且执行时互不影响，事务之间需要序列化执行，有时间顺序。 要求的隔离性是一种严格意义上的隔离，也就是多个事务是串行执行的，彼此之间不会受到任何干扰。这确实能够完全保证数据的安全性，但在实际业务系统中，这种方式性能不高。因此，数据库定义了四种隔离级别，隔离级别和数据库的性能是呈反比的，隔离级别越低，数据库性能越高，而隔离级别越高，数据库性能越差。 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务运行成功以后，对系统状态的更新是永久的，不会无缘无故回滚撤销。 参考1–CAP与ACID原则 参考2–MySQL的四种事务隔离级别 进阶1–实现 事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。 UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。和UndoLog相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。` 进阶2–分布式事务 参考1-再有人问你分布式事务，把这篇扔给他 参考2-常用的分布式事务解决方案","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"CAP原则(也称CAP定理)","date":"2017-07-17T13:26:24.000Z","path":"2017/07/17/CAP原则-也称CAP定理/","text":"相关内容参考此文,版权归原作者所有,转载请注明出处 由UC Berkeley的Eric Brewer教授提出(故CAP定理(CAP theorem)又被称作布鲁尔定理(Brewer&#39;s theorem)),MIT的Seth Gilbert和Nancy Lynch从理论上予以证明.CAP理论已成为分布式计算领域的公认定理。 CAP理论1.一致性（Consistency）：每次读操作都能保证返回的是最新数据； 2.可用性（Availability）：任何一个没有发生故障的节点，会在合理的时间内返回一个正常的结果； 3.分区容忍性（Partition-torlerance）：当节点间出现网络分区，照样可以提供服务。 CAP理论指出：CAP三者只能取其二，不可兼得 类似钱多或少离家近,可以满足其二,但三者都满足理论上很难.就看如何取舍~ 单机都只能保证CP, etcd满足了CP,牺牲了高可用性 Consistency 一致性 通常通过Raft或Paxos算法实现; Paxos协议是第一个被证明的一致性算法，但Paxos的论文非常晦涩难懂，导致基于Paxos的工程实践和教学都十分头疼; 于是Raft在设计的过程中，就从可理解性出发，使用算法分解和减少状态等手段，目前已经应用非常广泛. Availability 可用性 Partition Tolerance分区容错性 微服务中必须要具备Partition Tolerance即分区容错性,否则没什么意义,故而,依据CAP理论，必须在可用性（availability）和一致性（consistency）之间做出选择。 落地实践中，可用性一般是更好的选择，但是在服务和数据库之间维护数据一致性是非常根本的需求，微服务架构中应选择满足最终一致性。 ACID中的”C”(Consistency),和CAP中的”C”(Consistency)的区别理解数据库的事务，ACID，CAP和一致性 更多参考: 从Paxos不违反CAP来解释什么是CAP定理 浅谈分布式数据库中的事务 阮一峰-CAP 定理的含义","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"递归的缺点--以斐波那契数列为例","date":"2017-07-11T15:36:01.000Z","path":"2017/07/11/递归的缺点-以斐波那契数列为例/","text":"递归可以大大简化代码,但可能会出现大量重复计算,拖累程序的效率. 以斐波那契数列为例,探寻 递归/非递归算法两者的时间和空间差距 递归写法 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"time\")const N = 40func main() &#123; start := time.Now() var sli []int64 for i := 1; i &lt;= N; i++ &#123; sli = append(sli, fibonacci(i)) &#125; fmt.Printf(\"%d位的斐波那契数列为:%v\\n\", N, sli) fmt.Println(\"用时:\", time.Since(start))&#125;func fibonacci(n int) (res int64) &#123; if n &lt;= 2 &#123; res = 1 &#125; else &#123; res = fibonacci(n-1) + fibonacci(n-2) &#125; return&#125; 当N=40时,输出为: 1240位的斐波那契数列为:[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155]用时: 968.053722ms 当N改为50时,耗时将陡然增多至2分钟. 12350位的斐波那契数列为:[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025]50用时: 1m59.794771009s 非递归写法 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"time\")const N2 = 40func main() &#123; start := time.Now() var sli []int64 for i := 1; i &lt;= N2; i++ &#123; sli = append(sli, fibonacci2(i)) &#125; fmt.Printf(\"%d位的斐波那契数列为:%v\\n\", N2, sli) fmt.Println(\"用时:\", time.Since(start))&#125;func fibonacci2(n int) (res int64) &#123; var a, b int64 = 0, 1 for i := 0; i &lt; n; i++ &#123; a, b = b, a+b &#125; return a&#125; N2=40时,输出为: 1240位的斐波那契数列为:[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155]用时: 79.884µs 当N改为50时,结果为: 1250位的斐波那契数列为:[1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025]用时: 89.938µs 可见,差距相当相当明显! 当然,对于斐波那契数列,其非递归写法也非常简单,但对于更多情况下,非递归实现要比递归写法复杂很多.","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Tomcat各文件介绍","date":"2017-07-02T15:41:16.000Z","path":"2017/07/02/Tomcat各文件介绍/","text":"webapps目录用于存放项目war包或文件夹(不一定要把项目非放在webapps下面,放在其他位置,在server.xml配置文件里配置一个映射也可以~) ROOT文件夹下的这些东西,可以通过ip+端口直接访问,不需要加项目名~ conf目录存放配置文件 work目录存放tomcat在运行时编译后的文件,清空这个目录,再重启服务器,可以达到清空服务器缓存的效果~ temp文件夹用于存放运行过程中的临时文件,删掉没有任何影响","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"CAS机制","date":"2017-07-01T15:45:17.000Z","path":"2017/07/01/CAS机制/","text":"CAS的其他异义项 CAS除去计算机里的Compare and Swap，即比较再交换 外, 还有几个有意思的异义项。 Chinese Academy of Science，中国科学院。中国自然科学领域等级最高的机构。 Central Authentication Service，中央认证服务，耶鲁大学发起的一个开源项目，旨在为web应用提供一种可靠的单点登录方式。 Count of Arbitration for Sports，国际体育仲裁法庭。最近这个词频上新闻。 Chemical Abstracts Service，美国化学会给出现在文献中的物质分配的一个唯一编号，用以避免同一物质有多种名称，使检索更加方便。 计算机中的CAS 比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。 其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是原子性的操作(读和写两者同时具有原子性)，其实现方式是通过借助C/C++调用CPU指令完成的，所以效率很高 CAS 和 Synchronized CAS和Synchronized(Java中的关键字)分别属于乐观锁和悲观锁 CAS乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。（每次不加锁，而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败重试，直到成功为止。CAS机制是(线程)乐观锁的一种，可以理解成一个无阻塞多线程争抢资源的模型） Synchronized悲观地认为程序中的并发情况严重，所以严防死守。（使用Synchronized的线程一旦得到锁，其他需要锁的线程就挂起，等待持有锁的线程释放锁（思考：类似于mysql的共享锁还是独占锁/排它锁？）。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点） （Java中也有unsafe） Java中的sychronized类似Go的sync.Mutex，可以对一段代码加锁，以保证其并发安全性。但这样来实现并发安全并不高效，某些场景下可以使用原子操作类(java.util.concurrent.atomic，Go的sync.Atomic)来轻量级解决该问题可参考：Mutex vs Atomic CAS的原理 CAS 操作包含三个操作数 ---内存地址（V）、旧的预期值（A）和即将要更新的新值(B)。 执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作： CAS的缺点： 1.CPU开销较大 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。 2.不能保证代码块的原子性 CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。 3.ABA问题 这是CAS机制最大的问题所在。 什么是ABA问题？怎么解决？并发编程中的ABA问题 图片来自 CAS机制是什么鬼？ 更多参考： 漫画：什么是 CAS 机制？ 漫画：什么是CAS机制？（进阶篇） CAS原理 一文彻底搞懂CAS实现原理 简析CAS机制与实现原理","tags":[{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"设计模式","date":"2017-06-30T15:27:46.000Z","path":"2017/06/30/设计模式/","text":"https://www.cnblogs.com/java-my-life/ 工厂模式单例模式观察者模式策略模式模板模式","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"数据库设计三大范式","date":"2017-06-30T10:13:01.000Z","path":"2017/06/30/数据库设计三大范式/","text":"1．第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库 表中的所有字段值都是不可分解的原子值，则说明该数据库 表满足了第一范式。 2．第二范式(确保表中的每列都和主键相关) 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 3．第三范式(确保每列都和主键列直接相关,而不是间接相关) 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 简单来说 三大范式：第一范式就是说每个列就是是一个不可拆分的词语，若还可以再细分，便不符合第一范式。第二范式就是告诉人们在建表的时候要确立主键，方便查找。第三范式就是说如果一张表可以拆分要继续拆分。 数据库的三大范式 1.第二范式与第三范式的本质区别：在于有没有分出两张表 第二范式是说一张表中包含了多种不同实体的属性，那么必须要分成多张表，第三范式是要求已经分好了多张表的话，一张表中只能有另一张表的ID，而不能有其他任何信息，（其他任何信息，一律用主键在另一张表中查询） 2.必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Java的IO模型","date":"2017-06-29T15:26:04.000Z","path":"2017/06/29/Java的IO模型/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"TCP和UDP的区别","date":"2017-06-28T15:16:43.000Z","path":"2017/06/28/TCP和UDP的区别/","text":"udp没有握手,重传.拥塞等,是个无状态的,所以特别快,且安全,但是被攻击如洪水攻击也是不可避免买的….不可靠,不稳定","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"泛型","date":"2017-06-26T15:05:01.000Z","path":"2017/06/26/泛型/","text":"java是伪泛型,因为运行时会擦除掉.. 运行时多态 泛型和其他特性一样不是只有好处，为编程语言加入泛型会遇到需要权衡的两难问题。语言的设计者需要在编程效率、编译速度和运行速度三者进行权衡和选择，编程语言要选择牺牲一个而保留另外两个。 为什么 Go 语言没有泛型","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"Hashmap","date":"2017-06-25T15:02:26.000Z","path":"2017/06/25/Hashmap/","text":"解决哈希冲突,之前用的是链表法…新版本引入了红黑树… Hashmap的负载因子为0.75,Golang中的map,负载因子为6.5/8=0.8125 就一个HashMap，居然能跟面试官扯上半个小时？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"Java集合类: Set、List、Map、Queue使用场景梳理","date":"2017-06-24T15:01:01.000Z","path":"2017/06/24/Java集合类-Set、List、Map、Queue使用场景梳理/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"}]},{"title":"golang中new()和make()的区别","date":"2017-06-18T03:18:56.000Z","path":"2017/06/18/golang中new-和make-的区别/","text":"make 只适用于3种内建的引用类型：切片、map 和 channel。make(T) 返回一个类型为 T 的初始值，不是指针 new(T) 返回类型为*T; 即new(某个结构体),得到的结果是该结构体的指针; new 适用于值类型,如数组和结构体；new(T)相当于&amp;T{} new一般不常用,而用&amp;T{}代替 小问题: 如下输出为true还是false?123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; type LogParamter struct &#123; //name string &#125; p1 := LogParamter&#123;&#125; p2 := &amp;LogParamter&#123;&#125; p3 := new(LogParamter) fmt.Println(p1) fmt.Printf(\"%p\\n\", p2) fmt.Printf(\"%p\\n\", p3) fmt.Println(p2 == p3)&#125; 当LogParamter为空结构体时,输出为: 1234&#123;&#125;0x1196a780x1196a78true 当LogParamter为 123type LogParamter struct &#123; name string &#125; 时,输出为: 1234&#123;&#125;0xc0000661e00xc0000661f0false 如果不比较指针而直接比较值, 若LogParamter中某个字段的类型不能判等,即如: 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; type LogParamter struct &#123; //name string info map[string]string &#125; p1 := LogParamter&#123;&#125; // p2 := &amp;LogParamter&#123;&#125; // p3 := new(LogParamter) // fmt.Println(p1) // fmt.Printf(\"%p\\n\", p2) // fmt.Printf(\"%p\\n\", p3) // fmt.Println(p2 == p3) p4 := LogParamter&#123;&#125; fmt.Println(p1 == p4) //Invalid operation: p1 == p4 (operator == not defined on LogParamter)&#125; 则直接编译不通过 只有在结构体的所有字段类型全部支持判等时，才可做(值)判断操作","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"redis概念小结","date":"2017-06-17T12:32:06.000Z","path":"2017/06/17/redis概念小结/","text":"Redis持久化的几种方式 Redis 支持持久化, 是 Redis 和 Memcached 的主要区别之一，因为 Memcached 是不具备持久化功能的。 Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。 (其实还有一种被弃用的虚拟内存方式以及替代这种方式的diskstore方式; 4.0之后还引入了一种混合持久化方式. 但目前用使用中主要还是RDB和AOF两种方式) 快照方式（RDB, Redis DataBase）将某一个时刻的内存数据，以二进制的方式写入磁盘；RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。 1）RDB 优点 RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件； 采用该方式, 整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的; RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复； 性能最大化. RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作； 与 AOF 格式的文件相比，尤其当数据集很大时, RDB 文件可以更快的重启。 2）RDB 缺点 因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据； 如果想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。 RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，可能导致 Redis 停止为客户端服务几百毫秒甚至一秒钟。 AOF (Append-only file）以日志形式记录每一个写操作;1）AOF 优点 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的, 但数据安全性最高 。 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。 AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。 2）AOF 缺点 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。 Redis内存淘汰策略 长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，内存数据就会与磁盘产生频繁交换，使Redis性能急剧下降。此时如何淘汰无用数据释放空间，存储新数据就变得尤为重要了。redis采用配置参数maxmemory 的方式来限制内存大小. 当实际存储内存超出maxmemory 参数值时, 可以通过这几种淘汰策略,选出无用的key进行淘汰. 当前支持的淘汰策略有6种:123456volatile 英[ˈvɒlətaɪl]美[ˈvɑːlətl]adj. 易变的; 无定性的; 无常性的; 可能急剧波动的; 不稳定的; 易恶化的; 易挥发的; 易发散的;There have been riots before and the situation is volatile以前曾发生过暴乱，现在局势不太稳定。 volatile-lru：从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。 volatile-ttl：除了淘汰机制采用TTL，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。 allkeys-random：从数据集(server.db[i].dict）中选择任意数据淘汰。 no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。 一些使用: 在Redis中，数据有一部分访问频率较高，其余部分访问频率较低，或者无法预测数据的使用频率时，设置allkeys-lru是比较合适的。 如果所有数据访问概率大致相等时，可以选择allkeys-random。 如果开发者需要通过设置不同的ttl来判断数据过期的先后顺序，此时可以选择volatile-ttl策略。 如果希望一些数据能长期被保存，而一些数据可以被淘汰掉时，选择volatile-lru或volatile-random都是比较不错的。 由于设置expire会消耗额外的内存，如果计划避免Redis内存在此项上的浪费，可以选用allkeys-lru 策略，这样就可以不再设置过期时间，高效利用内存了。 几种淘汰机制:LRU淘汰LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除。另外，从 struct redisObject 中可以发现，每一个 redis 对象都会设置相应的 lru。每一次访问数据，会更新对应redisObject.lru。 在Redis中，LRU算法是一个近似算法，默认情况下，Redis会随机挑选5个键，并从中选择一个最久未使用的key进行淘汰。在配置文件中，按maxmemory-samples选项进行配置，选项配置越大，消耗时间就越长，但结构也就越精准。 关于LRU算法,参见 LRU算法浅析 TTL淘汰Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl 最大的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。 随机淘汰在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。 参考: Redis内存淘汰策略 Redis缓存更新策略 定时删除 :在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除 惰性删除 :也叫懒汉式式删除, key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null 定期删除 :每隔一段时间执行一次删除过期key操作 ;上面两种一种占cpu,一种占内存,这种方案算是以上两种的折中方案 memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点） 在使用懒汉式删除+定期删除时, 控制时长和频率这个尤为关键, 需要结合服务器性能, 以及并发量等情况进行调整. 1是主动删除的, 实时执行, 对CPU不是很友好, 但在最大程度上释放了内存. 所以这种方式算是一种内存优先优化策略; 2、3为被动删除, 所以过期键不会被立马删除, 还会存在一定的时间, 仍然占用着内存. 但是惰性删除的时候一般是单个删除,相对来说对CPU是友好的. 而定期删除这种策略, 既有避免1、2两种策略劣势的可能, 也有同时发生1、2两种策略劣势的可能.. 如果定期删除执行得过于频繁就可能会演变成定时删除, 如果执行得过少, 就有可能造成过多过期键未被删除而占用过多内存, 如果时间的设置不是太好, 既可能占用过多内存,又同时对CPU较大负载.. 故而使用定期删除策略的时候, 一定要把握好删除的时间点. 参考: 了解Redis过期策略及实现原理 Redis如果过期，是根据什么策略来进行删除的 Redis五种数据结构12345String——字符串Hash——字典List——列表Set——集合Sorted Set——有序集合 String12345671.LEN cuishuang：O(1)获取字符串长度2.APPEND uishuang redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）3.设置和获取字符串的某一段内容4.设置及获取字符串的某一位（bit）5.批量设置一系列字符串的内容6.原子计数器7.GETSET 命令的妙用，请于清空旧值的同时设置一个新值，配合原子计数器使用 Hash存储、读取、修改用户属性 如将uid作为key, values中存放用户的nickname,phone,avatar,gender等信息 123Redis使用哈希表作为字典的底层实现，每个字典都有两个哈希表，一个平时使用，另一个仅在进行rehash时使用哈希表使用链表来解决键冲突问题，被分配到同一个索引上的多个键值对会连接成一个单向链表 ListList 说白了就是链表（redis 使用双端链表实现的 List）。使用 List 结构，我们可以轻松地实现最新消息排行等功能（比如新浪微博的 TimeLine ）。 List 的另一个应用就是消息队列，可以利用 List 的 *PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。Redis 还提供了操作 List 中某一段元素的 API，你可以直接查询，删除 List 中某一段的元素 Redis构建了自己的链表的实现，其特性如下： 123456789双端：链表节点提供有prev和next对象,获取某个节点的前置节点和下一个节点的速度为O(1).无环：表头节点prev对象和表尾节点next对象都指向NULL,链表的访问都是以NULL访问为终点.带有表头和表尾对象：通过list结构的head和tail，获取表头和表尾对象的速度为O(1).带有长度计数器：获取链表长度的直接读取len字段值.速度为O(1).多态：通过dup、free、match三个方法,实现链表的多态,保存不同类型的值 SetRedis 集合是 string 类型的无序集合。set 元素最大可以包含(2 的 32 次方)个元素。set 是通过 hash table 实现的，hash table 会随着添加或者删除自动的调整大小。调整 hash table 大小时候需要同步(获取写锁)会阻塞其他读写操作。 利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 1231.共同好友、二度好友2.利用唯一性，可以统计访问网站的所有独立 IP3.好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐 Zsetzset是set的一个升级版本，它在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。 可以对指定键的值进行排序权重的设定，它应用排名模块比较多。 比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务，让重要的任务优先执行。 zset集合可以完成有序执行、按照优先级执行的情况； 121.带有权重的元素，比如一个游戏的用户得分排行榜2.比较复杂的数据结构，一般用到的场景不算太多","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"一夔已足","date":"2017-06-11T13:12:02.000Z","path":"2017/06/11/一夔已足/","text":"去时只是水露濛濛，归程却逢暴雨乍至。我站在一公共自行车棚下，无聊地注视着周遭从淅淅沥沥到滂沱漫漶。雨天青草花树散发独特气息，像不展的芭蕉和丁香，点点上心。 昨晚独走钱塘江滨，璀璨的灯光，让我想起走过无数些次的苏州河，从北新泾到古北路桥段，那里幽雅安逸，静谧着绚烂。我在盛开着迎春花的木板路上跑过好多次，在临河的椅子上或坐或躺，抬头仰着飘荡在夜空中的层云与月光。眼下却不知再见是何年何月，竟一时伤从中来：我去国离乡一千五百里，来一外省省会，用最宝贵青春建设他乡，这般作何？ 如我家乡，无论琴岛泉城，有此间一半工作机会，民营经济有此1/3活跃，官本位能稍稍放低姿态，掌握着大小权力的人能再多与时俱进更具现代意识一些，那我马上订票返乡，让我的热血和激情挥洒在家乡土壤，即便ta现在贫瘠，如40年前南海边的小县宝安。 初来业务不熟，同事更还只是点头点赞之交。新的框架，从未写过的接口，急迫的任务，高负荷的工作时长，都让我感到不适。像猝不及防的临战，必然要遭受以逸待劳的对方几次蓄谋多时的攻击。渡过这段需持续一月的战略防守，换气缓神，国庆前后便可千里跃进大别山，而三大战役和渡江战役，可在不远的明年如期。又可闲庭信步，我将离开再转战新的战场，正是山花烂漫时，ta在丛中笑。最困难的自然是伊始这段艰难时光。 目视着这无尽头的雨丝，想来呆等终究不是办法。于是趁着见小，骑车再又上路。路途一远，短裤T恤也便湿透。雨又渐大，我也不再为意，径自悠哉悠哉骑着。待至网易路口，住处已在近旁，分分钟可到，不期后面一位骑电动车的50来岁大爷，减速要给我雨衣。我未及开口，他便说“正好多一套，看你…”，后面声音渐低吞吐未说，形同落汤鸡的我自是明白。随即把掖在后座上的一件雨衣交于我手，便要骑车离去。我只有几句“多谢”，目送其身影远去。 而这可能是我一年里唯一一次需要雨衣，过后如下雨我便撑伞步行上下班，我逼仄狭小的空间，实在不愿多这样一件留之无用弃之可惜的物件。但在冰冷的雨天，陌生的城市，当我从一个素味平生而又别无所图的生人手里接过来时，它分明带有温度。对这座一直有些抵触的城市刹那间好感倍增。 22年前，也是在这座车会让人的城市，看到路边“偷”井盖的三五彪形大汉，身形瘦弱籍籍无名的一位马姓青年骑车路过，厉声要求放回去，传为一段美谈。 有形物件终会损坏遗失，人或默默无闻或叱咤一时也都会烟消云落。希望这份温度，这种精神能够延续传承。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"华山别传","date":"2017-05-30T02:23:45.000Z","path":"2017/05/30/华山别传/","text":"当年第一次华山论剑，中神通技压四绝，夺得&lt;九阴真经&gt;，因这两卷经书，在终南山大殿、大理国皇宫和东海桃花岛，掀起许多风波。第二次论剑，武林后起之辈郭靖接过师傅北丐和岳父东邪300招，获许未来的天下第一，侠之大者视之如若浮云。襄阳大战后，众人前去华山拜谒故去的西毒北丐，并排新五绝，是为第三次华山论剑，世事变迁白云苍狗，众人唏嘘感叹不已。 第三次论剑末尾，众人看到被追赶逃窜的潇湘子和尹克西。二人从少林寺藏经阁盗得一部经书&lt;九阳真经&gt;，被不懂外家招式的看书和尚觉远和其小徒张君宝追到华山之巅，眼看无法脱身，刚好身边有只苍猿，两人心生一计，便割开苍猿肚腹，将经书藏在其中，以此蒙混逃脱。 “今番良晤，豪兴不浅，他日江湖相逢，再当杯酒言欢。”杨过拂袖，携爱妻之手，与神雕并肩下山。留下幼小的郭襄痴痴怀恋。16岁那年风陵渡口初相遇，一见杨过自此毁弃终生。之后三年她到处寻寻觅觅，始终落得个冷冷清清：终南山古墓长闭，万花坳花落无声，绝情谷空山寂寂，风陵渡凝月冥冥。中途路过嵩山，再遇当年华山之上的旧交觉远和张君宝。觉远大师为免二人受到少林僧众责难，最终力竭，圆寂之前诵读所记经文，郭襄，君宝，少林寺无色禅师各记得其中一部分。郭襄终究寻杨过不得，在40岁那年大彻大悟落发为尼，开峨眉一派。 100多年后，历史的指针已从宋末到元末。当年那个明媚的少女已不再人世，当年的张君宝也已鹤发期颐，化名三丰成一派宗师。他的徒孙，身重玄冥神掌寒毒的张无忌机缘巧合，从当年那只苍猿腹中取出这部&lt;九阳真经&gt;，最终再次登顶武林之巅。 （华山派是道教的支派，以使剑著称，为全真道内部繁衍出七个支派之一，由‘全真七子’中的广宁子郝大通所创，由其弟子范圆曦、王志谨等进一步传播，成为中原主要武林门派之一。） 明朝建立，当年的明教式微彻底成为无政治属性的普通武林帮派，据说就是后来江湖上的‘魔教’日月神教的前身。当时，江湖上又有一部武学秘籍&lt;葵花宝典&gt;声名大噪。华山派亲逾骨肉的一对师兄弟，岳肃和蔡子峰来莆田南少林寺做客，有机会参看这部秘不示人的武学秘籍。二人分读，回到华山，参悟研讨，不料将书中记载一加印证，竟然牛头不对马嘴，全然合不上来。互相猜忌导致这两个兄弟到后来竟变成了对头冤家，华山派也就此分为气宗、剑宗。 莆田南少林方丈红叶禅师深知此书凶险，派自己得意弟子渡元禅师亲赴华山责备并劝阻二人（那个时候莆田还不开黑诊所，不造假鞋）。未期渡元禅师利用解释经文之时暗自记诵，下华山后再未回南少林寺。不久红叶禅师收到渡元禅师书信，道他凡心难抑，决意还俗。渡元后来易名「林远图」，以&lt;葵花宝典&gt;为基础，创出林家七十二路&lt;辟邪剑谱&gt;，并创建福威镖局名噪一时。 因为&lt;葵花宝典&gt;，日月神教‘十长老’两次攻上华山，五岳剑派设计将十长老诱入山腹石洞，用巨石封死洞口，十长老开凿出口未果，全亡。 华山派大弟子令狐冲，生性放荡不羁，爽朗豁达，豪迈潇洒，却有高度的忠义心，天生侠义心肠。此刻，他被道貌岸然的师傅岳不群罚在华山思过崖面壁思过。因自己挚爱的小师妹移情别恋家道中落而新入师门的福建福威镖局少主林平之，而愤懑异常，以拳击壁，无意中发现了当年的石洞，并习得魔教长老死前在石壁上刻下的五岳剑派所有剑法及破解招式。 又是百年，此时已是明末，女真崛起，扰乱辽东，国内矛盾重重，事端一触即发。勤勉的崇祯帝误中反间，自毁长城，蓟辽督师袁崇焕最终被不明真相的群氓啖咬惨死街头。 袁崇焕之子袁承志，身负复仇，华山学艺十几载。华山掌门，令狐冲徒孙穆人清将所学倾囊相授。学成临下华山，机缘之下巧遇多年前夏雪宜埋藏锥剑秘籍的山洞，成新一代金蛇郎君。最终袁成武林盟主，助李自成推翻明朝，最终和‘恩师’夏雪宜之女夏青青归隐，在世界第三大岛加里曼丹岛定居。而与他另有情愫的当朝公主阿九，则被自缢之前的父亲砍去一臂，后出家为尼。 后来，西方的理性之光逐渐照亮了这块土地，火车，火药，电器的出现让传统的江湖和武林愈行愈远。这座山和武林的关系到此告一段落。 fliter. 于渭南华山","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"},{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"诗情洛邑","date":"2017-05-27T12:17:28.000Z","path":"2017/05/27/诗情洛邑/","text":"梦里少年曾得暇，长安骑马，洛阳看花。青史成书，写长安惊鸿舞。铭刻成传，尽洛阳风流态。离歌倾城，唱尽长安繁华。霓裳多情，凉透洛阳心绪。 &lt;易经&gt;说“河出图，洛出书，圣人则之”。 好瞎BB不好好干活的本地人苏秦说“使我有洛阳二顷田，安能佩六国相印？”果然，只要成功了，说什么都是真理。 太史公说“昔三代之居，皆在河洛之间”。 在洛水之滨用意念艳遇神女、天下一斗才他占八分的曹植说“步登北邙阪，遥望洛阳山”他又说“名都多妖女，京洛出少年”。 玉树临风的潘岳说“终童山东之英妙，贾生洛阳之才子”。 羡慕潘岳容貌却不料“东施效颦”的左思说“崤函有帝皇之宅，河洛为王者之里”，一时洛阳纸贵。 荒淫无道的亡国之君杨广说“清歌凯捷九都水，归宴洛阳宫”。他在春秋吴国开凿基础上，大幅扩修运河，贯通至洛阳且连涿郡，连接五大水系。至元朝翻修时，弃洛阳而取直道，至当时也是今天首都的北京。 和他一样杀兄夺位却成明君典范的李世民说“华林满芳景，洛阳遍阳春”。 和上面这位关系乱糟糟的长寿女皇帝说“铭开武岩侧，图荐洛川中”。 她四儿子的第三个儿子李隆基说“洛阳芳树映天津，灞岸垂杨窣地新”，又说“鼓吹威夷狄，旌轩溢洛阳”。没有资格参加国内高考的酒鬼李太白说“忆昔洛阳董糟丘，为余天津桥南造酒楼”。他还说“谁家玉笛暗飞声，散入春风满洛城”。这家伙不高不壮却身轻体健通晓剑术，又兼身世成迷再加酗酒，各地不良人 当需特别关照。 小上面这哥们几岁,唐代双璧的另一块，坎坷不顺，一生漂泊流离，忠心社稷却从不被重用，感念民艰却无能为力，只有借助诗文以浇块垒“洛阳昔陷没，胡马犯潼关，天子初愁思，都人惨别颜”，“洛阳一别三千里，胡骑长驱五六年”，东都失陷了，他只剩回忆“昔在洛阳时，亲友相追攀”，“龙门横断野，驿树出城来”，痴痴憧憬着“洛阳大道时再清，累日喜得俱东行”，而闻听果真神奇地收复了，一贯沉郁顿挫的他难得酣畅一泻千里，“即从巴峡穿巫峡，便下襄阳向洛阳”，千年后的后人把他惊喜欲狂手舞足蹈的样子做成了“我很忙”的表情包：看把这老头乐的，同是春天前几年还哀叹“国破山河在，城春草木深”，还是“感时花溅泪，恨别鸟惊心”，没几年这不就成了“白日放歌须纵酒，青春作伴好还乡”。 我的老本家崔颢“寄语洛阳使，为传边塞情”，又有些“我在他乡，望着月光”的意思说“幽冀桑始青，洛阳蚕欲老”。 诗家天子王昌龄说“洛阳亲友如相问，一片冰心在玉壶”。诗画皆通的诗鬼王维说“洛阳女儿对门居，才可容颜十五余”。长眠于此的诗魔白乐天对比夸耀“何似东都正二月，黄金枝映洛阳桥”。“家本荥上籍占洛阳”的本土诗豪刘禹锡称赞“唯有牡丹真国色，花开时节动京城”。 “百代文宗”韩退之说“当春天地争奢华，洛阳园苑尤纷拏”。 毛主席和我都很喜欢的诗鬼李贺说“洛阳吹别风，龙门起断烟。冬树束生涩，晚紫凝华天”。明明不胜杯杓却偏偏逞强爱喝，爱弹琴好下棋的老头子欧阳修说“洛阳地脉花最宜,牡丹尤为天下奇”，他来我一样来晚了，却打趣道“曾是洛阳花下客，野芳虽晚不须嗟”。 小时候破坏公物后来从政并很懂历史的司马光说“若问古今兴废事,请君只看洛阳城”。他的老对头拗相公说“汉有洛阳子，少年明是非”。 … “当代徐霞客”爽哥说，洛阳可能是我唯一愿意留下来长居的中部城市。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"Vim入门","date":"2017-05-13T11:45:14.000Z","path":"2017/05/13/Vim入门/","text":"阮一峰-Vim 配置入门","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Tmux 使用小记","date":"2017-05-13T08:53:43.000Z","path":"2017/05/13/Tmux-使用小记/","text":"Tmux 使用教程","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Xorm隐藏的一个'坑'","date":"2017-05-12T14:00:34.000Z","path":"2017/05/12/Xorm隐藏的一个坑/","text":"项目中使用Xorm操作数据库,有次出现Update操作的bug: 当要更新的字段的值为空或0时,可能存在不会去修改的情况… 代码大致如下: 123456789101112func UpdateXXTable(data model.XXTable) (err error) &#123; if rows, err := db.XDb().Update(data, &amp;model.XXTable&#123;Id: rel.Id&#125;); err != nil &#123; log.Logger.Error(err) return err &#125; else if rows != 1 &#123; err = errors.New(\"update XXTable has no effect\") log.Logger.Error(err) return err &#125; else &#123; return nil &#125;&#125; 最初以为是bug, 用 raw sql 解决了问题. 之后仔细看了下Xorm的文档,发现不是bug,而是其特有的更新策略. 参见Xorm更新数据 确实很好奇为什么要这样设计..","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"少室山下 鸡鸣街","date":"2017-05-11T14:23:49.000Z","path":"2017/05/11/少室山下-鸡鸣街/","text":"却说令狐冲下了太室山，已近戌时，这时正值入夏，天虽未黑，一日在山间跋涉不进水米，却也饥肠辘辘，腹中馋虫咕咕大叫。昨日曾听客栈老板，本地有一夜市，名鸡鸣街，晚间热闹不一般。令狐冲回房，草草冲洗，湿身穿衣，敛集剩下的几块散碎银两，带上西洋美利坚乔铁匠制佩剑，走出客栈。一路执剑探看，走了约摸4里路，见一路口人头攒动，一条东西街道，延绵数里，皆是商贩，心下一凛，想来这必是鸡鸣街了。登封城虽非大邑，可令狐冲自小长于山间，绝少进城。面前灯火通明竟同白昼，花红酒绿好不热闹，山野盲流子几时曾见过这些，不觉好奇之兴奋，心下感慨：今日亲临，这夜市之誉，确是不虚了。在一小摊桌前坐定，招呼掌柜来一上等下酒菜，见同桌人有饮崂山琥珀酒者，也不禁绝口中干渴无味，食指大动，惜甚无酒。遂起身去近旁酒肆，沽来一大罐农夫御制清酒。这酒产自南宋皇城临安府，不过这时又已改叫做杭州。乃用淳安千岛湖中湖水古法炮制而成，畅销天下。令狐冲曾去杭州，那日同魔教左使向问天，营救任教主，正是在孤山梅庄西湖之下。只这淳安离杭州城有250里，处于山中，道路坎坷不易通行。 羹尽酒残，令狐冲抹抹嘴，放上两钱银子。踉踉跄跄走出，没走几步见一煎饼果子铺，量大份足，只要5个铜板。又见一人在卖樱桃，想曾听人说“樱桃好吃树难栽”，在华山未能得偿此果，不知味道若何。行至路边，听得重金属丝竹之声，有人和唱，字字铿锵，响亮至极，几曲下来竟毫不泄力。令狐冲大骇：此人内力如此之高世所罕见，想这登封一少林寺一嵩山，却是武学圣地。蹑手寻声看去，发声物却不是人，而是一形似牵牛的铁器。心中疑惑这是何机巧？感叹这世间能工巧匠实在之多，山东公输班，西洋特斯拉，皆是能化腐朽为神奇之神工。 细细听辩所发之声乐，令狐冲虽未上几年学，却也识得几字背得几诗，听这词句，却不是诗经楚辞，也非唐诗宋词，只听得“你是我的小呀小苹果”莫名之语，又闻听“月亮之上，我在仰望”，也不禁举头望月。这日正值四月十六，婵娟正浑圆低垂天边。令狐冲想起昨日还在洛阳，今日就已在嵩山脚下。见两楼之间明月，想起前人孟郊诗句，“天津桥下冰初结，洛阳陌上人行绝。榆柳萧疏楼阁闲，月明直见嵩山雪”，这孟郊乃是唐朝一位大大的文豪，绰号“诗囚”，和爱推敲的贾岛齐名，江湖人称“郊寒岛瘦”。 孟文豪“一日看尽长安花”原是令狐冲未失学时夙愿，却永远成梦，现下行走江湖辗转各地，早已将书本所学抛之脑后。倒是“临行密密缝，意恐迟迟归”更为贴切。想来已近西洋椿萱节，需为高堂备一份礼托驿馆寄回。人在他乡，望着月光，不禁多了些心涉遐想。又想起明日需去少室山拜会少林，便未再多虑。其时明月在天，清风拂叶，街上人渐散去，车马也少。令狐冲不时喝着农夫酒，一步步去回客房。","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"洛城东郊 绿竹巷","date":"2017-05-10T15:23:26.000Z","path":"2017/05/10/洛阳城中-绿竹巷/","text":"岳先生要在四月十六武林大会这天，赴嵩山封禅台找姓左的，用紫霞神功和新练成的林家剑谱，怼嵩山掌门的寒冰真气和大嵩阳掌。 华山派弟子令狐冲，身负上乘剑术，受冤除籍，下华山已有三日。正于洛阳东郊竹林学琴，或于黄河旧孟津渡口访友。听闻此消息，不得已中断洛城温存，赶赴登封。 途径洛邑以东的偃师，在驿路旁远远瞥见民舍当中的“玄奘寺”，不禁想起先帝朝一位吴姓秀才所著&lt;西游记&gt;，想那齐天大圣，三打白骨真假美猴，被唐僧冤枉赶走，也还是捐弃前嫌继续西行，不禁加快步伐向东而去。这书在当时属于禁书，莫说令狐冲没上过几年学，就是饱学鸿儒也未尝可知。令狐冲能想及此间典故原委，殊是难得。 不一日，已抵登封。这登封城原亦属洛阳，因几十年前朝廷修筑馆驿官道，使以东的小邑郑姆斯特丹渐聚集人脉，竟成河南府首屈一指的大城，后登封亦为其所辖。 令狐冲在马上打量两侧，灰衣僧众甚多三五里可见，想少林寺为天下第一名门正派，天下武功尽出少林，千年长盛不衰，又有扫地僧及觉远大师这样不露头角的人物，当真是卧虎藏龙人才辈出。一山不容二虎，而这左掌门，竟能在这小小登封城少林寺之上，拉扯起一派大旗，想来也是非同小可厉害人物。明日必有一场好戏。 天色渐晚，令狐冲想，此时登山太过唐突，不妨找店住下，明日一早再做商议。遂找店住下，饱食一顿，心想，我绝不可做事不管空手而上，于是又去杂货店购置小板凳，葵花籽，白皮瓜…","tags":[{"name":"金庸","slug":"金庸","permalink":"http://www.dashen.tech/tags/金庸/"}]},{"title":"Mac在文件夹/终端中打开终端/文件夹","date":"2017-05-08T11:32:38.000Z","path":"2017/05/08/Mac在文件夹-终端中打开终端-文件夹/","text":"在某个文件夹中打开终端 如图,想要在终端中到该文件夹,自然而然的办法是cd /usr/share/doc/postfix/html, 但其实还有更简洁的办法,即如上安装Go2Shell或cd to或FinderGo插件. (注:最新的系统Go2Shell有问题,但cd to仍可正常使用) 安装步骤如下: 下载后直接解压将解压后得到的”Cd To”程序拖拽至”应用程序”文件夹在”应用程序”文件夹中找到”Cd To”应用，按住Command + Option 键，将应用图标拖拽到Finder（访达）的工具栏上 在终端中打开某个文件夹 打开当前所在的文件夹:open . 打开指定的文件夹: open ~ open /home/ open ~/Downloads/ open /usr/share/doc/postfix/html","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"长安古意","date":"2017-05-05T04:36:21.000Z","path":"2017/05/05/长安古意/","text":"这几枚古旧的邮票，从我第一次放于手掌之间细细端详，已经有足足14年。这段听来朗朗的文字，从第一次我有些生疏地脱口读出，已经过去了整整12年。这本残破斑驳的老书，存世已有几十年。从我第一次抖落其上时间的尘埃翻开扉页，也已经将近10年。这几道石墨划下的笔痕，也有不下9年。这本薄薄的小书让我爱上唐诗，长安洛阳，自此心向往之。这页那年暑假在夕阳西下的阳台所做的摘写，笔迹已经干了快有8年。清明时分，汴河上下丝丝入画。一再推延，几历坎坷。我终于成行，一路向西。然而，我还有太多邮戳遮盖不住的壮美山河未曾亲至，有太多前人笔墨吟诵过的灞桥风月没有目睹。一个人脚力强健自顾向前，相比三五相随，显是可省却许些琐事，更高效率看更多风景。但更憧憬那天“有钱有闲”，我心甘情愿，放慢匆匆脚步，和挂念着的、期待着的人儿，把袂同游交头窃窃。 鼓楼 &amp; 回民街 泡馍与稠酒是我最喜爱的两样西安特产，可惜“鱼与熊掌不可兼得”，想在吃泡馍时佐以黄桂稠酒，在西安几乎是不可能的。因为西安泡馍馆大多是回民所开，西安回民泡馍馆决不卖稠酒。吃泡馍就稠酒的享受只有过两次，一次是去北京新街口的西安饭庄楼上，泡馍是好的，而稠酒是装在玻璃瓶中，喝一瓶开一瓶，且是冷的。另一次是在西安，因去陕西考古所公务，主人坚持请我吃饭，盛情难却，但我提出决不去大饭店，只愿去吃羊肉泡馍，无奈只得主随客便，从考古所出来，往大雁塔方向步行，有一泡馍馆，倒也干净，掰馍聊天之余，偶然瞥见墙边有一木架，上面摆列了一排锡壶，有大小两种。 ——赵珩《老饕漫笔》 登上南厢房小姐的闺房，下来时发觉楼梯陡峭，这鞋下生钩的足球脚都要猫着身子小心翼翼，不知几百年前小脚的大小姐下楼一趟是何费劲。我不知悉是否有个歇后语叫“小姐的闺房，易上难下”，不过我拿出手机，搜了下高家大院所在的村子，是否叫做高老庄。 高家大院 碑林博物馆 &amp;&amp; 骡马市步行街 拳毛騧“不嫌金甲重，且去捉飘风”，什伐赤“鬣焦朱色落，发断锯长麻”，白蹄乌“夜来霜压栈，骏骨折西风”，特勒骠“龙脊贴连钱，银蹄白踏烟”，飒露紫“竹批双耳峻，风入四蹄轻”，青骓马“万里可横行，真堪托死生”。 矗立国宝前，心摇如县旌。此刻随浮雕一同浮现的，是大唐英雄一时风云相聚，是凌烟阁二十四功臣的画卷，是玄武门兵变帝王家终究是不归路的悲情画面，是穷困潦倒的诗圣和多病苦吟的诗鬼謦欬而出的珠玉。当然还有那期&lt;贩卖国宝的人&gt;。 兴庆宫 &amp;&amp; 西安交通大学 云想衣裳花想容，春风拂槛露华浓。若非群玉山头见，会向瑶台月下逢。 名花倾国两相欢，常得君王带笑看。解释春风无限恨，沉香亭北倚阑干。 你在樱花道穿行，飞花胜雪我在胭脂坡眺望，长安弦月你在长安古城边，向西而安我在兴庆湖水畔，枝叶擎天—### 新城 &amp; 历史博物馆 &amp; 曲江池 &amp; 大雁塔- 位于城北的新城及市政府 历史博物馆 大概是博物馆逛的太多，而此又缺少镇馆之宝，这个当之无愧的“地下文物最多”省份的省级博物馆，甚至没能比去过的另几个省的博物馆，能带给我更多的兴奋，感觉有些乏味，味同鸡肋。人文景观像如人文学科，山川湖泊如自然学科，年轻时体力充沛，当多涉猎后者，趁年轻登山揽月，下坝抓虾。…另一个原由是，博物馆存在的价值和意义，必须是服务大多数人，而不能为少数geek。那些在平均水平之上的看客，也不得不赶大集似的跟着走马观花。而伟大的互联网，给了这些形形色色的小众兴趣一席栖身之地。作为善用网络让我病猫成虎又添翼的互联网从业者，如我喜欢这些历史，完全可以不局促于方寸之地，片刻光阴，而可随时随地，格物致知。 大雁塔 日宫开万仞,月殿耸千寻。华盖飞团影,幡红曳曲阴。绮霞遥笼帐,丛珠细网林。寥阔烟云表,超然物外心。 黄鹄去不息，哀鸣何所投。君看随阳雁，各有稻粱谋。 秋色从西来，苍然满关中。五陵北原上，万古青濛濛。 华清池 &amp; 兵马俑在诗词里，这里是“春寒赐浴华清池,温泉水滑洗凝脂”，是“长安回望绣成堆,山顶千门次第开”，是“山姿水态冠秦疆，美色当初醉李唐”，是“骊山语罢清宵半，泪雨霖铃终不怨”，是“桓桓双将怒，咄咄一夫危”。 在现实里，这里门票死贵，亮点乏善。不值一来又名气死大，属于典型的鸡肋景点。 已经感受不到“秦王扫六合，虎视何雄哉”的英雄豪气，而“奋六世之余烈,振长策而御宇内,吞二周亡诸侯,履至尊制六合,执敲扑鞭笞天下威振四海”的雄壮画面，也只能从太史公和贾谊苏洵的大块文章中找寻只鳞片羽。 我只在人潮涌动中隔着玻璃，或透过高立的栏杆远远瞥那么一眼。一将功成万骨枯，长平的40万鬼魂，骊山的70万徒役，2000多年后都只是无关痛痒的一个数字，已经体会不到当时的干戈杀伐和生死离别。 祖龙功盖三皇，在前辈基础以战止战结束分裂割据，受限于历史，尤其落后的技术、生产力水平与生产关系，不能过分苛责一个活动在两千多年前的帝王，能有今人的三观和思想。 只是倍觉庆幸，是在1979年后，一堆无机的碳氢氧元素才有序组合，赋予了我有机的生命，而火红的大运动已过，给了我独立思想发展和存在的可能。我无限憧憬儿孙后代人的美好世界：科学技术进步带来的社会更加公正公平；医学进展长足、寿命极大延长、病痛尽可能消除；物质更加丰富贫困线一再提高甚至消失不见；最大可能的包容不同，容许异见；年轻人如初升的太阳，满是喷薄而上的张力，没有沉重的买房结婚负担，更能在“任何一个晚上在任何一个地方说出心中想说，而没有任何恐惧”。 我又深知，正是活动在1979年前的相当多数前辈，在肃杀凛冽的深夜寒风中小心翼翼护佑着微弱的文明之火，在夹缝中匍匐，“迭代式微创新微进步”甚至“进两步退一步”，最终薪尽火传，交棒到新一代人手上。“我们往往会高估此后一两年的变化，而低估此后十年”，面对仰头才见的美好目标，来自尘埃复又归于尘埃的一代人，用这间隙中的几十年有意无意或大或小地向上攀爬，并最终在年老体乏时袒露肩膀，让富有生气的新一代人继续向前。 历史不应该只用来回味，还该在复杂经络的演进中找寻催化剂，助力这个古老大树新发的枝桠，继续蓬勃向前。 2016.5.5 观景而后感，5.6于旅舍天台。 诸大学 &amp; 小雁塔 西安交大雁塔校区 西北大学 在我的印象笔记里，一篇几年前的笔记既有“与西南联大对应的，（今天的）天津大学和北京师范转战西北，成立西北联大。抗战胜利回津回京后，原校址就是今天西北大学”。 以方位为名称的高校中，以东南、中南为优，少帅的东北大学次之。西南、西北再次之，及至中北，已经不值一睹。…但美国有所著名的西北大学，无著名的东南中南，在网络上，中美两所“西北大学”常造成混乱。 西北工业大学 西北电子科技大学 西安市博物院 烟雨长安，梦回大唐。风雪无字，吟叹武周。 骊山晚照，披秦地。曲江流饮，绕长安。 然一场暴雨，一阵沙尘，让诗词描绘的画卷浸水沾沙，诗情画意化为乌有。 应当说，这是一座有特色的城市，它的历史无城可比，它的未来难复辉煌。 城门 民国时开辟的四个城门，原皆已人名命名。1949年后，中正门改为解放门。 写长安的诗词名篇多不胜举,如题所用&lt;长安古意&gt;,出自”初唐四杰”卢照邻之笔,曾因诗中“梁家画阁中天起，汉帝金茎云外直”得罪武三思而入狱,出狱不久染风疾，服丹药中毒，手足残废。”后转少室山中之东龙门山，又徙居阳翟具茨山下，买园数十亩，疏凿颍水，环绕住宅，预筑坟墓，偃卧其中。”因政治上坎坷失意及长期病痛折磨，最后自投颍水。初唐四杰，俱是下场凄惨. 长安大道连狭斜，青牛白马七香车。玉辇纵横过主第，金鞭络绎向侯家。龙衔宝盖承朝日，凤吐流苏带晚霞。百尺游丝争绕树，一群娇鸟共啼花。游蜂戏蝶千门侧，碧树银台万种色。复道交窗作合欢，双阙连甍垂凤翼。梁家画阁中天起，汉帝金茎云外直。楼前相望不相知，陌上相逢讵相识。借问吹箫向紫烟，曾经学舞度芳年。得成比目何辞死，愿作鸳鸯不羡仙。比目鸳鸯真可羡，双去双来君不见。生憎帐额绣孤鸾，好取门帘帖双燕。双燕双飞绕画梁，罗帷翠被郁金香。片片行云着蝉鬓，纤纤初月上鸦黄。鸦黄粉白车中出，含娇含态情非一。妖童宝马铁连钱，娼妇盘龙金屈膝。御史府中乌夜啼，廷尉门前雀欲栖。隐隐朱城临玉道，遥遥翠幰没金堤。挟弹飞鹰杜陵北，探丸借客渭桥西。俱邀侠客芙蓉剑，共宿娼家桃李蹊。娼家日暮紫罗裙，清歌一啭口氛氲。北堂夜夜人如月，南陌朝朝骑似云。南陌北堂连北里，五剧三条控三市。弱柳青槐拂地垂，佳气红尘暗天起。汉代金吾千骑来，翡翠屠苏鹦鹉杯。罗襦宝带为君解，燕歌赵舞为君开。别有豪华称将相，转日回天不相让。意气由来排灌夫，专权判不容萧相。专权意气本豪雄，青虬紫燕坐春风。自言歌舞长千载，自谓骄奢凌五公。节物风光不相待，桑田碧海须臾改。昔时金阶白玉堂，即今惟见青松在。寂寂寥寥扬子居，年年岁岁一床书。独有南山桂花发，飞来飞去袭人裾。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"他们,让我对文学和文字 大改感观","date":"2017-05-02T07:04:19.000Z","path":"2017/05/02/他们-让我对文学和文字-大改感观/","text":"经过好多个静谧深夜，终于草草翻过马尔克斯另一部大作的尾页，该书是这位20世纪最具影响力的作家荣膺诺奖后，第一次又有新作付梓发行。和“惊艳”迷人到手不释卷的&lt;百年孤独&gt;比，&lt;霍乱时期的爱情&gt;没有那样的魔力，如同拍出&lt;霸王别姬&gt;的导演，有好多作品需要按快进。 2011年，我带着些忐忑走进偌大的王府井书店。一楼入口在轮番播报着&lt;百年孤独&gt;译作首次登录国内的消息。在其时，埋头于沉抑的山东高中院落，抬头只见四角天空的我，并不知马尔克斯大名，但心想如此连篇累牍地报道，想来该是不错，于是悄悄记了下来，打算抽空看看。 但这一等就是3年。那年4月，我埋头于无穷级数和线面积分，无暇更无心在旭日初升或斜阳将下的时刻，心无旁骛看一本与前途好像毫无关联的小说。那年4月初，恰巧所在书位上有一本&lt;百年孤独&gt;，于是翻几页作为疲乏时刻的休憩。不期十余天后作家辞世，透过网络，我看到了五大洲许多达官显贵或贩夫走卒自发的哀悼。这本书也实在具有魔力，我一再告知自己不要本末倒置，有时还是忍不住连看几十页。像一部优秀的如&lt;致命魔术&gt;那样情节引人入胜的电影，你只需要按捺住不耐烦的心情看10分钟，剩下的时间，你像是被吸在了那里，即便接下来是一场国家德比，是一桌饕餮盛宴，亦或眉梢起火，泰岳崩塌，甚至是你频送秋波的心怡妹子在楼下等你，你内心也在挣扎“等我看完再说”。 马尔克斯不光影响了莫言，很大程度也靠这部小说改变了我的三观。自此，文学不再是被我有色眼镜下歧视的公民。作为一名喜爱自然科学的高分理科生，我对文科一直无有太好印象。大概有三个比较标志性意义的时刻，让我观念逐渐改变。 一是进到高中再读鲁迅那些佶屈聱牙的文字。初中时学过其&lt;拿来主义&gt;，我的评价是“什么玩意儿”。而进入中学再学&lt;为了忘却的纪念&gt;，这时已有稍多些经历，有好多次郁结于心想要表达，却不知词从何来从何说起的乏力。而他一己之力在记录挞伐一个时代的黑暗，这种细致入微的情感表达，入木三分的刻画，多一字则多少一字则少的把握，都到运斤成风目无全牛程度。也是那时，我开始相信先生弃医从文，真是为影响更多人，而不是“医科更难学”。 二是一位颇好的中学同学，在一士谔谔众士诺诺的高中，我俩算是难得的“同类人”。他的理科与我一般好，但作文每次都是最优，甚至有次聊天，他告诉我以后他最想当一名作家。这让我跌掉眼镜：你怎么会去做这么没有技术含量的工作？我们这样聪明这样优秀，不是还有那么多科学难题在等待我们？…难逢知己，交流许多。他向我推荐了几部网络文学，其中一部叫&lt;庆余年&gt;。 如同两宋之交的人口南迁，彻底让南北方经济易位。&lt;百年孤独&gt;为文学正名。而此后对文学兴致大涨，坚定不移的科学家的大梦，反倒在诡谲的现实世界化为18岁那年的迷雾。 作家辞世已3周年。有的人死了，他还活着。 “永生永世！”他说。","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"零宽字符","date":"2017-04-21T13:30:37.000Z","path":"2017/04/21/零宽字符/","text":"强烈荐读： 探案：让被盗的数据“滴血认亲” 没想到 Unicode 字符还能这样玩？ 零宽字符的用途: 数据防爬： 将零宽度字符插入关键词文本中，使得匹配关键字时不能正确匹配，但是不影响用户的正常阅读 信息隐藏： 如 可实现隐形水印，找到泄密者 短网址 等 可折叠输入法，用的就是在原文中添加了部分特殊字符 12345678910111213141516171819202122零宽空格（zero-width space, ZWSP）用于可能需要换行处。 Unicode: U+200B HTML: &amp;#8203;零宽不连字 (zero-width non-joiner，ZWNJ)放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。 Unicode: U+200C HTML: &amp;#8204;零宽连字（zero-width joiner，ZWJ）是一个控制字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。 Unicode: U+200D HTML: &amp;#8205;左至右符号（Left-to-right mark，LRM）是一种控制字符，用于计算机的双向文稿排版中。 Unicode: U+200E HTML: &amp;lrm; &amp;#x200E; 或&amp;#8206;右至左符号（Right-to-left mark，RLM）是一种控制字符，用于计算机的双向文稿排版中。 Unicode: U+200F HTML: &amp;rlm; &amp;#x200F; 或&amp;#8207; 字节顺序标记（byte-order mark，BOM）常被用来当做标示文件是以UTF-8、UTF-16或UTF-32编码的标记。 Unicode: U+FEFF Unicode 字符百科 unicode字符查询","tags":[{"name":"密码学","slug":"密码学","permalink":"http://www.dashen.tech/tags/密码学/"}]},{"title":"至味人间","date":"2017-04-21T13:01:01.000Z","path":"2017/04/21/至味人间/","text":"樱桃好吃树难栽，生蚝味鲜壳难开。 在外漂泊不辨菽麦，在家尽享庖厨之欢。 一粥一饭见证寒来暑往，一饮一啄饱蘸苦辣酸甜。 过去我能想到最浪漫的事，是和未来的她在柴米油盐的琐屑疲劳后，能有心情和雅致，一起平静地看各种无用的公开课。淡淡地，静静地，看到会心处，相视一笑。 而今我诧讶，平素以之无趣的柴米油盐，过往眼中蹉跎生命的厨台案板，此刻却如此歆享。 和家人至亲一道，共同完成一桌喜爱的家宴。 辛苦劳作带来的幸福与喜悦，溢于言表。我的虎咽狼吞，父母的相视一笑，平常无奇的外表，弥足珍贵的味道。 时光恰如其分，浪费在最美好的事物上，慢品细酌，值得细细回味。 而再过不久，我茕茕一人，又要走上离乡外出的陌生路。 故乡终不再只有冬夏，春秋却止才寥寥几天。 “这是巨变的华夏，人和食物，比任何时候走的都要快。无论脚步怎样匆忙，不管聚散悲欢，来的有多么不由自主，总有一种味道，以其独有的方式，每天三次，在舌尖上提醒着我们，认清明天的去向，不忘昨日的来处。” 过去我想拥有自己的书房，早已得偿所愿多年。而今，我想在栖居的城市，有自己的厨房。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"平泉--老马识途&&望梅止渴","date":"2017-04-14T10:13:28.000Z","path":"2017/04/14/平泉-老马识途-望梅止渴/","text":"承德平泉撤县设市。平泉处河北东北，邻接内蒙古辽宁，有通衢辽蒙、燕赵门楣之称。平泉面积广阔，3297平方公里，与深港面积之和相当，但人口较少，经济发展一般。 提及承德，多数人第一观感是避暑山庄和木兰围场，是辛酉政变恭亲王慈禧叔嫂扳倒顾命八大臣。甚或，还有多年前许晴代言的露露。平泉这个处于边角位置的寻常县域，并不为人熟知。 平泉是典故老马识途和望梅止渴的发生地。前者出自&lt;韩非子&gt;，齐桓公应燕国要求，出兵攻打入侵燕国的外族山戎，部队迷路，放出老马，找到了出路。 而后一成语，是否出自平泉我却颇有疑惑，在&lt;三国演义&gt;第二十一回，青梅煮酒论英雄，此出在曹操征讨宛城张绣的路上。宛城即今天南阳，曹操应在南阳以南，前去征讨不会路过南阳以北的河北平泉（要说与&lt;观沧海&gt;一样，产生于征讨乌桓，就没有这个疑问了） 稍稍有些感到意外的，是新的平泉市归石家庄代管，而非承德。那这样原本是承德下辖一县的平泉，岂不是一下子和承德再无半点行政关系？…但与新近同样发生在河北，原本波静縠纹平的行政区划领域，始料不及炸出的炸弹“雄安新区”相比，这样的“意外”不足深究。","tags":[{"name":"区域经济","slug":"区域经济","permalink":"http://www.dashen.tech/tags/区域经济/"}]},{"title":"归去来兮 coming&going","date":"2017-04-13T12:46:12.000Z","path":"2017/04/13/coming-going/","text":"这座斑驳的覆满爬山虎的老墙，见证了过去639天里，许多次的离别与邂逅。只是今天，我成为了主角。 这段我来来往往，走过足有3000次的仙霞路，不久后将被绿茵笼罩。川流的人群里未曾有我，但夜半时分，依稀的车辆，交织的霓虹，醉酒的浪人，侍酒的女郎，当这些再如寻常那般出现，已没有一个戴着耳机哼着曲儿，思考着慢跑着冷冷睥睨而去的违和者，出现在略显凄冷的街头。 我如风卷残云，一口气退掉了所有工作相关的群，感到神清气爽。这是我职业生涯第一阶段的结尾，我实在清楚，此后的10-20年，我还要再经历不下15次这样的场合，这样的聚散。此刻的依依惜别，在那时已是轻车熟路微微一笑。 我想酣眠一场，醒来世上已历廿年。我45岁，春秋鼎盛，依旧豪气干云。有些积蓄，几套房产，家境中上，一儿一女。女如妻笑靥如花，儿似我聪明勤奋。我结束了漫长的职业生涯，开始找寻儿时的许多兴趣。或跋山涉水实践“现代徐霞客”，或自立门户，得偿许些缩龙成寸的未竟之志。 我的呓语被格格冷笑打断。我起身倚在床榻，方察南柯之下，一枕黄粱。20年会有太多的起伏跌宕，太多的不如人意。 清宵梦醒，一晌贪欢。而后我又要踏上前方充满未知的路，或是康庄，或如羊肠，影影绰绰间，天上的星辰和心中的道德律，在明暗中给予方向。 过去20年，我遇到过许多人，经逢过不算太多的一些事。今天往后的20年，我依旧如飘荡在时光之河的一钱槐叶，在势不可挡的流逝中，体验一份生活和生命赋予的喜怒悲欢。 2017.04.13。于古北路新疆烧烤店，等羊肉串间隙。 感谢我的兄弟们~我会默默贮在心里，许多年后，依然会记得","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"编程范式","date":"2017-04-12T13:46:11.000Z","path":"2017/04/12/编程范式/","text":"本篇是对视频编程范式 学习过程的记录 BNF 巴科斯-诺尔范式，是一种描述编程语言语法的语言 有很多不同的写法和格式 HTTP，Java等，都有基于BNF的描述 命令式 函数式 面向过程 面向对象","tags":[{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"MySQL 执行.sql文件","date":"2017-04-12T12:57:09.000Z","path":"2017/04/12/MySQL-执行-sql文件/","text":"之前都是把所有建表语句放在一个文件里，复制粘贴到Navicat中执行… 这样一张表写成一个.sql文件，其实比较明了。但初始化时怎样建这些表呢？ 挨个复制粘贴太麻烦… 这种一般都有init.sql，里面包含建库，建各张表。 init.sql: 123456789101112131415CREATE DATABASE 库1;USE 库1;SOURCE 表1.sql;SOURCE 表2.sql;SOURCE 表3.sql;...CREATE DATABASE 库2;USE 库2;SOURCE 表a.sql;SOURCE 表b.sql;SOURCE 表c.sql; 可以登陆mysql命令行，然后source一下这个init.sql即可 如果遇到Failed to open file &#39;xxx.sql&#39;, error: 2问题，多半是路径引起。 不要用绝对路径，在init.sql那个文件目录下，登陆mysql命令行，然后执行source init.sql","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"golang实现栈","date":"2017-04-11T16:43:08.000Z","path":"2017/04/12/golang实现栈/","text":"参考: Golang实现数据结构“栈”的三种实现，性能对比及应用示例 方法1: 利用Golang的slice(相当于利用数组) 1.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"fmt\" \"sync\")// Item the type of the stacktype Item interface&#123;&#125;// ItemStack the stack of Itemstype ItemStack struct &#123; items []Item lock sync.RWMutex&#125;// New creates a new ItemStackfunc NewStack() *ItemStack &#123; s := &amp;ItemStack&#123;&#125; s.items = []Item&#123;&#125; return s&#125;// Pirnt prints all the elementsfunc (s *ItemStack) Print() &#123; fmt.Println(s.items)&#125;// Push adds an Item to the top of the stackfunc (s *ItemStack) Push(t Item) &#123; s.lock.Lock() defer s.lock.Unlock() s.items = append(s.items, t)&#125;// Pop removes an Item from the top of the stackfunc (s *ItemStack) Pop() Item &#123; s.lock.Lock() defer s.lock.Unlock() if len(s.items) == 0 &#123; return nil &#125; item := s.items[len(s.items)-1] s.items = s.items[0 : len(s.items)-1] return item&#125;func main() &#123; s := NewStack() s.Push([]int&#123;1, 4, 7&#125;) s.Push([]int&#123;5, 8, 9&#125;) //fmt.Println(s) s.Print() s.Pop() //fmt.Println(s) s.Print()&#125; 1_test.go 123456789101112131415161718192021222324252627282930313233package mainimport ( \"strconv\" \"testing\")var stack *ItemStackfunc init() &#123; stack = NewStack()&#125;func Benchmark_Push(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; //fmt.Println(stack)&#125;func Benchmark_Pop(b *testing.B) &#123; b.StopTimer() //类似时间锁,在StopTimer()和StartTimer()之见的代码,不计入测量 for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; b.StartTimer() for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping stack.Pop() &#125;&#125; 关于基准测试,参考: Go测试 go test -test.bench=&quot;.*&quot; -benchmem -v 结果如下: 1234567goos: darwingoarch: amd64pkg: 上级目录/当前目录Benchmark_Push-4 3611212 379 ns/op 130 B/op 2 allocs/opBenchmark_Pop-4 20186299 52.2 ns/op 0 B/op 0 allocs/opPASSok 上级目录/当前目录 12.202s 方法2: 利用Golang的container/list内置包(即利用链表) 关于Go的list,参见golang中list的源码 2.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package mainimport ( \"container/list\" \"fmt\" \"sync\")type Stack struct &#123; list *list.List lock *sync.RWMutex&#125;func NewStack() *Stack &#123; aList := list.New() l := &amp;sync.RWMutex&#123;&#125; return &amp;Stack&#123;aList, l&#125;&#125;func (stack *Stack) Push(value interface&#123;&#125;) &#123; stack.lock.Lock() defer stack.lock.Unlock() stack.list.PushBack(value)&#125;func (stack *Stack) Pop() interface&#123;&#125; &#123; stack.lock.Lock() defer stack.lock.Unlock() e := stack.list.Back() if e != nil &#123; stack.list.Remove(e) return e.Value &#125; return nil&#125;func (stack *Stack) Peak() interface&#123;&#125; &#123; e := stack.list.Back() if e != nil &#123; return e.Value &#125; return nil&#125;func (stack *Stack) Len() int &#123; return stack.list.Len()&#125;func (stack *Stack) Empty() bool &#123; return stack.list.Len() == 0&#125;func main() &#123; s := NewStack() s.Push([]int&#123;1, 4, 7&#125;) s.Push([]int&#123;5, 8&#125;) s.Push([]string&#123;\"a\",\"d\",\"f\",\"g\",\"w\"&#125;) fmt.Println(s) fmt.Println(s.Len()) fmt.Println(s.list.Front().Value) fmt.Println(s.list.Back().Value) s.list.InsertBefore([]string&#123;\"cuishuang, dashen\"&#125;,s.list.Back()) fmt.Println(s.Len()) fmt.Println(s.list.Back().Value) fmt.Println(s.list.Back().Prev()) fmt.Println(s.list.Back().Next()) fmt.Println(s.Len()) s.Pop() fmt.Println(s.Len()) fmt.Println(s.list.Front().Value)&#125; 输出为: 1234567891011&amp;&#123;0xc00006a180 0xc000092000&#125;3[1 4 7][a d f g w]4[a d f g w]&amp;&#123;0xc00006a210 0xc00006a1e0 0xc00006a180 [cuishuang, dashen]&#125;&lt;nil&gt;43[1 4 7] 2_test.go 123456789101112131415161718192021222324252627282930313233package mainimport ( \"strconv\" \"testing\")var stack *Stackfunc init() &#123; stack = NewStack()&#125;func Benchmark_Push(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; //fmt.Println(stack)&#125;func Benchmark_Pop(b *testing.B) &#123; b.StopTimer() //类似时间锁,在StopTimer()和StartTimer()之见的代码,不计入测量 for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; b.StartTimer() for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping stack.Pop() &#125;&#125; go test -test.bench=&quot;.*&quot; -benchmem -v 结果如下: 1234567goos: darwingoarch: amd64pkg: 上级目录/当前目录Benchmark_Push-4 3439525 409 ns/op 85 B/op 3 allocs/opBenchmark_Pop-4 20381214 54.8 ns/op 0 B/op 0 allocs/opPASSok 上级目录/当前目录 14.733s 方法3: godoc的实现（自定义数据结构） 3.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( \"fmt\" \"sync\")type ( Stack struct &#123; top *node length int lock *sync.RWMutex &#125; node struct &#123; value interface&#123;&#125; prev *node &#125;)// Create a new stackfunc NewStack() *Stack &#123; return &amp;Stack&#123;nil, 0, &amp;sync.RWMutex&#123;&#125;&#125;&#125;// Return the number of items in the stackfunc (this *Stack) Len() int &#123; return this.length&#125;// View the top item on the stackfunc (this *Stack) Peek() interface&#123;&#125; &#123; if this.length == 0 &#123; return nil &#125; return this.top.value&#125;// Pop the top item of the stack and return itfunc (this *Stack) Pop() interface&#123;&#125; &#123; this.lock.Lock() defer this.lock.Unlock() if this.length == 0 &#123; return nil &#125; n := this.top this.top = n.prev this.length-- return n.value&#125;// Push a value onto the top of the stackfunc (this *Stack) Push(value interface&#123;&#125;) &#123; this.lock.Lock() defer this.lock.Unlock() n := &amp;node&#123;value, this.top&#125; this.top = n this.length++&#125;func main() &#123; s := NewStack() s.Push([]int&#123;1, 4, 7, 0, 11, -3, 9&#125;) s.Push([]int&#123;5&#125;) s.Push([]string&#123;\"a\", \"d\", \"f\", \"g\", \"w\"&#125;) fmt.Println(s.Peek()) fmt.Println(s.Len()) s.Pop() fmt.Println(s.Peek()) fmt.Println(s.Len())&#125; 输出为: 1234[a d f g w]3[5]2 3_test.go 同 2_test.go go test -test.bench=&quot;.*&quot; -benchmem -v 结果如下: 1234567goos: darwingoarch: amd64pkg: l上级目录/当前目录Benchmark_Push-4 3468397 361 ns/op 69 B/op 3 allocs/opBenchmark_Pop-4 24239797 52.3 ns/op 0 B/op 0 allocs/opPASSok 上级目录/当前目录 16.249s 性能对比: 实现方式 push速度 pop速度 push内存分配 pop内存分配 基于slice 379 ns/op 52.2 ns/op 130 B/op 0 B/op container/list链表 409 ns/op 54.8 ns/op 85 B/op 0 B/op 自定义数据结构 361 ns/op 52.3 ns/op 68 B/op 0 B/op 更多: 【golang】用container/list实现栈（Stack） Google结果","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"用redis实现分布式锁","date":"2017-04-11T16:18:04.000Z","path":"2017/04/12/用redis实现分布式锁/","text":"分布式锁可以基于数据库方式、基于redis方式、基于ZooKeeper方式去实现，一般基于redis的使用比较多 分布式锁机制原理及实现方式 以用户抢优惠券为例，100张优惠券，10000个用户来抢： 使用setnx，添加一个锁标志位，如称为lockKey, 如果添加成功, 则能够继续向下执行扣减优惠券数量操作, 最后再释放此标志位 setnx(key, value)，key不存在就新增，存在就什么都不做。同时有多个客户端发送setnx命令，只有一个客户端可以成功，返回1（true）；其他的客户端返回0（false) 但这样在一定情况下可能发生死锁 （如果获取到锁的线程，异常结束, 没有执行释放锁操作, 这样就会 产生死锁） 对 Redis 的 锁标志位加上过期时间即可 但在极端情况下，如请求加锁成功后, 接着还没来得及设置过期时间就宕机… 需要使添加锁标志位 &amp; 添加过期时间命令 具有原子性，要么一起成功, 要么一起失败 从 Redis 2.6.x 版本起, 提供了可选的 字符串 set 复合命令,可以保证添加字符串&amp;设置超时时间是原子的 SET key value [expiration EX seconds|PX milliseconds] [NX|XX] EX: 设置超时时间，单位是秒 PX: 设置超时时间，单位是毫秒 NX: IF NOT EXIST 的缩写，只有 KEY 不存在的前提下 才会设置值 XX: IF EXIST 的缩写，只有在 KEY 存在的前提下 才会设置值 如set(locakKey,&quot;当前状态，如locked&quot;，”nx“，”ex“，5) ，即如果没有locakKey，则原子性的设置locakKey值为locked，过期时间为5秒 这样 加锁以及设置过期时间就确实保证了原子性 还可能存在问题： 线程一获取锁成功, 设置过期时间五秒, 接着执行业务逻辑；执行的时间超过了过期时间， 锁标志位过期将进行释放。此时线程二获取锁成功；接着线程一执行完成, 执行释放锁的逻辑, 会顺手把线程二获取取的锁释放了，这时再来线程三，还是可以和线程二同时拿到这个资源 (如线程2执行时，就剩下最后一张优惠券了，线程三再一来，相当于超卖了) 创建辨别业务身份的唯一uuid，将这个uuid作为lockKey的value 解锁时需要判断锁的 val 是否和自己uuid的相同, 辨别成功才会释放锁 但可能还有问题 因为判断锁能不能释放和删除标志位并不是原子性的, 所以可能还是会存在误删 但redis的del 删除操作并没有提供原子命令… Redis 2.6.x后 允许开发者使用 Lua 语言编写脚本，并传到 Redis 中执行；Redis 会将 Lua 脚本中的命令当作一个整体执行, 中间不会插入其它命令 在Lua脚本中处理，保重删除的原子性 更多： redis分布式锁原理与实现 分布式锁基本原理 关键词： 1234setnx getsetexpiredel及lua脚本","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"iterm2奇技淫巧","date":"2017-03-29T12:06:42.000Z","path":"2017/03/29/iterm2奇技淫巧/","text":"多次被安利过tmux,实际上iterm2本身的快捷键及分屏操作已经足够强大,在此总结常用命令: Cmd + ; : 选择在当前窗口用过的命令: Cmd+Shift+H :显示进行过粘贴操作的命令 Cmd+Option+B : 命令回放(非常好用) Cmd + Option + E : 多窗口全局搜索 Ctrl+a: 光标移动到行首 Ctrl+e: 光标移动到行末 Ctrl+f: 前移一个字符 在HHKB上用很实用 Ctrl+b: 后退一个字符 在HHKB上用很实用 Ctrl+l: 清屏 类似于clear,往上翻还是能看到历史 Ctrl+p: 回到上一个历史命令 类似上下箭头 Ctrl+r: 倒转查找 Ctrl+d: 删除光标选中的字符 Ctrl+h: 删除前一字符 相当于delete Ctrl+w: 删除光标之前的字符 Ctrl+k: 删除光标之后的字符 窗口切换操作: Command + 数字 : 切换到该窗口 Command + t : 新建新的窗口 Command + 左右方向键 : 切换窗口 分屏操作: Command + d: 纵向分屏 Command + Shift + d : 横向分屏 Command + [ : 切换选中的分屏 ———————————————— 更多参考: mac下超好用的终端–iterm2用法与技巧","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"http相关问题目录","date":"2017-03-25T12:36:23.000Z","path":"2017/03/25/http相关问题目录/","text":"保持长连接的字段(key=&gt;value) connection:keep-alive 带这个字段,TCP连接就可以复用了;一个http处理完之后,另外一个http数据直接继续用这个连接。减少新建(三次握手)和断开TCP(四次挥手)连接的消耗。 HTTP/1.1之后默认开启Keep-Alive, 在HTTP的header中增加Connection选项。当设置为Connection:keep-alive表示开启，设置为Connection:close表示关闭 http中的keep-alive和TCP中的KeepAlive有所差异 参考: KeepAlive相关 Cookie中与安全相关的机制 Cookie的字段一般分为: [name(键)] [value(值)] [path(路径)] [domain(所属域)] [expires(过期时间)] [secure flag(安全标志)] [httponly flag] 其中name=value是必选项，其它都是可选项 name: 一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的。 value: 存储在cookie中的字符串值。最好为cookie的name和value进行url编码 path: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。 domain: cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(如：http://yq.aliyun.com，也可以不包含它(如：http://aliyun.com，则对于http://aliyun.com 的所有子域都有效). expires: 失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差。 max-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。 Secure flag , 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置 HttpOnly flag，HttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。 Secure Cookie机制 Secure Cookie机制指的是设置了secure标志的cookie。 Secure Cookie仅在https层面上安全传输，如果是http请求，就不会带上cookie。 这样能降低重要的cookie被中间人截获的风险。不过，也不是说可以万无一失。因为secure cookie对于客户端脚本来说是可读可写的，可读就意味着secure cookie能被盗取，可写意味着能被篡改，所以还是存在一定的风险。 HttpOnly属性 Cookie的HttpOnly属性，指浏览器不要在除HTTP/HTTPS请求之外暴露Cookie。 一个有HttpOnly属性的Cookie，不能通过非HTTP/HTTPS方式来访问，例如通过调用JavaScript(如引用document.cookie），能尽可能减少黑客使用跨域脚本攻击（XSS）来”偷走”Cookie。(但仍存在被xss攻击泄露Cookie的可能)。 Same-Site属性 当用户从http://a.com发起http://b.com的请求也会携带上Cookie，从http://a.com携带过来的Cookie称为第三方Cookie。 为了防止CSRF（Cross-site request forgrey,跨站点请求伪造）攻击，可以使用SameSite属性。 123Set-Cookie: CookieName=CookieValue; SameSite=Lax; Set-Cookie: CookieName=CookieValue; SameSite=Strict; strict模式下：浏览器在任何跨域请求中都不会携带Cookie，这样可以有效的防御CSRF攻击，但是对于有多个子域名的网站采用主域名存储用户登录信息的场景，每个子域名都需要用户重新登录，造成用户体验非常的差。 本地cookie与内存cookie 本地cookie与内存cookie，区别在于cookie设置的expires字段。 如果没有设置过期时间,就是内存cookie, 随着浏览器的关闭而从内存中消失 如果设置了过期时间是未来的某一个时间点，那这个cookie就会以文本的形式保存在操作系统本地，待过期时间到了才会消失。 很多网站为了提升用户的体验，省去每次用户登陆的麻烦，采用本地cookie的方式，让用户可以在未来的一个月，或者半年，永久等时间段内不需要进行登陆操作。 这也意味着，用户被攻击的风险变大了。攻击者通过xss得到这样的本地cookie后，能够在未来很长一段时间内，甚至是永久控制这目标用户的账号权限。 然而，即使采用内存cookie也存在一定的风险，攻击者可以给内存cookie加一个过期时间，使其变成本地cookie，这样还是无法避免以上的安全问题。说到底，用户账号是否安全与服务器端校验有关，包括重要cookie的唯一性（是否可预测），完整性（是否被篡改），过期等校验。 参考: Web安全：你必须知道的“Cookie安全” 浅谈cookie安全","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"Go unsafe包","date":"2017-03-22T13:55:08.000Z","path":"2017/03/22/Go-unsafe包/","text":"src/unsafe路径下只有unsafe.go一个文件: unsafe.go: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file./* Package unsafe contains operations that step around the type safety of Go programs. Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.*/package unsafe// ArbitraryType is here for the purposes of documentation only and is not actually// part of the unsafe package. It represents the type of an arbitrary Go expression.type ArbitraryType int// Pointer represents a pointer to an arbitrary type. There are four special operations// available for type Pointer that are not available for other types:// - A pointer value of any type can be converted to a Pointer.// - A Pointer can be converted to a pointer value of any type.// - A uintptr can be converted to a Pointer.// - A Pointer can be converted to a uintptr.// Pointer therefore allows a program to defeat the type system and read and write// arbitrary memory. It should be used with extreme care.//// The following patterns involving Pointer are valid.// Code not using these patterns is likely to be invalid today// or to become invalid in the future.// Even the valid patterns below come with important caveats.//// Running \"go vet\" can help find uses of Pointer that do not conform to these patterns,// but silence from \"go vet\" is not a guarantee that the code is valid.//// (1) Conversion of a *T1 to Pointer to *T2.//// Provided that T2 is no larger than T1 and that the two share an equivalent// memory layout, this conversion allows reinterpreting data of one type as// data of another type. An example is the implementation of// math.Float64bits://// func Float64bits(f float64) uint64 &#123;// return *(*uint64)(unsafe.Pointer(&amp;f))// &#125;//// (2) Conversion of a Pointer to a uintptr (but not back to Pointer).//// Converting a Pointer to a uintptr produces the memory address of the value// pointed at, as an integer. The usual use for such a uintptr is to print it.//// Conversion of a uintptr back to Pointer is not valid in general.//// A uintptr is an integer, not a reference.// Converting a Pointer to a uintptr creates an integer value// with no pointer semantics.// Even if a uintptr holds the address of some object,// the garbage collector will not update that uintptr's value// if the object moves, nor will that uintptr keep the object// from being reclaimed.//// The remaining patterns enumerate the only valid conversions// from uintptr to Pointer.//// (3) Conversion of a Pointer to a uintptr and back, with arithmetic.//// If p points into an allocated object, it can be advanced through the object// by conversion to uintptr, addition of an offset, and conversion back to Pointer.//// p = unsafe.Pointer(uintptr(p) + offset)//// The most common use of this pattern is to access fields in a struct// or elements of an array://// // equivalent to f := unsafe.Pointer(&amp;s.f)// f := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))//// // equivalent to e := unsafe.Pointer(&amp;x[i])// e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x[0])) + i*unsafe.Sizeof(x[0]))//// It is valid both to add and to subtract offsets from a pointer in this way.// It is also valid to use &amp;^ to round pointers, usually for alignment.// In all cases, the result must continue to point into the original allocated object.//// Unlike in C, it is not valid to advance a pointer just beyond the end of// its original allocation://// // INVALID: end points outside allocated space.// var s thing// end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))//// // INVALID: end points outside allocated space.// b := make([]byte, n)// end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n))//// Note that both conversions must appear in the same expression, with only// the intervening arithmetic between them://// // INVALID: uintptr cannot be stored in variable// // before conversion back to Pointer.// u := uintptr(p)// p = unsafe.Pointer(u + offset)//// Note that the pointer must point into an allocated object, so it may not be nil.//// // INVALID: conversion of nil pointer// u := unsafe.Pointer(nil)// p := unsafe.Pointer(uintptr(u) + offset)//// (4) Conversion of a Pointer to a uintptr when calling syscall.Syscall.//// The Syscall functions in package syscall pass their uintptr arguments directly// to the operating system, which then may, depending on the details of the call,// reinterpret some of them as pointers.// That is, the system call implementation is implicitly converting certain arguments// back from uintptr to pointer.//// If a pointer argument must be converted to uintptr for use as an argument,// that conversion must appear in the call expression itself://// syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))//// The compiler handles a Pointer converted to a uintptr in the argument list of// a call to a function implemented in assembly by arranging that the referenced// allocated object, if any, is retained and not moved until the call completes,// even though from the types alone it would appear that the object is no longer// needed during the call.//// For the compiler to recognize this pattern,// the conversion must appear in the argument list://// // INVALID: uintptr cannot be stored in variable// // before implicit conversion back to Pointer during system call.// u := uintptr(unsafe.Pointer(p))// syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))//// (5) Conversion of the result of reflect.Value.Pointer or reflect.Value.UnsafeAddr// from uintptr to Pointer.//// Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr// instead of unsafe.Pointer to keep callers from changing the result to an arbitrary// type without first importing \"unsafe\". However, this means that the result is// fragile and must be converted to Pointer immediately after making the call,// in the same expression://// p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))//// As in the cases above, it is invalid to store the result before the conversion://// // INVALID: uintptr cannot be stored in variable// // before conversion back to Pointer.// u := reflect.ValueOf(new(int)).Pointer()// p := (*int)(unsafe.Pointer(u))//// (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer.//// As in the previous case, the reflect data structures SliceHeader and StringHeader// declare the field Data as a uintptr to keep callers from changing the result to// an arbitrary type without first importing \"unsafe\". However, this means that// SliceHeader and StringHeader are only valid when interpreting the content// of an actual slice or string value.//// var s string// hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1// hdr.Data = uintptr(unsafe.Pointer(p)) // case 6 (this case)// hdr.Len = n//// In this usage hdr.Data is really an alternate way to refer to the underlying// pointer in the string header, not a uintptr variable itself.//// In general, reflect.SliceHeader and reflect.StringHeader should be used// only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual// slices or strings, never as plain structs.// A program should not declare or allocate variables of these struct types.//// // INVALID: a directly-declared header will not hold Data as a reference.// var hdr reflect.StringHeader// hdr.Data = uintptr(unsafe.Pointer(p))// hdr.Len = n// s := *(*string)(unsafe.Pointer(&amp;hdr)) // p possibly already lost//type Pointer *ArbitraryType// Sizeof takes an expression x of any type and returns the size in bytes// of a hypothetical variable v as if v was declared via var v = x.// The size does not include any memory possibly referenced by x.// For instance, if x is a slice, Sizeof returns the size of the slice// descriptor, not the size of the memory referenced by the slice.// The return value of Sizeof is a Go constant.func Sizeof(x ArbitraryType) uintptr// Offsetof returns the offset within the struct of the field represented by x,// which must be of the form structValue.field. In other words, it returns the// number of bytes between the start of the struct and the start of the field.// The return value of Offsetof is a Go constant.func Offsetof(x ArbitraryType) uintptr// Alignof takes an expression x of any type and returns the required alignment// of a hypothetical variable v as if v was declared via var v = x.// It is the largest value m such that the address of v is always zero mod m.// It is the same as the value returned by reflect.TypeOf(x).Align().// As a special case, if a variable s is of struct type and f is a field// within that struct, then Alignof(s.f) will return the required alignment// of a field of that type within a struct. This case is the same as the// value returned by reflect.TypeOf(s.f).FieldAlign().// The return value of Alignof is a Go constant.func Alignof(x ArbitraryType) uintptr 只有函数的签名和类型定义，但没有实现的代码：无论是 Go(go:linkname方式) 还是汇编的代码(如byteag里面的xx就是汇编代码实现)都没有。之所以如此，是因为 unsafe 包的功能需要在层次更低的编译器层面实现，所以这个包其实是内置在编译器里面实现的，unsafe.go这个文件只是为了达到文档记录的目的。 将注释移除,其实只有以下这几个函数和类型 1234567package unsafefunc Alignof(x ArbitraryType) uintptrfunc Offsetof(x ArbitraryType) uintptrfunc Sizeof(x ArbitraryType) uintptrtype ArbitraryTypetype Pointer 其中 ArbitraryType 类型只是为了文档记录的目的而存在，实际并没有参与到 unsafe 包的实现。这个类型代表了任意的 Go 语言表达式。 所以实际上 unsafe 包就只包含三个函数和一个类型 func Sizeof(x ArbitraryType) uintptr 12345678910111213141516package mainimport ( \"fmt\" \"unsafe\")type X struct &#123; n1 int16 n2 int16&#125;func main() &#123; fmt.Println(unsafe.Sizeof(X&#123;&#125;))&#125; 输出: 4 X 结构体有两个字段，其中每一个都占 2 个字节，所以整个结构体占用 size(n1) + size(n2) + size(X) = 2 + 2 + 0 = 4 func Offsetof(x ArbitraryType) uintptr 返回的是 offset（偏移值） 1234567891011121314151617package mainimport ( \"fmt\" \"unsafe\")type X struct &#123; n1 int16 n2 int16&#125;func main() &#123; fmt.Println(unsafe.Offsetof(X&#123;&#125;.n1)) fmt.Println(unsafe.Offsetof(X&#123;&#125;.n2))&#125; 输出: 0 2 func Alignof(x ArbitraryType) uintptr 各种数据类型在内存中的结构 有关内存对齐 12345678910111213141516package mainimport ( \"fmt\" \"unsafe\")type X struct &#123; n1 int8 n2 int16&#125;func main() &#123; fmt.Println(unsafe.Sizeof(X&#123;&#125;))&#125; 输出 4 为什么不是3? 由于 alignment 机制的要求，n2 的内存起始地址应该是自身大小的整数倍，也就是说它的起始地址只能是 0、2、4、6、8 等偶数，所以 n2 的起始地址没有紧接着 n1 后面，而是空出了 1 个字节。最后导致结构体 X 的大小是 4 而不是 3。机智的读者可能会想到：n1 和 n2 换个位置会怎样呢？这样一来，n2 的起始地址是 0，而 n1 的其实地址是 2，这么一来结构体 X 的大小就变成 3 了吧？答案是……不对的。原因还是因为 alignment，因为 alignment 除了要求字段的其实地址应该是自身大小的整数倍，还要求整个结构体的大小，是结构体中最大的字段的大小的整数倍，这使得结构体可以由多个内存块组成，其中每个内存块的大小都等于最大的字段的大小。可以利用这个tips来减少结构体的内存占用 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"unsafe\")type First struct &#123; a int8 b int64 c int8&#125;type Second struct &#123; a int8 c int8 b int64&#125;func main() &#123; fmt.Println(unsafe.Sizeof(First&#123;&#125;), unsafe.Sizeof(Second&#123;&#125;))&#125; 输出为: 24 16 上面两个结构体大小不同，是因为 First 结构体由三个大小为 8 字节的内存块组成：Sizeof(First.a) + 7 个空闲的字节 + Sizeof(First.b) + Sizeof(First.c) + 7 个空闲的字节 = 24 字节; 而 Second 结构体只包含 2 个 大小为 8 字节的内存块：Sizeof(Second.a) + Sizeof(Second.b) + 6 个空闲的字节 + Sizeof(Second.b) = 16 字节。下次定义结构体的时候可以用上这个小知识(让占空间大的类型尽可能在后面) 总结这三个函数的用法 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"unsafe\")func main() &#123; fmt.Println(\"Size of x: \", unsafe.Sizeof(x)) fmt.Println(\"Size of x.c: \", unsafe.Sizeof(x.c)) fmt.Println(\"Alignment of x.a: \", unsafe.Alignof(x.a)) fmt.Println(\"Alignment of x.b: \", unsafe.Alignof(x.b)) fmt.Println(\"Alignment of x.c: \", unsafe.Alignof(x.c)) fmt.Println(\"\\nOffset of x.a: \", unsafe.Offsetof(x.a)) fmt.Println(\"Offset of x.b: \", unsafe.Offsetof(x.b)) fmt.Println(\"Offset of x.c: \", unsafe.Offsetof(x.c))&#125;var x struct &#123; a int64 b bool c string&#125; 输出为: 123456789Size of x: 32Size of x.c: 16Alignment of x.a: 8Alignment of x.b: 1Alignment of x.c: 8Offset of x.a: 0Offset of x.b: 8Offset of x.c: 16 这三个方法都是在编译期执行的，这意味着只要编译器没有报错，在运行时也不会有问题发生 而 unsafe.Pointer则不然,有可能会发生运行时错误 type Pointer Golang 语言中的非类型安全指针 参考: 灵魂一问：unsafe 包真的不安全吗？","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go database/sql代码解读","date":"2017-03-21T06:22:38.000Z","path":"2017/03/21/Go-database-sql代码解读/","text":"sql 库的 prepare 行为设计得真脑残啊 https://juejin.cn/post/6844903843969368072 https://xie.infoq.cn/article/c705a7821cb0d63f8bd381276 http://xiaorui.cc/archives/5771","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Go Race Detector","date":"2017-03-20T16:30:21.000Z","path":"2017/03/21/Go-Race-Detector/","text":"竞态: 无任何同步保护下,并行读写同一份数据(即 同一个变量。 读写指有写的同时还有其它读或者写，都是读则不算） 多个goroutine 并发读写同一个变量，需要加锁，这应该是天经地义的常识！ 竞态检测 Go在1.1之后引入了竞争检测可使用go run -race xxx.gogo build -race xxx.gogo test -race xxx.go来进行竞争检测 demo.go:1234567891011121314151617package mainimport ( \"fmt\" \"time\")func main() &#123; a := 222 go func() &#123; a = 666 &#125;() a = 888 fmt.Println(\"a is \", a) time.Sleep(2 * time.Second)&#125; go func触发的goroutine和主goroutine都可能对a进行修改 go run -race demo.go: 123456789101112131415161718a is 888==================WARNING: DATA RACEWrite at 0x00c0000ba008 by goroutine 7: main.main.func1() /Users/fliter/go/src/shuang/racee/demo.go:11 +0x28Previous write at 0x00c0000ba008 by main goroutine: main.main() /Users/fliter/go/src/shuang/racee/demo.go:13 +0x70Goroutine 7 (running) created at: main.main() /Users/fliter/go/src/shuang/racee/demo.go:10 +0x64==================Found 1 data race(s)exit status 66 输出Warning: goroutine7运行到第11行和main的goroutine运行到第13行时触发竞争 且goroutine7是在第10行的时候产生的 race的内部实现大概是同时开启多个goroutine执行同一个命令，且纪录每个变量的状态(值)开启-race, 内存会增加5到10倍,执行时间增加2到20倍所以不要在正式环境使用~ 另一个demo： 1234567891011121314151617package mainimport \"fmt\"func main() &#123; c := make(chan bool) m := make(map[string]string) go func() &#123; m[\"1\"] = \"a\" // First conflicting access. c &lt;- true &#125;() m[\"2\"] = \"b\" // Second conflicting access. &lt;-c for k, v := range m &#123; fmt.Println(k, v) &#125;&#125; go run -race demo2.go: 12345678910111213141516171819202122==================WARNING: DATA RACEWrite at 0x00c0000a4180 by goroutine 7: runtime.mapaccess2_faststr() /usr/local/go/src/runtime/map_faststr.go:107 +0x48c main.main.func1() /Users/fliter/go/src/shuang/racee/demo2.go:9 +0x48Previous write at 0x00c0000a4180 by main goroutine: runtime.mapaccess2_faststr() /usr/local/go/src/runtime/map_faststr.go:107 +0x48c main.main() /Users/fliter/go/src/shuang/racee/demo2.go:12 +0x9cGoroutine 7 (running) created at: main.main() /Users/fliter/go/src/shuang/racee/demo2.go:8 +0x70==================1 a2 bFound 1 data race(s)exit status 66 只有并发读，会不会有问题？ 并发读取，而没有写操作，是不会有问题的！ go run -race racee.go: 12345678910111213141516171819package mainfunc main() &#123; aa := make(map[int]int) go func() &#123; for &#123; aa[0] = 5 //_ = aa[2] &#125; &#125;() go func() &#123; for &#123; _ = aa[1] &#125; &#125;()&#125; 12345678910111213141516171819202122232425==================WARNING: DATA RACERead at 0x00c00009a000 by goroutine 7: runtime.evacuate_fast32() /usr/local/go/src/runtime/map_fast32.go:373 +0x37c main.main.func2() /Users/fliter/go/src/run/racee.go:15 +0x3cPrevious write at 0x00c00009a000 by goroutine 6: runtime.mapaccess1_fast64() /usr/local/go/src/runtime/map_fast64.go:12 +0x1ec main.main.func1() /Users/fliter/go/src/run/racee.go:8 +0x38Goroutine 7 (running) created at: main.main() /Users/fliter/go/src/run/racee.go:13 +0x64Goroutine 6 (running) created at: main.main() /Users/fliter/go/src/run/racee.go:6 +0x44==================fatal error: concurrent map read and map writeFound 1 data race(s)exit status 66 而改为: 12345678910111213141516171819package mainfunc main() &#123; aa := make(map[int]int) go func() &#123; for &#123; //aa[0] = 5 _ = aa[2] &#125; &#125;() go func() &#123; for &#123; _ = aa[1] &#125; &#125;()&#125; 则没有任何问题 参考： Go语言是如何实现race detect的 谈谈 Golang 中的 Data Race golang中的race检测 golang工具race - 检测非法竞态访问数据","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"查看数据库字段&索引简明信息的工具","date":"2017-03-14T04:55:30.000Z","path":"2017/03/14/查看数据库字段-索引简明信息的工具/","text":"项目地址 在线预览 可以快速查看数据库中各表的字段名/字段类型/默认值及描述 可以快速查看各字段是否有索引及索引名称,类型等相关信息 所需环境: php 5.6以上 mysql 5.1及以上 nginx 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?php$title = \" &lt;tr&gt; &lt;td width=\\\"180\\\"&gt;字段名 &lt;/td&gt; &lt;td width=\\\"160\\\"&gt;字段类型&lt;/td&gt; &lt;td width=\\\"80\\\"&gt;可否为空&lt;/td&gt; &lt;td width=\\\"80\\\"&gt;Key&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;默认值&lt;/td&gt; &lt;td&gt;字段描述&lt;/td&gt; &lt;/tr&gt;\";$indexTitle = \" &lt;tr&gt; &lt;td width=\\\"60\\\"&gt;COLUMN_NAME&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;NON_UNIQUE&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;INDEX_NAME&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;SEQ_IN_INDEX&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;COLLATION&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;CARDINALITY&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;SUB_PART&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;PACKED&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;NULLABLE&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;INDEX_TYPE&lt;/td&gt; &lt;/tr&gt;\";const HOST = \"\";const DBNAME = \"\";const USER = \"\";const PASSWORD = \"\";$pdo = new PDO(\"mysql:host=118.126.97.71;dbname=daohang\", USER, PASSWORD);$pdo-&gt;query('set names utf8');$pdo-&gt;query('use information_schema');$allTablesSql = 'SELECT table_name name,TABLE_COMMENT value FROM INFORMATION_SCHEMA.TABLES WHERE table_type=\\'base table\\' and table_schema = \\'daohang\\' order by table_name asc';$query = $pdo-&gt;query($allTablesSql);$rs = $query-&gt;fetchAll();$allTablesRecordSql = 'select table_name,table_rows from tables where TABLE_SCHEMA = \\'daohang\\' order by table_rows desc; ';$query2 = $pdo-&gt;query($allTablesRecordSql);$rs2 = $query2-&gt;fetchAll();//获取表名和记录数的对应关系$recordArr = [];foreach ($rs2 as $tableInfo) &#123; $tableName = $tableInfo[\"table_name\"]; $tableRows = $tableInfo[\"table_rows\"]; $recordArr[$tableName] = $tableRows;&#125;//获取表名和索引的对应关系$allTablesIndexSql = ' SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = \\'daohang\\'; ';$query3 = $pdo-&gt;query($allTablesIndexSql);$rs3 = $query3-&gt;fetchAll();//获取表名和索引的对应关系,三维数组,键名是表名,键值是个二维数组,里面是这张表所有的索引$indexArr = [];foreach ($rs as $one) &#123; $tName = $one[\"name\"]; $indexArr[$tName] = [];&#125;foreach ($rs3 as $item) &#123; $tNameWithIndex = $item[\"TABLE_NAME\"]; array_push($indexArr[$tNameWithIndex], $item);&#125;$pdo-&gt;query('use daohang;');$html = '';foreach ($rs as $v) &#123; $sql = \"show full columns from `$v[name]` \"; $query = $pdo-&gt;query($sql); $tableData = $query-&gt;fetchAll(); $count = count($tableData); if (empty($v['value'])) &#123; $v['value'] = '无'; &#125; $recordNum = $recordArr[$v['name']]; $head = \"&lt;table class=\\\"tablelist\\\" style=\\\"margin:20px 0 0 20px; width:1200px;\\\"&gt; &lt;tr&gt;&lt;td colspan=\\\"10\\\" style=\\\"font-weight: bold; background:#abcbbb; \\\"&gt; 表：[ $v[name] ] &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp 描述: &amp;nbsp &lt;font color='blue'&gt;$v[value] &lt;/font&gt; &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp 行数: &amp;nbsp &lt;font color='purple'&gt;$recordNum &lt;/font&gt; &lt;/td&gt;&lt;/tr&gt;\"; $indexHead = \"&lt;table class=\\\"tablelist\\\" style=\\\"margin:20px 0 0 20px; width: 1200px;\\\"&gt; &lt;tr&gt;&lt;td height=\\\"3px\\\" colspan=\\\"10\\\" style=\\\"font-weight: bold; background:salmon; \\\"&gt; &lt;font color='purple' size='1px'&gt;&amp;nbsp;&lt;a href='https://blog.csdn.net/itas109/article/details/82879397' target='_blank'&gt;索引信息:&lt;/a&gt; &lt;/font&gt; &lt;/td&gt;&lt;/tr&gt;\"; $fenge = \"&lt;table class=\\\"tablelist\\\" style=\\\"margin:20px 0 0 20px; width: 1200px;\\\"&gt; &lt;tr&gt;&lt;td height=\\\"3px\\\" colspan=\\\"10\\\" style=\\\"font-weight: bold; background:scroll; \\\"&gt; &lt;font color='#1e90ff' size='1px'&gt;&amp;nbsp;&lt;HR SIZE=1&gt; &lt;/font&gt; &lt;/td&gt;&lt;/tr&gt;\"; //html画实线https://blog.csdn.net/lance_lot1/article/details/7921441 $str = ''; foreach ($tableData as $key =&gt; $item) &#123; $field = $item['Field']; $type = $item['Type']; $is_null = $item['Null']; $key = empty($item['Key']) ? \"&amp;nbsp;- \" : \"&lt;font color='#6a5acd'&gt;\" . $item['Key'] . \"&lt;/font&gt;\"; $default = empty($item['Default']) ? '无' : \"&lt;font color='#daa520'&gt;\" . $item['Default'] . \"&lt;/font&gt;\"; $comment = empty($item['Comment']) ? '无' : \"&lt;font color='red'&gt;\" . $item['Comment'] . \"&lt;/font&gt;\"; $body = \"&lt;tr&gt; &lt;td width=\\\"180\\\"&gt;$field&lt;/td&gt; &lt;td width=\\\"160\\\"&gt;$type&lt;/td&gt; &lt;td width=\\\"80\\\"&gt;$is_null&lt;/td&gt; &lt;td width=\\\"80\\\"&gt;$key&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$default&lt;/td&gt; &lt;td&gt;$comment&lt;/td&gt; &lt;/tr&gt;\"; $str .= $body; //字段信息(如类型,可否为空,备注等) &#125; $tableIndex = $indexArr[$v[\"name\"]]; //单张表的所有索引信息,二维数组 $indexStr = \"\"; foreach ($tableIndex as $itemIndex) &#123; $body = \"&lt;tr&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[COLUMN_NAME]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[NON_UNIQUE]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[INDEX_NAME]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[SEQ_IN_INDEX]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[COLLATION]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[CARDINALITY]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[SUB_PART]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[PACKED]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[NULLABLE]&lt;/td&gt; &lt;td width=\\\"60\\\"&gt;$itemIndex[INDEX_TYPE]&lt;/td&gt; &lt;/tr&gt;\"; $indexStr .= $body; &#125; $html .= $head . $title . $str . $indexHead . $indexTitle . $indexStr . $fenge;&#125;echo $html;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"PHP","slug":"PHP","permalink":"http://www.dashen.tech/tags/PHP/"}]},{"title":"使用pstree,查看进程树","date":"2017-03-11T11:20:39.000Z","path":"2017/03/11/使用pstree-查看进程树/","text":"在我的腾讯云CVM服务器上: pstree 查看进程树 pstree 1234567891011121314151617181920212223242526272829303132333435363738394041systemd─┬─YDLive───&#123;YDLive&#125; ├─YDService───12*[&#123;YDService&#125;] ├─accounts-daemon─┬─&#123;gdbus&#125; │ └─&#123;gmain&#125; ├─acpid ├─2*[agetty] ├─atd ├─barad_agent─┬─barad_agent │ └─barad_agent───3*[&#123;barad_agent&#125;] ├─containerd─┬─containerd-shim─┬─teacher───3*[&#123;teacher&#125;] │ │ └─10*[&#123;containerd-shim&#125;] │ └─9*[&#123;containerd&#125;] ├─cron ├─dbus-daemon ├─dockerd─┬─docker-proxy───5*[&#123;docker-proxy&#125;] │ └─9*[&#123;dockerd&#125;] ├─gunicorn───gunicorn───&#123;gunicorn&#125; ├─2*[iscsid] ├─lvmetad ├─mdadm ├─mongod───9*[&#123;mongod&#125;] ├─mysqld───28*[&#123;mysqld&#125;] ├─named───3*[&#123;named&#125;] ├─nginx───nginx ├─ntpd ├─php-fpm7.2───3*[php-fpm7.2] ├─polkitd─┬─&#123;gdbus&#125; │ └─&#123;gmain&#125; ├─python───4*[&#123;python&#125;] ├─rsyslogd─┬─&#123;in:imklog&#125; │ ├─&#123;in:imuxsock&#125; │ └─&#123;rs:main Q:Reg&#125; ├─sgagent───&#123;sgagent&#125; ├─shuang───4*[&#123;shuang&#125;] ├─sshd───sshd───sshd───bash───pstree ├─systemd───(sd-pam) ├─systemd-journal ├─systemd-logind ├─systemd-udevd ├─unattended-upgr───&#123;gmain&#125; └─uuidd pstree -p 查看进程树，并打印每个进程的PID pstree -p 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131systemd(1)─┬─YDLive(23458)───&#123;YDLive&#125;(23488) ├─YDService(23429)─┬─&#123;YDService&#125;(23467) │ ├─&#123;YDService&#125;(23468) │ ├─&#123;YDService&#125;(23469) │ ├─&#123;YDService&#125;(23750) │ ├─&#123;YDService&#125;(23751) │ ├─&#123;YDService&#125;(23762) │ ├─&#123;YDService&#125;(23763) │ ├─&#123;YDService&#125;(23764) │ ├─&#123;YDService&#125;(23765) │ ├─&#123;YDService&#125;(23766) │ ├─&#123;YDService&#125;(23767) │ └─&#123;YDService&#125;(23769) ├─accounts-daemon(1011)─┬─&#123;gdbus&#125;(1098) │ └─&#123;gmain&#125;(1077) ├─acpid(1099) ├─agetty(1314) ├─agetty(1320) ├─atd(1123) ├─barad_agent(2068)─┬─barad_agent(2074) │ └─barad_agent(2075)─┬─&#123;barad_agent&#125;(2086) │ └─&#123;barad_agent&#125;(2091) ├─containerd(1160)─┬─containerd-shim(1925)─┬─teacher(1942)─┬─&#123;teacher&#125;(2009) │ │ │ ├─&#123;teacher&#125;(2010) │ │ │ └─&#123;teacher&#125;(2011) │ │ ├─&#123;containerd-shim&#125;(1926) │ │ ├─&#123;containerd-shim&#125;(1927) │ │ ├─&#123;containerd-shim&#125;(1928) │ │ ├─&#123;containerd-shim&#125;(1929) │ │ ├─&#123;containerd-shim&#125;(1930) │ │ ├─&#123;containerd-shim&#125;(1931) │ │ ├─&#123;containerd-shim&#125;(1932) │ │ ├─&#123;containerd-shim&#125;(1933) │ │ ├─&#123;containerd-shim&#125;(1987) │ │ └─&#123;containerd-shim&#125;(2043) │ ├─&#123;containerd&#125;(1359) │ ├─&#123;containerd&#125;(1360) │ ├─&#123;containerd&#125;(1361) │ ├─&#123;containerd&#125;(1386) │ ├─&#123;containerd&#125;(1387) │ ├─&#123;containerd&#125;(1403) │ ├─&#123;containerd&#125;(1404) │ ├─&#123;containerd&#125;(1427) │ └─&#123;containerd&#125;(19570) ├─cron(1128) ├─dbus-daemon(1052) ├─dockerd(1189)─┬─docker-proxy(1918)─┬─&#123;docker-proxy&#125;(1919) │ │ ├─&#123;docker-proxy&#125;(1920) │ │ ├─&#123;docker-proxy&#125;(1921) │ │ ├─&#123;docker-proxy&#125;(1922) │ │ └─&#123;docker-proxy&#125;(1923) │ ├─&#123;dockerd&#125;(1378) │ ├─&#123;dockerd&#125;(1379) │ ├─&#123;dockerd&#125;(1380) │ ├─&#123;dockerd&#125;(1428) │ ├─&#123;dockerd&#125;(1542) │ ├─&#123;dockerd&#125;(1543) │ ├─&#123;dockerd&#125;(1547) │ ├─&#123;dockerd&#125;(1566) │ └─&#123;dockerd&#125;(1567) ├─gunicorn(1376)───gunicorn(1840)───&#123;gunicorn&#125;(1924) ├─iscsid(1153) ├─iscsid(1154) ├─lvmetad(427) ├─mdadm(1277) ├─mongod(1009)─┬─&#123;mongod&#125;(1353) │ ├─&#123;mongod&#125;(1354) │ ├─&#123;mongod&#125;(1355) │ ├─&#123;mongod&#125;(1565) │ ├─&#123;mongod&#125;(1568) │ ├─&#123;mongod&#125;(1574) │ ├─&#123;mongod&#125;(1575) │ ├─&#123;mongod&#125;(1576) │ └─&#123;mongod&#125;(1577) ├─mysqld(30985)─┬─&#123;mysqld&#125;(30995) │ ├─&#123;mysqld&#125;(30996) │ ├─&#123;mysqld&#125;(30997) │ ├─&#123;mysqld&#125;(30998) │ ├─&#123;mysqld&#125;(30999) │ ├─&#123;mysqld&#125;(31000) │ ├─&#123;mysqld&#125;(31001) │ ├─&#123;mysqld&#125;(31002) │ ├─&#123;mysqld&#125;(31003) │ ├─&#123;mysqld&#125;(31004) │ ├─&#123;mysqld&#125;(31005) │ ├─&#123;mysqld&#125;(31006) │ ├─&#123;mysqld&#125;(31008) │ ├─&#123;mysqld&#125;(31009) │ ├─&#123;mysqld&#125;(31010) │ ├─&#123;mysqld&#125;(31011) │ ├─&#123;mysqld&#125;(31012) │ ├─&#123;mysqld&#125;(31013) │ ├─&#123;mysqld&#125;(31014) │ ├─&#123;mysqld&#125;(31015) │ ├─&#123;mysqld&#125;(31016) │ ├─&#123;mysqld&#125;(31017) │ ├─&#123;mysqld&#125;(31018) │ ├─&#123;mysqld&#125;(31019) │ ├─&#123;mysqld&#125;(31022) │ ├─&#123;mysqld&#125;(31023) │ ├─&#123;mysqld&#125;(31024) │ └─&#123;mysqld&#125;(6445) ├─named(1046)─┬─&#123;named&#125;(1074) │ ├─&#123;named&#125;(1075) │ └─&#123;named&#125;(1076) ├─nginx(10919)───nginx(7623) ├─ntpd(1455) ├─php-fpm7.2(1100)─┬─php-fpm7.2(1488) │ ├─php-fpm7.2(31760) │ └─php-fpm7.2(31762) ├─polkitd(1184)─┬─&#123;gdbus&#125;(1200) │ └─&#123;gmain&#125;(1198) ├─python(1520)─┬─&#123;python&#125;(1536) │ ├─&#123;python&#125;(1537) │ ├─&#123;python&#125;(1539) │ └─&#123;python&#125;(1540) ├─rsyslogd(1018)─┬─&#123;in:imklog&#125;(1072) │ ├─&#123;in:imuxsock&#125;(1071) │ └─&#123;rs:main Q:Reg&#125;(1073) ├─sgagent(2056)───&#123;sgagent&#125;(2057) ├─shuang(8155)─┬─&#123;shuang&#125;(8156) │ ├─&#123;shuang&#125;(8157) │ ├─&#123;shuang&#125;(8158) │ └─&#123;shuang&#125;(24887) ├─sshd(1141)───sshd(660)───sshd(727)───bash(731)───pstree(3190) ├─systemd(3179)───(sd-pam)(3185) ├─systemd-journal(390) ├─systemd-logind(1118) ├─systemd-udevd(460) ├─unattended-upgr(1183)───&#123;gmain&#125;(1429) └─uuidd(1579) pstree -p &lt;pid&gt; 查看某个进程树型结构 pstree -p 1189 123456789101112131415dockerd(1189)─┬─docker-proxy(1918)─┬─&#123;docker-proxy&#125;(1919) │ ├─&#123;docker-proxy&#125;(1920) │ ├─&#123;docker-proxy&#125;(1921) │ ├─&#123;docker-proxy&#125;(1922) │ └─&#123;docker-proxy&#125;(1923) ├─&#123;dockerd&#125;(1378) ├─&#123;dockerd&#125;(1379) ├─&#123;dockerd&#125;(1380) ├─&#123;dockerd&#125;(1428) ├─&#123;dockerd&#125;(1542) ├─&#123;dockerd&#125;(1543) ├─&#123;dockerd&#125;(1547) ├─&#123;dockerd&#125;(1566) └─&#123;dockerd&#125;(1567) pstree -p 1378 1&#123;dockerd&#125;(1378)","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"使用Wireshark分析Redis协议","date":"2017-03-04T15:04:30.000Z","path":"2017/03/04/使用Wireshark分析Redis协议/","text":"https://www.cnblogs.com/atwanli/articles/5163420.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"使用Wireshark,探究Redis的PipeLine","date":"2017-03-02T15:56:47.000Z","path":"2017/03/02/使用Wireshark-探究Redis的PipeLine/","text":"先导篇 可使用brew install redis安装redis服务，安装完成后通过redis-server启动redis服务 使用 redis-cli启动(并连接)redis客户端 (因为都在一台机器上； 如果redis服务端在远程的机器上，则连接命令为redis-cli -h host -p port -a password) 理论篇 redis的客户端和服务端在马路南北，客户端发送get，set等命令，通过马路到达对岸的服务端去执行。原来每次只能发送一个命令，有了pipeline，可以一次发送多个命令。 即只用过一次马路，省了多个命令来回过马路的时间。 当马路比较差，车比较多(网络环境较差)时，pipeline的优势非常非常大~ 但也引入了新的问题。即原来单条指令如get，set，都是原子性的。但组合在一起，就不是原子性的了。这样就可能出现一批命令，有的成功有的失败的情况。redis提供了简单事务，把要一起执行的命令放到multi和exec命令之间.其中multi代表事务开始，exec代表事务结束 Redis中的管道（PipeLine）与事物（Transactions） Redis系列十：Pipeline详解 实践篇 \u0002​‎本​⁢机⁢​‎启​一\u0002‍​‌⁠个⁢\u0002⁢‌​server，再⁡启​‍⁣‏\u0002一个client进⁡‏‌⁢\u0002行‎一‌​些​‌‍set/get操\u0002⁠作‎​。 启动Wireshark, 在‏‌en0网卡上⁢‌过滤\u0002tcp.port==6379，会发现无结果。 如‍果\u0002‏\u0002⁡​redis的​⁣‏‌server和⁡client都‍在‌​\u0002⁣本‌机‍​，则‌‎\u0002​​一⁠‍​进Wireshark选网⁢⁡卡⁣⁡‍‎​时⁣‌，应该‏‎‎用​​‌loopback 1234567891011简述几个过滤规则：1、ip过滤：目标ip过滤：ip.dst==172.18.8.11,源ip地址过滤：ip.src==192.168.1.12;2、端口过滤：tcp.port==80，这条规则是把源端口和目的端口为80的都过滤出来。使用tcp.dstport==80只过滤目的端口为80的，tcp.srcport==80只过滤源端口为80的包；3、协议过滤：直接在fiter框中输入协议名称即可，如：http，tcp，udp，...4、http模式过滤:过滤get包，http.request.method==\"GET\",过滤post包，http.request.method==\"POST\"；5、如果使用多条件过滤，则需要加连接符号，and。比如 ip.src==192.168.1.12 and http.request.method==\"POST\" and tcp.srcport==80 PSH代表带有数据的包 ^1 客户端对redis服务器进行多次请求: 使用管道模式,单次发送多个命令: 如果是这样，依然是每一个命令发送一次请求 可参考此文，使用 (echo -en &quot;PING\\r\\n SET runoobkey redis\\r\\nGET runoobkey\\r\\nINCR visitor\\r\\nINCR visitor\\r\\nINCR visitor\\r\\n&quot;; sleep 10) | nc localhost 6379 (server端需启动，cli端不用启动)","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"软件设计","date":"2017-02-27T06:25:15.000Z","path":"2017/02/27/软件设计/","text":"1、内存又称主存，是CPU能直接寻址的存储空间，由半导体器件制成。CPU内外的高速缓存不属于主存，与主存容量无关，它是用来解决CPU与内存之间速度、容量不匹配的问题，容量相对于其他存储层次，量级较小。 2、系统的可靠性： 串联系统: $R = R_1 \\cdot R_2 \\cdot R_N$ 并联系统: $R = 1-(1-R_1) \\cdot (1-R_2) \\cdot (1-R_N)$ 3、流水线周期为执行时间最长的一段， 流水线计算公式: 一条指令执行时间 + (指令条数-1)*流水线周期 流水线相关问题 4、MIME是一个互联网标准，拓展了电子邮件标准，与安全无关。 MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型 PGP是一套用于信息加密、验证的应用程序.采用IDEA的散列算法作为加密与验证之用 PGP（Pretty Good Privacy，中文翻译“优良保密协议”） 5、公开密钥加密也称为非对称加密， 公开密钥加密（public-key cryptography）也称为非对称密钥加密（asymmetric cryptography），是一种密码学算法类型。该加密算法使用两个不同的密钥：加密密钥和解密密钥。(公钥加密,私钥解密) 常见的对称密钥加密算法：DES、3DES、RC-5、IDEA 对称加密(私钥加密体制)是发送者把密码和文件一起告诉接收方，使用同一套密钥，效率高，风险高 非对称加密使用的是两套公钥私钥，用接收方的公钥进行加密，接收方的私钥进行解密 数字签名用发送方的私钥签自己的名字，拿发送方的公钥来验证发送方的签名。 密钥加密技术和数字签名 6、Kerberos系统中可通过在报文中加入时间戳来防止重放攻击 7、外部实体一般为组织机构、人员、第三方系统 8、磁盘调度管理中，先进行移臂调度寻找磁道，再进行旋转调度寻找扇区 四种常用的磁盘调度算法 9、对N个数排序，最坏情况下时间复杂度最低的算法是归并排序算法 排序算法汇总 10、关键路径：持续时间加起来最长的那个, 关键路径上的活动没有总时差，可以根据关键路径上的活动求出最迟开始时间，然后反推出最迟完成时间，根据最早开始时间、持续时间、最早完成时间可以得出活动的总时差 11、编译器的工作过程划分为词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成、目标程序 几个阶段， 其中语法分析阶段的输入(词法分析阶段的输出)是记号流 12、对象图的对象名会有: 标识，并且对象图的关联关系一般不会出现多重度。 关联的多重度是指一个类的实例能够与另一个类的多少个实例相关联。 13、桥接设计模式将抽象部分与实现部分分离，属于结构型模式 14、在TCP/IP网络中，建立连接进行可靠通信是在运输层完成，此功能在OSI/RM中是在传输层来实现的 我理解的OSI网络模型和TCP/IP协议族 15、IPv4用32位二进制表示(即4个字节)，能够表示的地址空间是$2^{32}$ IPV6用128位二进制表示(即16个字节)，能够表示的地址空间是$2^{128}$ 即IPV6的地址空间是IPV4的 $2^{96}$ 倍 16、 最短移臂调度算法，即优先响应距离较近磁道的申请。 1、计算机执行指令的过程中，需要由CPU的控制器产生每条指令的操作信号并将信号送往相应的部件进行处理，以完成指定的操作 CPU的运算器只能完成运算，而控制器用于整个CPU的工作 2、DMA(直接主存存取) 是指 数据主存与I/0设备间(即主存与外设之间)直接成块传送 操作系统中常见缩略词翻译及简明释要 3、时间局部性是指程序中一条指令一旦被执行，则不久的将来可能再次被执行 空间局部性是指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问 4、在循环冗余校验CRC方法中，采用模2运算来构造校验位 CRC算法原理 5、RISC寻址方式比较单一，多寄存器寻址 6、应用级网关防火墙是内部网和外部网的隔离点 数据库防火墙部署于应用服务器和数据库之间 Web防火墙是入侵检测系统，入侵防御系统的一种 7、用户进行身份认证就是数字签名的认证，应使用发送方的公钥，数字证书中包含发送方公钥，使用数字签名来确保消息不可否认 8、震网病毒是一种 蠕虫病毒 9、数据流图建模应遵循:自顶向下、从抽象到具体的原则 10、符号表 在编译程序工作的过程中需要不断收集、记录和使用源程序中一些语法符号的类型和特征等相关信息。 11、要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置。体现了嵌入式操作系统的可定制性 12、极限编程(XP)先写测试代码，然后再编写程序 Extreme Programmingextreme英[ɪkˈstriːm]美[ɪkˈstriːm]adj. 极度的; 极大的; 异乎寻常的; 严重的; 严厉的; 极端的; 偏激的; 过分的;n. 极端不同的感情(或境况、行为方式等); 完全相反的事物; 极端; 极度; 极限;[例句]Don’t go doing anything extreme like leaving the country.千万不要做出诸如离开国家之类的极端行为。 13、在ISO/IEC9126软件质量模型中，软件质量特性 功能性 包含质量子特性安全性 14、聚合对象是指一个对象 包含其他对象 对象关系之聚合关系 UML类图 那一套 UML基础-类图-类之间的关系 15、在UML图中，部署图用于展示所交付系统中软件组件和硬件之间的物理关系 16、顺序图是一种交互图，它由一组对象或参与者以及它们之间可能发送的消息构成，展示了一个用例和多个对象的行为 17、观察者模式 适用于一对多对象依赖关系，当一个对象修改后，依赖它的对象都自动得到通知 迭代器模式 适用于访问一个聚合对象的内容而无须暴露它的内部表示 备忘录模式 适用于将对象的状态恢复到先前的状态 18、当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。这称为分布式数据库的可用性 19、具有4个节点的二叉树有14种 卡特兰数 leetcode-96 不同的二叉搜索树 n个节点的二叉树有多少种形态（Catalan数） 20、在Windows命令行窗口中使用ipconfig/all可以查看本机DHCP服务是否已启用 21、单代号网络图 求完成该项目的最少时间, 就是求它的关键路径,也就是持续时间加起来最长的 22、TCP和UDP协议均提供了端口寻址能力 1、CPU执行指令的过程中，会自动修改PC的内容， PC是指令计数器，用来存放将要执行的下一条指令。 指令寄存器(IR)存放即将执行的指令， 指令译码器(ID)对指令中的操作码字段进行分析和解释， 地址寄存器(AR)不是我们常用的CPU内部部件，其作用是用来保存当前CPU所要访问的内存单元或I/O设备的地址 操作系统中常见缩略词翻译及简明释要 2、在微机系统中，BIOS(基本输入输出系统)保存在主板上的ROM中 3、在计算机中，n位补码，表示的范围是负的$2^{n-1}$到正的$2^{n-1}-1$ 4、共享密钥加密指对称加密 加密和解密用同一个秘钥的方式,叫做共享秘钥加密(Common Key Crypto System),也称为对称秘钥加密 SSL（Secure Socket Layer）公开秘钥加密 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 HTTPS 的加密机制是混合秘钥 (即公开秘钥加密技术和共享秘钥加密技术结合) HTTPS 之共享秘钥 公钥 及 私钥 5、MD5是一种摘要算法，对任意长度的输入计算得到的结果长度为128位(即16字节) 1MD5 Message-Digest Algorithm 6、使用WEB方式收发电子邮件时必须设置账号密码登录 7、有可能无限期拥有的知识产权是商标权 8、结构化分析的输出不包括结构图 结构化方法的分析结果由以下几部分组成：一套分层的数据流图、一本数据词典、一组小说明（也称加工逻辑说明）、补充材料。 9、PV操作（含前驱图处理方法）记住P操作是申请资源，V操作是释放资源，弄清前驱图中的逻辑关系，给每个过程设置一个信号量，每次进行释放资源也就是V操作或者申请资源P操作去检查上一个进程是否已执行完成 10、模块化设计要求高内聚、低耦合。模块的大小要适中，模块的扇入扇出要合理。深度和宽度适当。 11、标记耦合：一组模块通过参数表传递记录信息，就是标记耦合。 这个记录是某一数据结构的子结构，而不是简单变量。其实传递的是这个数据结构的地址 12、 参数多态：应用广泛、最纯的多态。 包含多态：同样的操作可用于一个类型及其子类型。 强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。 过载多态：同一个名在不同的上下文中有不同的类型。 13、在分布式数据库中，分片透明是指用户或应用程序不需要知道逻辑上访问的表具体如何分块存储 14、 netstat 不能用于诊断DNS故障，它是控制台命令，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况 nslookup 是一个监测网络中DNS服务器是否能正确实现域名解析的命令行工具 PING 命令常用于测试连通性，在此过程中可看出是直接ping的目标地址 nslookup、ping、tracert 都可以加上一个主机域名作为其命令参数来诊断DNS故障 15、使用ADSL接入Internet，用户端需要安装PPPoE协议 1、浮点数对阶时，小阶向大阶对齐，同时将尾数右移n位(n为阶差的绝对值) 2、海明码公式: $ 2^r \\ge k + r + 1 $, k是原始信息码的位数，r是校验码的位数 海明校验码 3、流水线的吞吐率是最长流水段操作时间的倒数 流水线相关问题 4、《计算机软件保护条例》是由国务院颁布 5、数据字典 的条目不包括外部实体 6、Lisp是一种函数式编程语言 函数式编程语言 阮一峰-为什么Lisp语言如此先进？（译文） 和 指令式编程相比，函数式编程强调函数的计算比指令的执行重要。 和 过程化编程相比，函数式编程里函数的计算可随时调用。 函数式编程中最古老的例子莫过于1958年被创造出来的LISP了，透过 LISP，可以用精简的人力。较现代的例子包括Haskell、Clean、Erlang和Miranda等 7、若系统在将目录文件修改的结果写回磁盘时发生崩溃，则对系统的影响相对较大 系统目录就是指操作系统的主要文件存放的目录，目录中的文件直接影响到系统是否正常工作。 8、I/O设备管理软件一般分为四个层次，从上往下分别为设备无关I/O层、设备驱动程序、中断处理程序、硬件 9、软件维护工具不包括配置管理工具 10、耦合程度不取决于模块提供的功能数 11、路由器是工作在网络层的设备,交换机和网桥是数据链路层,中继器是工作在物理层上的连接设备 应表会传网数物 我理解的OSI网络模型和TCP/IP协议族 1、在程序的执行过程中，Cache与主存的地址映射是由硬件自动完成的 2、计算机系统的主存主要是由DRAM(动态随机存取存储器)构成的 3、海明码利用奇偶性进行检错和纠错，海明码既可检错又可纠错 4、HTTPS基于SSL安全协议，其默认端口是443 5、系统干涉属于典型被动攻击 6、后缀式和三地址码是常用的中间代码 7、某模块内涉及多个功能，这些功能必须以特定的次序执行，则该模块的内聚类型为过程内聚 8、UML类图通常不用于对对象快照进行建模 9、无向连通图不一定有边，但两个顶点之间有路径 10、25端口为SMTP，简单邮件传输协议，主要用于发送邮件，110端口为POP3负责邮件收取 11、现需要对一个基本有序的数组进行排序。此时最适宜采用的算法为插入排序算法，时间复杂度为O(n) 1、累加器用来暂时存放算术逻辑运算部件ALU运算的结果信息 2、当采用DMA方式时，不需要CPU执行程序指令来传送数据 3、对大量明文进行加密，考虑效率问题，一般采用对称加密，常见的对称密钥加密算法：DES、3DES、RC-5、IDEA 4、关键字和注释不能作为标识符给对象命名 5、螺旋模型更适合大型的昂贵的系统级的软件应用 6、采用面向对象方法进行软件开发，在分析阶段，架构师主要关注系统的行为 7、外观模式用于将一系列对象加以包装以简化其接口 8、一个脚本语言通常是解释运行而非编译 9、声音编码(图像编码、文本编码)是表示媒体，喇叭是表现媒体(还有各种物理设备，比如显示媒体键盘、鼠标和麦克风等) 10、为了防止电子邮件中的恶意代码，应该用文本方式阅读电子邮件 11、不管是常量还是变量，它们都有其类型属性 1、在程序运行过程中，CPU需要将指令从内存中取出并加以分析和执行。CPU依据指令周期的不同阶段来区分在内存中以二进制编码形式存放的指令和数据 2、改变数字载波频率可以改变乐音的音调。改变它的信号幅度可以改变乐音的音高 3、如果某段路径在关键路径上，那么不能推迟项目工期 4、可移植性包含: 适应性、易安装性、易替换性和共存性四个特性 5、软件测试的目的是为了发现尽可能多的缺陷 6、如果一个模块的 所有成分都操作同一数据集或生成同一数据集，则称为 通信内聚 7、动态绑定是实现多态的基础 8、转换是从一个状态变迁到另一个状态，所以一个转换至少有两个状态 9、策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换 10、对于正数和负数，左移一位就相当于乘以2的1次方，左移n位就相当于乘以2的n次方 11、为了攻击远程主机，通常利用端口扫描技术检测远程主机状态 12、软件开发过程中，需求分析阶段的输出不包括软件体系结构图 13、在利用增量模型进行开发时，如何进行模块的划分往往是难点所在，而不是这种模型的优点 14、数据的物理独立性和逻辑独立性分别是通过修改模式与内模式之间的映像、外模式与模式之间的映像来完成的 15、默认情况下，FTP服务器的控制端口为21，上传文件时的端口为20 参考自 ls_wifi的博客 ,在此致谢 例题: 计算机执行程序时，内存分为静态数据区、代码区、栈区和堆区。其中（&nbsp; ）一般在进行函数调用和返回时由系统进行控制和管理，（&nbsp; ）由用户在程序中根据需要申请和释放。 问题1选项 A.静态数据区 B.代码区 C.栈区 D.堆区 问题2选项 A.静态数据区 B.代码区 C.栈区 D.堆区 解: 本题考查程序语言基础知识。程序在不同的系统中运行时，虽然对其代码和数据所占用的内存空间会有不同的布局和安排，但是一般都包括正文段(包含代码和只读数据)、数据区、堆和栈等。例如， 在Linux系统中进程的内存布局示意图如下图所示。 更多: PV操作 流水线相关问题","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"墓畔哀歌","date":"2017-02-26T10:38:54.000Z","path":"2017/02/26/墓畔哀歌/","text":"作者：石评梅 一 我由冬的残梦里惊醒，春正吻着我的睡靥低吟！晨曦照上了窗纱，望见往日令我醺醉的朝霞，我想让丹彩的云流，再认认我当年的颜色。 披上那件绣着蛱蝶的衣裳，姗姗地走到尘网封锁的妆台旁。呵！明镜里照见我憔悴的枯颜，像一朵颤动在风雨中苍白凋零的梨花。 我爱，我原想追回那美丽的皎容，祭献在你碧草如茵的墓旁，谁知道青春的残蕾已和你一同殉葬。 二 假如我的眼泪真凝成一粒一粒珍珠，到如今我已替你缀织成绕你玉颈的围巾。 假如我的相思真化作一颗一颗的红豆，到如今我已替你堆集永久勿忘的爱心。 哀愁深埋在我心头。 我愿燃烧我的肉身化成灰烬，我愿放浪我的热情怒涛汹涌，天呵！这蛇似的蜿蜒，蚕似的缠绵，就这样悄悄地偷去了我生命的青焰。 我爱，我吻遍了你墓头青草在日落黄昏；我祷告，就是空幻的梦吧，也让我再见见你的英魂。 三 明知道人生的尽头便是死的故乡，我将来也是一座孤冢，衰草斜阳。有一天呵！我离开繁华的人寰，悄悄入葬，这悲艳的爱情一样是烟消云散，昙花一现，梦醒后飞落在心头的都是些残泪点点。 然而我不能把记忆毁灭，把埋我心墟上的残骸抛却，只求我能永久徘徊在这垒垒荒冢之间，为了看守你的墓茔，祭献那茉莉花环。 我爱，你知否我无言的忧衷，怀想着往日轻盈之梦。梦中我低低唤着你小名，醒来只是深夜长空有孤雁哀鸣！ 四 黯淡的天幕下，没有明月也无星光这宇宙像数千年的古墓；皑皑白骨上，飞动闪映着惨绿的磷花。我匍匐哀泣于此残锈的铁栏之旁，愿烘我愤怒的心火，烧毁这黑暗丑恶的地狱之网。 命运的魔鬼有意捉弄我弱小的灵魂，罚我在冰雪寒天中，寻觅那雕零了的碎梦。求上帝饶恕我，不要再惨害我这仅有的生命，剩得此残躯在，容我杀死那狞恶的敌人！ 我爱，纵然宇宙变成烬余的战场，野烟都腥：在你给我的甜梦里，我心长系驻于虹桥之中，赞美永生！ 五 我镇天踟蹰于垒垒荒冢，看遍了春花秋月不同的风景，抛弃了一切名利虚荣，来到此无人烟的旷野，哀吟缓行。我登了高岭，向云天苍茫的西方招魂，在绚烂的彩霞里，望见了我沉落的希望之陨星。 远处是烟雾冲天的古城，火星似金箭向四方飞游！隐约的听见刀枪搏击之声，那狂热的欢呼令人震惊！在碧草萋萋的墓头，我举起了胜利的金觥，饮吧我爱，我奠祭你静寂无言的孤冢！ 星月满天时，我把你遗我的宝剑纤手轻擎，宣誓向长空： 愿此生永埋了英雄儿女的热情。 六 假如人生只是虚幻的梦影，那我这些可爱的映影，便是你赠与我的全生命。我常觉你在我身后的树林里，骑着马轻轻地走过去。常觉你停息在我的窗前，徘徊着等我的影消灯熄。常觉你随着我唤你的声音悄悄走近了我，又含泪退到了墙角。常觉你站在我低垂的雪帐外，哀哀地对月光而叹息！ 在人海尘途中，偶然逢见个像你的人，我停步凝视后，这颗心呵！便如秋风横扫落叶般冷森凄零！我默思我已经得到爱的之心，如今只是荒草夕阳下，一座静寂无语的孤冢。 我的心是深夜梦里，寒光闪灼的残月，我的情是青碧冷静，永不再流的湖水。残月照着你的墓碑，湖水环绕着你的坟，我爱，这是我的梦，也是你的梦，安息吧，敬爱的灵魂！ 七 我自从混迹到尘世间，便忘却了我自己；在你的灵魂我才知是谁？ 记得也是这样夜里。我们在河堤的柳丝中走过来，走过去。我们无语，心海的波浪也只有月儿能领会。你倚在树上望明月沉思，我枕在你胸前听你的呼吸。抬头看见黑翼飞来掩遮住月儿的清光，你抖颤着问我：假如这苍黑的翼是我们的命运时，应该怎样？ 我认识了欢乐，也随来了悲哀，接受了你的热情，同时也随来了冷酷的秋风。往日，我怕恶魔的眼睛凶，白牙如利刃；我总是藏伏在你的腋下趑趄不敢进，你一手执宝剑，一手扶着我践踏着荆棘的途径，投奔那如花的前程！ 如今，这道上还留着你斑斑血痕，恶魔的眼睛和牙齿再是那样凶狠。但是我爱，你不要怕我孤零，我愿用这一纤细的弱玉腕，建设那如意的梦境。 八 春来了，催开桃蕾又飘到柳梢，这般温柔慵懒的天气真使人恼！她似乎躲在我眼底有意缭绕，一阵阵风翼，吹起了我灵海深处的波涛。 这世界已换上了装束，如少女般那样娇娆，她披拖着浅绿的轻纱，蹁跹在她那（姹）紫嫣红中舞蹈。伫立于白杨下，我心如捣，强睁开模糊的泪眼，细认你墓头，萋萋芳草。 满腔辛酸与谁道？愿此恨吐向青空将天地包。它纠结围绕着我的心，像一堆枯黄的蔓草，我爱，我待你用宝剑来挥扫，我待你用火花来焚烧。 九 垒垒荒冢上，火光熊熊，纸灰缭绕，清明到了。这是碧草绿水的春郊。墓畔有白发老翁，有红颜年少，向这一杯黄土致不尽的怀忆和哀悼，云天苍茫处我将魂招；白杨萧条，暮鸦声声，怕孤魂归路迢迢。 逝去了，欢乐的好梦，不能随墓草而复生，明朝此日，谁知天涯何处寄此身？叹漂泊我已如落花浮萍，且高歌，且痛饮，拼一醉烧熄此心头余情。 我爱，这一杯苦酒细细斟，邀残月与孤星和泪共饮，不管黄昏，不论夜深，醉卧在你墓碑傍，任霜露侵凌吧！我再不醒。","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"水墨徽州","date":"2017-02-22T14:14:46.000Z","path":"2017/02/22/水墨徽州/","text":"作者: 李娟 一 雨是徽州的一点淡墨，清水淡墨，描在泛黄的宣纸上。 睡梦的宏村是被潺潺溪水声唤醒的。漫步青石铺就的小巷，清流自家家门前而过，有白发的婆婆在水边浣洗。阡陌小巷，鸡犬相闻，你仿佛一瞬间走进光阴的皱纹里，走进几百年前的明代。 天落了小雨，雨一不留神，湿了粉墙，湿了黛瓦，湿了雕花的屋檐，湿了高耸的马头墙，湿了廊前的紫薇，湿了徽州女子水一样的双眸，湿了脚下的石板路，湿润了我的心。撑一把雨伞，漫步古朴幽静的小巷，人就像是一阕宋词了。 老宅，小巷，粉墙，溪流，月沼，古树，描绘成了一幅水墨丹青。 迎面走来买豆腐的妇人，挑着一副担子，素净的衣衫，竹筐里卧着白玉一样的豆腐，她的叫卖声旖旎婉转，如溪水边一丛丛凤仙花，水气泱泱。“吱呀”一声，小巷深处雕花的木门里，走出白发的老人，手里捧着青花瓷碗，不一会，她的青花瓷碗里就泊着两块白嫩的豆腐。 雨停了，一对老人坐在门前的石凳上聊天，笑语妍妍。老人脚下依偎着一只狗，门槛上卧着一只猫。一簇簇凌霄花从斑驳的围墙上探出头来，绿叶丛生，花枝摇曳。一场风雨后，淡黄色的凌霄花落在青石板上，凄美绝伦。有时，他们什么也不说，只默默的相对静坐着，反刍光阴，内心安详。谁知相思老，玄鬓白发生。世间的一切安然静美，都在默默无言地相守相依里。 小巷里遇见买木雕的小店，门口坐着一位老人，戴着眼镜，低着头专注地刻竹雕。我倚在门前，看他在碗口粗的竹筒上作画，上面刻着南湖荷开，小巷老宅。古朴雅致，诗意幽幽。 走进小巷深处，去看老宅。推开厚重的木门，幽暗的天井里，有一口大缸，缸里泊着浮萍几片，开着几朵洁白的睡莲。厅堂里一幅幅雄健刚劲的槛联：“几百年人家无非积善，第一等好事只是读书”。自古徽商都是儒商，遵循诗书礼仪，孝弟传家。一抬头就看见朱熹的对联：“松风间放鹤，花雨夜名琴”。另一副对联上写：“室雅何须大，花香不在多”落款则是郑板桥。正是，好诗如清风，佳句似香茗。从容入世，清淡出尘。多么雅致的古人，多么娴静闲逸的古代时光。 厢房的木门上雕刻着一幅幅画：平湖秋月，柳浪闻莺，断桥残雪，苏堤春晓”。花窗则上刻着“羲之戏鹅，渊明爱菊，和靖爱梅”，栩栩如生，每一幅木雕就是一个典雅的故事。唐诗宋词，信手拈来，被刻在老宅的木门上。此时，诗情和画意痴痴缠绕，千百年的诗书都在美轮美奂的木雕里。 走进老宅的后院，亭台水榭，蕉肥石瘦，回廊下一弯碧水中养着几尾红鲤鱼，欢快地游来游去。假山旁依着一树紫薇，正开得烂漫。这里，便是红顶商人与他的如花美眷赏月品茗的地方吧。 来徽州，就住在百年的老宅里，才能嗅到在古老文化芬芳。几百年的风雨沧桑，诗情画意都在深深的庭院里。一面花窗，一弯碧水，一处水榭，一个长廊，一幅石雕，让你品味出不同的意趣，那是古老岁月蕴含的古典与优雅，也是东方文化孕育的温婉和静美。 静夜里，倚在窗前，隔着百年的窗棂望月亮，月亮还是几百年前的月亮，人已隔着万水千山，却有着一样深深的寂寞。 深夜落雨了，听雨打窗棂，想起这座老宅经历多少旧事浮云，生死离散。记起诗句：悲欢离合总无情，一任阶前点滴到天明。徽州的雨夜，有着说不出的悲凉。 二 走进主人的卧室，幽暗的光线中，雕花的大木床，精雕细琢，富丽堂皇。上面雕刻着是鸳鸯戏水，麒麟送子，花开富贵。 恍惚间，看见几百年前一位红妆女子被抬进徽商世家，深深庭院里，一时间鼓乐喧天，歌舞升平。花烛摇曳，琴瑟相和，共赏春花秋月，共度天阶微凉。春宵几度后，他外出经商走了，一去经年，赚回来白花花的银子修老宅，建祠堂，铺桥修路，光耀门楣。她在老宅里默默等着，用思念和寂寂流年抗衡。“空守云房无岁月，不知人世是何年”，他一去几年，几十年。一日，他回来了，红顶商人衣锦还乡，站在厅堂里，她的发如雪，鬓如霜，他不敢上前与她相认。恍惚听见黄梅戏里婉转唱到：“少年子弟江湖老，红粉佳人两鬓斑”。似水流年里，她老了，老成木门上那只彩凤，再也飞不起来。 庭院深深深几许，多么深的庭院，原来就有多么深的寂寞。 每家老宅的厅堂里，依墙摆放着两张半圆的花梨木桌。原来，只有等外出经商的男人回来了，两张半圆桌才合二为一，全家人在厅堂里吃团圆饭。花好月圆，合家团圆。可是，有的男人走了，再也没有回来，那张花梨木桌，就倚在老屋的墙壁上，如同一对夫妻的命运，一生不得团圆。他在苏杭一带做生意发达了，十年一觉扬州梦，夜夜笙歌，妻妾成群，儿女成行，她却在老宅里等着，守着家业，守着孩子，守着苦涩的忠贞。 在香茗剧院里听徽剧，见她凄婉地唱到：风荷细雨愁更愁，花开花谢共白头……她的发白了，心也灰了。她老了，老成屋瓦上一块青苔，无限的苍绿，仿佛岁月之手轻轻一握，就能滴出点点清泪来。 她只是木门上一朵睡莲，他回不回来，花总在这里，不弃不离。她只是月沼中一轮明月，他回不回来，月总在这里，或盈或缺。可是，他只做了一朝的看花人，只做了一夕的赏月人。 徽州女人的寂寞，如小巷里的凌霄花，开了一年又一年，女人的忧愁，唯有廊前的花儿知晓。 直到她死了，他也没有回来，她等了长长的一生。换回来的，便是村头一座气势恢宏，寒意弥漫的贞洁牌坊。 在徽州老宅里，我一次次想到徽州才女苏雪林。她的一生是个传奇，她是一只展翅飞翔的凤凰，飞出了徽州，飞出了国门。她的才华和资质在许多民国女作家之上。然而，她被故乡遗忘了，似乎被中国的文学史遗忘了，她说：“我本应该是一只花蝴蝶，但被夹在空白页里。”她结婚不久，情感变故，和丈夫分道扬镳。而后漫长的一生，她学贯中西，著书立说，孤清终老，一直活到一百余岁。 三 月沼是村子的池塘，如半轮明月，称为月沼，我很喜欢这个名字，清雅有回味。原来，户户门前的汩汩清流，后来就汇集在月沼中，给古老的村落添了几许灵秀和诗意。不知道古人为何不将月沼修成圆形，小村不就有了一轮圆月。直到在西递见到一块石碑：作退一步想。忽然想起佛家说，花未全开月未圆，便是人生最好的境界。古人的智慧，便是懂得进退和取舍，水满则溢，月盈则亏，世间万事万物皆是如此。他们懂得留白和节制，如同一篇好文章，不会写得太满，不会把话说尽，才显得气象万千，意味悠长，引人无限遐思。 清晨的月沼静谧如梦，有几只白鹅伸着长脖子在碧波中觅食，白毛浮绿水，显得分外自在悠然，无数只红蜻蜓在水面盘旋。月沼两岸，粉墙高耸，瓦屋倒影。水中映着青山如黛，云朵晴空，美如幻梦，也映照着宏村八百年的风雨沧桑。 黄昏时节，夕阳余辉里，艳阳的火味正渐渐散去，水边的夜有几分清凉。月上青山时，月沼中便泊着半弯月亮。天上半弯月亮，水中半弯月亮。此时，月来水里，影落池中。 伴月沼品茶，一张小桌，几把竹椅，和友人围坐一处，淡茶几盏，赏两轮明月，清茶浅酌，是一件多么惬意的事。水边的茶楼亮起一串串红灯笼，水面灯影摇曳，波光潋滟，犹如月沼鬓上插着的一串发簪。 月沼边吟诗作画的诗人换了一茬又一茬，执手相伴的才子佳人换了一茬又茬一茬，似水年华里，多少红粉佳人青丝化为白雪，只有月沼不老，明月不老，青山不老。 小桥流水，粉墙黛瓦，山水之间有人家。与山水相依相伴，佳偶天成，和谐自然。美到极致的东西，往往都是最自然的，宏村不愧为中国画里的乡村。 四 漫步在小巷，顺着潺潺清流的方向一直走，一会儿，眼前豁然开朗，只见一面大湖，两岸树影摇曳，波光如镜。碧波中开满了荷花，或红或白，清风徐来，风动荷花香。湖面上立着一座石拱桥，犹如彩虹横卧清流之上。行走桥上，忍不住要问：无限荷香染暑衣，阮郎何处弄船归。人行碧波中，犹在画中游。原来这就是南湖，这座石拱桥有一个诗意的名字：画桥。 临南湖而居，就是庄严的南湖书院。走进书院，感到书香弥漫，静谧安然的地方有一种气场在。书院里立着一副对联：“漫研竹露裁唐句，细嚼梅花读汉书”令人回味悠长的诗句，似天雨流芳。一代代儒商，一个个莘莘学子就是从这里开启生命的智慧，他们饱读诗书，通今博古。观天地日月，感人世沧桑。面对一湖碧波，风荷细雨，风声水声读书声里，一个个小生命便如一颗颗莲子，只待春风拂面，知识的天雨润泽心灵，生命就如莲花盛开。他们被书墨之香滋养温润，懵懂的灵魂被诗书一次次唤醒。而后，羽翼丰满的学子们走出徽州，展翅高飞。 留恋在徽州，粉墙黛瓦，云树烟芦，小桥流水，曲径通幽。汤显祖有诗：一生痴绝处，无梦到徽州。是的，他连梦里不曾想到，徽州之美，含蓄优雅，与世无争，气定神闲，美在风骨。徽州是浪蕊浮花都尽了，别有嫣然风流。 徽州是一部古书，一阕宋词，一幅木雕，一杯淡茶，一簇花开，一轮明月，一卷水墨丹青…… 徽州从未消失，她只是和流逝的岁月在一起。 水墨徽州散文","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"robfig/cron使用小结","date":"2017-02-22T12:30:02.000Z","path":"2017/02/22/robfig-cron使用小结/","text":"robfig/cron/v3 是一个 Golang 的定时任务库，支持 cron 表达式。其源码值得一读, 低耦合高内聚体现地淋漓尽致,其中涉及的装饰器模式,并发处理等都很值得学习。 如果是 0 30 * * * *, 那就是每个 xx:00 和 xx:30 执行 而如果是@every 10m, 则是从当前时间起(服务启动时间)，每30分钟执行一次，未必是xx:00，xx:30时刻执行 参考一不留神就掉坑, 可利用在线工具查看具体执行时间 其相关源码,可参考: Golang 定时任务 github/robfig/cron/v3 使用与源码解析 Golang crontab定时执行任务（github.com/robfig/cron） cron表达式解析 + robfig/cron 源码剖析","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"MySQL中的WAL(Write-Ahead-Logging)","date":"2017-02-22T09:37:26.000Z","path":"2017/02/22/MySQL中的WAL-Write-Ahead-Logging/","text":"数据库IO简介 IO有四种类型：连续读，随机读，随机写和连续写，连续读写的IO size通常比较大(128KB-1MB)，主要衡量吞吐量，而随机读写的IO size比较小(小于8KB)，主要衡量IOPS和响应时间。数据库中的全表扫描是连续读IO，索引访问则是典型的随机读IO，日志文件是连续写IO，而数据文件则是随机写IO。 数据库系统基于传统磁盘访问特性来设计，最大特点是日志文件采用sequential logging，数据库中的日志文件，要求必须在事务提交时写入到磁盘，对响应时间的要求很高，所以设计为顺序写入的方式，可以有效降低磁盘寻道花费的时间，减少延迟时间。日志文件的顺序写入，虽然是物理位置是连续的，但是并不同于传统的连续写类型，日志文件的IO size很小(通常小于4K),每个IO之间是独立的(磁头必须抬起来重新寻道，并等待磁盘转动到相应的位置)，而且间隔很短，数据库通过log buffer(缓存)和group commit的方式(批量提交)来达到提高IO size的大小，并减少IO的次数，从而得到更小的响应延迟，所以日志文件的顺序写入可以被认为是“连续位置的随机写入”，更关注IOPS，而不是吞吐量。 数据文件采用in place uddate的方式，意思是数据文件的修改都是写入到原来的位置，数据文件不同于日志文件，并不会在事务commit时写入数据文件，只有当数据库发现dirty buffer过多或者需要做checkpoint动作时，才会刷新这些dirty buffer到相应的位置，这是一个异步的过程，通常情况下，数据文件的随机写入对IO的要求并不是特别高，只要满足checkpoint和dirty buffer的要求就可以了。 https://www.google.com/search?q=wal+mysql&amp;oq=WAL+mysql&amp;aqs=chrome.0.0j0i8i30l2j69i61.3287j0j4&amp;sourceid=chrome&amp;ie=UTF-8 http://mysql.taobao.org/monthly/2018/07/01/ MYSQL专题（六）：MYSQL的日志顺序读写，数据文件随机读写以及linux底层原理 https://blog.csdn.net/im_cheer/article/details/89811004?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight MySQL读写IO的操作过程解析 顺序io和随机io分别在什么情况下出现？为什么日志是顺序io，数据是随机io？ 相关图片 MySQL 读后总结 MySQL 索引设计概要 图片来自第9章 操作系统和硬件优化 mysql server组成","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"浮点数的表示","date":"2017-02-19T13:45:38.000Z","path":"2017/02/19/浮点数的表示/","text":"$$N = M * R^e$$ 其中, S称为 数符,也称为符号位, 为0或1,用来标识M的正或负 e 是比例因子的指数, 称为浮点数的指数, 是一个整数. 常称为真值,其与阶码E的关系为E=e+127, E的正负称之为 阶符 M 称为浮点数的尾数, 是一个纯小数 R 是比例因子的基数, 对二进记数制的机器R是常数 2 故而对计算机有 $$N = M * 2^e$$ 浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。 mantissan. （数学）假数；（对数）尾数；数值部分;[例句]An Algorithm for Adjusting Mantissa Errors Resulted from Data Dealing一种针对数据尾数误差的调整算法 按IEEE754标准,32位浮点数和64位浮点数的标准格式为 无论是32位浮点数还是64位浮点数, 由于基数 R是固定常数2,所以不必用显示方式来表示 32位的浮点数中，浮点数的 符号位 S 占1位，安排在最高位，S=0表示正数，S=1表示负数。 M是 尾数，放在低位部分，占用23位，小数点位置放在尾数域最左（最高）有效位的右边。 E是 阶码，占用8位 阶符 采用隐含方式，即采用 移码 方法来表示正负指数。 IEEE 754是第二种。IEEE 754没有阶符，它的阶码是阶数加上一个固定的位移，使得其阶数可以按照无符号整型数处理 移码方式 对两个指数大小的比较和对阶操作都比较方便，因为阶码域值大者 其指数值也大。采用这种方式时，将浮点数的指数 真值e变成阶码E时，应将指数e加上一个固定的偏移值127（即二进制 01111111），即E=e+127 为提高能表征的精度,当尾数的值不为0时,尾数域的最高有效位应为1,这称为浮点数的规格化表示 否则以修改阶码同时左右移动小数点位置的办法,使其变成规格化数的形式 (可结合 最后的例题理解) 在IEEE754标准中，一个规格化的32位浮点数x的真值表示为 $$x = (-1)^S \\times 1.M \\times 2^{E-127}$$ e = E - 127 其中尾数域所表示的值是1.M。由于规格化的浮点数的尾数域最左位（最高有效位）总是1，故这一位经常不予存储，而认为隐藏在小数点的左边。于是用23位字段可以存储24位有效数。 64位的浮点数中符号位1位，阶码域11位，尾数域52位，指数偏移值是1023.因此规格化的64位浮点数x的真值为 $$x = (-1)^S \\times 1.M \\times 2^{E-1023}$$ e = E - 1023 例题 若浮点数x的754标准存储格式为$(4136000)_{16}$，求其浮点数的十进制数值。 解：将16进制数展开后，可得二进制数格式为 0100 0001 0011 0110 0000 0000 0000 即 $$指数e = 阶码-127 = 10000010-01111111 = 00000011 = (3)_{10}$$ 包括隐藏位1的尾数 $1.M = 1.011 0110 0000 0000 0000 0000 = 1.011011$ 于是有 $$x=(-1)^S \\times 1.M \\times 2^e = +（1.011011） \\times 2^3 = +1011.011 = (11.375)_{10}$$ 2.将数 $(20.163)_{10}$ 转换成754标准的32位浮点数的二进制存储格式。 解： . 首先分别将整数和小数部分转换成二进制数： 十进制浮点数，整数部分转换成二进制，采用除2取余法，将余数从低到高排列，即为整数的二进制数； 123456789101112整数部分20/2=10 .... 010/2=5 .... 05/2=2 .... 12/2=1 .... 01/2=0 ..... 1 小数部分转换成二进制，采用乘2取整法，将取整数顺序排列，即为小数的二进制数。 小数部分乘2直到小数部分为0，或取到想要的位数，或循环出现前。 12345678910111213141516171819202122小数部分0.163*2=0.326 00.326*2=0.652 00.652*2=1.304 10.304*2=0.608 00.608*2=1.216 10.216*2=0.432 00.432*2=0.864 00.864*2=1.728 10.728*2=1.456 10.456*2=0.912 0 不要求精度时，通常取到8~10位 即 $20.163_{10} = 10100.0010100110_{2}$ . 移动小数点到第1、2位之间，得e的值 $$10100.0010100110 = 1.01000010100110 * 2^4$$ 即 e=4 （小数点移动了4位） . 求出S、E、M 的值 S=0，&nbsp; E=4+127=131，&nbsp; M=01000010100110 S由小数点的后一位可以看出，0为正数，1为负数。 所以有: 0 10000001 01000010100110000000000 IEEE754标准中32位浮点数表示 S E M S是符号位占1位，E是阶码占8位，M是尾数占23位。 3.设16位浮点数，其中阶符1位、阶码值6位、数符1位、尾数8位。若阶码用移码表示，尾数用补码表示，则该浮点数所能表示的数值范围是 如果浮点数的阶码(包括1位阶符)用X位的移码表示，尾数(包括1位数符)用Y位的补码表示，则浮点数表示的数值范围如下: 最大正数: $$+(1-2^{-Y+1})*2^{2^{X-1}-1}$$ 最小负数: $$-1*2^{2^{X-1}-1}$$ 此处, X=6+1=7, Y=8+1=9 当尾数的值不为0时，尾数的最高有效位应为1，这称为浮点数的规格化表示 这样形式的叫规格化 参考: 计算机浮点数规格化表示 工具: 可视化浮点数 该网页提供32位浮点数和64位浮点数的二进制结构图，可以方便地设置每一个二进制位，显示对应的数字。 推荐阅读： 阮一峰-浮点数的二进制表示","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"我理解的OSI网络模型和TCP/IP协议族","date":"2017-02-17T15:33:03.000Z","path":"2017/02/17/我理解的OSI网络模型和TCP-IP协议族/","text":"OSI（Open System Interconnect,开放式系统互联）是ISO在推出的网络互联模型;TCP/IP是70年代中期美国国防部为其ARPANET广域网开发的网络体系结构和协议标准，以它为基础组建的INTERNET是目前国际上规模最大的计算机网络，正因为INTERNET的广泛使用，使得TCP/IP成了事实上的标准。 前者有7层(应表会传网数物),后者有4层(应传网链) TCP/IP并不是特指TCP协议和IP协议,而是指以其为代表的协议簇,即TCP/IP实际上是一组协议 TCP/IP到底是四层还是五层可参考 更多可参考 关于常问的”三次握手”和”四次分手” 其实理解为一次握手的三个步骤更好 一些讨论:a1a2a3a4a5a6 位码即tcp标志位,有6种标示: SYN(同步序列编号(Synchronize Sequence Numbers),synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送)FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码) Acknowledge number(确认号码)","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"linux三剑客之awk(忌求全尾大不掉,简明实用版)","date":"2017-02-17T02:29:43.000Z","path":"2017/02/17/linux三剑客之awk-忌求全尾大不掉-简明实用版/","text":"运维大神的博文 还有一个超长版 阮一峰 - awk入门教程","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"hexdump命令","date":"2017-02-01T10:11:08.000Z","path":"2017/02/01/hexdump命令/","text":"比较特殊的文件内容查看工具 hex 英[heks]美[heks]v. 施魔法以加害(某人);n. 十六进制，巫婆，妖法;[例句]It can display data in ASCII, decimal, hex, and octal formats.它能够显示ASCII的数据，小数，十六进制和八进制格式。 hexdump是UNIX下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。 一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件，也不止限于以十六进制格式查看。 在分析mysql binlog或者ibd文件时候，常会用到hexdump 查看物理文件的存储内容。 语法: hexdump [选项] [文件]… 选项: 123456789-n length 只格式化输入文件的前length个字节。-C 输出规范的十六进制和ASCII码。-b 单字节八进制显示。-c 单字节字符显示。-d 双字节十进制显示。-o 双字节八进制显示。-x 双字节十六进制显示。-s 从偏移量开始输出。-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：'a/b \"format1\" \"format2\"'。 对于 -e: 每个格式字符串由三部分组成，每个由空格分隔，第一个形如a/b，b表示对每b个输入字节应用format1格式，a表示对每a个输入字节应用format2格式，一般a&gt;b，且b只能为1，2，4，另外a可以省略，省略则a=1。format1和format2中可以使用类似printf的格式字符串，如： %02d：两位十进制 %03x：三位十六进制 %02o：两位八进制 %c：单个字符等 还有一些特殊的用法： %_ad：标记下一个输出字节的序号，用十进制表示。 %_ax：标记下一个输出字节的序号，用十六进制表示。 %_ao：标记下一个输出字节的序号，用八进制表示。 %_p：对不能以常规字符显示的用 . 代替。 同一行如果要显示多个格式字符串，则可以跟多个-e选项。 实例: hexdump -e &#39;16/1 &quot;%02X &quot; &quot; | &quot;&#39; -e &#39;16/1 &quot;%_p&quot; &quot;\\n&quot;&#39; test 12300 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | ................ 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F | ................ 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F | !\"#$%&amp;'()*+,-./ 摘自: hexdump命令 参考: Linux命令学习总结：hexdump","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"岁月无痕","date":"2017-01-27T10:40:25.000Z","path":"2017/01/27/岁月无痕/","text":"翻看旧照和故物集结册，很难想象，竟然整整过去了24年和12年。那年春晚结束后的深夜，从奶奶家老宅走出，我穿着东北大军靴，拿着一把生锈的小刀，冠名曰“冷艳锯”，外面用纸壳粘折作为剑鞘，剑把末端拴上剑穗，拿在手中飞舞。 雪花堆叠覆盖了老家那条红砖铺设的“中心大街”，路灯昏暗，却在素洁无垠的月光笼罩下，一切安详隐约可见。此起彼伏的爆竹和烟花，以及弥散在空气中特有的我称之为“年味”的气息，与蹦蹦跳跳欢欣不已的我动静相融，那是12年前的除夕夜。 那年除&lt;千手观音&gt;外，给我留下深刻印象的是黄宏巩汉林小品&lt;装修&gt;，“东风吹，战鼓擂，装修需要我黄大锤”。我改编了这句开场台词并不时重复，让我年轻的爸妈捧腹。而今，春晚已经是毫无存在感的东西。12年，仿佛只是一瞬。闭眼，却都真切历历在目。 12年前，早上陪同我去给长辈拜年的还有堂哥堂姐，而今，ta们居在大城，皆成家有子，弟弟年幼身在沪上，逢年还从未回，作为新新人类，此地习俗怕已陌生，家乡长辈更是相逢不识。12年来，我早起拜年的对象也愈发稀少，ta们同那个以“腌透了的咸鸭蛋”代指黄宏的填词人闫肃，在这一旬岁月里告别了这烦喧世界。 下午去山间公墓上坟祭拜，平素幽静无人的坟场被炮声扰得粉碎。望着燃烧的黄钱纸化为余红未褪的灰烬，局部空气受热升腾，给人强烈的目眩感和幻灭感。那刹那一刻，我想到很多，但受限于止有两旬的阅历和依旧拙劣的笔力，我无法把捕捉到的信息不做失真地还原。 今天，我带着耳机，步行10分钟，从望京横穿309国道和胶济铁路，到另一个地级市的姥姥家。ta们年过九十日渐衰老，我几乎无法想象，他当年是如何用仅存的一只手把我抱起，对着院中那棵已经不再的梧桐树，磕磕鞋上尘土放入冰糕箱中，穿过马路和大桥，只为满足我“看看新家有没有贴上马赛克瓷砖”。而我的“新家”也已然不再名副其实，它已经建成20年，我只在其中常住两年。姥姥患病已过10年，一侧偏瘫，神志清晰却表达不出，精神矍铄却行动不便。同样很难想象，许多年前，我正是跟在她们几个挎着篮子的裹脚老太太身后，去“很远很远”的村边”打兔子草”。那次，我相依相伴形影不离的竖笛，遗落在了到我小腿的麦苗层中，沮丧失望哇哇落泪，忐忑地回去寻找，幸运发现。那一年，揣着失而复得如释重负的畅快心情，风吹麦浪，绿油油的麦田摆动一波未至一波又起，我迎风奔跑，不时跳跃飞舞，咧嘴欢笑，丝毫未留意刚被风吹干的泪痕。 许多年前，更确切是当从奶奶家到“新家”的一公里距离我第一次敢独自行走。路过“南和巷”已残破多载的“代销点”，几位晒太阳的老太太，因我未像平时跟着父母走过时在，在大人催促下喊其“奶奶”，而质问甚至抛出口头禅般的脏话，听后十分生气，用我有限的词汇和其“对骂”。过去讲“三个女人一台戏”，何况又是三位“桥胜路，盐赛米”的老妪，年幼的我不敢恋战，择路快逃。今天路过那里，却早是物是人非许多年。 在下午公墓烧纸燃炮间隙，听到近旁几位前来祭祀的男人不经意的对话，“今天比初一来的人都多啊”，“嗨，初一都在家打扑克了”。祖宗灵前，能这样直白潇洒不遮不掩地表述，让我莞尔失笑。我们都是大变化时代中的小人物，根深蒂固奉若圭皋的风俗礼仪，在新时代价值观的冲击下支离破碎，像&lt;百鸟朝凤&gt;那段西安城头的日落，有些许不舍却不得不如此。碑上男主人皆有名有姓，女主人则只有姓氏名被隐去，哪怕这位男主人有两任夫人，能看到的也只是她们的姓氏，这让我感到有些逆眼，而我只是这个儒家发源地有新时代精神的年青一代，尚不能算“新人类”——虽不知未来具体去往何处，却都知目标是朝更平等更幸福的地方。 我看着远近起伏连绵的新茔旧墓，不禁想到自己。这里会是我跋涉千山万水留宿异乡几万日夜最终的归宿吗？一个甲子后，我一生落幕，也会是此地一处毫不起眼的坟茔？…当我稍稍像爸妈透露这想法，ta们当即笑我守旧思量太久。“哪里能给你幸福，哪里是你的新家乡”。自出生起，生命已经是一头点燃并疯狂燃烧不为所动的香烛，迟早有天是要灯灭香熄。而唯一能做的，是用余生的60年，做更多有价值和幸福感的事。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"红黑树与最小堆","date":"2017-01-20T08:30:01.000Z","path":"2017/01/20/红黑树与最小堆/","text":"红黑树是一种平衡二叉树 红黑树的应用 Java 1.8之后HashMap的实现 epoll (a) socket管理中的很多 文件系统 定时器(b) 进程调度 内存管理(a) map(a) 无论场景多么复杂,无外乎用到rbtree的两大特性: a.key/value –&gt; 用来快速查找,如map b.是顺序的,通过中序遍历,可以查找一段范围内的数据 –&gt;诶进程调度,定时器(nginx里有用) Linux内核中如何运用的红黑树? 进程管理 task_structtask_struct 结构体,每一个进程,每一个线程,就是一个task_struct结构体 写时复制 Copy-On-Write,即fork出的子进程(或者pthreat_create出的线程),只有在发生更改时,才会发生分离 每个进程,一定有且仅有一个task_struct ntyco–那个老师写的,不是佳作,但有值得借鉴之处 完全公平调度(cfs)用到了红黑树 nginx里的定时器也是这样做的,以时间戳作为key,定时去判断哪些节点超时了,然后执行相应事件 内存管理 mm_struct (用来管理页表) 虚拟内存区域(VMA) (更多可参考 为什么 Linux 默认页大小是 4KB) 如何去表示一块细小的碎片内存? 答: 开始位置,大小或结束位置 我理解的 内存管理中所谓的”管理”,就是标记(占用或释放),定位/寻址 epoll的实现 epoll即EventPoll(fs),可以在Linux内核源码中搜索EventPoll, fs即文件系统,epoll是文件系统里的一个东西,而不是网络里的内容 epoll跟网络有关? 错,半毛钱关系没有… fd –&gt; file descriptor,文件描述符,socket也是fd. epoll是用来管理I/O的,socket是I/O的一种 2.6之后加入的epoll 实现原理: 用红黑树来存I/O,有1万个I/O,红黑树里就有1万个节点. key是int型的fd,value就是对应I/O的状态,如水平触发,带进来的状态等 把这成千上万个I/O里有数据的,放到一个队列里,即就绪队列.epoll_wait就是从这个队列(链表)里,拿到用户空间里 如何知道这个I/O有数据来了? 水平触发和边沿触发如何实现? 其核心原理是什么?epoll是不是线程安全的? 内核中的其他部分 如sk_buff在内核源码中 搜一下rb_node, 就能知道内核里有多少使用到了红黑树 看内核源码,可以下一个 Source Insight 阅读内核代码时,不要去读那些和驱动,和硬件相关的.看通用型的,如进程调度,内存管理这些模块 动态规划没那么重要,相比来说,要对rbtree,btree及其排序有较好掌握 参考: https://blog.csdn.net/guoweimelon/article/details/50904346 https://blog.csdn.net/hrn1216/article/details/51465270 https://zhuanlan.zhihu.com/p/37968599 https://www.zhihu.com/question/27840936 https://www.cnblogs.com/elwinch/articles/2040753.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"软考中级之软件设计师方向","date":"2017-01-16T13:21:36.000Z","path":"2017/01/16/软考中级之软件设计师方向/","text":"下午的题，第一道数据流图，第二道数据库，第三道是uml，第四道算法，一般用C语言描述，第5/6道 二选一，java或C++,面向对象编程， 以设计模式为背景 下午的考的很稳定，45分很稳.方法技巧高过实际经验 计算机组成原理与体系结构","tags":[]},{"title":"Jetbrains系列IDE行操作快捷键汇总","date":"2017-01-11T14:48:27.000Z","path":"2017/01/11/Jetbrains系列IDE行操作快捷键汇总/","text":"12345678func InSliceInt64(i int64, sl []int64) bool &#123; for _, vv := range sl &#123; if vv == i &#123; return true &#125; &#125; return false&#125; 连接行 会把光标后面的行移动到光标所在行 假设光标在for _, vv := range sl {的{后，使用连接行操作一次，会变为如下： 排序行 根据嵌套深度，进行排序。 嵌套最深(tab键最多的)会排在最前面，反之 func xxx之类顶格写的，都会排在最后面 可以用来快速找到在一个文件中，嵌套最深的是哪一段 其他实际使用场景不多~ 反转行 会把整个文件的行逆序。 即原来 package main在第一行，执行该操作后会到最后一行 拆分行 无需快捷键 删除行 command+”回退键“ 可以无需选中，就快速删除一行 添加或移动文本光标&lt;/ `b&gt; option+点击 好用，可以选中多行，并进行处理 在上方克隆文本光标 在下方克隆文本光标 参考上条 反向剪切行 剪切光标以左的部分 剪切到行尾 control+k 从光标处剪切到行尾 和上面的命令对称~ 删除到行尾 从光标处删除到行 (剪贴板不会有记录) 删除到行首 从光标处删除到行首 (剪贴板不会有记录) 和上面的命令对称~ 重复行或选区 command+D 实用 重复整行 和上面命令差不多 将文本光标移至行尾 command + -&gt; 当某行特别长时，有一些用处 将文本光标移至行首 参考上条 在保持选区的情况下将文本光标移至行尾 shift+command+ -&gt; 用处不大 在保持选区的情况下将文本光标移至行首 参考上条 扩展行选区 有些用~ 不停选中下一行 我设置成了 shift+control+N 选择文本光标处的一行 选中光标所在的行 比较实用 我设置成了 command+L 开始新行 无需解释 在当前位置之前开始新行 上一个命令的对称操作 在光标的上一行开始新行 缩进行或选区 等同于选中后敲Tab键 取消缩进行或选区 等同于选中后敲shift+Tab键 跳转到行：列 我设置成了 command+G","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Implicit memory aliasing in for loop.","date":"2017-01-11T08:14:52.000Z","path":"2017/01/11/Implicit-memory-aliasing-in-for-loop/","text":"https://stackoverflow.com/questions/62446118/implicit-memory-aliasing-in-for-loop https://www.coder.work/article/7183745","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Gin升级导致的获取客户端真实IP失败问题","date":"2017-01-11T07:19:44.000Z","path":"2017/01/11/Gin升级导致的获取客户端真实IP失败问题/","text":"https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/120426004","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"spew--极其好用的Go语言深层打印包","date":"2016-12-30T10:39:08.000Z","path":"2016/12/30/spew-极其好用的Go语言深层打印包/","text":"深度打印 如果变量为接口/多层嵌套的复杂结构体,且里面包含指针类型,用fmt打印时,结果将十分不可读. go-spew这个package,非常完美地解决了此问题. spew为动词,译作”(使) 喷出，涌出”,也有”呕吐”的意思.读作”si biu”.[例句]The volcano spewed out more scorching volcanic ashes, gases and rocks火山喷出更多灼热的火山灰、气体和岩块。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\")type AppDeveloper struct &#123; DeveloperID string `json:\"id\"` Name *string `json:\"name\"` Email string `json:\"email\"` CompanyInfo *company `json:\"company\"`&#125;type company struct &#123; companyName string companyOwner *string address string isListed *bool&#125;func main() &#123; name := \"Alex\" entrepreneur := \"马化腾\" //企业家,创业者 isPubliced := true //香港和英国：a public company; 美国：a listed company user := AppDeveloper&#123; \"123\", &amp;name, \"i@dashen.tech\", &amp;company&#123; \"腾讯\", &amp;entrepreneur, \"深圳\", &amp;isPubliced&#125;, &#125; fmt.Println(user) n, err := spew.Println(user) fmt.Println(n, err)&#125; 输出为: 12345&#123;123 0xc0000102d0 i@dashen.tech 0xc000066390&#125;&#123;123 &lt;*&gt;Alex i@dashen.tech &lt;*&gt;&#123;腾讯 &lt;*&gt;马化腾 深圳 &lt;*&gt;true&#125;&#125;68 &lt;nil&gt; // Println is a wrapper for fmt.Println that treats each argument as if it were passed with a default Formatter interface returned by NewFormatter. It returns the number of bytes written and any write error encountered. See NewFormatter for formatting details. spew.Println() 返回写入的字节数以及遇到的任何写入错误 可见,如果遇到pointer类型,会在前面标出为&lt;*&gt;类型,但输出的还是该指针在内存里存放的值; 和fmt相比,可读性强太多了 spew包中其他的方法 spew.Dump:1234567891011121314151617181920package mainimport ( \"github.com/davecgh/go-spew/spew\")type Project struct &#123; Id int64 `json:\"project_id\"` Title string `json:\"title\"` Name string `json:\"name\"` Data *string `json:\"data\"` Commits *string `json:\"commits\"`&#125;func main() &#123; commit := \"第一次提交\" o := Project&#123;Name: \"hello\", Title: \"world\", Commits: &amp;commit&#125; spew.Dump(o)&#125; 输出为: 1234567(main.Project) &#123; Id: (int64) 0, Title: (string) (len=5) &quot;world&quot;, Name: (string) (len=5) &quot;hello&quot;, Data: (*string)(&lt;nil&gt;), Commits: (*string)(0xc0000682b0)((len=15) &quot;第一次提交&quot;)&#125; spew.Printf:123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\")func main() &#123; ui8 := uint8(5) pui8 := &amp;ui8 ppui8 := &amp;pui8 // Create a circular data type. type circular struct &#123; ui8 uint8 c *circular &#125; c := circular&#123;ui8: 1&#125; c.c = &amp;c fmt.Println(\"pui8:\", pui8) fmt.Println(\"pui8:\", *pui8) fmt.Println(\"------------\") fmt.Println(\"ppui8:\", ppui8) fmt.Println(\"ppui8:\", **ppui8) fmt.Println(\"------------\") // Print! spew.Printf(\"ppui8: %v\\n\", ppui8) spew.Printf(\"circular: %v\\n\", c)&#125; 输出为: 12345678pui8: 0xc00008e160pui8: 5------------ppui8: 0xc000088030ppui8: 5------------ppui8: &lt;**&gt;5circular: &#123;1 &lt;*&gt;&#123;1 &lt;*&gt;&lt;shown&gt;&#125;&#125; spew.ConfigState:1234567891011121314151617181920package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\")func main() &#123; scs := spew.ConfigState&#123;Indent: \"\\t\"&#125; // Output using the ConfigState instance. v := map[string]int&#123;\"one\": 1&#125; scs.Printf(\"v: %v\\n\", v) fmt.Println(\"--------------------\") scs.Dump(v)&#125; 输出为: 12345v: map[one:1]--------------------(map[string]int) (len=1) &#123; (string) (len=3) &quot;one&quot;: (int) 1&#125; // Indent specifies the string to use for each indentation level. The global config instance that all top-level functions use set this to a single space by default. If you would like more indentation, you might set this to a tab with “\\t” or perhaps two spaces with “ “. //缩进指定用于每个缩进级别的字符串。 默认情况下，所有顶级功能使用的全局配置实例将其设置为单个空间。 如果您希望缩进更多，可以将其设置为带有“ \\ t”的选项卡，或者带有“”的两个空格。 番外: *符号有两个用处: 表明这是一个指针类型,是一个状态,形容词; 解引用,是一个动作,动词 如 上面代码中的Name字段的类型为*string,即要求该字段需要是字符串指针类型. 变量name为string类型,则取指针即&amp;name后即变为*string类型,对&amp;name解引用*&amp;name则又变为string类型 123456789package mainimport \"fmt\"func main() &#123; name := \"fliter\" fmt.Println(*&amp;name)&#125; 输出为: 1fliter 更多可点击","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"使用dig理解DNS","date":"2016-12-11T13:52:11.000Z","path":"2016/12/11/使用dig理解DNS/","text":"本文全篇参考自阮一峰-DNS 原理入门，对照内容操作一遍。 查询过程 六段信息： 123456789101112131415161718dig dashen.tech; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; dashen.tech;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 17162;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;dashen.tech. IN A;; ANSWER SECTION:dashen.tech. 600 IN A 118.126.97.71;; Query time: 370 msec;; SERVER: 114.114.114.114#53(114.114.114.114);; WHEN: Mon Oct 11 11:50:50 CST 2016;; MSG SIZE rcvd: 45 第一段是查询参数和统计12345; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; dashen.tech;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 17162;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 第二段是查询内容12;; QUESTION SECTION:;dashen.tech. IN A 查询域名dashen.tech的A记录，A是address的缩写 第三段是DNS服务器的答复 12;; ANSWER SECTION:dashen.tech. 600 IN A 118.126.97.71 上面结果显示，dashen.tech有四个A记录，即一个IP地址。 600是TTL值（Time to live），表示缓存时间，即600秒之内不用重新查询。 如果是dig bilibili.com,则为: 1234;; ANSWER SECTION:bilibili.com. 61 IN A 120.92.174.135bilibili.com. 61 IN A 110.43.34.66bilibili.com. 61 IN A 119.3.238.64 有三个A记录 第四段显示dashen.tech的NS记录 NS是 Name Server的缩写，即哪些服务器负责管理dashen.tech的DNS记录。 最新的dig命令，没有了第四段，第五段的信息 第五段是上面四个域名服务器的IP地址 最新的dig命令，没有了第四段，第五段的信息 第六段是DNS服务器的一些传输信息 1234;; Query time: 370 msec;; SERVER: 114.114.114.114#53(114.114.114.114);; WHEN: Mon Oct 11 11:50:50 CST 2016;; MSG SIZE rcvd: 45 本机的DNS服务器是114.114.114.114，查询端口是53（DNS服务器的默认端口），以及回应长度是45字节 DNS服务器 本机一定要知道DNS服务器的IP地址。通过DNS服务器，才能知道某个域名的IP地址到底是什么。 DNS服务器的IP地址，可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。 （Linux系统里中，DNS服务器的IP地址保存在/etc/resolv.conf文件） DNS服务器可以用内网地址，也可以用公网的DNS服务器，如Google的8.8.8.8 本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果:123456789101112131415161718192021dig @8.8.8.8 dashen.tech ; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @8.8.8.8 dashen.tech; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 36114;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 512;; QUESTION SECTION:;dashen.tech. IN A;; ANSWER SECTION:dashen.tech. 600 IN A 118.126.97.71;; Query time: 85 msec;; SERVER: 8.8.8.8#53(8.8.8.8);; WHEN: Mon Oct 11 13:56:17 CST 2016;; MSG SIZE rcvd: 56 域名的层级 DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询 12;; QUESTION SECTION:;dashen.tech. IN A 每个域名的尾部都多了一个点, 这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。 即真正的域名为 dashen.tech.root，简写为dashen.tech. 。因为根域名.root对于所有域名都是一样的，所以可以省略 根域名的下一级，叫做”顶级域名”（top-level domain，TLD），比如.com、.net、.tech； 再下一级叫做”次级域名”（second-level domain，SLD），dashen.tech里面的.dashen，这一级域名是用户可以注册的； 再下一级是主机名（host），比如n.dashen.tech里面的n，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的 即 1234主机名.次级域名.顶级域名.根域名n.dashen.tech.root 根域名服务器 DNS服务器根据域名的层级，进行分级查询 每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。 (有点像网络的分层结构) 所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下： 123从\"根域名服务器\"查到\"顶级域名服务器\"的NS记录和A记录（IP地址）从\"顶级域名服务器\"查到\"次级域名服务器\"的NS记录和A记录（IP地址）从\"次级域名服务器\"查出\"主机名\"的IP地址 DNS服务器怎么知道”根域名服务器”的IP地址? 因为 “根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485; This file holds the information on root name servers needed to; initialize cache of Internet domain name servers; (e.g. reference this file in the \"cache . \"; configuration file of BIND domain name servers).;; This file is made available by InterNIC ; under anonymous FTP as; file /domain/db.cache; on server FTP.INTERNIC.NET; -OR- RS.INTERNIC.NET;; last update: Feb 04, 2008; related version of root zone: 2008020400;; formerly NS.INTERNIC.NET;. 3600000 IN NS A.ROOT-SERVERS.NET.A.ROOT-SERVERS.NET. 3600000 A 198.41.0.4A.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:BA3E::2:30;; formerly NS1.ISI.EDU;. 3600000 NS B.ROOT-SERVERS.NET.B.ROOT-SERVERS.NET. 3600000 A 192.228.79.201;; formerly C.PSI.NET;. 3600000 NS C.ROOT-SERVERS.NET.C.ROOT-SERVERS.NET. 3600000 A 192.33.4.12;; formerly TERP.UMD.EDU;. 3600000 NS D.ROOT-SERVERS.NET.D.ROOT-SERVERS.NET. 3600000 A 128.8.10.90;; formerly NS.NASA.GOV;. 3600000 NS E.ROOT-SERVERS.NET.E.ROOT-SERVERS.NET. 3600000 A 192.203.230.10;; formerly NS.ISC.ORG;. 3600000 NS F.ROOT-SERVERS.NET.F.ROOT-SERVERS.NET. 3600000 A 192.5.5.241F.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2f::f;; formerly NS.NIC.DDN.MIL;. 3600000 NS G.ROOT-SERVERS.NET.G.ROOT-SERVERS.NET. 3600000 A 192.112.36.4;; formerly AOS.ARL.ARMY.MIL;. 3600000 NS H.ROOT-SERVERS.NET.H.ROOT-SERVERS.NET. 3600000 A 128.63.2.53H.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:1::803f:235;; formerly NIC.NORDU.NET;. 3600000 NS I.ROOT-SERVERS.NET.I.ROOT-SERVERS.NET. 3600000 A 192.36.148.17;; operated by VeriSign, Inc.;. 3600000 NS J.ROOT-SERVERS.NET.J.ROOT-SERVERS.NET. 3600000 A 192.58.128.30J.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:C27::2:30;; operated by RIPE NCC;. 3600000 NS K.ROOT-SERVERS.NET.K.ROOT-SERVERS.NET. 3600000 A 193.0.14.129 K.ROOT-SERVERS.NET. 3600000 AAAA 2001:7fd::1;; operated by ICANN;. 3600000 NS L.ROOT-SERVERS.NET.L.ROOT-SERVERS.NET. 3600000 A 199.7.83.42;; operated by WIDE;. 3600000 NS M.ROOT-SERVERS.NET.M.ROOT-SERVERS.NET. 3600000 A 202.12.27.33M.ROOT-SERVERS.NET. 3600000 AAAA 2001:dc3::35; End of File 上面列表中 列出了根域名（.root）的所有NS记录A.ROOT-SERVERS.NET、B.ROOT-SERVERS.NET和C.ROOT-SERVERS.NET … M.ROOT-SERVERS.NET，以及它们的IP地址（即A记录） 所有记录的TTL值是3600000秒，相当于1000小时。即每1000小时才查询一次根域名服务器的列表。 世界上一共有十三组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET。 至于为何只有13台，而不是更多，可参考 DNS为什么查询根域名服务器只返回13个IP地址,主要原因是DNS包传输限制和DNS中UDP和TCP传输 分级查询的实例 使用 dig +trace dashen.tech 可以显示DNS的整个分级查询过程: 12345678910111213141516171819202122232425262728293031323334353637; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace dashen.tech;; global options: +cmd. 1572 IN NS m.root-servers.net.. 1572 IN NS g.root-servers.net.. 1572 IN NS b.root-servers.net.. 1572 IN NS k.root-servers.net.. 1572 IN NS d.root-servers.net.. 1572 IN NS h.root-servers.net.. 1572 IN NS f.root-servers.net.. 1572 IN NS j.root-servers.net.. 1572 IN NS l.root-servers.net.. 1572 IN NS e.root-servers.net.. 1572 IN NS i.root-servers.net.. 1572 IN NS a.root-servers.net.. 1572 IN NS c.root-servers.net.;; Received 239 bytes from 114.114.114.114#53(114.114.114.114) in 16 mstech. 172800 IN NS e.nic.tech.tech. 172800 IN NS b.nic.tech.tech. 172800 IN NS a.nic.tech.tech. 172800 IN NS f.nic.tech.tech. 86400 IN DS 50095 8 2 83F40D01141484D8F07305E5D2E44AC5663149054C598D6E9D993C66 1686C6EEtech. 86400 IN DS 50095 8 1 82F72F2462DEE25B99DA2470535AD0A7D131F1EBtech. 86400 IN RRSIG DS 8 1 86400 20161023170000 20161010160000 14748 . PoK6fDMO8T0AKyvodBWRAZK7Vo7Pl31PWefgfZma7TQLUPCxaxaLKZCJ D7EfmByB1f3nRWriGTlaLjiO6fKBoOePaNG0kL651fRTTfytDyjW6kXg e698gva7IzR9eocUV5FSu+bXZrKt6Hfxtmg1gSJU4MvIVGU0jPiI/GKc 52N6oc4r8kGN2Ca6HCT8bAL+bLvwTvqahYwsc43ixI+7JOpBYhw7te/B w0LhLjNP38ZSVnHiJzf3mwAGoF/Q9ub6mcruqC8Osp51J9gL60xvxai0 y/TgDLN66b8gsl2Z+62x7ViICnmxeqlwvDru3OtYmSlVx4JPp5onW9Bm 0kb/gw==;; Received 655 bytes from 192.112.36.4#53(g.root-servers.net) in 89 msdashen.tech. 3600 IN NS dns9.hichina.com.dashen.tech. 3600 IN NS dns10.hichina.com.9btf69hmd3n6368rdfnvtq09vgqbb2th.tech. 3600 IN NSEC3 1 1 1 - 9C0LP1P9G6FET7L79F0CMUGIH2GB7GUG NS SOA RRSIG DNSKEY NSEC3PARAM9btf69hmd3n6368rdfnvtq09vgqbb2th.tech. 3600 IN RRSIG NSEC3 8 2 3600 20161105153518 20161006082354 50883 tech. iCObjft9FYbJ1bUd08w9wx4NR/IOnYMgc8HdRKue2iX1OdLPEfuSEHvV qo00oNOKBg4Vwkd/gh6zyCGzErS0jukA0Wooske8Ws1qHI7iLqvlAh05 OJUubLRW4WCeuVfBqLALtoqaGZCF5m0qqgWKzZKwh/QEQNK3rdZlAzbK 2rQ=mesb2ou9l8il9h8n68m004d8e28iuq1h.tech. 3600 IN NSEC3 1 1 1 - MF0J2KO8MFRQD8VU89VHKFOBC9DISRCU NS DS RRSIGmesb2ou9l8il9h8n68m004d8e28iuq1h.tech. 3600 IN RRSIG NSEC3 8 2 3600 20161105050614 20161006082354 50883 tech. jYVanLMWDECIyolSk9UdCWiQZN4Hlr/Lh8dozO00+Yz6dHWGcUVaGrEl vTmZw1nU28iy/f2b7bUHvMFlOkqLRHTmzkw30YiQFxLULzeBEz22QSD/ AMrZBrNolEOkxZ9dZerRZZc80qLB1l0/LHbSNX4VENTbwwDVU8AXH+wu MW0=;; Received 577 bytes from 212.18.248.60#53(e.nic.tech) in 243 msdashen.tech. 600 IN A 118.126.97.71;; Received 56 bytes from 106.11.141.125#53(dns9.hichina.com) in 38 ms 第一段 列出根域名.的所有NS记录，即所有根域名服务器: 12345678910111213141516; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace dashen.tech;; global options: +cmd. 1572 IN NS m.root-servers.net.. 1572 IN NS g.root-servers.net.. 1572 IN NS b.root-servers.net.. 1572 IN NS k.root-servers.net.. 1572 IN NS d.root-servers.net.. 1572 IN NS h.root-servers.net.. 1572 IN NS f.root-servers.net.. 1572 IN NS j.root-servers.net.. 1572 IN NS l.root-servers.net.. 1572 IN NS e.root-servers.net.. 1572 IN NS i.root-servers.net.. 1572 IN NS a.root-servers.net.. 1572 IN NS c.root-servers.net.;; Received 239 bytes from 114.114.114.114#53(114.114.114.114) in 16 ms 根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问dashen.tech 的顶级域名服务器tech.的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。 1234tech. 172800 IN NS e.nic.tech.tech. 172800 IN NS b.nic.tech.tech. 172800 IN NS a.nic.tech.tech. 172800 IN NS f.nic.tech. 上面结果显示.tech域名的4条NS记录，同时返回的还有每一条记录对应的IP地址。 然后，DNS服务器向这些顶级域名服务器发出查询请求，询问dashen.tech的次级域名dashen.tech的NS记录: 12dashen.tech. 3600 IN NS dns9.hichina.com.dashen.tech. 3600 IN NS dns10.hichina.com. 上面结果显示dashen.tech有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。 然后，DNS服务器向上面这四台NS服务器查询.dashen.tech的主机名 （此处.dashen.tech和n.dashen.tech等效） 12dashen.tech. 600 IN A 118.126.97.71;; Received 56 bytes from 106.11.141.125#53(dns9.hichina.com) in 38 ms 上面结果显示，dashen.tech有`条A记录，即这四个IP地址都可以访问到网站。 并且还显示，最先返回结果的NS服务器是dns9.hichina.com，IP地址为106.11.141.125 NS 记录的查询 dig命令可以单独查看每一级域名的NS记录: 12345678910111213141516171819202122➜ ~ dig ns tech ; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; ns tech;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6506;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;tech. IN NS;; ANSWER SECTION:tech. 488 IN NS b.nic.tech.tech. 488 IN NS e.nic.tech.tech. 488 IN NS a.nic.tech.tech. 488 IN NS g.nic.tech.tech. 488 IN NS f.nic.tech.;; Query time: 295 msec;; SERVER: 114.114.114.114#53(114.114.114.114);; WHEN: Mon Oct 11 14:44:06 CST 2016;; MSG SIZE rcvd: 106 12345678910111213141516171819 dig ns dashen.tech; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; ns dashen.tech;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 15949;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;dashen.tech. IN NS;; ANSWER SECTION:dashen.tech. 1399 IN NS dns9.hichina.com.dashen.tech. 1399 IN NS dns10.hichina.com.;; Query time: 47 msec;; SERVER: 114.114.114.114#53(114.114.114.114);; WHEN: Mon Oct 11 14:44:15 CST 2016;; MSG SIZE rcvd: 79 DNS的记录类型 域名与IP之间的对应关系，称为”记录”（record）。 根据使用场景，”记录”可以分成不同的类型（type），如前面的A记录和NS记录 常见的DNS记录类型如下： 123456789（1） A：地址记录（Address），返回域名指向的IP地址。（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。 一般来说，为了服务的安全可靠，至少该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点故障。 CNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。 由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。 PTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录: 123456789101112131415161718➜ ~ dig -x 192.30.252.153; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; -x 192.30.252.153;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 56184;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;153.252.30.192.in-addr.arpa. IN PTR;; ANSWER SECTION:153.252.30.192.in-addr.arpa. 3600 IN PTR lb-192-30-252-153-iad.github.com.;; Query time: 48 msec;; SERVER: 223.5.5.5#53(223.5.5.5);; WHEN: Mon Oct 11 15:15:40 CST 2016;; MSG SIZE rcvd: 91 上面结果显示，192.30.252.153这台服务器的域名是lb-192-30-252-153-iad.github.com。 逆向查询的一个应用，可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名 dig命令可以查看指定的记录类型: 123dig a dashen.techdig ns dashen.techdig mx dashen.tech 其他DNS工具 whois命令可用来查看域名的注册情况: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 whois dashen.tech% IANA WHOIS server% for more information on IANA, visit http://www.iana.org% This query returned 1 objectrefer: whois.nic.techdomain: TECHorganisation: Radix FZCaddress: Directiplexaddress: Next to Andheri Subwayaddress: Old Nagardas Road, Andheri (East)address: Mumbai - 400069address: Indiacontact: administrativename: Directororganisation: Radix FZCaddress: Directiplexaddress: Next to Andheri Subwayaddress: Old Nagardas Road, Andheri (East)address: Mumbai - 400069address: Indiaphone: +1.4154494774fax-no: +91.2230797508e-mail: admin@radixregistry.comcontact: technicalname: CTOorganisation: CentralNicaddress: Saddlers House, 4th Flooraddress: 44 Gutter Laneaddress: London EC2V 6BRaddress: United Kingdomphone: +44.2033880600fax-no: +44.2033880601e-mail: tld.ops@centralnic.comnserver: A.NIC.TECH 194.169.218.60 2001:67c:13cc:0:0:0:1:60nserver: B.NIC.TECH 185.24.64.60 2a04:2b00:13cc:0:0:0:1:60nserver: E.NIC.TECH 212.18.248.60 2a04:2b00:13ee:0:0:0:0:60nserver: F.NIC.TECH 212.18.249.60 2a04:2b00:13ff:0:0:0:0:60ds-rdata: 50095 8 1 82F72F2462DEE25B99DA2470535AD0A7D131F1EBds-rdata: 50095 8 2 83F40D01141484D8F07305E5D2E44AC5663149054C598D6E9D993C661686C6EEwhois: whois.nic.techstatus: ACTIVEremarks: Registration information: http://www.radix.websitecreated: 2015-03-12changed: 2016-08-26source: IANA# whois.nic.techDomain Name: DASHEN.TECHRegistry Domain ID: D12780260-CNICRegistrar WHOIS Server: grs-whois.hichina.comRegistrar URL:Updated Date: 2019-11-07T06:57:51.0ZCreation Date: 2015-11-13T09:27:03.0ZRegistry Expiry Date: 2025-11-13T23:59:59.0ZRegistrar: Alibaba Cloud Computing Ltd. d/b/a HiChina (www.net.cn)Registrar IANA ID: 1599Domain Status: ok https://icann.org/epp#okRegistrant Organization: Cui ShuangRegistrant State/Province: Shan DongRegistrant Country: CNRegistrant Email: Please query the RDDS service of the Registrar of Record identified in this output for information on how to contact the Registrant, Admin, or Tech contact of the queried domain name.Admin Email: Please query the RDDS service of the Registrar of Record identified in this output for information on how to contact the Registrant, Admin, or Tech contact of the queried domain name.Tech Email: Please query the RDDS service of the Registrar of Record identified in this output for information on how to contact the Registrant, Admin, or Tech contact of the queried domain name.Name Server: DNS9.HICHINA.COMName Server: DNS10.HICHINA.COMDNSSEC: unsignedBilling Email: Please query the RDDS service of the Registrar of Record identified in this output for information on how to contact the Registrant, Admin, or Tech contact of the queried domain name.Registrar Abuse Contact Email: domainabuse@service.aliyun.comRegistrar Abuse Contact Phone: +86.95187URL of the ICANN Whois Inaccuracy Complaint Form: https://www.icann.org/wicf/&gt;&gt;&gt; Last update of WHOIS database:16-10-11T07:19:23.0Z &lt;&lt;&lt;# grs-whois.hichina.comAllow only queries : com,net,cc,tv 阮一峰-根域名的知识","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"echo导致的bug","date":"2016-12-07T12:35:40.000Z","path":"2016/12/07/echo导致的bug/","text":"鉴权服务的基本规则是对 秘钥AppSecret、随机字符串Nonce、当前时间戳CurTime，三者拼接然后进行SHA1运算，生成一个CheckSum。鉴权时传递AppKey、Nonce、CurTime及生成的CheckSum，鉴权服务器会进行同样运算，并比较结果。 可参考 请求结构-Header QA同事反映鉴权服务出现问题，我计算后发现，他得出的CheckSum和我用Go得出的结果不一致；另一位同事用Java，也得到了和我一致的结果。 QA同事是用shell进行请求，他忙无瑕查看，我要来脚本，代为debug。脱敏和简化后的代码如下： 123456#!/bin/bashAppSecret=123456qwertNonce=`cat /proc/sys/kernel/random/uuid` # Linux内核提供的生成uuid的方法CurTime=`date +%s` # 当前时间戳CheckSum=`echo \"$&#123;AppSecret&#125;$&#123;Nonce&#125;$&#123;CurTime&#125;\"|sha1sum|awk '&#123;print $1&#125;'`echo $&#123;CheckSum&#125; 加一些调试代码： 123456789#!/bin/bashAppSecret=123456qwertNonce=`cat /proc/sys/kernel/random/uuid` # Linux内核提供的生成uuid的方法echo 随机字符串为：$&#123;Nonce&#125;CurTime=`date +%s` # 当前时间戳echo 当前时间戳为：$&#123;CurTime&#125;CheckSum=`echo \"$&#123;AppSecret&#125;$&#123;Nonce&#125;$&#123;CurTime&#125;\"|sha1sum|awk '&#123;print $1&#125;'`echo $&#123;CheckSum&#125; (在一台Linux机器上) 执行结果如下： 随机字符串为：02b6811a-e742-4509-aca9-111cd9181171 当前时间戳为：1638879142 b024f38d88385afcf9d8af2e88d5e0d3660d73c6 而使用Go， 12345678910111213141516171819202122package mainimport ( \"crypto/sha1\" \"fmt\" \"io\")func main() &#123; appSecret := \"123456qwert\" nonce := \"02b6811a-e742-4509-aca9-111cd9181171\" //curTimeStr := strconv.Itoa(int(time.Now().Unix())) curTimeStr := \"1638879142\" t := sha1.New() io.WriteString(t, appSecret+nonce+curTimeStr) checkSum := fmt.Sprintf(\"%x\", t.Sum(nil)) fmt.Println(\"checkSum is:\", checkSum)&#125; 输出： 1checkSum is: cfc81eaa30c016f33b84575afe4a36afe78fcddc 将三者拼接的结果 123456qwert02b6811a-e742-4509-aca9-111cd91811711638879142，找一个在线SHA1网站运算: 与Go运算出的结果一致，初步可以判断shell写的有bug。 根据 这篇文章提示， 如果echo 指定-n，即不换行输出，则可能得到正确结果。一试果不其然…. echo不加-n会默认换行输出，换言之 echo ”123456qwert02b6811a-e742-4509-aca9-111cd91811711638879142“ 隐含有一个换行符\\n，在进行sha1sum运算时，包含了这个换行符，即 echo -ne &quot;123456qwert02b6811a-e742-4509-aca9-111cd91811711638879142\\n&quot; | sha1sum Go代码中添加\\n, 得到同样结果： 12345678910111213141516171819202122package mainimport ( \"crypto/sha1\" \"fmt\" \"io\")func main() &#123; appSecret := \"123456qwert\" nonce := \"02b6811a-e742-4509-aca9-111cd9181171\" //curTimeStr := strconv.Itoa(int(time.Now().Unix())) curTimeStr := \"1638879142\" t := sha1.New() io.WriteString(t, appSecret+nonce+curTimeStr+\"\\n\") checkSum := fmt.Sprintf(\"%x\", t.Sum(nil)) fmt.Println(\"checkSum is:\", checkSum)&#125; 输出： 1checkSum is: b024f38d88385afcf9d8af2e88d5e0d3660d73c6 另外 关于 echo -n 和echo -e 参数的意义： echo -n 不换行输出 echo -e 处理特殊字符 带有-e选项时，若字符串中出现以下字符,则特别加以处理，而不会将它当成一般文字输出： \\a 发出警告声； \\b 删除前一个字符； \\c 最后不加上换行符号； \\f 换行但光标仍旧停留在原来的位置； \\n 换行且光标移至行首； \\r 光标移至行首，但不换行； \\t 插入tab； \\v 与\\f相同； \\ 插入\\字符； \\nnn 插入nnn（八进制）所代表的ASCII字符；","tags":[{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"查看装有linux系统机器的配置","date":"2016-11-30T15:27:40.000Z","path":"2016/11/30/查看装有linux系统机器的配置/","text":"查看内存 free -m : 以M为单位进行展示内存使用情况123 total used free shared buff/cache availableMem: 3951 1797 910 4 1243 1853Swap: 0free -g : 以G为单位进行展示内存使用情况123 total used free shared buff/cache availableMem: 3 1 0 0 1 1Swap: 0 0 0以G为单位且”退一法”策略,精度不够准确—### 查看系统版本号 cat /etc/issue 1Ubuntu 16.04.3 LTS \\n \\l 查看CPU主频信息 lscpu 123456789101112131415161718192021222324Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 2On-line CPU(s) list: 0,1Thread(s) per core: 2Core(s) per socket: 1Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 79Model name: Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzStepping: 1CPU MHz: 2494.222BogoMIPS: 4988.44Hypervisor vendor: KVMVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 40960KNUMA node0 CPU(s): 0,1Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt 查看系统的ip地址 ifconfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 options=1203&lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP&gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201&lt;PERFORMNUD,DAD&gt;gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280stf0: flags=0&lt;&gt; mtu 1280XHC1: flags=0&lt;&gt; mtu 0XHC20: flags=0&lt;&gt; mtu 0XHC0: flags=0&lt;&gt; mtu 0en6: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether ac:de:48:00:11:22 inet6 fe80::aede:48ff:fe00:1122%en6 prefixlen 64 scopeid 0x7 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: activeen0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 78:4f:43:51:7c:f3 inet 15.38.229.23 netmask 0xfffff800 broadcast 15.38.231.255 media: autoselect status: activep2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304 ether 0a:4f:43:51:7c:f3 media: autoselect status: inactiveawdl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1484 ether fa:83:12:04:95:ed inet6 fe80::f883:12ff:fe04:95ed%awdl0 prefixlen 64 scopeid 0xa nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: activeen1: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether ee:00:78:72:c1:01 media: autoselect &lt;full-duplex&gt; status: inactiveen2: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether ee:00:78:72:c1:00 media: autoselect &lt;full-duplex&gt; status: inactiveen3: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether ee:00:78:72:c1:05 media: autoselect &lt;full-duplex&gt; status: inactiveen4: flags=8963&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 options=60&lt;TSO4,TSO6&gt; ether ee:00:78:72:c1:04 media: autoselect &lt;full-duplex&gt; status: inactivebridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt; ether ee:00:78:72:c1:01 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x2 member: en1 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 11 priority 0 path cost 0 member: en2 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 12 priority 0 path cost 0 member: en3 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 13 priority 0 path cost 0 member: en4 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 14 priority 0 path cost 0 media: &lt;unknown type&gt; status: inactiveutun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 2000 inet6 fe80::d73b:4182:e869:9982%utun0 prefixlen 64 scopeid 0x10 nd6 options=201&lt;PERFORMNUD,DAD&gt; 查看系统的CPU详细信息 cat /proc/cpuinfo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253processor : 0vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2494.222cache size : 40960 KBphysical id : 0siblings : 2core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveoptbugs :bogomips : 4988.44clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management:processor : 1vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2494.222cache size : 40960 KBphysical id : 0siblings : 2core id : 0cpu cores : 1apicid : 1initial apicid : 1fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveoptbugs :bogomips : 4988.44clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management:","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"}]},{"title":"Go Best Practice","date":"2016-11-27T07:39:29.000Z","path":"2016/11/27/Go-Best-Practice/","text":"如何写出优雅的 Go 语言代码 Go package和goroutine的一些理解和实践 Go 的一些”坑” init()的执行顺序 &amp;&amp; Go scheduler的初始化过程 不要乱用init，各种中间件等显式初始化，比如在main中或在main中调用初始化的方法，千万不存init满天飞 不要有src目录，不然隔着屏幕都能闻到一股浓浓的Java味 不要按MVC分层，按业务划分 fmt等格式化工具，有没有必要，要不要使用，压根不需要讨论 写好ut..几个package可以使用。 https://github.com/golang/mock Java 和 Ruby 这些语言在框架中往往采用水平拆分的方式划分不同层级的职责，而 Go 语言项目的最佳实践就是按照职责对模块进行垂直拆分 当然这并不是说我们一定不能使用 init 函数，作为 Go 语言赋予开发者的能力，因为它能在包被引入时隐式地执行了一些代码，所以我们更应该慎重地使用它们。 如果一个略有规模的项目中没有出现任何 type … interface 的定义，那么作者可以推测出这在很大的概率上是一个工程质量堪忧并且没有多少单元测试覆盖的项目，我们确实需要认真考虑一下如何使用接口对项目进行重构。 因为单元测试不是集成测试的，它的运行不应该依赖除项目代码外的其他任何系统","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"MySQL对json类型的操作","date":"2016-11-19T05:57:40.000Z","path":"2016/11/19/MySQL对json类型的操作/","text":"参考: https://www.lnmp.cn/mysql-57-new-features-json.html https://www.cnblogs.com/amerkor/p/13646581.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"浅析Chromium源码之获取和编译","date":"2016-11-11T03:11:11.000Z","path":"2016/11/11/浅析Chromium源码之获取和编译/","text":"官方文档 安装depot_toolsdepot_tools是Google官方提供的一个用来checkout、compile、run和submit的工具集 1234567git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git# 添加depot_tools路径到PATHexport PATH=&quot;$PATH:/Users/fliter/depot_tools&quot;source ~/.zshrc 如果Operation timed out，也可以使用国内的地址 git clone https://source.codeaurora.org/quic/lc/chromium/tools/depot_tools参见 depot_tools Google代码管理工具包如果只是为了看代码，也可以使用gitee快速克隆Chromium https://cloud.tencent.com/developer/article/1329229","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"hexo安装实用插件","date":"2016-11-08T11:53:53.000Z","path":"2016/11/08/hexo安装实用插件/","text":"支持数学公式 参见 hexo中插入数学公式 使hexo中的Markdown支持脚注功能 卸载hexo默认有渲染器： npm un hexo-renderer-marked --save 安装 hexo-renderer-markdown-it： npm i hexo-renderer-markdown-it --save (使用该插件并用如下配置，会使得###后面的内容在前面多一个段落起始符¶) 在根目录的 _config.yml中添加： 1234567891011121314151617181920212223# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor #permalinkSymbol: ¶ permalinkSymbol: ¶ 详解：12345678910111213141516171819202122232425262728293031# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: # 渲染设置 render: # 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串 html: true # 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思） xhtmlOut: false # 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现） breaks: true # 是否自动识别链接并把它渲染成链接 linkify: true # 是否自动识别印刷格式（意思是把(c)渲染为©这样的） typographer: true # 如果typographer被设置为true，则该选项用于设置将dumb quotes（\"\"）自动替换为smart quotes quotes: '“”‘’' # 设置所需插件 plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup # 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了） anchors: level: 2 collisionSuffix: 'v' permalink: true permalinkClass: header-anchor permalinkSymbol: ¶ 脚注 效果如下：Footnotes[^1] have a label[^label] and a definition[^DEF]. [^1]: This is a footnote[^label]: A footnote on “label”[^DEF]: The definition of a footnote. 下标 效果如下：sup x^2^ 上标 效果如下：ins Inserted 下划线 效果如下：https://github.com/hexojs/hexo-renderer-markdown-it 为hexo添加上标、下标、脚注等功能 为Hexo博客添加脚注插件","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Linux的进程和线程","date":"2016-11-04T10:41:09.000Z","path":"2016/11/04/Linux的进程和线程/","text":"点击 Linux内核分析与应用3-进程管理 多进程与多线程 fork: &emsp;&emsp;&nbsp;&emsp;&emsp;&emsp;&emsp;创建进程pthread_create: &emsp;创建线程ps -aux | wc -l: &emsp;&nbsp;&nbsp;统计进程数在Linux内核中,对于线程实现非常特殊, 他并不区分线程和进程, 线程只是一种特殊的进程罢了Linux内核初探:进程与线程—进程有独立的地址空间,线程则没有独立地址空间. 同一个进程的不同线程, 它们之间共享地址空间的.对于多进程模型, 因为之间相互独立, 其优点就是安全性比较好. 一个进程的crash, 不会导致整个软件的崩溃;而线程则不行,一个进程里的某个线程crash,会影响整个进程.多进程的缺点, 是其创建和上下文切换的开销比较大, 另外进程之间要想相互通讯需要专门的机制(IPC)才能实现进程间通讯.这恰恰是线程的优点, 如果是同一个进程的不同线程, 它们在一个进程的地址空间里，所以, 其相互通讯比较方便, 它们之间的切换也比较简单. (创建线程比较简单, 切换也比较轻巧, 通讯也比较方便, 相互协作比较好).但多线程也有缺点,就是不稳定.因为同一个进程里的若干个线程，如果有一个(线程)崩溃, 就会使得整个进程的其他线程也一起崩溃, 相互干扰比较大. (相互通讯比较容易,相互干扰也比较大)那软件设计时,一般采用多进程模型还是多线程模型呢? 要看具体的应用场景, 比如对于浏览器软件, (浏览器的每一个选项卡, 或说每一个浏览器页面, 是用多线程还是多进程实现更好呢?) 显然是多进程，为什么呢, 因为浏览器页面之间几乎没什么通讯需求, 所以这时候线程易于通讯的优点就发挥不出来, 反而是一个线程崩溃,导致同进程其他线程崩溃这个缺点非常致命. (肯定不希望一个页面崩溃,会连带导致其他页面也崩溃) . 所以我们一般是用多进程来实现浏览器的 ,实际上是访问同一个网站的若干页面是在一个进程的不同线程(如打开了三个新浪的新闻页,这三个页面对应一个进程), 但访问不同的网站是不同的进程(如打开了两个新浪,三个搜狐,一个网易,对应三个进程) 更多参阅: Linux 进程必知必会 进程、线程、轻量级进程、协程和go中的Goroutine 阮一峰-进程与线程的一个简单解释 Linux的任督二脉：进程调度和内存管理 面试必问：进程和线程有什么区别？","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"godoc","date":"2016-11-03T13:16:57.000Z","path":"2016/11/03/godoc/","text":"godoc 命令和 golang 代码文档管理 如何写高大上的 godoc（Go 文档） Go文档管理 godoc -http=127.0.0.1:6060 -play 或 简写为 godoc -http=:6060 -play Go 秉承 “注释即文档” 的理念，符合 godoc 的文档均从 Go 代码中提取并生成 有需要时再完善即可~","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"西甲第9场,瓦伦西亚vs巴塞罗那","date":"2016-10-23T14:05:00.000Z","path":"2016/10/23/西甲第9场-瓦伦西亚vs巴塞罗那/","text":"这场并不算豪门对决巨星竞技的比赛没成想如此异彩纷呈动人心魄. 刚在欧冠4:0击杀英超榜首曼城的巴萨,兵疲马弊,以残阵对阵江河日下的蝙蝠军团—10多年前,瓦伦西亚尚曾登顶西甲之巅而今风头已然不再. 上半场队魂伊涅斯塔膝盖被撞倒地不起,随后被抬下场,这让无数红蓝球迷眉头紧蹙倍觉不爽:32岁的老白已经年轻不再,每次受伤都可能会让他提前永远离开绿茵场. 随后梅西进球,直至上半场结束形势尚好. 下半场穆尼尔面对旧主取得进球,1:1. 4分钟后,纳尼挑传,罗德里戈跟进左脚凌空打门,比分反超. 这让我心里咯噔一下连连摇头,倘若齐装满员,尤其是要有小白这号中场大脑,剩下30分钟反超尚有可能,可是现在,客场作战,面对攻势如潮的瓦伦西亚,能够扳平比分吗? 6分钟后,巴萨角球机会,作为红蓝军团场上不多的几个高点之一的布教授争顶头球被扑出,苏牙左路爆射进门,2:2扳平. 直至最后伤停补时,双方激烈拼杀但均无斩获.我几乎准备接受平局结果,91分钟50几秒,一次配合,几次前场倒脚,苏牙带球来到禁区被放倒,毫无争议地获得点球… 这最后时刻突如其来的大悬念,让我骨碌一下翻身站起,双手攥拳屏神凝气.欣喜同时又有些忧心忡忡,活脱脱像写&lt;永遇乐 京口北固亭怀古&gt;时的辛弃疾… 我看到梅西站到点球点前,对方门将以扑点球著称,成功率能达42%! 那是短短一刻,但我闪过好多画面,是几个月前欧冠决赛点球点前的格里兹曼,是几个月前百年美洲杯决赛对阵智利面对俱乐部队友布拉沃的梅西,是多年前我第一次看欧冠面对切尔西时的C罗…甚至还有抢七大战最后时刻,轻飘飘一个背传失误而成遗恨的库里… 啊,所幸球进了….当真当是弯臂跃起大啸三声 是役,多赛一场的巴萨以19分暂时跃居西甲首位,梅西以22球超越萨拉成为对巴伦西亚取得进球最多的球员.射手榜上,本场苏神取得1球梅西收获2球,两人以7球暂居射手榜前二. 这场胜利不易,但希望老白伤情无碍,早日回到赛场.","tags":[{"name":"足球&体育","slug":"足球-体育","permalink":"http://www.dashen.tech/tags/足球-体育/"}]},{"title":"Scarborough Fair","date":"2016-10-09T15:39:17.000Z","path":"2016/10/09/Scarborough-Fair/","text":"Scarborough Fair 中文译作斯卡波罗集市. 原是一首古老的英国民歌，其起源可一直追溯到中世纪. 此曲还被用作电影《毕业生》插曲 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： Are you going to scarborough fair?问尔所之，是否如适。 Parsely sage rosemary and thyme.蕙兰芫荽，郁郁香芷。 Remember me to one who lives there.彼方淑女，凭君寄辞。 (he/) she once was a true love of mine.伊人曾在，与我相知。 Tell (him/)her to make me a cambric shirt.嘱彼佳人，备我衣缁。 Parsely sage rosemary and thyme.蕙兰芫荽，郁郁香芷。 Without no seams nor needle work.勿用针砧，无隙无疵。 Then she will be a true love of mine.伊人何在，慰我相思。 on the side of hill in the deep forest green,彼山之阴，深林荒址。 tracing of sparrow on snow crested brown.冬寻毡毯，老雀燕子。 blankets and bed clothers the child of maintain雪覆四野，高山迟滞。 sleeps unawafe of the clarion call.眠而不觉，寒笳清嘶。 tell her to find me an acre of land.嘱彼佳人，营我家室。 parsely sage rosemary and thyme.蕙兰芫荽，郁郁香芷。 between the salt water and the sea strand,良田所修，大海之坻。 then she will be a true love of mine.伊人应在，任我相视。 on the side of hill a sprinkling of leaves彼山之阴，叶疏苔蚀。 washes the grave with slivery tears.涤我孤冢，珠泪渐渍。 a soldier cleans and polishes a gun.惜我长剑，日日拂拭。 sleeps unaware of the clarion call.寂而不觉，寒笳长嘶。 tell her to reap it with a sickle of leather.嘱彼佳人，收我秋实。 parsely sage rosemary and thyme.蕙兰芫荽，郁郁香芷。 and gather it all in a bunch of heather.敛之集之，勿弃勿失。 then she will be a ture love of mine.伊人犹在，唯我相誓。 generals order their soldiers to kill and to fight for a cause.将帅有令，勤王之事。 they have long ago forgoten.争斗缘何，久忘其旨。 sleeps unaware of the clarion call痴而不觉，寒笳悲嘶。","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Hotel California","date":"2016-10-07T16:03:20.000Z","path":"2016/10/08/Hotel-California/","text":"Hotel California 中文译作加州旅馆 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： On a dark desert highway, cool wind in my hair子夜荒原,风啸吾鬓.Warm smell of colitas, rising up through the air燥风鼓涌,气蒸腾迷.Up ahead in the distance, I saw a shimmering light引首彼方,灯火豆荧.My head grew heavy and my sight grew dim昏弱已极,抬眼欲迷.I had to stop for the night There she stood in the doorway;渴求投栖,忽见娉婷.I heard the mission bell And I was thinking to myself, “This could be Heaven or this could be Hell”恍惚存疑,未知何地?Then she lit up a candle and she showed me the way烛炬微燃,示吾前行.There were voices down the corridor, I thought I heard them say…骤闻歌泣,侧耳倾听.“Welcome to the Hotel California幸哉行者,至此仙境.Such a lovely place, Such a lovely face福地洞天,妙颜清丽.Plenty of rooms at the Hotel California客舍俨然,轩室无尽.Any time of year, you can find it here “何时来此,永可欢愉.Her mind is Tiffany-twisted, she got the Mercedes bends伊人心深,曲丝琉璃.She got a lot of pretty, pretty boys, that she calls friends宝鞍良驹,少年如云.How they dance in the courtyard, sweet summer sweat.庭院蹁跹,蜜汗甜雨.Some dance to remember, some dance to forget或舞为忘,或舞为忆.So I called up the Captain, “Please bring me my wine” He said, ‘We haven’t had that spirit here since 1969’唤仆取酒,答已久磬.And still those voices are calling from far away, Wake you up in the middle of the night远歌遥吟,震耳惊心.Just to hear them say…幽幽一曲,行者何幸!“Welcome to the Hotel California Such a lovely place，Such a lovely face福地洞天,妙颜清丽.They livin’ it up at the Hotel California What a nice surprise, bring your alibis”沉醉纵乐, 何顾德行.Mirrors on the ceiling, The pink champagne on ice粉冰沉醴,玉镜莹莹.And she said ‘We are all just prisoners here, of our own device’吾辈为囚,臣服诸欲.And in the master’s chambers, They gathered for the feast堂室辉煌,开宴相聚.They stab it with their steely knives, But they just can’t kill the beast剑影刀光,狂舞无益.Last thing I remember, I was running for the door I had to find the passage back to the place I was before惊惶疾奔,逃寻归径.Relax,’ said the night-man,侍者低语,佳客莫惊,“ We are programmed to receive.吾等相守,永来伺宾.You can checkout any time you like,君既来此,莫思相离.but you can never leave!”告别无期,在此心狱!","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"The Sound of Silence","date":"2016-10-07T15:58:11.000Z","path":"2016/10/07/The-Sound-of-Silence/","text":"The Sound of Silence 中文译作寂静之声 或 寂静之音. &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： Hello darkness, my old friend,寂静吾友，君可安然。I’ve come to talk with you again,又会君面，默语而谈。Because a vision softly creeping, Left its seeds while I was sleeping,浮光掠影，清梦彷徨。And the vision that was planted in my brain ，Still remains幽幽往昔，慰我心房。Within the sound of silence. In restless dreams I walked alone寂静之声，孤独过往。Narrow streets of cobblestone, ‘Neath the halo of a street lamp,迢迢陋巷，回声辗转。I turned my collar to the cold and damp When my eyes were stabbed by the flash of a neon light薄襟何耐，子夜灯凉。That split the night，And touched the sound of silence.忧伤流布，寂寞声残。And in the naked light I saw，Ten thousand people, maybe more.忽而望之，灯下熙攘。People talking without speaking, People hearing without listening,无声而言，无事而忙。People writing songs that voices never share ，And no one dare Disturb the sound of silence.妙音难享，曲成即藏。“Fools” said I, “You do not know Silence like a cancer grows.愚者何知，寂静如伤。hear my words that I might teach you, Take my arms that I might reach you.”且相携手，听我衷肠。But my words like silent raindrops fell, And echoed In the wells of silence寂静雨珠，连落难断。And the people bowed and prayed ，To the neon god they made.造神祈祷，正经虔然。And the sign flashed out its warning, In the words that it was forming.警语宣诫，且莫失忘。And the sign said, “The words of the prophetsare written on the subway wallsAnd tenement halls.”万千心语，谁知其详？And whisper’d in the sounds of silence.In the sounds of silenceIn the sounds of silence唯尔寂静，轻声永传。","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Sleeping Sun","date":"2016-10-06T15:52:24.000Z","path":"2016/10/06/Sleeping-Sun/","text":"Sleeping Sun 中文译作赤晖深堕 或 落噪归静. 死亡的悲伤、禁忌的爱、深重的痛苦构成了这首歌曲 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： The sun is sleeping quietlyOnce upon a century日兮日兮沉沦东海百年孤寂Wistful oceans calm and redArdent caresses laid to rest沧浪之水浴血奔歌环日而息For my dreams I hold my lifeFor wishes I behold my night彼云之梦穷尽吾生征途如夜漫漫多岐The truth at the end of timeLosing faith makes a crime时不逝兮真假不现无失吾念无加吾罪I wish for this night-timeto last for a lifetimeThe darkness around meShores of a solar sea愿待吾生此景长留黑暗有翼光岸若失Oh how I wish to go down with the sunSleepingWeepingWith you旸兮旸兮愿将从之与子同逝与子同泣Sorrow has a human heartFrom my god it will depart悲通心灵坚信吾念忧伤不至I’d sail before a thousand moonsNever finding where to go寻航千月上下求索无处可觅Two hundred twenty-two days of lightWill be desired by a night彼光之日为炬成灰无数永昼只为一夕A moment for the poet’s playUntil there’s nothing left to say壮兮美哉诗人传颂世人无语悄然沉醉I wish for this night-timeto last for a lifetimeThe darkness around meShores of a solar sea愿待吾生此景长留黑暗有翼光岸若失Oh how I wish to go down with the sunSleepingWeepingWith you旸兮旸兮誓将从之与子同逝与子同泣I wish for this night-timeto last for a lifetimeThe darkness around meShores of a solar sea愿待吾生此景长留黑暗有翼光岸若失Oh how I wish to go down with the sunSleepingWeepingWith you旸兮旸兮誓将从之与子同逝与子同泣 &nbsp;&nbsp;&nbsp;&nbsp; 另一版本如下： The sun is sleeping quietly日渐寂于渊Once upon a century弹指逾百年Wistful oceans calm and red日暮熔沧海Ardent caresses laid to rest漠漠洗铅华For my dreams I hold my life此生托迷梦For wishes I behold my night夙夜求慧眼The truth at the end of time时穷知乃现Losing faith makes a crime独惑一念间I wish for this night-time唯盼夜翼垂to last for a lifetime扶将终此生The darkness around me浓夜如毡裹Shores of a solar sea卷我日寂海Oh how I wish to go down with the sun愿为随日没Sleeping Weeping With you与子并孤枕Sorrow has a human heart断肠谁曾补From my god it will depart唯恐尽流年I’d sail before a thousand moons欲将逐明月Never finding where to go无尽穷所托Two hundred twenty-two days of light光明苦匆匆Will be desired by a night转瞬归长夜A moment for the poet’s play少年负侠气Until there’s nothing left to say已如梦黄粱I wish for this night-time唯盼夜恒驻to last for a lifetime此生绕璧间The darkness around me夜魇如毡裹Shores of a solar sea席我滨日崖Oh how I wish to go down with the sun誓愿随日没Sleeping WeepingWith you与子同衾眠","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Hey Jude","date":"2016-10-05T15:45:52.000Z","path":"2016/10/05/Hey-Jude/","text":"Hey Jude 是披头士乐队成员 保罗·麦卡特尼创作的一首歌，于1968年发行。当时另一位成员约翰·列侬第一次离婚，其儿子朱利安闷闷不乐，保罗·麦卡特尼通过这首歌鼓励朱利安勇敢面对现实。 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： Hey jude, don’t make it bad吾侄朱得 勿自伤情Take a sad song and make it better抚琴奏曲 歌以咏志Remember to let her into your heart将之汝心 将之汝命Then you can start to make it better含苞待放 实可至也Hey jude, don’t be afraid吾侄朱得 勿忧勿惧You were made to go out and get her朱门开启 佳人欢颜The minute you let her under your skin 将之肌肤 如影随形Then you begin to make it better含苞待放 实可至也And anytime you feel the pain, hey jude, refrain吾侄朱得 痛勿轻陈Don’t carry the world upon your shoulders山雨欲来 之关门For well you know that it’s a fool who plays it cool愚夫献雅 鸡犬相闻By making his world a little colder阴沟调醋 暗自伤神Hey jude, don’t let me down吾侄朱得 勿欺吾盼You have found her, now go and get her朝识佳人 夕归为伴Remember to let her into your heart将之汝心 将之汝命Then you can start to make it better含苞待放 其可至也So let it out and let it in, hey jude, begin吾侄朱得 花开堪折 将启程You’re waiting for someone to perform with红袖添香 时不我待And don’t you know that it’s just you非寒三日 尺冰何在Hey jude, you’ll do吾侄朱得 君须谨记The movement you need is on your shoulder鲈鱼鲜美 结网先行 &nbsp;&nbsp;&nbsp;&nbsp;另一版本： Hey jude, don’t make it bad吾侄朱得勿自伤情Take a sad song and make it better聆彼伤曲，心复又晴Remember to let her into your heart深切勿忘，请君入心Then you can start to make it better由是我知，心复又平Hey jude, don’t be afraid吾侄朱得，勿要惶惶You were made to go out and get her轻启朱门，求彼伊芳The minute you let her under your skin欢聚时辰，护彼在怀Then you begin to make it better由是我知，花开愈旺And anytime you feel the pain, hey jude, refrain若彼成殇，克之制之Don’t carry the world upon your shoulders三寸之肩，何担天下For well you know that it’s a fool who plays it cool汝当了悟，抑之愚矣By making his world a little colder惟余卿心，冷而复寒Hey jude, don’t let me down吾侄朱得，勿负我望You have found her, now go and get her既已寻彼，求之伊芳Remember to let her into your heart 深切勿忘，请君入心Then you can start to make it better由是我知，花开愈旺So let it out and let it in, hey jude, begin畅诉幽肠，至彼伊芳You’re waiting for someone to perform with三生等待，与子同裳And don’t you know that it’s just you何为不知，卿本此样Hey jude, you’ll do吾侄朱得，为之苍茫The movement you need is on your shoulder汝需所行，见彼肩上","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Casablanca","date":"2016-10-05T15:34:11.000Z","path":"2016/10/05/Casablanca/","text":"Casablanca 中文译作卡萨布兰卡. 是上世纪70年代由 Bertie Higgins在看完同名电影后有感而写 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： I fell in love with you watching CasablancaBack row of the drive in show in the flickering light 偕子后庭，谍影观兮，灯摇火曳，好逑卿兮。Popcorn and cokes beneath the stars became champagne and caviarMaking love on a long hot summers night熟水黍饮，化秬鬯兮，酷暑长夜，葛藟绵兮。I thought you fell in love with me watching CasablancaHolding hands ‘neath the paddle fans in Rick’s Candle lit cafe执子之手，眸映月兮，卿车我共，徜徉戏兮。Hiding in the shadows from the spiesMoroccan moonlight in your eyes热唇蜜吻，佚卿淡兮，卿我爱意，暨日增兮。Making magic at the movies in my old chevroletOh A kiss is still a kiss in Casablanca戏里关雎，惄其情兮，未尝莅斯，不我感兮。But A kiss is not a kiss without your sighPlease come back to me in Casablanca戏外卿我，简不载兮，遐弃我以，怛心膂兮。I love you more and more each day as time goes byI guess there’re many broken hearts in CasablancaYou know I’ve never really been thereSo I don’t know热唇蜜吻，佚卿淡兮，卿我爱意，暨日增兮。","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Someone Like You","date":"2016-10-05T15:05:10.000Z","path":"2016/10/05/Someone-Like-You/","text":"Someone Like You 中文译作另寻沧海 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： I heard, that your settled down.已闻君，诸事安康。That you, found a girl and you’re married now.遇佳人，不久婚嫁。I heard that your dreams came true.已闻君，得偿所想。Guess she gave you things, I didn’t give to you.料得是，卿识君望。Old friend, why are you so shy?旧日知己，何故张皇？It ain’t like you to hold back or hide from the lie.遮遮掩掩，欲盖弥彰。I hate to turn up out of the blue uninvited.客有不速，实非我所想。But I couldn’t stay away, I couldn’t fight it.避之不得，遑论与相抗。I’d hoped you’d see my face&amp; that you’d be reminded,异日偶遇，识得依稀颜。That for me, it isn’t over.再无所求，涕零而泪下。Never mind, I’ll find someone like you.毋须烦恼，终有弱水替沧海。I wish nothing but the best, for you too.抛却纠缠，再把相思寄巫山。Don’t forget me, I beg, I remember you said:勿忘昨日，亦存君言于肺腑。“Sometimes it lasts in love but sometimes it hurts instead”“情堪隽永，也善心潮掀狂澜。”Sometimes it lasts in love but sometimes it hurts instead, yeah.情堪隽永，也善心潮掀狂澜，然。You’d know, how the time flies.光阴常无踪，词穷不敢道荏苒。Only yesterday, was the time of our lives.欢笑仍如昨，今却孤影忆花繁。We were born and raised in a summery haze.彼时初执手，夏雾郁郁湿衣衫。Bound by the surprise of our glory days.自缚旧念中，诧喜荣光永不黯。I hate to turn up out of the blue uninvited.客有不速，实非我所想。ButI couldn’t stay away, I couldn’t fight it.避之不得，遑论与相抗。I’d hoped you’d see my face&amp; that you’d be reminded,异日偶遇，识得依稀颜。That for me, it isn’t over.再无所求，涕零而泪下。Never mind, I’ll find someone like you.毋须烦恼，终有弱水替沧海。I wish nothing but the best, for you too.抛却纠缠，再把相思寄巫山。Don’t forget me, I beg, I remember you said:勿忘昨日，亦存君言于肺腑。“Sometimes it lasts in love but sometimes it hurts instead”“情堪隽永，也善心潮掀狂澜。”Sometimes it lasts in love but sometimes it hurts instead, yeah.情堪隽永，也善心潮掀狂澜，然。Nothing compares, no worries or cares.无可与之相提，切莫忧心同挂念。Regret’s and mistakes they’re memories made.糊涂遗恨难免，白璧微瑕方可恋。Who would have known how bittersweet this would taste?此中酸甜苦咸，世上谁人堪相言？Never mind, I’ll find someone like you.毋须烦恼，终有弱水替沧海。I wish nothing but the best, for you too.抛却纠缠，再把相思寄巫山。Don’t forget me, I beg, I remember you said:勿忘昨日，亦存君言于肺腑。“Sometimes it lasts in love but sometimes it hurts instead”“情堪隽永，也善心潮掀狂澜。”Sometimes it lasts in love but sometimes it hurts instead, yeah.情堪隽永，也善心潮掀狂澜，然。Never mind, I’ll find someone like you.毋须烦恼，终有弱水替沧海。I wish nothing but the best, for you too.抛却纠缠，再把相思寄巫山。Don’t forget me, I beg, I remember you said:勿忘昨日，亦存君言于肺腑。“Sometimes it lasts in love but sometimes it hurts instead”“情堪隽永，也善心潮掀狂澜。”Sometimes it lasts in love but sometimes it hurts instead, yeah.情堪隽永，也善心潮掀狂澜，然。 &nbsp;&nbsp;&nbsp;&nbsp; 另一个版本： I heard, that your settled down. 幸闻君事 安得所往 That you, found a girl and your married now. 宜室佳人 携子与归 I heard that your dreams came true. 幸闻君事 安得所愿 Guess she gave you things, I didn’t give to you. 君之所望 卿俱偿兮。 Old friend, why are you so shy? 嗟乎故友，为何遑然？ It ain’t like you to hold back or hide from the lie. 已然旧事，坦告吾知。 I hate to turn up out of the blue uninvited. 卿之今日 吾之昔兮 ButI couldn’t stay away, I couldn’t fight it. 逝如流水，勿论相逆。 I’d hoped you’d see my face&amp; that you’d be reminded, 但望君顾，尤识旧颜。 That for me, it isn’t over. 此去已矣，感而伤兮。 Never mind, I’ll find someone like you. 叹兮无忧，三千弱水。 I wish nothing but the best, for you too. 唯寄与愿 心系念之 。 Don’t forget me, I beg, I remember you said: 昨日尤在 君音绕耳。 “Sometimes it lasts in love but sometimes it hurts instead” “隽情如醉，心怀伤之。” Sometimes it lasts in love but sometimes it hurts instead, yeah. 隽情如醉，心怀伤之，已矣。 You’d know, how the time flies. 叹兮今岁，荏苒如箭。 Only yesterday, was the time of our lives. 旧影如昨，莞而思之。 We were born and raised in a summery haze. 夏雾郁郁 炽爱如燃。 Bound by the surprise of our glory days. 思之念之，如坠星火。 I hate to turn up out of the blue uninvited. 卿之今日 吾之昔兮 ButI couldn’t stay away, I couldn’t fight it. 逝如流水，勿论相逆。 I’d hoped you’d see my face&amp; that you’d be reminded, 但望君顾，尤识旧颜。 That for me, it isn’t over. 此去已矣，感而伤兮。 Nothing compares, no worries or cares. 无以相较，无可相顾。 Regret’s and mistakes they’re memories made. 爱伤恨遗，情之所系。 Who would have known how bittersweet this would taste? 个中百味，谁可堪言？ Never mind, I’ll find someone like you. 叹兮无忧，三千弱水。 I wish nothing but the best, for you too. 唯寄与愿 心系念之 。 Don’t forget me, I beg, I remember you said: 昨日尤在 君音绕耳。 “Sometimes it lasts in love but sometimes it hurts instead” “隽情如醉，心怀伤之。” Sometimes it lasts in love but sometimes it hurts instead, yeah. 隽情如醉，心怀伤之，已矣。","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"What Are Words","date":"2016-10-04T14:21:25.000Z","path":"2016/10/04/What-Are-Words/","text":"What Are Words 中文译作你的话到底算什么 Anywhere you are, I am near不论你在何处，我都会在你身旁Anywhere you go, I’ll be there不论你去何方，我都会一路相伴Anytime you whisper my name, you’ll see不论何时，只要你轻呼唤我的名字，我就会出现Every single promise I’ll keep我信守着每一个誓言Cause what kind of guy would I be因为如果在你最需要我的时候离去If I was to leave when you need me most这样的我，还算什么呢What are words那些誓言If you really don’t mean them如果不是发自真心When you say them有何意义What are words那些誓言If they’re only for good times如果不能共患难Then that‘s all又有何意义When it’s love当爱至深时Yeah, you say them out-loud those words你大声许下的那些诺言They never go away永远都不会消逝They live on, even when we’re gone即使我们都已逝去，誓言仍直到永远And I know an angel was sent just for me上帝为我派来了一位天使And I know I’m meant to be where I am现在我终于明白 我的使命And I’m gonna be standing right beside her tonight终于明白 我该何去何从 今夜起 我将守候在她身旁And I’m gonna be by your side我永远在你身边I would never leave when she needs me most在她最需要我的时候 我将不离不弃What are words那些誓言If you really don’t mean them如果不是发自真心When you say them有何意义What are words那些誓言If they’re only for good times如果不能共患难Then they don’t又有何意义When it’s love当爱至深时Yeah, you say them out-loud those words你大声许下的那些诺言They never go away永远都不会消逝They live on, even when we’re gone即使我们都已逝去，誓言仍直到永远Anywhere you are, I am near不论你在何处，我都会在你身旁Anywhere you go, I’ll be there不论你去何方，我都会一路相伴And I’m gonna be here forever more一直一直陪伴着你Every single promise I keep我信守着每一个誓言Cause what kind of guy would I be因为如果在你最需要我的时候离去If I was to leave when you need me most这样的我，还算什么呢I’m forever keeping my angel close我会紧紧守护着我的天使直到永远","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Greensleeves","date":"2016-10-03T14:58:52.000Z","path":"2016/10/03/Greensleeves/","text":"Greensleeves 中文译作绿袖子,一首英国民谣，据传为亨利八世所作 &nbsp;&nbsp;&nbsp;&nbsp;诗经体译文 如下： Alas my love, you do me wrong我思断肠，伊人不臧。 To cast me off discourteously 弃我远去，抑郁难当。I have loved you all so long我心相属，日久月长。Delighting in your company与卿相依，地老天荒。Greensleeves was all my joy绿袖招兮，我心欢朗。Greensleeves was my delight绿袖飘兮，我心痴狂。Greensleeves was my heart of gold绿袖摇兮，我心流光。And who but my Lady Greensleeves绿袖永兮，非我新娘。I have been ready at your hand我即相偎，柔荑纤香。To grant whatever you would crave我自相许，舍身何妨。I have both waged life and land欲求永年，此生归偿。Your love and good will for to have回首欢爱，四顾茫茫。Thou couldst desire no earthly thing伊人隔尘，我亦无望。But still thou hadst it readily彼端箜篌，渐疏渐响。Thy music still to play and sing人既永绝，心自飘霜。And yet thou wouldst not love me斥欢斥爱，绿袖无常。Greensleeves now farewell adieu绿袖去矣，付与流觞。God I pray to prosper thee我燃心香，寄语上苍。For I am still thy lover true我心犹炽，不灭不伤。Come once again and love me伫立垅间，待伊归乡。","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"Right Here Waiting","date":"2016-10-03T06:48:36.000Z","path":"2016/10/03/Right-Here-Waiting/","text":"Right Here Waiting 中文译作此情可待 Oceans apart day after day 海隔一方，日复一日And I slowly go insane我开始恍惚I hear your voice on the line你的声音在线可闻But it doesn’t stop the pain但哪能消解心中愁闷If I see you next to never 倘若此生不能相见How can we say forever 何能誓说海枯石烂Wherever you go 任凭天涯海角Whatever you do 任凭天马行空I will be right here waiting for you 此生为你守候Whatever it takes 莫道付出天大代价Or how my heart breaks 莫道我心破碎I will be right here waiting for you 为你此地守候I took for granted all the times 我曾一直笃信That I thought I would last somehow 你我能共度良宵I hear the laughter I taste the tears 我内心窃喜But I can’t get near you now 我孤芳自赏Oh can’t you see it baby哦 亲爱的，你哪能不知？You’ve got me goin’ crazy 让我身心如此癫狂?Wherever you go 凭天涯海角Whatever you do 任凭天马行空I will be right here waiting for you 此生为你守候Whatever it takes 莫道付出天大代价Or how my heart breaks 道我心破碎I will be right here waiting for you 为你此地守候I wonder how we can survive 好想知晓，如何安享此情此爱？This romance 这种浪漫But in the end if I’m with you 但倘若有一天能回到你身边I’ll take the chance 我会奋不顾身Oh can’t you see it baby 哦 亲爱的，你哪能不知？You’ve got me goin’ crazy 让我身心如此癫狂?Wherever you go 任凭天涯海角Whatever you do 任凭天马行空I will be right here waiting for you 此生为你守候Whatever it takes 莫道付出天大代价Or how my heart breaks莫道我心破碎I will be right here waiting for you 为你此地守候Waiting for you 为你守候","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"浙城浙湖","date":"2016-09-25T14:20:47.000Z","path":"2016/09/25/浙城浙湖/","text":"上有天堂，下有苏杭。白苏柳永一线文人的吟咏传颂，让此浙城浙湖名贯神州。 自富阳至桐庐一百许里，奇山异水，天下独绝。 这里有魂侑江东的孙氏英烈。 这里“风清听漏惊乡梦，灯下闻歌乱别愁。” 这里“山名天竺堆青黛，湖号钱唐泻绿油。” 这里“烟柳画桥，风帘翠幕，参差十万人家。” 这里有玉龙金凤明珠跌落的城市名片，西湖西子两相宜，是“黑云翻墨未遮山， 白雨跳珠乱入船”，或是“接天莲叶无穷碧，映日荷花别样红”，抑是“雾凇沆砀，天与云、与山、与水，上下一白”。 雷峰塔外，三五讨论是否能寻盛装白蛇的钵盂；灵隐寺旁，焚香念经的老人还会常提吴越王智退黄巢的旧谈。 三潭印月，断桥残雪，南屏晚钟，曲院风荷，柳浪闻莺，金牛出水，平湖秋月，三台梦迹…一个个诗意的名字背后，是同样诗意的故事和风景。 这里青山有幸得埋忠骨，他们是抗击外族侵略的民族英雄。或意图直捣黄龙府重整旧河山，或挽国家于危亡 匡社稷于即颠，或明知事难偏要勉强。他们并称“三杰”，后一位叛徒出卖死于敌手，前两位却是被自己人直接所害。他们是39岁的岳飞，59岁的于谦，42岁的张煌言。 玉泉，之江，西溪，紫金港，华家池，这里有中国最“水”的浙大。淘宝，天猫，阿里巴巴，支付宝，这里有互联网时代最明星的企业。 鲁冠球，宗庆后，冯根生，汪力成，当然还有互联网造就的两位首富，三石和扁哥，他们跨越多个年龄段，涵盖多个领域，他们并非都籍贯在此出生于斯，却把企业重要核心业务甚至总部放于距离上海咫尺之遥的杭州。 这里的GDP刚刚超过1万亿，止位列全国第十。落后于天津，苏州，重庆，成都和武汉。但影响力和潜力，却绝不止第10。这里房屋开启限购，初和北上深一样“待遇”。 这是画卷和诗词，历史和神话里的杭州。当抱以满满期待身至亲临，却不出所料发现，像远望畅阔天际的星空，转头仍要踩在硬邦邦的尘世土地。 /接下","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"go get某个包某次提交后的代码","date":"2016-09-14T12:29:34.000Z","path":"2016/09/14/go-get某个包某次提交后的代码/","text":"go get xxxxxxx@某次commit_id","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"使用rust开发命令行工具","date":"2016-09-12T13:55:05.000Z","path":"2016/09/12/使用rust开发命令行工具/","text":"生成二进制文件，将其扔到环境变量的path下即可~ 用rust打造实时天气命令行工具 找到合适的API 使用该api 如请求 api.openweathermap.org/data/2.5/weather?q=Beijing&amp;appid=your_key: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"coord\": &#123; \"lon\": 116.3972, \"lat\": 39.9075 &#125;, \"weather\": [&#123; \"id\": 803, \"main\": \"Clouds\", \"description\": \"broken clouds\", \"icon\": \"04d\" &#125;], \"base\": \"stations\", \"main\": &#123; \"temp\": 293.35, \"feels_like\": 292.34, \"temp_min\": 291.09, \"temp_max\": 294.13, \"pressure\": 1026, \"humidity\": 35, \"sea_level\": 1026, \"grnd_level\": 1020 &#125;, \"visibility\": 10000, \"wind\": &#123; \"speed\": 4.86, \"deg\": 344, \"gust\": 7.43 &#125;, \"clouds\": &#123; \"all\": 73 &#125;, \"dt\": 1634262993, \"sys\": &#123; \"type\": 2, \"id\": 2021025, \"country\": \"CN\", \"sunrise\": 1634250256, \"sunset\": 1634290552 &#125;, \"timezone\": 28800, \"id\": 1816670, \"name\": \"Beijing\", \"cod\": 200&#125; 初始化项目&amp;coding 使用cargo new rust_weather 初始化一个项目。 对于cargo.toml文件： 123456789101112131415[package]name = \"rust_weather\"version = \"0.1.0\"edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]structopt = \"0.3.21\"exitfailure = \"0.5.1\"serde = \"1.0.114\"serde_json = \"1.0.56\"serde_derive = \"1.0.114\"reqwest = &#123; version = \"0.11\", features = [\"json\"] &#125;tokio = &#123; version = \"1\", features = [\"full\"] &#125; 对于src/main.rs文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172use exitfailure::ExitFailure;use reqwest::Url;use serde_derive::&#123;Deserialize, Serialize&#125;;use structopt::StructOpt;#[derive(Serialize,Deserialize,Debug)]struct W &#123; coord: Coord, weather: Weather, base: String, main: Main,&#125;impl W &#123; async fn get(city: &amp;String) -&gt; Result&lt;Self, ExitFailure&gt; &#123; let url = format!(\"https://api.openweathermap.org/data/2.5/weather?q=&#123;&#125;&amp;appid=40452068d845180226c3f289341974b7\", city); // 转换为url let url = Url::parse(&amp;*url)?; let resp = reqwest::get(url).await?.json::&lt;W&gt;().await?; Ok(resp) &#125;&#125;#[derive(Serialize,Deserialize,Debug)]struct Coord &#123; lon: f64, lat: f64,&#125;#[derive(Serialize,Deserialize,Debug)]struct Weather &#123; details: Details,&#125;#[derive(Serialize,Deserialize,Debug)]struct Details &#123; id: i32, main: String, description: String, icon: String,&#125;#[derive(Serialize,Deserialize,Debug)]struct Main &#123; temp: f64, feels_like: f64, temp_min: f64, temp_max: f64, pressure: i32, humidity: i32,&#125;#[derive(StructOpt)]struct Input &#123; city: String&#125;#[tokio::main]async fn main() -&gt; Result&lt;(), ExitFailure&gt; &#123; let input = Input::from_args(); //println!(\"&#123;&#125;\", input.city); let resp = W::get(&amp;input.city).await?; println!(\"&#123;&#125; \\n 天气: &#123;&#125; \\n 当前温度: &#123;&#125; \\n 最高温度: &#123;&#125; \\n 最低温度: &#123;&#125; \\n 湿度: &#123;&#125;\", input.city, resp.weather.details.main, resp.main.temp, resp.main.temp_max, resp.main.temp_min, resp.main.humidity); //println!(\"Hello, world!\"); Ok(())&#125; 使用cargo run Beijing进行调试 直到能够准确输出预订结果，如下： 123456789➜ rust_weather git:(master) ✗ cargo run Beijing Finished dev [unoptimized + debuginfo] target(s) in 0.13s Running `target/debug/rust_weather Beijing`Beijing 天气: Clouds 当前温度: 293.35 最高温度: 294.13 最低温度: 291.09 湿度: 35 将二进制文件移动到系统PATH路径下 此时target/debug/rust_weather即想要的二进制文件，可将其复制到任意一个系统PATH路径下 echo $PATH 1/opt/homebrew/opt/node@12/bin:/Users/fliter/.nvm/versions/node/v16.9.0/bin:/usr/local/Cellar/mysql@5.7/5.7.28/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Users/fliter/.cargo/bin:/usr/local/go/bin:/Users/fliter/go/bin:/Users/fliter/Downloads/:/bin:/usr/local/MongoDB/bin:/usr/local/Cellar/ffmpeg/4.3.1/bin:/Users/fliter/.cargo/bin 还可以重命名，如改为weather,复制到usr/local/bin下，而后source .zshrc 在任意命令行窗口下，执行 weather Binzhou: 123456Binzhou 天气: Rain 当前温度: 291.63 最高温度: 291.63 最低温度: 291.63 湿度: 67 参考自原子之音","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"Linux系统文件的三种time(atime/ctime/mtime)","date":"2016-09-04T11:54:49.000Z","path":"2016/09/04/Linux系统文件的三种time-atime-ctime-mtime/","text":"使用Go操作文件，根据创建时间(或修改时间)进行不同处理。 在Mac上，文件相关的结构体字段在syscall/ztypes_darwin_arm64.go下的Stat_t: 123456789101112131415161718192021type Stat_t struct &#123; Dev int32 Mode uint16 Nlink uint16 Ino uint64 Uid uint32 Gid uint32 Rdev int32 Pad_cgo_0 [4]byte Atimespec Timespec Mtimespec Timespec Ctimespec Timespec Birthtimespec Timespec Size int64 Blocks int64 Blksize int32 Flags uint32 Gen uint32 Lspare int32 Qspare [2]int64&#125; 时间相关的有四个字段，即Atimespec、Mtimespec、Ctimespec和Birthtimespec。根据以下代码： 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"github.com/pkg/errors\" \"os\" \"syscall\" \"time\")func main() &#123; file, err := os.Stat(\"/Users/fliter/blog\") if err != nil &amp;&amp; errors.Is(err, os.ErrNotExist) &#123; fmt.Println(\"文件确实不存在，err is:\", err) //创建多级目录 //os.MkdirAll(\"/Users/fliter/blog\", os.ModePerm) &#125; stat_t := file.Sys().(*syscall.Stat_t) fmt.Println(stat_t) fmt.Println(timespecToTime(stat_t.Atimespec)) // 访问时间 fmt.Println(timespecToTime(stat_t.Ctimespec)) // 修改时间 fmt.Println(timespecToTime(stat_t.Mtimespec)) // 修改时间 fmt.Println(timespecToTime(stat_t.Birthtimespec)) // 创建时间&#125;func timespecToTime(ts syscall.Timespec) time.Time &#123; return time.Unix(ts.Sec, ts.Nsec)&#125; 创建时间并不是Ctimespec，而是Birthtimespec。 Ctimespec和Mtimespec似乎都是修改时间？？ 这就涉及到UNIX/Linux操作系统中，文件相关的三个time---atime,mtime,ctime mtime是指文件内容被最后一次修改的时间,ctime则指文件的元数据(如权限，所有者等)最后一次被修改的时间 在Linux中,可以通过stat命令查看 更多测试&amp;验证相关，可参考此文","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"大时代下的小人物----<幸福时光>影评","date":"2016-08-28T12:41:18.000Z","path":"2016/08/28/大时代下的小人物-幸福时光-影评/","text":"一袋薯片,一盒葡萄汁,一个半小时,我倚靠窗边,看完了这部16年前的老电影.我很惊讶,这样朴素的小人物电影,竟和&lt;满城尽带黄金甲&gt;出自同一导演.这样的惊讶,不亚于得知研究尼采的周国平去写鸡汤. 关闭播放器,我打开朋友圈浏览,打算随后发出这段写好的文字和图片.在看得不算太多的动态里,竟有3条是轻松筹—-对于大多数人,根本不知道这是一个社交型众筹网站,从新疆的葡萄到geek自己研发的充满科技感的炫品均可;但对大多数人,点开轻松筹的链接意味着看到另一个个体和家庭的不幸. 自轻松筹问世以来,我看到的形形色色的链接已超过百个,ta们来自华北的平原,西南的盆地,ta们长幼性别各异,但都面临生死考验而缺钱医治.无奈只能把自己的不幸告知大家,把病历、身份证明和躺在病床的无助衰容放在网上,以乞一线生机. 互联网放大了痛苦,互联网让我们更接近真实—-在过去你并不能这般清晰地知悉如此多的不幸,但这些不幸,又是真实客观存在,躲不掉避不了地摆放在那里. 脑海浮现去年9月在shift老校区,那个请求抱我一下的胖女孩,她大概已经不在人世了. 这电影,让我想起10年后上映的同样小成本,同样故事情节发生在没落厂房,同样票房惨淡的文艺片&lt;钢的琴&gt;,对这部我评分极高的电影,我想用吴晓波那篇&lt;中国工人阶级的忧伤&gt;来推荐已经足够.吴晓波：中国工人阶级的忧伤（钢的琴）影评 电影画风同样让我想类比的,是贾樟柯的作品.这个从山西走出的电影导演,一直在电影中表现小人物、小个体在大背景、大时代下的生存状态和命运起伏;他作品挑战当下,忠实记录真实的当代中国的风貌.他一直发声:’不能因为时代高速前进就忽略那些没有赶上时代列车的人’. 好多人不喜欢他陈黯平落的叙事和残酷黑色的结局—-虽然这是真实世界的直观反映.我一直觉得,在青春校园烂片刚有消停,羽皇大战冰族王子的玄幻电影又将轰炸荧屏,并不讨喜迎合的贾氏风格和贾氏作品,不是太多而恰恰是太少. 许多年后,这些曾靠特效和狗血剧情,用’校园’’青春’撩拨观众的心,靠明星偶像保障票房的作品都会被深埋尘埃,但是&lt;三峡好人&gt;和&lt;山河故人&gt;,很有可能会被爱好历史的后人翻出新赏—-这是电影在娱乐功能外更大的功能. 我不由想起巴尔扎克,他自诩法国社会的书记员,以91部小说和2400多个人物如是反应了几百年的法国社会.当时的国王王后都不再了,严苛的政策法令也解禁重生,活跃在各个舞会光彩夺目的交际花也已经陨落成泥不知所归,也没有人会再为当时可笑的闹剧和与权威的冲突而噤若寒蝉. 这部惨淡的电影过后,作为导演的张艺谋拍出了许多大卖特卖的商业大片,这些电影多华丽壮阔,气势恢宏,他成为中国最成功最有票房保障的电影导演之一.而小他一代的第六代电影导演贾樟柯,则是不温不火,时而被禁,时而发声出来宣传,隔几年拍出一部关于小人物的电影.而更新一代的从作家从主持人等转岗而来的导演们,则更简单粗暴和直接,但他们依靠人气和舆论运作,总能收获不差的票房.的确,对于这些进电影院消费的生力军的年龄群体,他们的作品更合这些年轻的男男女女的胃口. 很久后,也许是过了几代人,总有人会意识到’黄钟毁弃瓦釜雷鸣’的事情时时代代都在发生,叫好不叫座的电影作品,也会永远永远存在.而稍稍能做的，是请那些此刻还在坚守的电影人,收下我微不足道的敬意.","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"图像处理","date":"2016-08-13T13:52:17.000Z","path":"2016/08/13/图像处理/","text":"阮一峰-图像与滤波阮一峰-高斯模糊的算法阮一峰-相似图片搜索的原理阮一峰-相似图片搜索的原理（二）阮一峰-如何识别图像边缘？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"是思考让苇草发展和进步--简评<黑客与画家>","date":"2016-08-12T14:47:28.000Z","path":"2016/08/12/是思考让苇草发展和进步-简评-黑客与画家/","text":"‘如果伽利略说帕多瓦城（Padua）的人身高三米，他只会被当作一个古怪的疯狂科学家。但是，他说地球围绕太阳运转，性质就完全不一样了。教廷知道，这种话会让人们开始思考。’ 让我从金句佳段频出的&lt;黑客与画家&gt;中只选一句话作为书评题记，很可能会是这句平平无奇毫无修饰的陈述句。 2200年前的一个秋天，被征调服徭役的一队农民因为大雨延误日期，根据当时法律，他们都要被斩杀。同样是死，奔着拼死一搏的心态，中国历史上第一次农民起义就此爆发。起义头领陈胜喊出‘王侯将相，宁有种乎’的惊世质问？这句话本不是什么神兵利刃或先进战术，但会让统治者不由战粟，因为它会让习以为常的人进行思考。 那时,在齐国故都临淄正西110里外的一块土地上，我的70代先祖过着日出而作日落而息的生活。那时劳动生产率不高，他即便十分辛劳，生活也清清苦苦。在他小时的某刻,也许想不通而问过为何要缴缴税服徭役这样的问题,他的父亲惊慌地捂住他的嘴,不允许他问这样’反动’的问题,因为当他这般大时,也问过他的父亲类似的问题,他的父亲也是如此进行回复.那是秦朝,靠严刑峻法统治,五家为伍，十家为什，相互监督，相互检举，若不揭发，十家连坐。这些规定早在上几代就有了,而那时,代际之间几乎没有变化,龙永远是龙,鼠永远是鼠,不存在鼠变成龙的通道.繁衍,只是生产新一台田间劳动的机械机器.人们没有勇气和机会去问为什么,人们的交流范围有限,又都人心惶惶小心翼翼.别人都是如此,这已成为现状,也许这就是天理.那个时代音讯阻隔,信息不畅,对于2000里外关中发生的宫斗,如制定法律的李斯丞相被赵高腰斩于市,毫不知情. 回到书中这句话。现在我去告诉一个小学生，地球并不是宇宙的中心。他很可能会疑惑地看着我，心想‘这1+1=2的常识需要你告诉我？’。而告诉他几百年前曾有人为坚持这个观点而被活活烧死，即便他知道这个人叫布鲁诺，细想之下还是无法理解：说地球不是宇宙中心搅动了谁的利益蛋糕吗？坚持这样一种现在看来是常识公理一样的观点怎么会至于丧命？ 每个时期，总有一些超前的因为一些观点受到打击甚至性命之虞，哪怕这些观点在今天看已经见怪不怪觉得再正常不过… 而同期的大多数，现实生活的劳累，祖祖辈辈的传承，让他们习惯了这一些，他们意识不到这有什么‘不合理’而认为是天经地义。像潘石屹&lt;我的价值观&gt;中的回忆,辛亥革命后，走骆驼路过潘集寨的人说现在皇帝没有了,山村里的人惶惶不可终日… 在今天我们崇尚自我奋斗实现自我，而在秦朝，这无异于痴人说梦，社会的阶层关系像印度的种姓制度根本无法逾越，如果你侥幸出生在达官人家，那么恭喜你，你有比现在的官二代多得多的社会资源，而且往往可以世袭罔替。 而如果不幸生在了农人家—–也没什么不幸，因为当时绝大多数都如此，那这一辈子出头无望,没有渠道和途径.你就是在地里干活的的工具,你是复制品,延续着上代和上上代的使命,又传承到下一代又下一代。 东西方在漫漫长路上经过的路途大致是相似的，直到布洛诺时代，教会仍会处死异见份子。在布鲁诺被烧死的1600年，欧洲的文艺复兴运动也达到了顶峰。这场也许是人类历史最伟大的运动给后世留下的最珍贵遗产，绝对不是名画&lt;蒙娜丽莎&gt;和雕塑&lt;大卫&gt;，而是对人价值与尊严的肯定。 文艺复兴把“人”从“上帝”的统治下解放了出来，他们不再憧憬来世的生活，不再承受原始的罪恶感，不再对金钱财富躲躲闪闪了；他们把自己的幸福建立在现实的社会中，主张享受人间的快乐和幸福，主张对财富的现实追求。一方面启蒙了欧洲人的思想与心灵，另一方面也促进了欧洲技术生产力的快速发展。在十六世纪，地理大发现、商业革命、宗教改革……这些重大历史事件无一不与文艺复兴密切相关。文艺复兴打破了旧思想的樊篱、宗教的束缚，颠覆了人们以往对人性的认识，改造了世俗的精神世界；欧洲的文艺复兴时期，见证了人性的回归；也扩大了人类探索的空间，为世界带来了无限的活力。 同期的中国，处在封建统治的最高峰，那是明末清初之交，在不到半个世纪后的1644年，清军入关，定都北京。又经过150年的高度集权，封建制度所能迸发的力量达到了抛物线的最高峰，此后是迅速的衰落。在200年后的1840年，天朝上邦地大物博的中国，竟然被边鄙之地小国寡民的英国击败，此后开启了一段屈辱的被胖揍，直到又100年后，才真正又从国家意义上实现了独立自主。 我想起鸦片战争时林则徐的思想转变，起初这位心忧社稷的汉人传统知识分子，也以为英国人膝盖不会打弯，我们可以轻而易举将其击败。但是当战争开始，这位咋舌的优秀旧官僚十分不情愿地意识到，这和传统的战争已经不同了，这是两个时代两种文明之间的跨维战争。 现在，再来思考真正有价值的东西是什么？我们总归有一天要变为尘土，而且用大历史的眼光看，这个时间十分短暂。现在，不论你在一线城市街头还是县城街区，你随意去考一下路人能否把宋朝皇帝顺序说一遍，我敢打赌，9成以上的人说不正确，而在我的祖先生活的时代，这些人都是生杀予夺集于一身，是苍天赋予的上天之子。同样，你去考几百年后的人，问他们能否把建国后的国家元首按顺序说出姓名，他们多半是答不出的。对于他们，和知道这些对比，这天中午吃什么午餐可能更加重要。 每个人生命有限，人类的发展需要代际的薪火传承。后一代人接过前辈的火炬，在他们的肩膀上再向上一点。然而这个过程和交接更多是在无形无意中进行的。而把进步的衡量标准细化和具体到每一个微小个体，比笼统的归结到国家有意义的多。几百年后，可能党会变了，国家的界限可能也模糊了，这时的权贵后嗣到那时可能早已没落多时。只有人，只有把对人的关怀和重视当成中心，在一个由人组成的社会，这才是永不过时的。 ‘回顾历史，我们会发现很多这样的例子。人们因为说真话而给自己惹来麻烦。许多的言论，今天的人们看来再平常不过，但是放在过去都是不能说的。以此推断，未来的人们很可能会发现，他们觉得很平常的话，在我们今天这个时代都是不能说的。现在有没有伽利略这样的人和事？很可能是有的。’","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"记《神探狄仁杰》","date":"2016-08-03T11:43:45.000Z","path":"2016/08/03/记《神探狄仁杰》/","text":"看完了&lt;神探包青天&gt;，可堪天雷滚滚，质低品劣！铁三角散伙，本对&lt;神探狄仁杰V&gt;和新生出的神包拯系列有些小小期待，怎奈这胡编滥造的剧情，真不值得多吐槽… 当初狄仁杰系列确实独辟蹊径，吊诡的情节曲折反覆的转折曾可叫人拍案惊绝。04年问世的神I，&lt;幽州案&gt;李元芳含冤蒙难，邂逅狄阁老，就此黄金搭档开启一段匡社稷于既颠的探案旅程，案末狄公不解的疑问也为神II中蛇灵案，也是整个神剧的最高峰留了花蛋。 &lt;蓝衫记&gt;鲜有精彩的武打，但蜜蜂一事颇有深意，告诫“看似是亲眼所见之事未必为真”，眼睛和耳朵可能会骗你，只有缜密的逻辑，合理的推理分析，才是真正可以信赖的东西。所涉及越王谋反一事也确有史实可考：高宗李治为太宗第七子，越王李贞为第八子，即是武后的小叔子。时高宗去世5年，武后临朝，大肆加封武氏宗族，并命分封外地的李氏亲王限期入京，李姓诸侯王自然忌惮这是鸿门宴，时为皇叔的李贞带头，假诏起兵，然事败身死。其后人支族被赐凶姓“虺”，也暗合蛇灵中八大高手之首的闪灵虺文忠缘何一力推翻武周。此案最终也留有花蛋，但至今未拍，故而无解。 &lt;滴血雄鹰案&gt;则以前朝天宝大将军宇文成都冤魂不死为覆在其表的诡异外衣，幕后黑衣为高宗与武后之女即著名的太平公主，然武后却做假意不知实难动手，却知太平公主狼子野心欲效其母，也暗合多年后其造反被李隆基诛杀一事。06年问世的神II，以&lt;崇州案&gt;唐代名将王孝杰攻伐契丹全军覆没起篇，上承&lt;幽州案&gt;，下接其后的&lt;蛇灵案&gt;。个人认为神剧在《蛇灵案》达到巅峰，时值初中，晚间归家，看至此处，惊叹精彩，真想遁入其中随狄公和元芳寻幽察暗，一探究竟。总部偏处时荒僻不已的柳州大扬山陀螺地中的蛇灵，听名字即觉是一神秘组织。小庙之中，李元芳用链子刀击杀魔灵一幕，让人血脉贲张却又不至让人觉得如手撕鬼子太不靠谱。 及至蛇灵落幕，袁天罡伏法，整个剧集就开始步入下坡。大概是导演兼编剧的钱雁秋江郎才尽，第三部中的西凉黑衣社，淮扬铁手团，已明显狗尾续貂。到了第四部，简直一落千丈，甚至为津津此剧倍觉羞愧。 随后的铁三角英雄三部曲，这种强调个人英雄主义和百回千转案情的题材，如同味精，少些可让人耳目一新，多了则必审美疲劳。在历史上，有神探之名而又在广大乡野村夫如我间有广泛知名度的，即狄仁杰与宋包拯明海瑞三人，有扎实理论基础的真正大家宋慈，则只适合出现在正史而非演义之中。故而，导演与主演分道扬镳，在浩瀚千年史册中导演想再找一个合适人物，其实并不容易。新近听单田芳评书，&lt;三侠五义&gt;&lt;白眉大侠&gt;&lt;铁伞怪侠&gt;，钱雁秋并不缺奇诡的想象，可堪电视剧中的徐老怪。感觉如在此题材上删改添更，余幅颇大，既有市场又有剧情，应会更好。 2015/5/5","tags":[{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"批量更新某文件夹下多个git仓库","date":"2016-07-30T13:03:09.000Z","path":"2016/07/30/批量更新某文件夹下多个git仓库/","text":"文件夹下有几十个git仓库，想全部更新, 但不想手工 cd xx &amp;&amp; git pull。 写脚本批量更新之 效果如下： 12345678910111213141516#!/bin/bashfor i in *;doif [ -d $i ];then # 如果$i为目录#echo \"处理\"$i\"项目\"; #添加颜色echo -e \"\\033[37m处理\"$i\"项目\\033[0m\" cd $i;git pull#pwdecho -e \"\\033[35m----拉取完成----\\033[0m\" echo -e \"\\n\"cd ../fidone shell系列合集: 用shell批量修改文件名 根据条件关闭软件 统计命令汇总","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"中国梅西在哪里","date":"2016-07-30T12:02:40.000Z","path":"2016/07/30/中国梅西在哪里/","text":"许多年后，我大概才模糊地忆起，在十六年前一个暮色西陲的傍晚，我曾经不太费劲地扑出中国梅西的点球，轻而易举地盖掉中国库里的投篮。 这座面积5倍于邹平县的中国东部沿海城市，曾走出过包括中国篮球代表人物姚明和中国田径代言人刘翔在内的知名运动员。当中部距离省政府40分钟车程的山村小学学生还如电影画面般赤脚或穿着断成几截的破鞋开心地追逐（至少4年前如此），你能在这里走不太远的距离找到一个或大或小的足球场。当这里开明的父母鼓励甚至要求孩子多去运动，并意识到如有天赋这是比中规中矩读书考学有出息得多的路，而处在帝国庞大神经最末梢的广大四五线小城和乡村，后知后觉的卫道士还顽固倔强地坚守，执拗地不加任何定语地灌输着读书考学是通向彼岸的独路桥，在那里去体校是低人一等是考不上中学无路可走的选择。 中国有13亿的人口，有将近10万亿美元的经济总量，在足球、篮球等一线赛事上，我们还没走出过一个顶级球员。十六年前，阿根廷一户不太富裕的家庭，为家中身患侏儒症身高只有140公分的13岁孩子而举家搬到西班牙巴萨罗那，这个天赋过人的少年在几年后技惊四座，并擎起前辈火炬，成为当世足坛第一人，美利坚总统奥观海之女和中东战乱国家难民的儿子都成其粉。 中国的梅西在哪里呢？他有着可能同样出色的天赋，他身体健康对地沟油瘦肉精免疫，他的父母开明并全力支持，他国家的俱乐部氛围浓厚有慧眼识人的伯乐而没有那么多见不得人的勾当。按照概率应该是有凤毛麟角，只是经这几难，已再无人。此刻也许在工地抽着红梅渡过漫漫长夜，在富士康机械的流水线蹉跎岁月。 中国早晚会有梅西和库里的，只是我们这一批，身上还有纵向比微不足道横向比重却千钧的历史负担，恐怕是没有机会了。 让我们努力，让我们足够开明也有能力：当我们为人父母，如果惊讶发现我们的孩子万分幸运地被上天恩赐坠下的天赋砸中，请小心呵护，直到其长成参天大树。","tags":[{"name":"足球&体育","slug":"足球-体育","permalink":"http://www.dashen.tech/tags/足球-体育/"}]},{"title":"MySQL实战45讲中的部分sql","date":"2016-07-22T12:43:25.000Z","path":"2016/07/22/MySQL实战45讲中的部分sql/","text":"1.12 2.两阶段提交 与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。 3.","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"MySQL三星索引","date":"2016-07-22T08:21:23.000Z","path":"2016/07/22/MySQL三星索引/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"探究Go语言真正的执行入口","date":"2016-07-19T13:28:39.000Z","path":"2016/07/19/探究Go语言真正的执行入口/","text":"编译好的可执行文件 真正的执行入口，并非我们所写的 main.main 函数，编译器总会插入一段引导代码，完成诸如命令行参数、运行时初始化等工作。然后才会进入用户逻辑。 (「Go语言学习笔记」) test.go: 12345package mainfunc main() &#123; println(\"hello shuang!\")&#125; go build -gcflags &quot;-N -l&quot; -o dashen test.go 调试程序时，最好使用 -gcflags “-N -l”参数，关闭编译器代码优化和函数的内联，避免断点和单步执行无法准确对应源码行，避免小程序和局部变量被优化掉。(更多可参见go build可选的那些参数,Go中的内联优化,golang逃逸技术分析) 使用gdb，在Linux机器上调试的具体过程详见 gdb/lldb调试工具 在此使用dlv在Mac上进行调试 使用dlv调试Go程序：","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"init()的执行顺序 && Go scheduler的初始化过程","date":"2016-07-19T11:16:49.000Z","path":"2016/07/19/init-的执行顺序-Go-scheduler的初始化过程/","text":"Shit Mountain遇险记： init先于main执行。 某陈年老代码，不遵循单一入口，各种中间件的初始化不放在main.go里，而是很多package都有一个init(如 有一个叫做storage文件夹，用来放各种存储。该文件夹下有一个init())… 这样做平时没什么，有一天，需要给mysql，redis，kafka，httpclient等加一个哨兵监控。 需要在mysql，redis初始化时，拿到哨兵的实例，用其中某个collector作为参数传递。。 这个监控的sdk，按常理显然应该在main.go里初始化，而各个包的init，先于main.main执行，于是在在mysql，redis等初始化时，调用哨兵显然为nil。。 最后通过hook，或全局变量予以解决。。当时也有考虑，在init()满天飞的场景下，能否确定哪个init()最先执行？ 或者能否也写一个init()初始化哨兵监控 并保证其最先执行？ 这其实涉及到runtime ….（待写） 爽哥于深夜 pointer.go: 123456789101112131415package mainimport ( \"fmt\")func main() &#123; var p **int var i int = 10 var p1 *int = &amp;i fmt.Println(\"p1=\", p1) p = &amp;p1 fmt.Println(\"p=\", p)&#125; go build -gcflags=all=&quot;-N -l&quot; pointer.go (go build -gcflags=all=”-N -l” 禁用编译器优化和内联函数，在研究runtime时非常有必要 ​​) Golang init() 函数 Go：神奇的init函数 Go语言goroutine调度器初始化 https://7byte.github.io/2017/05/20/golangPackageInit/ https://studygolang.com/articles/6464 【Golang源码分析】golang的启动原理 Golang后台单元测试实践 基于Golang的云原生日志采集服务设计与实践 Golang 并发编程核心篇 —— 内存可见性 GODEBUG=INITTRACE=1 ./dashen https://stackoverflow.com/questions/24790175/when-is-the-init-function-run https://play.golang.org/p/9P-LmSkUMKY https://xie.infoq.cn/article/7baab69fe385d0c6a1b35fa32 https://zboya.github.io/post/go_scheduler/ https://learnku.com/go/t/47135 https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.10.GC-GC.md","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"异或运算","date":"2016-07-12T16:23:11.000Z","path":"2016/07/13/异或运算/","text":"阮一峰-异或运算 XOR 教程","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"亲测体验Nginx中location的优先级","date":"2016-06-28T12:22:23.000Z","path":"2016/06/28/亲测体验Nginx中location的优先级/","text":"nginx中location的顺序(优先级)及rewrite规则写法 Nginx 配置文件格式化 https://segmentfault.com/a/1190000022315733 https://nginx-playground.wizardzines.com 一个线上的 nginx 游乐场。你可以在网页上填写 nginx 配置文件，然后在线启动一个 nginx 实例。接着，你输入各种 curl 命令，与这个实例互动。 https://jishuin.proginn.com/p/763bfbd6cef9 https://nginx.viraptor.info/ https://jvns.ca/blog/2021/09/24/new-tool--an-nginx-playground/ https://www.google.com.hk/search?q=httpie+%E5%92%8Ccurl&amp;newwindow=1&amp;sxsrf=APq-WBsYOl567VPW-WDFGnpDW0MeRJ2AZA%3A1644840441225&amp;ei=-UUKYp3hDKrl2roP7_u2sAY&amp;ved=0ahUKEwjdwdeRlP_1AhWqslYBHe-9DWYQ4dUDCA4&amp;uact=5&amp;oq=httpie+%E5%92%8Ccurl&amp;gs_lcp=Cgdnd3Mtd2l6EAM6BwgAEEcQsAM6BwgjEK4CECc6BAgjECc6BQgAEMsBOgUIABCABDoICAAQDBAKEB46BQghEKABOgUIABCiBEoECEEYAEoECEYYAFDOB1jwNGDsN2gIcAF4AIABrwGIAfAMkgEEMy4xMJgBAKABAcgBCMABAQ&amp;sclient=gws-wiz 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package mainimport ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"math/rand\" \"net/http\" \"os\" \"os/exec\" \"strings\" \"syscall\" \"time\")type RunRequest struct &#123; NginxConfig string `json:\"nginx_config\"` Command string `json:\"command\"`&#125;type RunResponse struct &#123; Result string `json:\"result\"`&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) http.Handle(\"/\", wrapLogger(Handler&#123;runHandler&#125;)) log.Fatal(http.ListenAndServe(\":8080\", nil))&#125;func runHandler(w http.ResponseWriter, r *http.Request) error &#123; w.Header().Add(\"Access-Control-Allow-Origin\", \"*\") w.Header().Add(\"Access-Control-Allow-Headers\", \"*\") if r.Method != \"POST\" &#123; // OPTIONS request return nil &#125; body, err := ioutil.ReadAll(r.Body) if err != nil &#123; return fmt.Errorf(\"failed to read body: %s\", err) &#125; var req RunRequest json.Unmarshal([]byte(body), &amp;req) // write config file, err := os.CreateTemp(\"/tmp\", \"nginx_config\") errorFile, err := os.CreateTemp(\"/tmp\", \"nginx_errors\") if err != nil &#123; return fmt.Errorf(\"failed to create temp file, %s\", err) &#125; file.WriteString(req.NginxConfig) file.Close() defer os.Remove(file.Name()) defer os.Remove(errorFile.Name()) // set up network namespace namespace := \"ns_\" + randSeq(16) if err := exec.Command(\"ip\", \"netns\", \"add\", namespace).Run(); err != nil &#123; return fmt.Errorf(\"failed to create network namespace: %s\", err) &#125; defer exec.Command(\"ip\", \"netns\", \"delete\", namespace).Run() if err := exec.Command(\"ip\", \"netns\", \"exec\", namespace, \"ip\", \"link\", \"set\", \"dev\", \"lo\", \"up\").Run(); err != nil &#123; return fmt.Errorf(\"failed to create network namespace: %s\", err) &#125; // start httpbin httpbin_cmd := exec.Command(\"ip\", \"netns\", \"exec\", namespace, \"go-httpbin\", \"-port\", \"7777\") if err := httpbin_cmd.Start(); err != nil &#123; return fmt.Errorf(\"failed to start go-httpbin: %s\", err) &#125; defer kill(httpbin_cmd) // start nginx nginx_cmd := exec.Command(\"ip\", \"netns\", \"exec\", namespace, \"nginx\", \"-c\", file.Name(), \"-e\", errorFile.Name(), \"-g\", \"daemon off;\") if err != nil &#123; return fmt.Errorf(\"failed to get pipe: %s\", err) &#125; ch := make(chan error) go func() &#123; ch &lt;- nginx_cmd.Run() &#125;() // Check for errors select &#123; case &lt;-ch: logs, _ := os.ReadFile(errorFile.Name()) return fmt.Errorf(\"nginx failed to start. Error logs:\\n\\n %s\", string(logs)) case &lt;-time.After(100 * time.Millisecond): defer term(nginx_cmd) break &#125; // run curl curlArgs := strings.Split(strings.TrimSpace(req.Command), \" \") if curlArgs[0] != \"curl\" &amp;&amp; curlArgs[0] != \"http\" &#123; return fmt.Errorf(\"command must start with 'curl' or 'http'\") &#125; curlCommand := append([]string&#123;\"netns\", \"exec\", namespace&#125;, curlArgs...) output, _ := exec.Command(\"ip\", curlCommand...).CombinedOutput() // return response resp := RunResponse&#123; Result: string(output), &#125; response, err := json.Marshal(&amp;resp) if err != nil &#123; return fmt.Errorf(\"failed to marshal json, %s\", err) &#125; w.Header().Add(\"Content-Type\", \"application/json\") w.Write(response) return nil&#125;func wrapLogger(handler http.Handler) http.Handler &#123; return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123; rw := &amp;responseWrapper&#123;w, 200&#125; start := time.Now() handler.ServeHTTP(rw, r) elapsed := time.Since(start) log.Printf(\"%s %d %s %s %s\", r.RemoteAddr, rw.status, r.Method, r.URL.Path, elapsed) &#125;)&#125;func term(cmd *exec.Cmd) &#123; if cmd.Process != nil &#123; cmd.Process.Signal(syscall.SIGTERM) &#125;&#125;func kill(cmd *exec.Cmd) &#123; if cmd.Process != nil &#123; cmd.Process.Kill() &#125;&#125;var letters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")func randSeq(n int) string &#123; b := make([]rune, n) for i := range b &#123; b[i] = letters[rand.Intn(len(letters))] &#125; return string(b)&#125;","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"猜数游戏-Rust版","date":"2016-06-19T16:38:01.000Z","path":"2016/06/20/猜数游戏-Rust版/","text":"cargo new guessing_game 输入任意内容，并打印出来 main.rs:12345678910111213141516use std::io; // 像String这些类型都在预先导入的prelude里，如果要使用的不在prelude里，则需要显式导入fn main() &#123; println!(\"猜数\"); println!(\"猜测一个数\"); let mut guess = String::new(); //String::new()返回一个String实例，创建一个空白的字符串 // 读取一行内容,放到guess里; (io::stdin()返回一个句柄) io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\");// 引用在Rust里默认也是不可变的，所以需要&amp;mut // &#123;&#125;为占位符，类似golang里的%s，%d println!(\"你猜测的数是:&#123;&#125;\", guess)&#125; 生成随机数 Cargo.toml 123456789[package]name = \"guessing_game\"version = \"0.1.0\"edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rand = \"^0.3.14\" # ^代表任何与0.3.14这个版本公共api兼容的版本都可以 rand包还依赖libc 123456789101112131415161718192021use std::io;// 像String这些类型都在预先导入的prelude里，如果要使用的不在prelude里，则需要显式导入use rand::Rng; // trait，类似golang的接口，定义了很多方法fn main() &#123; println!(\"猜数\"); let secret_number = rand::thread_rng().gen_range(1, 101); // [a,b) println!(\"神秘数字是&#123;&#125;\", secret_number); println!(\"猜测一个数\"); let mut guess = String::new(); //String::new()返回一个String实例，创建一个空白的字符串 // 读取一行内容,放到guess里; (io::stdin()返回一个句柄) io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\");// 引用在Rust里默认也是不可变的，所以需要&amp;mut // &#123;&#125;为占位符，类似golang里的%s，%d println!(\"你猜测的数是:&#123;&#125;\", guess)&#125; 比较大小 1234567891011121314151617181920212223242526272829303132333435use std::io;use std::cmp::Ordering;// 像String这些类型都在预先导入的prelude里，如果要使用的不在prelude里，则需要显式导入use rand::Rng; // trait，类似golang的接口，定义了很多方法fn main() &#123; println!(\"猜数\"); // i32 u32 i64,不指定则默认i32 let secret_number = rand::thread_rng().gen_range(1, 101); // [a,b) println!(\"神秘数字是&#123;&#125;\", secret_number); println!(\"猜测一个数\"); let mut guess = String::new(); //String::new()返回一个String实例，创建一个空白的字符串 // 读取一行内容,放到guess里; (io::stdin()返回一个句柄) io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\");// 引用在Rust里默认也是不可变的，所以需要&amp;mut // shadow, 隐藏；（用同名变量隐藏旧变量） // trim 去掉空格等 // parse 将字符创串装换为u32 类型 let guess: u32 = guess.trim().parse().expect(\"Please type a number!\"); // &#123;&#125;为占位符，类似golang里的%s，%d println!(\"你猜测的数是:&#123;&#125;\", guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(\"Too small!\"), //arm,类似分支吧 Ordering::Greater =&gt; println!(\"Too big!\"), //arm,类似分支吧 Ordering::Equal =&gt; println!(\"You win!\"), //arm,类似分支吧 &#125;&#125; 做多次猜测，直到猜对 12345678910111213141516171819202122232425262728293031323334353637383940414243use std::io;use std::cmp::Ordering;// 像String这些类型都在预先导入的prelude里，如果要使用的不在prelude里，则需要显式导入use rand::Rng; // trait，类似golang的接口，定义了很多方法fn main() &#123; println!(\"猜数\"); // i32 u32 i64,不指定则默认i32 let secret_number = rand::thread_rng().gen_range(1, 101); // [a,b) println!(\"神秘数字是&#123;&#125;\", secret_number); loop &#123; println!(\"猜测一个数\"); let mut guess = String::new(); //String::new()返回一个String实例，创建一个空白的字符串 // 读取一行内容,放到guess里; (io::stdin()返回一个句柄) io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\");// 引用在Rust里默认也是不可变的，所以需要&amp;mut // shadow, 隐藏；（用同名变量隐藏旧变量） // trim 去掉空格等 // parse 将字符创串装换为u32 类型 let guess: u32 = match guess.trim().parse() &#123; // match，是rust错误处理的惯用方式 Ok(num) =&gt; num, Err(_) =&gt; continue, //_表示舍弃，不关心 &#125;; // &#123;&#125;为占位符，类似golang里的%s，%d println!(\"你猜测的数是:&#123;&#125;\", guess); match guess.cmp(&amp;secret_number) &#123; Ordering::Less =&gt; println!(\"Too small!\"), //arm,类似分支吧 Ordering::Greater =&gt; println!(\"Too big!\"), //arm,类似分支吧 Ordering::Equal =&gt; &#123; println!(\"You win!\"); break; &#125; &#125; &#125;&#125;","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"King's Day Speech","date":"2016-06-17T11:49:12.000Z","path":"2016/06/17/King-s-Day-Speech/","text":"原文作者Guido van Rossum, 地址King’s Day Speech,仅作翻译及注解 Today the Netherlands celebrates King’s Day. To honor this tradition, the Dutch embassy in San Francisco invited me to give a “TED talk” to an audience of Dutch and American entrepreneurs. Here’s the text I read to them. Part of it is the tl;dr of my autobiography; part of it is about the significance of programming languages; part of it is about Python’s big idea. Leve de koning! (Long live the king!) 注: 荷兰前100多年都是女王，因此一直称女王节。威廉王子2014年即位后，变身国王节。&nbsp;女王节固定为4月30日，原为庆祝威廉王子曾曾祖母的生日。国王节为威廉王子的生日4月27日。&nbsp;节日当天国王会发表祝词并巡游。&nbsp;当天的热闹程度堪比嘉年华，全国大街小巷全是地摊，每户人家把闲置的东西以极便宜的价格售出。全“橙”狂欢，荷兰 King’s Day国王节Dutch embassy荷兰大使馆autobiographyn. 自传；自传文学 Python: a programming language created by a community Excuse my ramblings. I’ll get to a point eventually. Let me introduce myself. I’m a nerd, a geek. I’m probably somewhere on the autism spectrum. I‘m also a late bloomer. I graduated from college when I was 26. I was 45 when I got married. I’m now 60 years old, with a 14 year old son. Maybe I just have a hard time with decisions: I’ve lived in the US for over 20 years and I am still a permanent resident. I’m no Steve Jobs or Mark Zuckerberg. But at age 35 I created a programming language that got a bit of a following. What happened next was pretty amazing. But I’ll get to that. At age 10 my parents gave me an educational electronics kit. The kit was made by Philips, and it was amazing. At first I just followed the directions and everything worked; later I figured out how to design my own circuits. My prized possessions were the kit’s three (!) transistors. ramblingsn. 漫无边际的讲话，东拉西扯的讲话；胡扯表不满; 随笔late bloomer开花晚的植物；智力发展晚的人. 大器晚成的人permanent resident永久性居民circuitsn. [电子] 电路（circuit的复数）；环路；巡回v. 环行；巡回旅行（circuit的三单形式）prizedadj. 珍贵的，宝贵的possessionsn. [经] 财产；所有物（possession的复数形式）worldly possessions: 身外之物transistorsn. [电子] 晶体管；晶体三极管（transistor的复数） I took one of my first electronics models, a blinking light, to show and tell in 5th grade. It was a total dud — nobody cared or understood its importance. I think that’s one of my earliest memories of finding myself a geek: until then I had just been a quiet quick learner. In high school I developed my nerdiness further — I hung out with a few other kids interested in electronics, and during physics class we sat in the back of the class discussing NAND gates while the rest of the class was still figuring out Ohm’s law. Fortunately our physics teacher had figured us out: he employed us to build a digital timer that he used to demonstrate the law of gravity to the rest of the class. It was a great project and showed us that our skills were useful. The other kids still thought we were weird: it was the seventies and many were into smoking pot and rebelling; another group was already preparing for successful careers as doctors or lawyers or tech managers. But they left me alone, I left them alone, and I graduated as one of the best of my year. After high school I went to the University of Amsterdam: It was close to home, and to a teen growing up in the Netherlands in the seventies, Amsterdam was the only cool city. (Yes, the student protests of 1968 did touch me a bit.) Much to my high school physics teacher’s surprise and disappointment, I chose to major in math, not physics. But looking back I think it didn’t matter. dudn. 衣服；[军] 哑弹；无用物adj. 无用的NAND gates 与非; 与非门figured out: 想出;理解;弄清demonstratevt. 证明；展示；论证vi. 示威weirdadj. 怪异的；不可思议的；超自然的rebelling叛逆,反抗Rebelling Teenage: 叛逆的青春期孩子Much to my high school physics teacher’s surprise and disappointment, I chose to major in math, not physics. But looking back I think it didn’t matter.让我的高中物理老师感到惊讶和失望的是，我选择了数学专业，而不是物理专业。 但是回想一下，我认为这没关系。 In the basement of the science building was a mainframe computer, and it was love at first sight. Card punches! Line printers! Batch jobs! More to the point, I quickly learned to program, in languages with names like Algol, Fortran and Pascal. Mostly forgotten names, but highly influential at the time. Soon I was, again, sitting in the back of class, ignoring the lecture, correcting my computer programs. And why was that? In that basement, around the mainframe, something amazing was happening. There was a loosely-knit group of students and staff with similar interests, and we exchanged tricks of the trade. We shared subroutines and programs. We united in our alliances against the mainframe staff, especially in the endless cat-and-mouse games over disk space. (Disk space was precious in a way you cannot understand today.) But the most important lesson I learned was about sharing: while most of the programming tricks I learned there died with the mainframe era, the idea that software needs to be shared is stronger than ever. Today we call it open source, and it’s a movement. Hold that thought! At the time, my immediate knowledge of the tricks and the trade seemed to matter most though. The mainframe’s operating system group employed a few part-time students, and when they posted a vacancy, I applied, and got the job. It was a life-changing event! Suddenly I had unlimited access to the mainframe — no more fighting for space or terminals — plus access to the source code for its operating system, and dozens of colleagues who showed me how all that stuff worked. basementn. 地下室；地窖mainframe computer大型计算机；主机电脑it was love at first sight. 一见钟情card punch [计] 卡片穿孔机Line printers 行式打印机Batch jobs 批处理作业loosely knit组织松散的, adj. having only distant social or legal tiesYet sometimes the hype is justified, in particular in the case of open- source software, free programs developed by loosely knit groups of developers.特别是由分散各地的开发者紧密结合在一起免费程序——开源软件。endless adj. 无止境的；连续的；环状的；漫无目的的endless: 无止境的Endless Love: 无尽的爱Endless Space: 无尽空间vacancyn. 空缺；空位；空白；空虚 I now had my dream job, programming all day, with real customers: other programmers, the users of the mainframe. I stalled my studies and essentially dropped out of college, and I would not have graduated if not for my enlightened manager and a professor who hadn’t given up on me. They nudged me towards finishing some classes and pulled some strings, and eventually, with much delay, I did graduate. Yay! I immediately landed a new dream job that would not have been open to me without that degree. I had never lost my interest in programming languages as an object of study, and I joined a team building a new programming language — not something you see every day. The designers hoped their language would take over the world, replacing Basic. It was the eighties now, and Basic was the language of choice for a new generation of amateur programmers, coding on microcomputers like the Apple II and the Commodore 64. Our team considered the Basic language a pest that the world should be rid of. The language we were building, ABC, would “stamp out Basic”, according to our motto. Sadly, for a variety of reasons, our marketing (or perhaps our timing) sucked, and after four years, ABC was abandoned. Since then I’ve spent many hours trying to understand why the project failed, despite its heart being so clearly in the right place. Apart from being somewhat over-engineered, my best answer is that ABC died because there was no internet in those days, and as a result there could not be a healthy feedback loop between the makers of the language and its users. ABC’s design was essentially a one-way street. Stalled: 止步不前stalled train: 停滞列车drop out退出；退学；脱离enlightenedadj. 开明的；文明的；有知识的；觉悟的nudgedv. 推进；轻推；用肘轻推；唠叨；往前挤；鼓励；接近（nudge 的过去式和过去分词）landedv. 降落；（使）飞机平稳着陆；（乘飞机或船）着陆；（使）着陆；跳落（land 的过去式及过去分词）adj. 拥有大量土地的；包括大量土地的；take over the world 席卷全球pestn. 害虫；有害之物；讨厌的人stamp out扑灭；踩灭. 此处译为 淘汰 比较贴切over-engineered 过度设计 Just half a decade later, when I was picking through ABC’s ashes looking for ideas for my own language, that missing feedback loop was one of the things I decided to improve upon. “Release early, release often” became my motto (freely after the old Chicago Democrats’ encouragement, “vote early, vote often”). And the internet, small and slow as it was in 1990, made it possible. Looking back 25 years, the Internet and the Open Source movement (a.k.a. Free Software) really did change everything. Plus something called Moore’s Law, which makes computers faster every year. Together, these have entirely changed the interaction between the makers and users of computer software. It is my belief that these developments (and how I managed to make good use of them) have contributed more to the success of “my” programming language than my programming skills and experience, no matter how awesome. It also didn’t hurt that I named my language Python. This was a bit of unwitting marketing genius on my part. I meant to honor the irreverent comedic genius of Monty Python’s Flying Circus, and back in 1990 I didn’t think I had much to lose. Nowadays, I’m sure “brand research” firms would be happy to charge you a very large fee to tell you exactly what complex of associations this name tickles in the subconscious of the typical customer. But I was just being flippant. I have promised the ambassador not to bore you with a technical discussion of the merits of different programming languages. But I would like to say a few things about what programming languages mean to the people who use them — programmers. Typically when you ask a programmer to explain to a lay person what a programming language is, they will say that it is how you tell a computer what to do. But if that was all, why would they be so passionate about programming languages when they talk among themselves? Just half a decade later 仅仅五年后Looking back 25 years 回顾25年interactionn. 相互作用，相互影响；交流；[数] 交互作用；互动unwittingadj. 不知情的；不知不觉的，无意的subconsciousadj. 潜意识的，下意识的n. 下意识（心理活动），潜意识（心理活动）flippantadj. 轻率的；嘴碎的；没礼貌的ambassadorn. 大使；代表；使节Typically 通常lay person 门外汉, 外行passionateadj. 热情的；热烈的，激昂的；易怒的 In reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it. Think of the incredible success of companies like Google or Facebook. At the core of these are ideas — ideas about what computers can do for people. To be effective, an idea must be expressed as a computer program, using a programming language. The language that is best to express an idea will give the team using that language a key advantage, because it gives the team members — people! — clarity about that idea. The ideas underlying Google and Facebook couldn’t be more different, and indeed these companies’ favorite programming languages are at opposite ends of the spectrum of programming language design. And that’s exactly my point. True story: The first version of Google was written in Python. The reason: Python was the right language to express the original ideas that Larry Page and Sergey Brin had about how to index the web and organize search results. And they could run their ideas on a computer, too! So, in 1990, long before Google and Facebook, I made my own programming language, and named it Python. But what is the idea of Python? Why is it so successful? How does Python distinguish itself from other programming languages? (Why are you all staring at me like that? :-) In reality / In fact 实际上clarityn. 清楚，明晰；透明spectrumn. 光谱；频谱；范围；余象And that’s exactly my point. 这正是我的意思。 I have many answers, some quite technical, some from my specific skills and experience at the time, some just about being in the right place at the right time. But I believe the most important idea is that Python is developed on the Internet, entirely in the open, by a community of volunteers (but not amateurs!) who feel passion and ownership. And that is what that group of geeks in the basement of the science building was all about. Surprise: Like any good inspirational speech, the point of this talk is about happiness! I am happiest when I feel that I’m part of such a community. I’m lucky that I can feel it in my day job too. (I’m a principal engineer at Dropbox.) If I can’t feel it, I don’t feel alive. And so it is for the other community members. The feeling is contagious, and there are members of our community all over the world. inspirationaladj. 鼓舞人心的；带有灵感的，给予灵感的principal engineer 首席工程师principaladj. 主要的；资本的n. 首长；校长；资本；当事人contagiousadj. 感染性的；会蔓延的; 有感染力的 The Python user community is formed of millions of people who consciously use Python, and love using it. There are active members organizing Python conferences — affectionately known as PyCons — in faraway places like Namibia, Iran, Iraq, even Ohio! My favorite story: A year ago I spent 20 minutes on a video conference call with a classroom full of faculty and staff at Babylon University in southern Iraq, answering questions about Python. Thanks to the efforts of the audacious woman who organized this event in a war-ridden country, students at Babylon University are now being taught introductory programming classes using Python. I still tear up when I think about the power of that experience. In my wildest dreams I never expected I’d touch lives so far away and so different from my own. And on that note I’d like to leave you: a programming language created by a community fosters happiness in its users around the world. Next year I may go to PyCon Cuba! consciouslyadv. 自觉地；有意识地affectionatelyadv. 亲切地；挚爱地faculty and staff n. 教职员,教职工audaciousadj. 无畏的；鲁莽的war-ridden 战火纷飞; 兵连祸结;In my wildest dreams 在我最狂野的梦想中fostersv. 培养，促进；代养，照料（他人子女一段时间）（foster 的第三人称单数）","tags":[{"name":"译海一粟","slug":"译海一粟","permalink":"http://www.dashen.tech/tags/译海一粟/"}]},{"title":"使用泰勒公式,计算哈希碰撞的概率","date":"2016-06-13T13:34:23.000Z","path":"2016/06/13/使用泰勒公式-计算哈希碰撞的概率/","text":"阮一峰-哈希碰撞与生日攻击","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"Linux中的硬链接和软链接","date":"2016-06-13T11:28:31.000Z","path":"2016/06/13/Linux中的硬链接和软链接/","text":"软链接类似Windows的快捷方式,将原文件删掉后,软链接会失效;硬链接相当于将可执行文件copy了一份,删掉原来的,硬链接依然有效; 概述 Linux 文件系统是树状结构, 根目录下存在一系列子目录,目录里边有文件或者子目录 Linux 文件系统把硬盘分为三个部分：超级块、inode 列表、数据区 inode 指示该文件的数据存放在数据区的哪些块内。因为这个“映射”关系不能变更，因此，inode 相当于代表着文件本身。（值得注意的是，文件名与文件本身不是直接映射起来的，中间隔着 inode） 首先要弄清楚,在Linux系统中,内核为每一个新创建的文件分配一个Inode(索引结点),每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存，从而实现文件的快速访问。 而链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法。 Linux中包括两种链接： 硬链接(Hard Link)和软链接(Soft Link),软链接又称为符号链接（Symbolic link） 硬链接 本质是一个指针，指向文件索引节点，系统并不为它重新分配inode。 可以用 ln 命令来建立硬链接。 当为一个文件创建硬链接时，硬链接会使用和文件相同的inode号，此时会发现，原来文件的inode数由最初的1变为了2，实际上硬链接和文件使用了相同的inode，只不过是inode连接数增加了，删除文件不会影响硬链接，硬链接的inode数会从2变为1 只有将所有指向某文件的指针,也即链接数减为0时，内核才会真将文件内容从磁盘上删除。 另外，硬链接只能应用于文件，而不能应用于目录，且不能跨文件系统。 尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处： （1）不可以在不同文件系统的文件间建立链接 （2）只有超级用户才可以为目录创建硬链接。 软链接(符号链接) 软链接(符号链接)是对一个文件的间接指针, 而硬链接直接指向文件的inode。 软链接克服了硬链接的不足，可以作用于目录，也没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。 建立软链接，只要在ln后面加上选项 –s。 在创建文件的软链接时，软链接会使用一个新的inode，所以软链接的inode号和文件的inode号不同，软链接的inode里存放着指向文件的路径。 如果删除文件，软链接则也无法使用，因为文件的路径不存在了；当再次创建这个文件时（文件名与之前相同），软链接又会重新指向这个文件（inode号与之前不同了），而硬链接不会受其影响 总结 硬链接原文件＆链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件＆链接文件拥有不同的inode号，表明他们是两个不同的文件；在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系，就像文件被复制了一份一样；链接数目是不一样的，软链接的链接数目不会增加，硬链接会相应的加一；文件大小是不一样的，硬链接文件显示的大小是跟原文件是一样的，而这里软链接显示的大小与原文件就不同了。 硬链接有点像聚簇索引,数据和索引在一起. 软链接有些像非聚簇索引,数据和索引是独立的. 参考: Linux内核分析与应用8-文件系统 文件系统的中枢—Inode结构体 Linux的硬链接和软连接（符号链接）的区别","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"制作crate并发布到Crates.io","date":"2016-06-07T13:10:56.000Z","path":"2016/06/07/制作crate并发布到Crates-io/","text":"准备 发布 crate 时, 一旦发布无法修改,无法覆盖, 因此要注意邮箱等一些个人信息 访问crates.io 的 帐号设定页面,生成Token 并在命令行 执行 cargo login your token 此命令将告诉 Cargo 你的 API 令牌, 并将其存储在本地 ~/.cargo/credentials crates.io 上crate的名字, 会采取先到先得的方式分配. 打包 &amp; 发布 对于 Cargo.toml: 12345678910[package]name = \"dashen\"version = \"0.1.1\"authors = [\"cuishuang &lt;i@dashen.tech&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]ferris-says = \"0.2\" 执行cargo publish: 这是因为缺少一些关键信息：关于该 crate 用途的描述和用户可能在何种条款下使用该 crate 的 license 想要修正这个错误, 需要在 Cargo.toml 中引入这些信息. 描述通常是一两句话, 它会出现在 crate 的搜索结果中和 crate 页面里.对于 license 字段, 需要一个 license 标识符值（license identifier value）Linux 基金会的 Software Package Data Exchange (SPDX) 列出了可以使用的标识符例如指定 crate 使用 MIT License,可增加 MIT 标识符 123456789101112[package]name = \"dashen\"version = \"0.1.1\"authors = [\"cuishuang &lt;i@dashen.tech&gt;\"]edition = \"2018\"description = \"the first crate by fliter\"license = \"MIT\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]ferris-says = \"0.2\" 再次执行 cargo publish: 这是因为没有指定git仓库 新建一个仓库,指定为远程仓库,并提交代码 再次执行 cargo publish: 此时也能在crates.io搜到刚刚发布的crate 英文版文档: Publishing a Crate to Crates.io 中文版文档: 将 crate 发布到 Crates.io","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"快速配置 Rust 开发环境并编写一个小应用","date":"2016-06-06T13:10:20.000Z","path":"2016/06/06/快速配置-Rust-开发环境并编写一个小应用/","text":"安装: curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 更新: Rust 的升级非常频繁. 如果安装 Rustup 后已有一段时间,那么很可能 Rust 版本已经过时, 运行 rustup update 获取最新版本的 Rust rustc：编译Rust程序 rustc只适合简单的Rust程序，较大型的项目还是推荐使用Cargo Cargo：Rust 的构建工具和包管理器 在安装 Rustup 时, 也会安装 Rust 构建工具和包管理器的最新稳定版,即 Cargo. Cargo 可以做很多事情： cargo build 可以构建项目 cargo run 可以运行项目 cargo test 可以测试项目 cargo doc 可以为项目构建文档 cargo publish 可以将库发布到 crates.io 要检查否安装了 Rust 和 Cargo, 可在终端中运行: cargo --version cargo run cargo check cargo build –release cargo install在Mac上,Cargo可以像brew一样,安装很多Rust写的工具,如安装一款比Tmux还要好用的终端工具zellij: cargo install zellij 为编辑器安装Rust插件: 创建新项目: cargo new hello-rust 这会生成一个名为 hello-rust 的新目录, 其中包含以下文件： 其中, Cargo.toml 为 Rust 的清单文件, 包含了项目的元数据和依赖库 src/main.rs 为编写应用代码的地方 进入项目中,执行 cargo run 添加依赖: 在 Rust 中, 通常把包称作 crates 可以在 crates.io, 即 Rust 包的仓库中找到所有类别的库 (包和库,可以认为是一回事) 此处使用名为 ferris-says 的库. 在 Cargo.toml 文件中添加以下信息: （从 crate 页面上获取）12[dependencies]ferris-says = \"0.2\" (点击这个小图标,就会跳到这个包的官方地址) 然后运行： cargo build Cargo 就会安装该依赖. (运行此命令会创建一个新文件 Cargo.lock, 该文件记录了本地所用依赖库的精确版本. 类似于yarn.lock) 编写应用: 在 main.rs 中: 123456789101112use std::io::&#123;BufWriter, stdout&#125;;use ferris_says::say;fn main() &#123; let stdout = stdout(); let message = String::from(\"Hello fellow Rustaceans! --- by shuang\"); let width = message.chars().count(); let mut writer = BufWriter::new(stdout.lock()); say(message.as_bytes(), width, &amp;mut writer).unwrap();&#125; 执行 cargo run: 了解更多: Ferris 是 Rust 社区的 非官方吉祥物. 很多 Rust 程序员自称 Rustaceans, 它与crustacean(甲壳纲动物) 相似 建议用“they”、“them”等代词, 而不用带性别的代词来指代 Ferris Ferris 与形容词 ferrous(adj. [化学] 亚铁的；铁的，含铁的) 相似, 其的含义与铁有关. 由于 Rust（锈）通常由铁形成, 因此算得上是这个吉祥物名字的有趣来源 参考: 入门:快速配置 Rust 开发环境并编写一个小应用！ 连微软也在力推: Take your first steps with Rust","tags":[{"name":"Rust","slug":"Rust","permalink":"http://www.dashen.tech/tags/Rust/"}]},{"title":"os包里的一些函数","date":"2016-06-04T10:39:52.000Z","path":"2016/06/04/os包里的一些函数/","text":"os.getenv方法 os.Args以及 os.Stat以及os.Create","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"项目中遇到的算法问题","date":"2016-05-31T14:57:51.000Z","path":"2016/05/31/项目中遇到的算法问题/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport \"fmt\"type Info struct &#123; ID string Name string ParentId string&#125;func main() &#123; var data []Info data = append(data, Info&#123;\"7\", \"测试7\", \"2\"&#125;, Info&#123;\"2\", \"测试2\", \"1\"&#125;, Info&#123;\"1\", \"测试1\", \"\"&#125;, Info&#123;\"8\", \"测试-8\", \"7\"&#125;, Info&#123;\"9\", \"测试-9\", \"8\"&#125;, Info&#123;\"10\", \"测试-10\", \"9\"&#125;, Info&#123;\"101\", \"测试-101\", \"9\"&#125;, Info&#123;\"102\", \"测试-102\", \"9\"&#125;, Info&#123;\"1001\", \"测试-1001\", \"101\"&#125;, Info&#123;\"122\", \"节点2\", \"20000\"&#125;, Info&#123;\"123\", \"节点3\", \"122\"&#125;, Info&#123;\"124\", \"节点4\", \"123\"&#125;, Info&#123;\"127\", \"节点7\", \"126\"&#125;, Info&#123;\"125\", \"节点5\", \"124\"&#125;, Info&#123;\"126\", \"节点6\", \"125\"&#125;, Info&#123;\"128\", \"节点8\", \"127\"&#125;, Info&#123;\"20000\", \"顶级节点\", \"\"&#125;, Info&#123;\"a\", \"宋江\", \"\"&#125;, Info&#123;\"b\", \"卢俊义\", \"a\"&#125;, Info&#123;\"c\", \"无用\", \"b\"&#125;, ) fmt.Println(data) // 每一条的id均不相同, 顶级节点的parent_id为空,能保证每个都能连成一棵树 // 输出当id=7时,该节点以上及以下的id值 rootSli := []Info&#123;&#125; for _, v := range data &#123; if v.ParentId == \"\" &#123; fmt.Println(v.ID) rootSli = append(rootSli, v) &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"跨系统导致的换行问题","date":"2016-05-13T08:54:58.000Z","path":"2016/05/13/跨系统导致的换行问题/","text":"不同系统的换行符有所不同: Windows: \\r\\n Unix: \\n MacOs: \\r 故而在跨系统处理一些按行分隔的字符串或文件时(如.csv),就可能出现因换行符不一致而引发的问题. 如下是一段从csv文件中读取id的代码, 1234567891011121314151617181920212223242526var ids []int64file, err := os.Open(\"/Users/dashen/Desktop/ids.csv\")if err != nil &#123; panic(\"err is:\",err)&#125;defer file.Close()buff := bufio.NewReader(file)for &#123; line, errRead := buff.ReadString('\\n') if errRead == io.EOF &#123; break &#125; if errRead != nil &amp;&amp; errRead != io.EOF &#123; panic(\"errRead is:\",errRead) &#125; id, errAtoi := strconv.Atoi(line) if errAtoi != nil &#123; panic(\"errAtoi is\",errAtoi) &#125; ids = append(ids, int64(id))&#125; 如果都在unix平台运行,则这段代码不会有任何问题,但当文件导出自unix,却在Mac或Windows上运行时,就可能有如下问题: strconv.Atoi: parsing “xxx \\r”: invalid syntax 这时的解决办法, 可以在代码中做处理,如 line = strings.Replace(line, &quot;\\n&quot;, &quot;&quot;, -1) 或 line = strings.Replace(line, &quot;\\r&quot;, &quot;&quot;, -1) 也可以借助系统自带(或自行安装)的格式转换工具,如dos2unix,dos2unix进行处理,而后再执行代码","tags":[{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"大端字节序和小端字节序","date":"2016-05-12T16:17:19.000Z","path":"2016/05/13/大端字节序和小端字节序/","text":"阮一峰-理解字节序","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"Golang使用go与channel实现生产者/消费者模型","date":"2016-05-07T12:25:33.000Z","path":"2016/05/07/Golang使用go与channel实现生产者-消费者模型/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"素书","date":"2016-05-04T12:50:38.000Z","path":"2016/05/04/素书/","text":"原始章第一 夫道、德、仁、义、礼，五者一体也。道者，人之所蹈，使万物不知其所由。德者，人之所得，使万物各得其所欲。仁者，人之所亲，有慈惠恻隐之心，以遂其生成。义者，人之所宜，赏善罚恶，以立功立事。礼者，人之所履，夙兴夜寐，以成人伦之序。夫欲为人之本，不可无一焉。贤人君子，明于盛衰之道，通乎成败之数，审乎治乱之势，达乎去就之理。故潜居抱道，以待其时。若时至而行，则能极人臣之位；得机而动，则能成绝代之功。如其不遇，没身而已。是以其道足高，而名重于后代。 正道章第二 德足以怀远，信足以一异，义足以得众，才足以鉴古，明足以照下，此人之俊也！行足以为仪表，智足以决嫌疑，信可以使守约，廉可以使分财，此人之豪也！守职而不废，处义而不回，见嫌而不苟免，见利而不苟得，此人之杰也！ 求人之志章第三 绝嗜禁欲，所以除累。抑非损恶，所以禳过。贬酒阙色，所以无污。 避嫌远疑，所以不误。博学切问，所以广知。高行微言，所以修身。 恭俭谦约，所以自守。深计远虑，所以不穷。亲仁友直，所以扶颠。 近恕笃行，所以接人。任材使能，所以济务。殚恶斥谗，所以止乱。 推古验今，所以不惑。先揆后度，所以应卒。设变致权，所以解结。 括囊顺会，所以无咎。橛橛梗梗，所以立功。孜孜淑淑，所以保终。 本德宗道章第四 夫志心笃行之术。长莫长于博谋，安莫安于忍辱，先莫先于修德，乐莫乐于好善，神莫神于至诚，明莫明于体物，吉莫吉于知足，苦莫苦于多愿，悲莫悲于精散，病莫病于无常，短莫短于苟得，幽莫幽于贪鄙，孤莫孤于自恃，危莫危于任疑，败莫败于多私。 遵义章第五 以明示下者暗，有过不知者蔽，迷而不返者惑，以言取怨者祸，令与心乖者废，后令谬前者毁，怒而无威者犯，好众辱人者殃，戮辱所任者危，慢其所敬者凶，貌合心离者孤，亲谗远忠者亡，近色远贤者昏，女谒公行者乱，私人以官者浮，凌下取胜者侵，名不胜实者耗。略己而责人者不治，自厚而薄人者弃废。以过弃功者损，群下外异者沦，既用不任者疏，行赏吝色者沮。多许少与者怨，既迎而拒者乖。薄施厚望者不报，贵而忘贱者不久。念旧怨而弃新功者凶，用人不正者殆，强用人者不畜，为人择官者乱，失其所强者弱，决策于不仁者险，阴计外泄者败，厚敛薄施者凋。战士贫游士富者衰；货赂公行者昧；闻善忽略，记过不忘者暴；所任不可信，所信不可任者浊。牧人以德者集，绳人以刑者散。小功不赏，则大功不立；小怨不赦，则大怨必生。赏不服人，罚不甘心者叛。赏及无功，罚及无罪者酷。听谗而美，闻谏而仇者亡。能有其有者安，贪人之有者残。 安礼章第六 怨在不舍小过，患在不豫定谋。福在积善，祸在积恶。饥在贱农，寒在惰织。安在得人，危在失士。富在迎来，贫在弃时。上无常操，下多疑心。轻上生罪，侮下无亲。近臣不重，远臣轻之。自疑不信人，自信不疑人。枉士无正友，曲上无直下。危国无贤人，乱政无善人。爱人深者求贤急，乐得贤者养人厚。国将霸者士皆归，邦将亡者贤先避。地薄者大物不产，水浅者大鱼不游，树秃者大禽不栖，林疏者大兽不居。山峭者崩，泽满者溢。弃玉取石者盲，羊质虎皮者柔。衣不举领者倒，走不视地者颠。柱弱者屋坏，辅弱者国倾。足寒伤心，民怨伤国。山将崩者下先隳，国将衰者民先毙。根枯枝朽，民困国残。与覆车同轨者倾，与亡国同事者灭。见已失者慎将失，恶其迹者须避之。畏危者安，畏亡者存。夫人之所行，有道则吉，无道则凶。吉者百福所归；凶者百祸所攻。非其神圣，自然所钟。务善策者无恶事，无远虑者有近忧。同志相得，同仁相忧，同恶相党，同爱相求，同美相妒，同智相谋。同贵相害，同利相忌，同声相应，同气相感。同类相依，同义相亲，同难相济，同道相成，同艺相规，同巧相胜。此乃数之所得，不可与理违。释己而教人者逆，正己而化人者顺。逆者难从，顺者易行，难从则乱，易行则理。如此理身、理家、理国，可也！ 素书","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"goroutine泄露","date":"2016-04-27T13:52:04.000Z","path":"2016/04/27/goroutine泄露/","text":"参考: Go并发编程–goroutine leak的产生和解决之道 goroutine泄露：原理、场景、检测和防范 go使用context包避免goroutine泄露问题 golang使用pprof检查goroutine泄露 获取goroutine id的方法再谈谈获取 goroutine id 的方法 鸟窝-Hi, 使用多年的go pprof检查内存泄漏的方法居然是错的?! 鸟窝-Go内存泄漏？不是那么简单! 记一次Golang内存分析——基于go pprof 记一次 pprof 分析解决 golang 项目内存泄漏的过程 golang 内存分析/动态追踪","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"成语缀辑IV","date":"2016-04-19T14:03:09.000Z","path":"2016/04/19/成语缀辑IV/","text":"W 挖耳当招 把别人抬手挖耳朵的动作,误认为是跟自己打招呼.比喻期待的心情非常迫切 瓦釜雷鸣 瓦合之卒 比喻胡乱凑合起来,并不齐心的军队. 外宽内忌 表面宽宏大量,内心却多猜忌(袁绍) 外巧内嫉 外表乖巧,内心却忌妒 外顺内悖 表面顺从,内心悖逆 丸泥封关 用一个泥丸封住函谷关. 形容地势险要，只要少量兵力就可以把守 刓方为圆 wán 把方的削成圆的。比喻改变忠直之性，随俗俯仰.正直个性变得圆通世故 玩世不羁 玩岁愒日 kài 贪图安逸,荒废光阴,虚度岁月 《左传·昭公元年》：“赵孟将死矣，主民，玩岁而愒日，其与几何？ 朱熹 “知陛下之志必于复仇启土,而无玩岁愒日之心” 顽廉懦立 nuò 使贪婪的人能够廉洁，使怯弱的人能够自立。形容高尚的事物或行为对人的感化力强。出自战国·邹·孟轲《孟子·万章下》 近义 顽石点头 挽弩自射 拉弓自射,比喻自己做事害自己. 搬石砸脚 莞尔而笑 形容微笑的样子 ，出自《楚辞·渔父》 万壑争流 形容壮美奇妙的景色 万箭攒心 万缕千丝 万象森罗 万应灵药 能治各种病的灵药.比喻能解决任何问题的好办法 含有讽刺或诙谐意 万众睢睢 suī 意思是所有人的眼睛都看着上面，形容众人共同期待或感到惊奇的神情。 出自《汉书·五行志中》 汪洋恣肆/汪洋闳肆 hóng,意同”宏” 形容文章、言论书法等气势豪放，潇洒自如。同“汪洋自肆”。 唐·柳宗元《直城县开国伯柳公行状》:“凡为文，去藻饰之华靡，汪洋自肆，以适己为用。” 明·归有光《与潘子实书》:“听其言汪洋恣肆，而实无所折衷，此今世之通患也。” 网漏吞舟 是网里漏掉吞舟大鱼；比喻法律太宽，使重大的罪犯也能漏网。 出自《史记·酷吏列传序》。 枉尺直寻 弯曲的只有一尺,伸直的却有八尺. 意思是比喻在小处委屈一些，以求得较大的好处。 出自《孟子·滕文公下》。 罔上虐下 指 瞒上欺下 罔知所措 不知怎么办才好 惘然若失 心情不舒畅，好像丢掉了什么东西似的。 出自《后汉书·黄宪传》 望风响应 看到对方有什么举动,就积极响应,或按照对方要求去做 出自《檄吴将校部曲文》。 望衡对宇 形容住处相距很近, 门庭相对, 可以互相望见 出自北魏·郦道元《水经注·沔水》。 望门投止 逃难或出奔时，见有人家就去投宿，求得暂时存身。后泛指在仓猝情况下，来不及选择存身的地方。 出自《后汉书·张俭传》 危若朝露 危险得像清早的露水一样，太阳一出就要消失，形容面临灭亡，情况危急。 出自《史记·商君列传》。 危言谠论 dǎng 正直的言论 出自于宋.王安石《答孙元规大资书》 微文深诋 指想尽办法把无罪的人定成有罪 利用苛细的法律条文,故意陷人于罪 出自《史记·酷吏列传》。 微言大义 包含在精微语言里的深刻的道理 指精微的言辞,深刻的道理,多就以精当的言辞阐述儒家经典的要义而言. 出自《移书让太常博士书》。 韦编三绝 为恶不悛 quān 坚持作恶，不肯悔改。 出自《搜神记》。 为鬼为蜮 yù 像鬼蜮一样阴险狠毒，在暗地里害人的人。 出自《诗经·小雅·何人斯》。 为裘为箕 qiú jī 喻子弟能继承父兄的事业 出自《礼记·学记》 惟精惟一 指精纯专一。 出自《尚书·大禹谟》：“人心惟危，道心惟微，惟精惟一，允执厥中。 委决不下 犹豫不能判定 娓娓不倦 连续谈论，不知疲倦。 出自《警世通言》。 为渊驱鱼，为丛驱雀 水獭想捉鱼吃，却把鱼赶到深渊去了，鹞鹰想捉麻雀吃，却把麻雀赶到丛林中去了。 原比喻方法不当，适得其反，现用于比喻不善于团结人或笼络人，把可以依靠的力量赶到敌对方面去。也比喻为政不善，人心涣散，使百姓投向敌方 未艾方兴 同 方兴未艾 未达一间 意思是指未能通达,只差一点. 表示两者非常接近,只相差一点点. 出自汉·扬雄《法言·问神》。 未定之天 比喻事情还没有着落或还没有决定。 出自《儿女英雄传》 未焚徙薪 wèi fén xǐ xīn 在火患之前就先将柴薪搬开，比喻防患于未然。 出自《喻世明言》。 未风先雨 比喻未见事实先下结论。 出自《醒世恒言》。 未可厚非 无可厚非 不应过分责难 指说话做事虽有缺点,但还有可取之处,应予谅解 出自《汉书·王莽传》 未明求衣 天没有亮就穿衣起床。形容勤于政事。 出自《汉书·邹阳传》：“始孝文皇帝据关入立，寒心销志，不明求衣。” 未始不可 不是不可以，委婉的肯定 《红楼梦》一七回：“各举所长，优则存之，劣则删之，～。 畏天恤民 wèi tiān xù mín 敬畏上天，救济下民，古代维护封建统治的伦理观念。 出自《栾城集·第四表许允批答二首》。 畏威怀德 畏惧声威，感念德惠。 出自《国语·晋语八》 畏影避迹 wèi yǐng bì jì 比喻庸人自扰，不明事理。 出自《庄子·渔父》。 莞尔而笑 形容微笑的样子 ，出自《楚辞·渔父》 谓予不信 认为我所说的话不实在,不可靠 出自《诗经·王风·大车》 猬结蚁聚 人众集结 出自南朝·梁·任昉《奏弹曹景宗》 魏紫姚黄 原指宋代洛阳两种名贵的牡丹品种。后泛指名贵的花卉。 出自《绿竹堂独饮》。 文不尽意 文章未能完全表达出心意 文从字顺 形容写文章遣词造句妥帖通顺,自然流畅. 出自《南阳樊绍述墓志铭》 文江学海 比喻文章和学问似长江、大海般深广博大；比喻文学深奥、丰富。 出自唐郑愔《柏梁体联句》。 文经武纬 指从文武两方面治理国家 出自唐·颜真卿《郭公庙碑铭》 文恬武嬉 文官安闲自在，武将游荡玩乐。 形容天下太平无事，或文武官安于现况，苟且过日。 文武官员都贪图安逸享乐,不把国家大事放在心上 出自《进撰平淮西碑文表》。 闻过则喜 听到别人批评自己的缺点或错误，表示欢迎和高兴；指虚心接受意见。 出自《孟子·公孙丑上》。 闻一知十 听到一点就能理解很多；形容善于类推。 出自《论语·公冶长》。 问道于盲 向瞎子问路；比喻向什么也不懂的人请教，不解决问题。 多用作谦辞 出自《答陈生书》。 瓮牖绳枢 蜗角虚名 蜗行牛步 蜗牛爬行，老牛慢走，比喻行动或进展极慢。 卧榻之侧，岂容他人鼾睡 自己的床上，怎么能让别人呼呼睡大觉？ 比喻不许别人侵入自己的利益范围。 卧雪眠霜 睡卧在霜雪之上，比喻艰苦的流浪生活。 出自《汉宫秋》 也作 卧月眠霜 握发吐哺 wò fà tǔ bǔ 比喻礼贤下士，殷切求才。 出自《史记·周世家》。 握椠怀铅 wò qiàn huái qiān 随身携带笔简,以备记事. 指勤于写作或校勘. 出自晋·葛洪《西京杂记》 握蛇骑虎 比喻处境极险恶 出自《魏书·彭城王传》 握瑾怀瑜/握瑜怀瑾 乌飞兔走 形容光阴迅速流逝。 乌：古代传说日中有三足乌，故称太阳为金乌； 兔：古代传说中月中有玉兔，故称月亮为玉兔。 出自《春愁》。 乌鸟私情 指侍奉尊亲的孝心 出自《陈情表》 呜呼哀哉 原为表示哀痛的感叹语，旧时祭文中常用。 现用以指死亡或完蛋。 出自《左传·哀十六年》，《诗经·大雅·召旻》 诬良为盗 陷害、冤枉守法的好人是盗贼 出自《桃花扇·归山》 屋下架屋 比喻机构或文章结构重叠 比喻无谓的重复而无所创新 出自《世说新语·文学》 无病自灸 比喻自找苦吃或自寻烦恼 出自《庄子·盗跖》 无耻之尤 yóu 最无耻的,形容无耻到了极点 出自清·王士禛《分甘余话》 无根无蒂 没有依靠，没有牵累 出自东汉·班固《汉书·叙传上》 无偏无党 形容处事公正，没有偏向 出自《书·洪范》 无声无臭 xiù 没有声音，没有气味。 比喻没有名声，默默无闻，或不产生影响。 后来形容默默无闻,或事情沉寂,没有发生影响. 出自《诗经·大雅·文王》。 无私有弊 虽然没有自私的意图，但却有弊病，因为处于不能不发生怀疑的地位而担着嫌疑。 没有不轨行为,但因处于有嫌疑的环境之中而使人猜疑. 无隙可乘 无庸讳言 没有什么不可以直说的，指可以坦率地说 无庸赘述 无源之水, 无本之木 吴牛喘月 比喻因疑心而害怕，也比喻人遇事过分惧怕，而失去了判断的能力，也形容天气酷热。 出自《世说新语·言语》 “我就像南方怕热的水牛，看到月亮以为是太阳，忍不住就喘起气来了” 吴市吹箫 原指春秋时楚国的伍子胥逃至吴国,在市上吹箫乞食 比喻在街头行乞, 比喻过艰苦的流亡生活 出自《史记·范睢蔡泽列传》 梧鼠技穷 比喻才能有限 《荀子·劝学》：“腾蛇无足而飞，梧鼠五技而穷。”。 五方杂厝/处 wǔ fāng zá cuò 各地方的人杂居一处，形容居民复杂 出自《汉书·地理志下》 五黄六月 指阴历五、六月间农忙时节，人手紧张忙不过来。 出自《西游记》: “只为五黄六月，无人使唤，父母又年老，所以亲身来送。” 武不善作 既动武就不能讲斯文 出自《西游记》 武昌剩竹 比喻尚可备用的材料 出自《晋书·陶侃传》 舞态生风 跳舞的姿态像风吹那样飘逸,比喻舞姿轻盈飘逸 出自明·冯梦龙《东周列国志》 舞文弄法 玩弄法律条文作弊 物阜民安 物离乡贵 物伤其类 X 夕惕若厉 朝夕戒惧，如临危境，不敢稍懈。 厉:不脱衣过河 出自《易·乾》。 惜指失掌 因舍不得一个指头而失掉一个手掌，比喻因小失大。 出自《南史·阮佃夫传》 溪壑无厌 比喻人的贪欲太大，难得满足。 出自《南齐书·谢脁传》。 熙来攘往 形容人来人往，非常热闹拥挤。 出自《史记·货殖列传》。 膝痒搔背 膝部发痒，却去搔背。比喻力量没有使在点子上。 习非成是 对某些错误事情习惯了，反以为本来就是对的。 出自《法言·学行》。 习焉不察 指经常接触某种事物，反而觉察不到其中存在的问题。 出自《孟子·尽心上》。 习与性成 长期习惯于怎样的生活环境，就逐渐养成相应的习性。 出自 《尚书·太甲上》。 席不暇暖 指连坐席还没有来得及坐热就起来了。形容很忙，多坐一会儿的时间都没有。 出自刘义庆《世说新语·德行》。 席丰履厚 比喻祖上遗产丰富。也形容生活优裕。 出自《二十年目睹之怪现状》 袭故蹈常 指因循守旧，照老规矩办事。 出自宋·苏轼《伊尹论》。 洗心涤虑 比喻彻底改变过去不好的思想和念头。 出自宋·苏轼《策略二》。 喜眉笑眼 喜之不胜 指高兴得不得了 细大不捐 小的大的都不抛弃，形容包罗一切，没有选择。 也指收罗的东西多,毫无遗漏. 遐迩闻名 下坂走丸 从斜坡上滚下弹丸。比喻口才顺势无阻，敏捷而无停滞。 出自汉·荀悦《汉纪·高祖纪一》。 下笔千言 形容文思敏捷，写作迅速。 出自《送丰稷》 畏影避迹 指刚下车，意指官吏刚到任所、比喻刚到工作的地方。 出自《礼记·乐记》。 下井投石 下陵上替 在下者凌驾于上，在上者废弛无所作为，即上下失序，纲纪废坠。出自《左传·昭公十八年》 下愚不移 指下等的愚人，决不可能有所改变， 出自《论语·阳货》。 夏雨雨人 有如夏天的雨落在人身上，比喻及时给人帮助和教育。 出自汉·刘向《说苑·贵德》。 先入之见 指在对某事物进行调查研究之前就形成或接受的看法。指成见。 出自《汉书·息夫躬传》 先声后实 比喻先用声势挫折敌方士气，然后交战。 出自《史记·淮阴侯列传》 先意承志 指孝子不等父母开口就能顺父母的心意去做；后指揣摸人意，谄媚逢迎。 出自《礼记·祭义》 纤尘不染 原指佛教徒修行时，排除物欲，保持心地洁净；现泛指丝毫不受坏习惯，坏风气的影响；也用来形容非常清洁、干净。 出自《法苑珠林》 纤悉无遗 xiān xī wú yí，意思是一点都没有遗漏。 出自《唐丞相太子少师牛僧孺神道碑铭序》 也做 纤芥无遗 纤芥之疾 比喻不必在意的小毛病。 出自《明夷待访录·原臣》。 近似 癣疥之疾 鲜衣美食 穿的是华丽的衣服，吃的是美味的食品；形容生活优裕。 明·冯梦龙《警世通言》卷十七：“德称此时虽然借寓僧房，图书满案，鲜衣美食，已不似在先了。” 贤贤易色 指关注内在的东西，内在美，易色是指换掉，外在的关注。比如我们生活当中很多人喜欢用外部的东西来评判别人。第一个贤是动词，第二个贤是名词，易也是动词，色是名词。 指尊崇贤者,看轻女色 出自《论语·学而》 咸与维新 指一切除旧更新 指一切受恶劣习俗影响或犯罪的人都可改过自新 也泛指一切都需要改革更新. 出自《书·胤征》 咸嘴淡舌 比喻无事生非或没话找话说。 出自清·曹雪芹《红楼梦》第五十八回。 涎皮赖脸 xián pí lài liǎn，意思是厚着脸皮纠缠，惹人厌烦。 出自《宝剑记》。 涎皮涎脸 xián pí xián liǎn，意思指嬉皮笑脸，厚着脸皮跟人纠缠。 出自杨朔《三千里江山》 涎言涎语 厚着脸皮胡言乱语，撒赖。 出自清·曹雪芹《红楼梦》。 衔华佩实 形容文章的形式和内容都完美，也形容草木开花结果。 出自《文心雕龙·征圣》。 衔环结草 衔尾相随 马嚼子接着马尾巴；形容一个紧跟着一个，成单行前进。 出自《汉书·匈奴传》。 显亲扬名 指使双亲显耀，名声传扬 出自《孝经·开宗明义》 现世现报 指人做了恶事，今生就会得到报应。 出自《法苑珠林·妄语部》 献可替否 指劝善归过，提出兴革的建议。 亦作“献可替不”。 相待而成 互相辅助以取得成功 相反相成 指两个对立的事物既互相排斥又互相促成。即相反的东西也相互依赖，具有同一性。 出自《汉书·艺文志》。 相去天渊 比喻二者相隔极远，差别极大。 出自清·夏敬渠《野叟曝言》。 也作相隔天渊 相视莫逆 形容彼此间友谊深厚，无所违逆于心。 出自《庄子·大宗师》。 香象渡河 佛教用语，比喻悟道精深；也形容评论文字精辟透彻。 出自《优婆塞戒经》。 香消玉减 意思是美女日渐消瘦。 也作香消玉碎 出自元·贾仲名《萧淑兰》。 详情度理 审察情由，推测事理。 出自清·曹雪芹《红楼梦》。 降邪从正 降伏妖邪，使之改邪归正 出自《西游记》 祥云瑞气 旧时认为天上彩色的云气为吉祥的征兆，故称祥云瑞气 出自《紫微宫》 响彻云霄 形容声音响亮，好像可以穿过云层，直达高空。 出自《隋唐演义》。 响遏行云 形容歌声嘹亮，高入云霄，连浮动着的云彩也被止住了。 出自《列子·汤问》。 向风慕义 xiàng fēng mù yì，意思是指向往其教化，仰慕其礼义。或指向往其风度，仰慕其义行。 出自《番夷求贡疏》 向壁虚造 xiàng bì xū zào，意思是对着墙壁，凭空造出来的。比喻无事实根据，凭空捏造 出自《说文解字·序》 也作 向壁虚构 向隅而泣 一个人面对墙角哭泣。比喻非常孤立或得不到机会而失望地哭泣，后多用以形容因被冷落、抛弃而感到孤独绝望，无可奈何。 出自《说苑·贵德》 也作 向隅独泣 相风使帆 比喻根据情势的变化而改变态度。 出自《五灯会元·圆通禅师》。 相时而动 观察时机，针对具体情况采取行动。 出自《左传·隐公十一年》 象牙之塔 指主张“为艺术而艺术”的资产阶级文艺家脱离社会现实的个人幻想的艺术境界。也比喻脱离现实生活的知识分子的小天地。也比喻存在于理想的空间。 出自《朝花夕拾·二十四孝图》。 象箸玉杯 xiàng zhù yù bēi 形容生活奢侈 出自《韩非子·喻老》 像心像意 顺遂心愿，合乎心意 出自《京本通俗小说·海陵王荒淫》 枭首示众 斩首悬示于众 出自《古今小说·汪信之一死救全家》 枵肠辘辘 xiāo cháng lù lù 出自清·蒲松龄《聊斋志异·西湖主》 枵：空虚。辘辘：车轮滚动的声音。肚子饿得辘辘叫，形容十分饥饿 清·蒲松龄《聊斋志异·西湖主》：“忽僮仆肢体微动，喜而扪之。无何，呕水数斗，醒然顿苏。相与曝衣石上，近午始燥可着。而枵肠辘辘，饥不可堪。” 枵腹从公 xiāo fù cóng gōng，意思是指饿着肚子办公家的事。形容一心为公。 出自《殷开山传》 清·李宝嘉《洗在狱》楔子：“到了这个分上，要想他们毁家纾难，枵腹从公，恐怕走遍天涯，如此好人，也找不出一个。” 哓哓不休 xiāo xiāo bù xiū，意思为争辩个没完。 出自《重答张籍书》。 宵旰图治 xiāo gàn tú zhì，意思是宵衣旰食，勤于政事，设法治理好国家。 出自《明史·罗侨传》。 《阅江楼记》（明代宋濂作）：“臣不敏，奉旨撰记。欲上推宵旰图治之功者，勒诸贞珉”。 《旧唐书-刘fen传》（大和二年对策）：“若夫任贤惕厉，宵衣旰食，宜黜左右之纤佞，进股肱之大臣。” 白居易《长庆集》（陈鸿的长恨歌传）：“玄宗在位岁久，倦于旰食宵衣，政无大小，始委于右丞相，深居游宴，以声色自娱。” 宵衣旰食 形容为处理国事而辛勤地工作。多用以称颂帝王勤于政事。 南朝陈徐陵《陈文帝哀册文》：勤民听政，旰衣宵食。 若夫任贤惕厉，宵衣旰食，宜黜左右之纤佞，进股肱之大臣。——《旧唐书·刘蕡传》 近义词：夙夜不懈、握发吐哺 萧规曹随 按照前人的成规办事。 出自《史记·曹相国世家》。 萧墙祸起 霄壤之别 比喻差别极大，出自《抱朴子·内篇·论仙》。 也作 霄壤之殊 小惩大诫 有小过失就惩戒，使受到教训而不致犯大错误。 出自《周易·系辞下》。 小器易盈 xiǎo qì yì yíng，意思是比喻器量狭小，容易自满。 出自《在元城与魏太子笺》。 小黠大痴 xiǎo xiá dà chī，意思是小处狡黠精明，而大处往往糊涂失算。 出自《送穷文》。 小小不言 指细微的，不值得一提的 出自《官场现形记》 晓行夜宿 一早起来赶路，到夜里才住宿下来；形容旅途奔波劳苦。 出自《楚昭公》。 效颦学步 比喻盲目模仿而弄巧成拙 出自明李贽《答耿司寇书》 邪不干正 胁肩谄笑 为了奉承人，缩起肩膀装出笑脸。形容巴结人的丑态。 出自《孟子·滕文公下》。 挟权倚势 意思是凭借和倚仗权势。 出自元·孔文卿《东窗事犯》。 挟山超海 夹着泰山跨越北海，比喻做绝对办不到的事。 出自《孟子·梁惠王上》。 屑榆为粥 把榆树皮磨成碎屑，做成粥食。指艰苦生活 心安神泰 心不应口 应：合。意思是心里想的和嘴里说的不一致，指为人虚伪。 出自明·杨德芳《步步娇·闺怨》。 心慈面软/心粗胆大/心粗气浮/心胆俱裂/心荡神摇 心旌摇摇 xīn jīng yáo yáo，心神不定或情思起伏。 出自《战国策·楚策一》。 心劳日拙 现多指做坏事的人，虽然使尽坏心眼，到头来不但捞不到好处，处境反而一天比一天糟。 多用作贬词。 出自《尚书·周官》。 心手相应/心手相忘 形容手法熟练，心里怎么想，手就怎么做。 出自《南史·萧子云传》。 心中无数 指对情况了解不清楚，心里没有底。 出自姚雪垠《李自成》。 欣喜雀跃 新硎初试 xīn xíng chū shì，意思是像新磨的刀那样锋利，比喻刚参加工作就显露出出色的才干。 出自《庄子·养生主》。 薪尽火传 馨香祷祝 xīn xiāng dǎo zhù，原指迷信的人虔诚地向神祈祷祝愿；后引申指真诚地期望。 出自《尚书·酒诰》。 信而有征 意思是可靠而且有证据。 出自《左传·昭公八年》。 信赏必罚 有功劳的一定奖赏，有罪过的一定惩罚。 出自《韩非子·外储说右上》。 兴利除害/兴利除弊 兴灭继绝 使灭绝了的重新振兴起来，延续下去。 惺惺惜惺惺 意思是比喻同类的人互相爱惜，珍惜。 行不由径 意思是从来不走邪路；比喻行动正大光明。 出自《论语·雍也》。 行成于思 意思是做事情成功是因为多思考，失败是由于不经心；指做事情要多思考，多分析 出自《进学解》 行若狗彘 指人无耻，行为像猪狗一样。 出自西汉·贾谊《论治安策》。 行远自迩 xíng yuǎn zì ěr，意思是走远路必须要从最近的一步走起；比喻做事情都得由浅入深，一步步前进。 出自 《礼记·中庸》: “譬如行远必自迩，譬如登高必自卑。” 形格势禁 指受形势的阻碍或限制，事情难于进行。 出自《史记·孙子吴起列传》。 形容槁木 形销骨立 兴会淋漓 形容兴致很高，精神舒畅。 出自《歧路灯》。 性命交关/凶年饥岁 兄弟阋墙 xiōng dì xì qiáng，意思是指兄弟之间的纠纷，也比喻内部争斗 出自《诗经·小雅·棠棣》 胸无宿物 胸中没有过夜的东西；比喻心地坦率，没有成见。 出自《世说新语 赏誉》 熊经鸟伸 意思是古代一种导引养生之法；状如熊之攀枝，鸟之伸脚。 战国·宋·庄周《庄子·刻意》：“吹呴呼吸，吐故纳新，熊经鸟申，为寿而已矣。” 休牛放马 把牛马放归山林，停止充作军用，比喻不要战争要和平 出自于《尚书·武成》。 修旧利废 把破旧的修补好，把废物利用起来，指厉行节约。 出自《汉书·司马迁传》。 修身洁行 思是修养品性，保持洁白的德行。 出自《史记·魏公子列传》。 修文偃武 为提倡文教，停息武事。 出自《九日曲池游眺》。 羞人答答 形容自己感觉难为情。 出自《西厢记》。 羞与为伍 把跟某人在一起认为是可耻的事。 羞，感到羞耻；与，跟；为伍，作伙伴。 出自南朝·宋·范晔《后汉书·党锢列传》。 虚声恫吓 故意夸大其词，借以威吓对方。 虚应故事 照例应付，敷衍了事。指用敷衍的态度对待工作。 出自《宋史·刘黻传》。 虚位以待/虚左以待 恤孤念寡 xù gū niàn guǎ 指关心、照顾 孤儿 寡妇。 也作“恤孤爱寡”。 悬车致仕 xuán chē zhì shì， 意思是指告老引退，辞官家居。 旋乾转坤 xuán qián zhuǎn kūn 比喻从根本上改变社会面貌或已成的局面。也指人魄力极大。 出自《潮州刺史谢上表》。 癣疥之疾 xuǎn jiè zhī jí，比喻无关紧要的小问题和小毛病。 出自《吕氏春秋·直谏》。 削木为吏 xuē mù wéi lì，意思是不能受狱吏的侮辱，即使是木头做的狱吏也不能见他。形容狱吏的凶暴可畏。 出自 汉·司马迁《报任安书》 穴居野处 意思是居住在洞里生活在荒野，形容原始人的生活状况。 出自《易·系辞下》 学无常师 意思是求学没有固定的老师。指凡有点学问、长处的人都是老师。 出自《论语·子张》 雪兆丰年 血流漂杵 熏天赫地 形容气势炽热，气势极盛。 薰莸不同器 xūn yóu bù tóng qì 意思是香草和臭草不能放在同一器具里。比喻君子与小人或好人与坏人不可同处。 循名责实 xún míng zé shí，意思是按着名称或名义去寻找实际内容，使得名实相符。 出自《韩非子·定法》。 徇情枉法 意思受到私情的左右做出违法的事。 出自元·王謦《中书右丞相史公神道碑》。 Y 压倒元白 比喻作品胜过同时代有名的作家。 出自《唐摭言·慈恩寺题名游赏赋咏杂记》。 压肩叠背 指人众多密集 鸦默雀静/鸦没鹊静 睚眦必报 睚眦之怨 像瞪眼看人这样的小怨，引申为极小的怨恨。 出自《史记·范睢蔡泽列传》。 雅人深致 原是赞赏《诗经·大雅》的作者有深刻的见解。后形容人的言谈举止不俗。 出自南朝宋·刘义庆《世说新语·文学》。 烟波钓徒 指隐逸于渔的人。也指隐居者 出自《新唐书·张志和传》。 烟岚云岫 yān lán yún xiù，意思是形容山峦之间云雾之气弥漫缭绕。 出自《万卷楼记》。 湮没无闻 延颈企踵， yán jǐng qǐ zhǒng 意思是伸长脖子，抬起脚跟。形容急切盼望。 出自《剧秦美新》 延颈跂踵、延颈举踵 言必有据 说话一定要有根据。 出自鲁迅《&lt;故事新编&gt;序言》。 言必有中/言不达意/言不及义 言必有中，指一说话就能说到点子上。出自《论语·先进》。 言不达意，说的话不能准确地表达思想内容。亦作“言不逮意”。出自《明史·广西土司传二·思明》。 言不及义，形容说话内容无聊或说不到问题的关键所在。也指只说些无聊的话，不涉及正经道理。出自 《论语·卫灵公》。 言不践行 说了不能实行。 出自清·吴趼人《二十年目睹之怪现状》。 言不尽意 情意曲折深远，言语难以全部表达；常用于书信末尾，表示说的话没能把意思都表达出来。 出自 《易·系辞上》。 言出法随 话一说出口，法律就跟在后面；指法令一经公布就严格执行，如有违犯就依法处理。 出自清·林则徐《奉旨前往广东查办海口事件传牌稿》。 言和意顺 言语和顺，情意相谐。 出自《红楼梦》 言近旨远 话很浅近，含义却很深远。 出自《孟子·尽心 下》。 言清行浊 说的是清白好话，做的是污浊坏事。形容人言行不一。 出自《命书》。 言人人殊 意思是指各人有各人的意见。同一消息或事情，各人却说成各不相同的情形。 出自《史记·曹相国世家》。 言扬行举 意思是德行和名声来选择人才。 出自《礼记·文王世子》。 言犹在耳 说的话还在耳边；形容对人家说的话还记得清清楚楚。 出自《左传·文公七年》。 言者无罪，闻者足戒 1.指出自己观点和方法的人不应该承担什么责任，而听的人可以从中吸取有价值的东西．这样才能发挥出群众的智慧。 2.提意见的人只要是善意的，即使提的不正确，也是无罪的。听取意见的人即使没有对方所提的缺点错误，也值得引以为戒。 言之不预 没有事先通知、提醒。 出自《新民主主义论》。 言之过甚 意思是话说得太过头了。 出自《追求》。 沿波讨源 循着水流寻找源头。比喻根据线索探求事物的根源 出自《文赋》。 研精覃思 精心研究，深入思考。 出自《尚书序》。 掩目捕雀 遮住眼睛捉飞雀，比喻盲目做某件事或自欺欺人。 出自《三国志·魏书·陈琳传》。 掩映生姿 形容景物在映衬下显得更美。 偃兵息甲 息：停止。甲：铠甲。 放下武器，收起铠甲。指停止战斗。也作“偃武息戈”。 偃武修文 停止武事，振兴文教。 出自《尚书·武成》。 艳如桃李 宴安鸩毒 yàn ān zhèn dú，意思是贪图安逸享乐如同饮毒酒自杀一样致命、有害。比喻耽于逸乐而杀身。用以警戒人别懒惰的用语。 出自《左传·闵公元年》。 燕俦莺侣/燕侣莺俦 燕俦莺侣: yàn chóu yīng lǚ，意思是年轻的女伴，也比喻相爱的青年男女。 出自元·胡祗遹《点绛辰·赠妓》。 燕侣莺俦: 意思是比喻年轻的女伴，也比喻相爱的青年男女。出自《青楼十咏·小酌》。 燕雀处屋 yàn què chǔ wū，意思是燕雀在堂上筑巢。比喻处境危险而不自知。 出自《孔丛子·论势》。 扬名显亲 指使双亲显耀，名声传扬。 出自《孝经·开宗明义》。 羊质虎皮 羊虽然披上虎皮，还是见到草就喜欢，碰到豺狼就怕得发抖，它的本性没有变。比喻外表装作强大而实际上很胆小。 出自《素书》。 仰人鼻息 仰：依赖；鼻息：指呼吸时进出的气。靠别人的呼吸活下去。 比喻依赖人，看人的脸色行事 出自《后汉书·袁绍传》。 仰首伸眉 意气昂扬的样子。 出自汉·司马迁《报任少卿书》。 养虺成蛇 yǎng huǐ chéng shé，意思是比喻纵容敌人，任其强大起来。 即 养虎遗患。 出自《国语·吴语》 养痈遗患 yǎng yōng yí huàn，比喻纵容包庇坏人坏事，结果会遭受祸害。 出自《后汉书·冯衍传》。 腰金衣紫/腰金拖紫 腰中挂着金印，身上穿着紫袍。指做了大官 未艾方兴 同 方兴未艾 尧天舜日 尧、舜：古代传说中的两位贤君。尧、舜在位的时期。原用以称颂帝王的盛德。后也比喻天下太平的时候。 杳如黄鹤 药笼中物 比喻备用的人才。 出自《新唐书·元行冲传》。 要言妙道 中肯的名言，深微的道理。 出自汉·枚乘《七发》。 野无遗才/野无遗贤 指任人唯贤，人尽其才。同“野无遗贤”。古多以称颂圣明之世 夜雨对床 指亲友或兄弟久别重逢，在一起亲切交谈。 出自《雨中招张司业宿》。 一表非凡 形容人的仪表出众，很不寻常。 出自元·无名氏《鸳鸯被》第一折。 一唱百和 形容附和的人极多。 出自《孽海花》。 一酬一酢 yī chóu yī zuò，意思是一来一往地互相敬酒。 出自《儿女英雄传》。 一得之功 一点微小的成绩。 出自西汉·司马迁《史记·淮阴侯列传》。 一得之见 谦虚的说法，指自己对某个问题的见解。 出自《史记·淮阴侯列传》。 一得之愚 指自己对某件事的一点看法。 出自《史记·淮阴侯列传》。 一定不易 原指一定下来就不变更，后形容事理正确，不可改变。 出自《淮南子·主术训》。 一饭千金 比喻厚厚地报答对自己有恩的人。 出自《史记·淮阴侯列传》。 一傅众咻 yī fù zhòng xiū，意思是一个人教导，众人吵闹干扰。比喻不能有什么成就。 出自《孟子·滕文公下》。 一国三公 一个国家有三个主持政事的人。比喻事权不统一，使人不知道听谁的话好。 出自《左传·僖公五年》。 一呼百诺 一人呼唤，百人应答。形容有钱有势，仆从很多。 出自《韩诗外传》。 一狐之腋 yī hú zhī yè，意思是一只狐狸腋下的皮毛。比喻珍贵的东西。 出自西汉·司马迁《史记·赵世家》。 一举数得 一孔之见 一匡天下 消除混乱局面，使天下安定下来。 出自《论语·宪问》。 一劳永逸 一了百当 指办事妥当、彻底，出自张居正《答山东巡抚何来山》 一颦一笑 一曝十寒 yī pù shí hán 虽然是最容易生长的植物，晒一天，冻十天，也不可能生长。比喻学习或工作一时勤奋，一时又懒散，没有恒心。 出自《孟子·告子上》。 一清如水 像流水一样清澈。形容为官廉洁，不贪污、不受贿。也形容十分清洁。 出自《西湖二集·祖统制显灵救驾》 一丘之貉 同一山丘上的貉。比喻彼此同样低劣，并无差异 出自《汉书·杨恽传》 一仍旧贯 yī réng jiù guàn，意思是按照老规矩办事，没有丝毫改变。 出自《论语·先进》。 一日之雅 意思是指短暂的交往，交情不深。 出自 《汉书·谷永传》。 一身二任 指一个人同时担负两项任务。 出自《汉书·王吉传》。 一望而知 一看就明白 出自《歧路灯》 一笑置之 指笑了一笑就放在旁边了，表示不当一回事。出自《书梦》 一心一德 大家一条心，为一个共同目标而努力 出自《尚书·泰誓中》 一言丧邦 指一句话可以亡国。 出自《论语·子路》和《旧唐书·孙伏伽传》 一言兴邦 指一句话可以兴国。 出自 《论语·子路》。 一语破的 yī yǔ pò dì，意思是一句话就说中要害。 出自《带经堂诗话·品藻类》。 一字褒贬 一个字的褒扬或贬斥，泛指记事论人，用字措辞严谨有分寸。 伊于胡底 yī yú hú dǐ，意思是到什么地步为止（对不好的现象表示感叹）。 出自《诗经·小雅·小旻》。 衣不重采 yī bù chóng cǎi，意思是不穿多件色彩鲜艳的衣服。形容衣着朴素。 出自《史记·吴太伯世家》。 移宫换羽 yí gōng huàn yǔ，意思原指乐曲换调，后也比喻事情的内容有所变更。 出自《意难忘·美人》。 遗风遗泽 先人留下的教化德泽。 出自 苏轼《母聂氏温国太夫人外制》。 以耳代目 拿眼睛当耳朵。指不亲自去调查了解，光听信别人说的。 出自《聊斋志异·司文郎》。 以观后效 指将罪犯从轻处分，再看他以后的表现。 出自《后汉书·安帝纪》。 以管窥天/以蠡测海 从小孔或缝隙里看。通过竹管子的孔看天，比喻见闻狭隘或看事片面。 出自《庄子·秋水》。 以蠡测海，yǐ lí cè hǎi，意思是用贝壳来量海。比喻观察和了解很狭窄很片面。 汉·东方朔《答客难》：“以管窥天，以蠡测海。” 以儆效尤 yǐ jǐng xiào yóu，儆：使人警醒，不犯错误。效：效仿。尤：过失。 意思是指处理一个坏人或一件坏事，以达到警醒他人的目的 出自《左传·庄公二十一年》。 以类相从 指按其类别各相归属。 出自《荀子·正论》 以狸饵鼠 捉老鼠用猫作诱饵。比喻事情不能成功。 出自《商君书·农战》 以邻为壑 以其昏昏使人昭昭 兴利除害/兴利除弊 以手加额，意思是把手放在额上，表示欢欣庆幸。 出自杨万里《章贡道院记》。 额手相庆 以售其奸 用来推行他的奸计。 出自 柳宗元《送娄图南秀才游淮南将入道序》。 以汤沃雪 用开水浇雪。比喻效果明显。也比喻事情很容易做。 出自 《淮南子·兵略训》。 以汤止沸 用开水去制止水的沸腾。比喻不从根本上着手，对事情没有帮助。 出自《吕氏春秋·尽数》。 以文会友 指通过文字来结交朋友。 出自《论语·颜渊》。 迤逦不绝 yǐ lǐ bù jué，意思是曲折连绵不断。 出自宋·张君房《云笈七签》 倚门傍户 做学问自己没有见解，只袭取别人的说法。 出自宋·释普济《五灯会元》。 拾人牙慧? 异乎寻常 跟平常的情况很不一样。 出自 茹志娟《在社会主义的轨道上》。 抑恶扬善/抑强扶弱 易如拾芥 yì rú shí jiè，意思是容易得如同拾芥子一样。比喻事情极容易办成。 出自《汉书》卷七十五 悒悒不乐/悒悒寡欢 yì yì，意思是心里郁闷，感到不快。 出自《汉武帝内传》。 逸闻趣事 意在笔前/意在笔先 写字构思在落笔以前。或指作诗文前先作思想上的酝酿，然后着笔。 出自王羲之 《题卫夫人笔阵图后》 薏苡明珠/薏苡之谤 yì yǐ míng zhū，意思是薏米被进谗的人说成了明珠。比喻被人诬蔑，蒙受冤屈。 出自《后汉书·马援传》。 因陋就简 原意是因循原来的的简陋，不求改进；后指就着原来简陋的条件办事。 出自《移书让太常博士》。 因人成事 依靠别人的力量办成事情。 出自 《史记·平原君虞卿列传》。 因势利导 顺着事情发展的趋势，向有利于实现目的的方向加以引导。 出自司马迁《史记·孙子吴起列传》。 因循守旧 死守老一套，缺乏创新的精神。 出自《汉书·循吏传序》。 因循贻误/因循坐误 出自《孽海花》，情况发生了变化，还是沿用旧办法 因噎废食 音容宛在 殷鉴不远 指周朝子孙应以商的灭亡为鉴戒。后泛指前人的教训就在眼前。 出自《诗经·大雅·荡》。 殷民阜财 īn mín fù cái 释义 殷：殷实，富足；阜：丰富。民众富足，物产丰饶。 出处 汉·扬雄《法言·孝至》：“君人者务在殷民阜财，明道信义。” 吟风咏月 旧指文人写作或朗诵以风月等自然景色为题材的作品，现多形容作品空虚无聊。 唐·范传正《李翰林白墓志铭》：“吟咏风月，席天幕地，但贵其适所以适，不知夫所以然而然。” 吟风弄月、咏月嘲风 银样镴枪头 镴 là：焊锡，也就是铅锡合金。 本意是将焊锡做成枪头，看上去明晃晃的像银质一样，比喻表面看起来还不错，实际上不中用，好像颜色如银子的锡镴枪头一样。 出自 《西厢记》 寅忧夕惕 yín yōu xī tì，释义为执政者忧心忡忡，早晚提心吊胆，出自 《南齐书·明帝纪》。 引虎自卫 意思是企图依仗恶人，结果反受其害。 出自明·罗贯中《三国演义》 第63回：“严颜在巴郡，闻刘璋差法正请玄德入川，拊心而叹曰：此所谓独坐穷山，引虎自卫者也！” 饮冰食檗/饮冰茹檗 yǐn bīng shí bò，意思是喝冷水，吃苦味的东西；形容生活清苦，为人清白。 檗， 木名。即黄檗。也称“黄柏”。 出自白居易 《三年为刺史》。 饮泣吞声 意思是眼泪只能往肚里流，不敢哭出声来；形容受压迫时，忍受痛苦，不敢公开表露。 出自《水浒全传》第九十八回：“琼英知了这消息，如万箭攒心，日夜吞声饮泣，珠泪偷弹，思报父母之仇，时刻不忘。” 鹰扬虎视 像鹰那样飞翔，如虎一般雄视。形容十分威武。 出自《诗经·大雅·大明》。 郢书燕说 yǐng shū yān shuō，意思是比喻牵强附会，曲解原意。 出自《韩非子·外储说左上》。 distorted interpretation 景从云集 如影随形，如云聚集，形容追随者多，天下云集，出自《封神演义》。 庸医杀人 医术低劣的医生误用药物而害人性命。 出自《宋史·食货志上》。 雍容尔雅 形容态度大方，举止不俗。 出自《史记·司马相如列传》 饔飧不继/饔飧不济 yōng sūn bù jì，意思是指吃了上顿没有下顿，形容生活十分穷困。 饔：早饭；飧：晚饭。 明·朱用纯《朱子家训》（《治家格言》）：“虽饔飧不继，犹有余欢。” 清·无名氏《杜诗言志》卷七：“于是，衡门之下，环堵萧然，饔飧不继，过日恒饥耳。” 循名责实 xún míng zé shí，意思是按着名称或名义去寻找实际内容，使得名实相符。 出自《韩非子·定法》。 永志不忘 用舍行藏 形容一个人的处世态度。当为世所用时，则积极努力地去做，当不为世所用时，则退而隐居起来。 出自《论语·第七章·述而篇》。 用行舍藏 被任用就行其道，不被任用就退隐。 出自《论语·述而》 优孟衣冠 yōu mèng yī guān，意思是比喻假扮古人或模仿他人。也指登场演戏。 出自《史记·滑稽列传》。 优哉游哉 yōu zāi yóu zāi，意思是指生活悠闲自在，出自《诗经·小雅·采菽》。 忧患余生 指饱经患难之后侥幸保全下来的生命 宋·苏轼《东坡题跋·跋嵇叔夜〈养生论〉后》：“东坡居士以桑榆之末景，忧患之余生，而后学道，虽为达者所笑，犹贤乎已也。” 清·章炳麟《致段祺瑞电》：“既已忧患余生，出而图事，则宜屏迩言而闳远略。 忧深思远 指深刻忧虑，长远打算。 《诗经·唐风·蟋蟀》小序：“忧深思远，俭而用礼，乃有尧之遗风焉。” 高瞻远瞩 由此及彼， 有的放矢 放箭要对准靶子。比喻说话做事有针对性。 出自《整顿党的作风》。 有加无已 yǒu jiā wú yǐ，意思是不停地增加或事态发展越来越厉害。 出自《左传·昭公七年》 有闻必录 听到什么，不管对不对，全都记录下来。 出自清·张春帆 《宦海》。 有眼如盲/有眼无珠 牖中窥日 yǒu zhōng kuī rì，意思是从窗户中看太阳。比喻读书专注而不广博。 比喻学识浅的人成见少,易于接受新的知识 出自《世说新语·文学》。 迂回曲折 于今为烈 指某件事过去已经有过，现在更加厉害。 出自《孟子·万章下》。 予取予求 yú qǔ yú qiú，“予”指“我” 。原指从我这里取，从我这里求（财物）；后指任意索取。 出自《左传·僖公七年》。 鱼贯而出/鱼贯而入/鱼贯而行 鱼游釜中 鱼在锅里游；比喻处境危险，快要灭亡。 出自《后汉书·张纲传》。 羽毛未丰 指小鸟的羽毛还没有长全，比喻尚未成熟或力量还不够强大。 出自《战国策·秦策一》。 郁郁不乐 言犹在耳 说的话还在耳边；形容对人家说的话还记得清清楚楚。 出自《左传·文公七年》。 遇事生风 原形容处事果断而迅速；后指一有机会就挑拨是非，引起事端。 出自《汉书·赵广汉传》。 元方季方 指两人难分高下；后称兄弟皆贤为“难兄难弟”或“元方季方”。 出自《世说新语·德行》。 原始要终 探求事物发展的起源和结果。 出自《周易·系辞下》 圆颅方趾 yuán lú fāng zhǐ，意思是方脚圆头，指人类。 出自《淮南子·精神训》。 援笔而就 yuán bǐ ér jiù，意思是援笔，拿笔。 出自《新唐书·韦思谦传》。 援笔立成 月盈则食 指月圆之后就要变成下弦月，比喻事物盛到极点就会衰落。 出自《周易·丰》。 月晕础润 yuè yùn chǔ rùn，意思为事情将要发生的先兆。 出自梁启超《新民说》第十八节：“今日中国之现象，其月晕础润之几既动矣。若是乎，则智育将为德育之蠹；而名德育而实智育者，益且为德育之障也。” 月晕而风，础润而雨 比喻从某些征兆可以推知将会发生的事情。 月晕而风不一定出现，已经做了验证；础润而雨验证为真。 宋苏洵《辨奸论》：“事有必至，理有固然，惟天下之静者，乃能见微而知著，月晕而风，础润而雨，人人知之。” 清 百一居士《壶天录》卷上：“燥湿为天地自然之气，月晕而风，础润而雨，人以此测於几先者，固古今一致也。”亦作“月晕知风，础润知雨”。 长舆 《论莱阳民变事》：“月晕知风，础润知雨，窃恐踵 莱阳 而起者，祸变相寻而来未有已也。” 粤犬吠雪 意思广东很少下雪，狗看见下雪就叫。比喻少见多怪。 出自唐·柳宗元《答韦中立论师道书》。 蜀狗吠日 云程发轫 yún chéng fā rèn，旧时祝人前程远大的颂辞。 云程：青云万里的路程；发轫：启车行进，比喻事业的开端 战国·楚·屈原《离骚》：“朝发轫于苍梧兮，夕余至乎县圃。 云诡波谲 云山雾罩 形容云雾弥漫，也指人说话不着边际。 云兴霞蔚 云气升腾，彩霞聚集。形容灿烂绚丽的景象。 出自《世说新语·言语》。 云行雨洽/云行雨施 yún xíng yǔ qià，汉语成语，比喻广施恩泽。 《乐府诗集·舞曲歌辞一·北齐文武舞歌》：“云行雨洽，天临地持。” 羊质虎皮 羊虽然披上虎皮，还是见到草就喜欢，碰到豺狼就怕得发抖，它的本性没有变。比喻外表装作强大而实际上很胆小。 出自《素书》。 允文允武 形容既能文又能武。 出自《诗经·鲁颂·泮水》。 运乖时蹇 yùn guāi shí jiǎn，意思是时运不佳，处于逆境。 出自明·许仲琳《封神演义》。 运斤成风 Z 咂嘴弄舌 zā zuǐ nòng shé，意思是形容贪馋的样子。 出自清·吴敬梓《儒林外史》 再衰三竭 形容军队逐渐丧失了开始时的锐气，战斗力越来越弱。 出自《左传·庄公十年》。 be nearing exhaustion；weakening and close to exhaustion (idiom)；in terminal decline；on one’s last legs 再作冯妇 zài zuò féng fù，比喻再干旧行业。 《孟子·尽心下》：“晋人有冯妇者，善搏虎，卒为善士；则之野，有众逐虎，虎负嵎，莫之敢撄；望见冯妇，趋而迎之，冯妇攘臂下车，众皆悦之，其为士者笑之。” 在官言官 指处在什么样的地位就说什么样的话。 出自《礼记·曲礼下》。 载歌载舞 形容非常的欢乐。 宋·郭藏倩《乐府诗集·北齐南郊乐歌·昭夏乐》：“饰牲举兽，载歌且舞，既舍伊腯，致精灵府。” 载笑载言 指边笑边说话。 出自《诗经·国风·卫风·氓》“既见复关，载笑载言”。 载舟覆舟 水能载舟，亦能覆舟出自《荀子.哀公》，是说统治者如船，老百姓如水，水既能让船安稳地航行，也能将船推翻吞没，沉于水中，表示事物用之得当则有利，反之必有弊害。 臧否人物 āng pǐ rén wù，意思是指评论人物好坏，出自 《晋书·阮籍传》 责有攸归 zé yǒu yōu guī，意思是是谁的责任，就该归谁承担，指责任有所归属， 出自高阳《清宫外史》。 啧有烦言 zé yǒu fán yán，本义是指人多嘴杂，今多指很多人议论纷纷，表示不满。 出自《左传·定公四年》。 昃食宵衣 zè shí xiāo yī，意思是入夜才吃晚饭，天不亮就穿衣起床。指勤于政务。 出自《陈文皇帝哀册文》 宵衣旰食、夙夜不懈、握发吐哺 斩将搴旗 zhǎn jiàng qiān qí，意思是拔取敌旗，斩杀敌将，形容勇猛善战。 出自《吴子·料敌》。 展眼舒眉 指高兴，眉眼舒展。形容称心遂意的样子。 出自:元·郑光祖《王粲登楼》第三折：“几曾道展言舒眉，则被你误了人儒冠布衣。” 战不旋踵 zhàn bù xuán zhǒng，意思是打仗时不向后转。形容勇猛向前。 出自《史记·孙子吴起列传》。 彰明较著/彰明昭著 zhāng míng jiào zhù，意思是指事情或道理极其明显，很容易看清。 出自《史记·伯夷列传》 彰善瘅恶 zhānɡ shàn dàn è，意为表扬好的，斥责恶的。 出自《尚书·毕命》。 招权纳贿/招权纳赂 zhāo quán nà huì/lu，意思是把持着权力，收受贿赂。 出自《汉书·季布传》 招降纳叛 原指收容接纳敌方投降叛变过来的人，以扩大自己的势力；现指收罗坏人，结党作恶 出自《宋史·刘光世传》。 recruit derecruit deserters and traitors 朝乾夕惕 zhāo qián xī tì，意思是形容一天到晚勤奋谨慎，没有一点疏忽懈怠。 出自《周易·乾》。 折冲樽俎 zhé chōng zūn zǔ，意思是指不用武力而在酒宴谈判中制敌取胜。 出自《战国策·齐五策》。 折节下士 意思是屈己下人，尊重有见识有能力的人。 出自《三国志·魏志·袁绍传》：“绍有姿貌威容，能折节下士，士多附之，太祖少与交焉。” 折节向学 是指改变旧习，发愤读书。 出自《后汉书·段颎传》。 辙乱旗靡 zhé luàn qí mǐ，意思是车辙错乱，旗子倒下。形容军队溃败逃窜。 出自《左传·庄公十年》 crisscross chariot tracks and drooping banners—signs of an army in headlong flight 枕戈待旦/枕戈寝甲 枕流漱石 hěn liú shù shí，意思是指隐居生活。 出自《世说新语·排调》 赈贫贷乏 zhèn pín dài fá，意思是救济穷人。 出自 《新唐书·刘仁轨传》。 峥嵘轩峻 zhēng róng xuān jùn 出自《红楼梦》，解释为高大雄伟，很有气势。 清·曹雪芹《红楼梦》第二回：“大门前虽冷落无人，隔着围墙一望，里面厅殿楼阁，也还都峥嵘轩峻，就是后一带花园子里面树木山石，也还都有蓊蔚洇润之气，那里象个衰败之家 ?” 蒸食哀梨/哀梨蒸食 zhēng shí āi lí ，意思是比喻不辨东西好坏而随意糟蹋。 正本清源 根本上整顿，从源头上清理。比喻从根源上加以整顿清理。 出自《汉书·刑法志》。 正言不讳 指说话爽直，毫无忌讳。 出自《卜居》 正言直谏 以正义之语，规劝皇帝、上级、长辈或朋友。 出自 三国·魏·桓范《谏争》：“今正言直谏，则近死辱而远荣宠，人情何好焉，此乃欲忠于主耳 正颜厉色 形容板着脸，神情非常严厉。 出自《汉书·王莽传》。 郑人买履 有个郑国人因过于相信“尺度”，造成买不到鞋子的故事。揭示了郑人拘泥于教条心理，依赖数据的习惯。 这则寓言讽刺了那些墨守成规的教条主义者，说明因循守旧，不思变通，终将一事无成。 郑卫之音 指春秋战国时郑、卫等国的民间音乐，出自《礼记·乐记》。 decadent music；the music of the states of Zheng and Wei 政出多门 原意是政令出自几个卿大夫的门下；指中央领导软弱，国家权力分散。 出自《左传·成公十六年》。 支吾其词 指用含混的话搪塞应付，以掩盖真实情况。 出自《官场现形记》 只轮不反 zhi lun bu fan，意思是比喻全军覆没。 一匹马一只战车都未返回. 同“只轮无反”。 出自《西征赋》。 芝艾俱焚 芝艾同被烧毁；比喻好的坏的同归于尽。 出自《三国志·魏志·公孙度传》。 芝兰玉树 比喻有出息的子弟。 出自《晋书·谢安传》。 枝附影从 枝条附着树干，影子随从形体。比喻追随模访。 出自南朝·梁·刘勰《文心雕龙·杂文》。 知疼着热 zhī téng zháo rè，意思是对人十分关心爱护（多指亲人）。 出自 清·曹雪芹《红楼梦》第六十五回：“无奈二姐儿倒是个多情人，以为贾琏是终身之主了，凡事倒还知疼着热。” [1] 知往鉴今 知无不言言无不尽 知音识趣 指犹言知情识趣。 出自《初刻拍案惊奇》。 知足不辱 知道满足就不会欺辱自己的身体。 表示不要有贪心。 出自《老子》。 《老子》第四十四章：“知足不辱，知止不殆，可以长久。”《汉书·疏广传》：“吾闻知足不辱，知止不殆。” 《道德经》 第四十四章，“名与身孰亲？身与货孰多？得与亡孰病？甚爱必大费；多藏必厚亡。故知足不辱，知止不殆，可以长久”。 执鞭随蹬 手里拿着马鞭，跟在马镫旁边。比喻因敬仰而愿意追随在左右。 出自《论语·述而》 执两用中 zhí liǎng yòng zhōng，意思是指做事要根据不同情况，采取适宜的办法。 出自《礼记·中庸》。 执牛耳 直情径行 凭着自己的意思径直地去做。比喻想怎么干就怎么干。 出自《礼记·檀弓下》。 直言贾祸 指说话直率的人会惹祸。 出自 《左传·成公十五年》。 指不胜屈 zhǐ bù shèng qū，意思是扳着指头数也数不过来。形容为数很多。 出自 清·陈康祺《郎潜记闻》：“本朝大臣夺情任事者，指不胜屈。” 炙冰使燥 zhì bīng shǐ zào，意思是用火烤冰，想使它干燥，比喻事情办不到。 出自《抱朴子·刺骄》：“欲望萧雍济济，后生有武，是犹炙冰使燥，积灰令炽矣。” 治丝而棼 zhì sī ér fén ，意思是指理丝不找头绪，就会越理越乱。 比喻解决问题的方法不正确，使问题更加复杂。 出自《左传·隐公四年》。 栉风沐雨 zhì fēng mù yǔ，意思是大雨洗发，疾风梳头。后用以形容经常在外面奔波劳碌。 栉：梳头发。沐：洗头。 出自《庄子·天下》。 智尽能索 比喻智慧、办法、才能均已用尽。 出自 《史记·货殖列传》。 Wisdom all can all alone 智圆行方 圆：圆满，周全；方：端正，不苟且。 形容知识要广博周备，行事要方正不苟。大概意思为有雄才大志又品正方行实现德与才的结合。 出自《文子·微明》：“文子曰：凡人之道，心欲小，志欲大；智欲圆，行欲方。” 终南捷径 指求名利的最近便是门路。 出自《新唐书·卢藏用传》。 终天之恨 指到死的时候都清除不了的悔恨或不称心的事情。 出自 明·高则诚《琵琶记·一门旌奖》：“卑人空怀罔极之思，徒抱终天之恨。” 钟灵毓秀 钟鸣漏尽 暮钟已经敲完，漏水的壶也将滴完。比喻年老力衰，已到晚年。也指深夜。 出自 汉·崔寔《政论》：“钟鸣漏尽，洛阳城中，不得有行者。” be in one’s declining years 踵事增华 zhǒng shì zēng huá，意思是继续前人的事业，并使更加完善美好。 南朝·梁·萧统《文选序》：“盖踵其事而增华，变其本而加厉。物既有之，文亦宜然。” 众毛攒裘 zhòng máo cuán qiú，意思是聚集许多小块皮毛，能够缝成一件皮衣；比喻积少成多。 出自《西游记》。 众目昭彰 大家都看得很清楚。 出自《初刻拍案惊奇》。 众擎易举 zhòng qíng yì jǔ，意思是许多人一齐用力，容易把东西举起来。比喻大家同心协力就容易把事情办成。 出自明·张岱《募修岳鄂王祠姆疏》：“盖众擎易举，独力难支。” ####众星拱辰 比喻众人拥护，围绕着一个他们所敬仰的人。意同众星捧月。 拱：环绕，拱卫；辰：指北极星。天上众星拱卫北辰。旧指有德的国君在位，得到天下臣民的拥戴。后也比喻四方归向一处 舟中敌国 同船的人都可能成为敌人。比喻大家反对，十分孤立。 出自《史记·孙子吴起列传》。 吴起为魏国守西河。 有一次，魏武侯和吴起坐船顺西河而下，看着两岸壮观的景色，武侯对吴起说：“好啊!江山如此险固，真是我们魏国的福气！” 吴起说：“福气是由于道德高尚，而不是由于江山的险固。从前三苗部落住的地方左边有洞庭湖，右边有彭蠡湖，不修德义，被大禹消灭了。夏朝的桀住的地方，左边有河济，右边有泰华，南面有伊阙，北面有羊肠，不修仁政，被汤流放。 商朝的纣住在孟山的左边，太行山的右边，常山的北面，黄河的南面，不修德政，被周武王杀了。因此，高尚的道德比险固的江山更重要。如果君王不修德，同船上的人都可能成了敌人。”武侯说：“说得好！” 周而不比 意思是以公正之心对待天下众人，没有预定的成见及私心，不徇私护短。 周，圆周，合围合群。比，前后紧随，结党为奸。 出自《论语之为政篇》。 肘腋之忧/肘腋之患 zhǒu yè zhī yōu，意思是比喻产生于身边的祸患 出自《三国志·蜀志·法正传》 朱唇皓齿 朱紫难别 形容善恶不辨。 can not tell the good from the devil 出自 《三国志·蜀志·董允传》：“丞相亮将北伐，住汉中，虑后主富于春秋，朱紫难别，以允秉心公亮，欲任以宫省之事。” 诛不避贵 zhū bù bì guì，意思是惩治罪人没躲避富贵的人。 出自 《晏子春秋·内篇问上》：“诛不避贵，赏不遗贱；不淫于乐，不遁于哀；尽智导民，而不伐焉，劳力岁事，而不责焉。” 诛求无己 zhū qiú wú yǐ，意思是强行索取贪求，没完没了。 出自西汉·董仲舒《春秋繁露·王道》 诛心之论 指不问罪行，只根据其用心以认定罪状；也指揭穿动机的评论。 出自《后汉书·霍谞传》。 珠还合浦/合浦珠还 zhū huán hé pǔ 比喻东西失而复得或人去而复回。 出自《后汉书·循吏传·孟尝》。 珠辉玉映 指珍珠和美玉相互辉映 pearl and jade emitting resplendence bedeckedly 唐·徐寅《歌赋》：“斯赋之盛，珠辉玉映。可以发昏蒙，佐明圣。为前古之楷式，作後来之龟镜。非寡人之所知，敢不承天之命。” 珠围翠绕 zhū wéi cuì rào，珠：珍珠；翠：翡翠。 意思是形容妇女妆饰华丽。也形容富贵人家随侍的女子众多。 出自《误入桃源》。 珠玉在侧 比喻仪态俊秀的人在身边，出自《世说新语·容止》。 铢积寸累 zhū jī cùn lěi，意思是形容一点一滴地积累，也形容事物完成的不容易。 出自《侯鲭录》。 accumulate little by little;build up bit by bit 铢两悉称 zhū liǎng xī chèn，意思是形容两者轻重相当，丝毫不差。 出自《伪自由书·不通两种》。 exactly equal in weight；have the same weight 竹苞松茂 zhú bāo sōng mào，比喻家门兴盛。也用于祝人新屋落成。也多用于祝寿 出自《诗经·小雅·斯干》。 舳舻千里 zhú lú qiān lǐ，意思是船多，首尾相接，千里不绝。 出自《汉书·武帝纪》。 煮豆燃萁/助桀为虐/转祸为福 筑室道谋 zhù shì dào móu，比喻做事自己没有主见，缺乏计划，一会儿听这个，一会儿听那个，终于一事无成。 出自《诗经·小雅·小旻》。 追亡逐北 zhuī wáng zhú běi，意思是追击败走的敌军。 出自汉·贾谊《过秦论》。 锥处囊中 锥子放在口袋里，锥尖就会露出来。比喻有才能的人不会长久被埋没，终能显露头角。 出自《史记·平原君虞卿列传》。 real talent will finally be discovered 坠茵落溷 zhuì yīn luò hùn，意思是随风而落，有的飘在茵席上，有的落在粪坑里；比喻境遇好坏不同。 出自《梁书·儒林传·范缜传》。 惴惴不安 zhuì zhuì 形容因害怕或担心而不安。 出自《诗经·秦风·黄鸟》。 谆谆告诫 zhūn zhūn gào jiè，意思是恳切耐心地劝告。 出自 《诗经·大雅·抑》。 拙口钝腮/笨嘴笨腮 zhuō kǒu dùn sāi，意思是比喻嘴笨，没有口才。 出自《西游记》。 斫轮老手 zhuó lún lǎo shǒu，意思是用斫木制造车轮的行家。指对某种事情经验丰富的人。 出自《庄子·天道》。 齐桓公在堂上读书，轮扁在堂下砍削木材制作车轮，轮扁放下椎凿的工具走上堂来，问齐桓公说：“请问，公所读的是什么书呀？”桓公说：“是记载圣人之言的书。” 又问：“圣人还在吗？” 桓公说：“已经死去了。”轮扁说：“那么您所读的书不过是圣人留下的糟粕罢了。”桓公很生气的说：“我读书，你一个做轮子的匠人怎么能议论？说出道理就可以放过你，没有道理可说就要处死你。”轮扁说：“我是从我做的事情看出来的。砍削木材制作轮子，榫头做得过于宽缓，就会松动而不牢固，做得太紧了，又会滞涩而难以进入。我却能够做得不宽不紧，得心应手，口里说不出来其中的奥妙，但其中自有度数分寸在。我不能明白地告诉我的儿子，我儿子也不能从我这里得到做轮子的经验和方法，所以我已七十岁了，还在独自做车轮。古代人和他们所不能言传的东西都已一起死去了，所以您读的所谓圣人之书就只不过是古人留下的糟粕罢了！” 着手成春 zhuó shǒu chéng chūn，意思是一动手便有了春意。比喻诗人、画家才思高雅；也比喻医生医术高明。 着：接触；挨上 出自《诗品·自然》。 擢发难数/罄竹难书 趑趄不前 zī jū bù qián，趑趄迟疑不敢前进。 形容犹豫畏缩不敢前进。 出自《周易·夬》。 唐·韩愈《送李愿归盘谷序》：“足将进而趑趄，口将言而嗫嚅。” 自拔来归 拔：摆脱，离开。归，归降，投降。 指自觉离开恶劣环境，归向光明。指敌方人员投奔过来。 出自《新唐书·李绩传》：“自拔以归，从秦王伐东都，战有功。” 自出机杼/自出机轴 zì chū jī zhù ，比喻写文章能创造出新的风格和体裁。 出自《魏书·祖莹传》。 自郐以下 zì kuài yǐ xià，比喻从某某以下就不值得评论。 出自先秦·左丘明《左传·襄公二十九年》。 “自郐以下。无讥焉”，吴国的季札在鲁国看周代的乐舞，对于各诸侯国的乐曲都有评论，但从郐国以下他就没有再表示意见。比喻从某某以下就不值得评论。 亦省作“ 自郐 ”。 自相鱼肉 当作鱼肉一般任意宰割。指内部相互残杀 出自《晋书·刘元海载记》。 自以为得计 自以为计谋很对很好了（含贬义）。 唐·韩愈《柳子厚墓志铭》：“此宜禽兽夷狄所不忍为，而其人自视以为得计，闻子厚之风，亦可以少愧矣。” 唐宪宗时期，力图革新政治的王叔文遭到贬黜，柳宗元因此也被贬官。好友韩愈为柳宗元作《柳子厚墓志铭》，谈到人在困窘时才能显出气节道义，那些表面握手言欢似乎肝胆相照，背后却落井下石还自以为计，真是可悲。 自怨自艾 zì yuàn zì yì，意思是悔恨自己的错误，自己改正。现在只指悔恨自己的错误。 出自《孟子·万章上》。 字斟句酌 指写文章或说话时慎重细致，一字一句地推敲琢磨。 出自清·纪昀《阅微草堂笔记》。 Weigh every word 暴戾恣睢/暴戾恣睢 bào lì zì suī，形容凶残横暴，想怎么干就怎么干，出自《史记·伯夷列传》。 恣意妄为 zì yì wàng wéi，意思是随心所欲，胡作非为。 出自《清史稿·列传二·诸王一》 综核名实 zōng hé míng shí，意思是全面考核事物的称说是不是与实际相符。 出自《汉书·宣帝纪赞》 钻冰取火/钻冰求火 比喻徒劳无功。出自《全元散曲·普天乐·嘲风情》 罪不容诛 意思是罪恶极大，杀了也抵不了所犯的罪恶。 出自《汉书·游侠传序》。 even death cannot atone for the offense;be guilty of crimes for which even death is sufficient punishment 罪有攸归 罪责有所归属。指罪犯必受惩治。出自《封神演义》。 遵养时晦/遵时养晦 遵：遵循，按照；时：时势；晦：隐藏。 原为颂扬周武王顺应时势，退守待时。后多指暂时隐居，等待时机。 左辅右弼 zuǒ fǔ yòu bì，意思是比喻在左右辅助。 出自《晋书·潘尼传》：“左辅右弼，前疑后承。一日万机，业业兢兢。” 左支右绌， ，原指弯弓射箭的姿势，左手支持，右手屈曲。指力量不足，应付了这方面，那方面又出了问题 出自《战国策·西周策》。 坐视不救 见别人遇到困难或危险，坐在一旁看着不去援救。 出自明·罗贯中《三国演义》。 坐以待旦 坐着等天亮。多形容勤恳，也形容因心中烦躁或其他原因而无法入睡。 出自《尚书·太甲上》 sit up and wait for daybreak; remain a wake till dawn 番外 不啻天渊不啻(chi)：无异于。渊：深潭。 无异于从云天之上到深潭之底。比喻差别极大。 清·李渔《闲情偶寄·宾白第四》：“吴有吴音，越有越语，相去不啻天渊。” 白圭之玷 [bái guī zhī diàn] 白玉的斑点，喻完美中的缺憾。形容美好的人或事物存在的小缺点 诗经·大雅·抑:“白圭之玷，尚可磨也；斯言之玷，不可为也。” 示例: 也不过白圭之玷，并非晚节不终。 ———— 鲁迅《且介亭杂文末编关于太炎先生二三事》 唐·刘知几《史通·书事》(《通释》八)：范晔博采众书，裁成汉典，观其所取，颇有奇工。至于方术篇……言唯迂诞，事多诡越。可谓美玉之瑕，白圭之玷。借哉！ 又作[美玉之玷] 才贯二酉 cái guàn èr yǒu 形容读书甚多、学识渊博。 据《太平御览》卷四引《荆州记》裁：传说大酉、小酉(在今湖南沅陵县)二山藏书很多。 相传当年秦始皇“焚书坑儒”时，朝廷博士官伏胜冒着生命危险，从咸阳偷运出书简千余卷，辗转跋涉，藏于二酉洞中，使先秦文化典籍得以流传后世。成语“学富五车，书通二酉”出于此。这些书简在秦灭汉兴时献给汉高祖刘邦，刘邦在获得伏胜所献大量秦前书简时大喜，亲自将二酉藏书洞封为“文化圣洞”，将二酉山立为“天下名山”。从此后，二酉山二酉洞就成为天下圣迹，成为读书人毕生向往和追求的地方。以后历朝历代文人墨客，前往二酉拜谒更是络绎不绝，留下了大量的诗词文章。山上一度建院立阁，修堂造亭，香火旺盛。为纪念伏胜修建的伏胜宫和为保护二酉洞修建的藏书阁就是典型的建筑代表。在山半石洞下方，留有京师大学堂总监督即北京大学第四任校长、湖南督学使者张亨嘉于清光绪六年（1890年）二月所立的榜书碑刻“古藏书处”四个大字。 草间求活 形容只求眼前能马马虎虎活下去。 《世说新语笺疏》中卷上《方正》:王大将军既反，至石头，周伯仁往见之。谓周曰：“卿何以相负？”对曰：“公戎车犯正，下官忝率六军，而王师不振，以此负公。”南朝梁·刘孝标注引《晋阳秋》曰：“王敦既下，六军败绩。顗长史郝嘏及左右文武劝顗避难，顗曰：‘吾备位大臣，朝廷倾挠，岂可草间求活，投身胡虏邪？’乃与朝士诣敦，敦曰：‘近日战有余力不？’对曰：‘恨力不足，岂有余邪？’”","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"gomodifytags:好用的struct标签操作工具","date":"2016-04-16T13:04:14.000Z","path":"2016/04/16/gomodifytags-好用的struct标签操作工具/","text":"gomodifytags go get github.com/fatih/gomodifytags 对于 struct_demo.go: 123456789101112package maintype Server struct &#123; Name string Port int EnableLogs bool BaseDomain string Credentials struct &#123; Username string Password string &#125;&#125; 针对整个结构体进行操作 gomodifytags -file struct_demo.go(文件名) -struct Server(结构体名) -add-tags json -w (-w 是直接改写之前的结构体) 则会自动加上json标签: 123456789101112package maintype Server struct &#123; Name string `json:\"name\"` Port int `json:\"port\"` EnableLogs bool `json:\"enable_logs\"` BaseDomain string `json:\"base_domain\"` Credentials struct &#123; Username string `json:\"username\"` Password string `json:\"password\"` &#125; `json:\"credentials\"`&#125; 支持3种命名样式: snakecase: “BaseDomain” -&gt; “base_domain”,蛇形命名法 camelcase: “BaseDomain” -&gt; “baseDomain”,驼峰命名法 lispcase: “BaseDomain” -&gt; “base-domain” 如再给该结构体添加一个驼峰格式的xml标签,但不要直接改写,输出到命令行即可: gomodifytags -file demo.go -struct Server -add-tags xml -transform camelcase 123456789101112package maintype Server struct &#123; Name string `json:\"name\" xml:\"name\"` Port int `json:\"port\" xml:\"port\"` EnableLogs bool `json:\"enable_logs\" xml:\"enableLogs\"` BaseDomain string `json:\"base_domain\" xml:\"baseDomain\"` Credentials struct &#123; Username string `json:\"username\" xml:\"username\"` Password string `json:\"password\" xml:\"password\"` &#125; `json:\"credentials\" xml:\"credentials\"`&#125; 给结构体添加一个”validate:gt=1”和”scope:read-only”标签: gomodifytags -file struct_demo.go -struct Server -add-tags validate:gt=1,scope:read-only 123456789101112package maintype Server struct &#123; Name string `json:\"name\" validate:\"gt=1\" scope:\"read-only\"` Port int `json:\"port\" validate:\"gt=1\" scope:\"read-only\"` EnableLogs bool `json:\"enable_logs\" validate:\"gt=1\" scope:\"read-only\"` BaseDomain string `json:\"base_domain\" validate:\"gt=1\" scope:\"read-only\"` Credentials struct &#123; Username string `json:\"username\" validate:\"gt=1\" scope:\"read-only\"` Password string `json:\"password\" validate:\"gt=1\" scope:\"read-only\"` &#125; `json:\"credentials\" validate:\"gt=1\" scope:\"read-only\"`&#125; 给之前的json标签,在字段名后 添加一个”omitempty”,并直接改写: gomodifytags -file struct_demo.go -struct Server -add-tags json --add-options json=omitempty -w 123456789101112package maintype Server struct &#123; Name string `json:\"name,omitempty\"` Port int `json:\"port,omitempty\"` EnableLogs bool `json:\"enable_logs,omitempty\"` BaseDomain string `json:\"base_domain,omitempty\"` Credentials struct &#123; Username string `json:\"username,omitempty\"` Password string `json:\"password,omitempty\"` &#125; `json:\"credentials,omitempty\"`&#125; gomodifytags -file struct_demo.go -struct Server -remove-options json=omitempty 移除刚刚添加的omitempty: 123456789101112package maintype Server struct &#123; Name string `json:\"name\"` Port int `json:\"port\"` EnableLogs bool `json:\"enable_logs\"` BaseDomain string `json:\"base_domain\"` Credentials struct &#123; Username string `json:\"username\"` Password string `json:\"password\"` &#125; `json:\"credentials\"`&#125; 移除掉json标签: gomodifytags -file struct_demo.go -struct Server -remove-tags json 123456789101112package maintype Server struct &#123; Name string Port int EnableLogs bool BaseDomain string Credentials struct &#123; Username string Password string &#125; &#125; 移除掉所有标签: gomodifytags -file struct_demo.go -struct Server -clear-tags 移除所有标签的第一个值之后的所有内容, gomodifytags -file struct_demo.go -struct Server -clear-options -w 如对于 123456789101112package maintype Server struct &#123; Name string `json:\"name,omitempty\" xml:\"name,attr\"` Port int `json:\"port,omitempty\" xml:\"port,attr\"` EnableLogs bool `json:\"enable_logs,omitempty\" xml:\"enable_logs,attr\"` BaseDomain string `json:\"base_domain,omitempty\" xml:\"base_domain,attr\"` Credentials struct &#123; Username string `json:\"username,omitempty\" xml:\"username,attr\"` Password string `json:\"password,omitempty\" xml:\"password,attr\"` &#125; `json:\"credentials,omitempty\" xml:\"credentials,attr\"`&#125; 执行后变为: 123456789101112package maintype Server struct &#123; Name string `json:\"name\" xml:\"name\"` Port int `json:\"port\" xml:\"port\"` EnableLogs bool `json:\"enable_logs\" xml:\"enable_logs\"` BaseDomain string `json:\"base_domain\" xml:\"base_domain\"` Credentials struct &#123; Username string `json:\"username\" xml:\"username\"` Password string `json:\"password\" xml:\"password\"` &#125; `json:\"credentials\" xml:\"credentials\"`&#125; 针对结构体的某几行进行操作 gomodifytags -file struct_demo.go -line 8,11 -clear-tags json gomodifytags -file struct_demo.go -line 6,7 -remove-tags json gomodifytags -file struct_demo.go -line 2,7 -add-tags bson gomodifytags -file struct_demo.go -offset 100 -add-tags bson 这几个命令完全可以”望文生义”,无需解释.. 参考自 gomodifytags","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"go-callvis:极其好用的Go程序调用图生成工具","date":"2016-04-15T12:02:11.000Z","path":"2016/04/15/go-callvis-极其好用的Go程序调用图生成工具/","text":"接触一个新项目, 阅读官方库或第三方package,经常使用自带的go list命令或用depth包来查看其依赖了哪写包,如: go list 该命令后面的参数./下,必须包含.go文件. ./将列出当前目录下所有.go文件的依赖,也可以指定具体某个.go文件,如go list -json xxx.go 该参数既可以是指定的本地路径,也可以是本地go/src路径下安装的某个第三方package,也可以是官方库,如: 该命令无法列出github公开可访问,但本地没有的package的依赖,如: 返回值部分字段的解释: Imports 字符串切片（[]string）: 该代码包中的源码文件显式导入的依赖包的导入路径的列表。 Deps 字符串切片（[]string）: 所有的依赖包（包括间接依赖）的导入路径的列表。 只查看某个字段,可以加-f 双花括号 .字段名 双花括号命令 (需去掉-json参数),如: 更多参考 depth文档及安装 同样也可以查看go官方库的依赖: 查看本地go/src路径下已有的包: 可配合其-internal,-max,-explain target-package,-json等可选参数使用. go-callvis以上两个工具,都只能在命令行输出项目的依赖关系,希望能有更直观地图像方式. go-callvis这个包,完美解决了该需求~ 调用关系如下: 绿色是官方package 黄色是第三方package 美中不足是该工具要求指定目录下必须有main.go文件, 默认输出格式为svg,可以通过-format=png指定为需要的格式","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"开机过程","date":"2016-04-12T16:08:03.000Z","path":"2016/04/13/开机过程/","text":"阮一峰-计算机是如何启动的？阮一峰-Linux 的启动流程阮一峰-为什么主引导记录的内存地址是0x7C00？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"explore","slug":"explore","permalink":"http://www.dashen.tech/tags/explore/"}]},{"title":"Go测试","date":"2016-04-12T13:15:37.000Z","path":"2016/04/12/Go测试/","text":"简述: 测试分为单元测试（测试功能,Unit Test,简称UT）和基准测试（测试性能,Benchmark Test,简称BMT）。 对于xx.go文件, 使用xx_test.go作为其对应的测试文件. 1go test -v -run=\"指定函数名\" -v 表示冗余(verbose)输出\b,其实并不是一般理解的”可视化”(visualize) 单元测试: 对于单元测试,函数名以Test开头, 接收一个指针型参数（*testing.T） 基准测试: 基准测试以Benchmark开头, 接收一个指针型参数（*testing.B） 1go test -v -run=\"none\" -bench=. -run=”none”, 不允许单元测试, 运行所有基准测试. -bench 可以指定函数名, 支持正则. -benchmem 表示分配内存的次数和字节数. -benchtime=”3s” 表示持续3秒. 如: 123456789101112131415161718192021222324252627282930313233package mainimport ( \"strconv\" \"testing\")var stack *ItemStackfunc init() &#123; stack = NewStack()&#125;func Benchmark_Push(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; //fmt.Println(stack)&#125;func Benchmark_Pop(b *testing.B) &#123; b.StopTimer() //类似时间锁,在StopTimer()和StartTimer()之见的代码,不计入测量 for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping now := strconv.Itoa(i) stack.Push(\"test\" + now) &#125; b.StartTimer() for i := 0; i &lt; b.N; i++ &#123; //use b.N for looping stack.Pop() &#125;&#125; 379 ns/op 表示每次操作耗时379纳秒 130 B 表示每次操作 用了130字节(Byte) 2 allocs 表示每次操作分配2次内存 参考: go test命令（Go语言测试命令）完全攻略 golang 测试，单元测试和基准测试 译文 Go 高性能系列教程之一：基准测试","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"成语缀辑III","date":"2016-04-11T12:21:05.000Z","path":"2016/04/11/成语缀辑III/","text":"O 偶一为之 指平常很少这样做，偶尔才做一次。 出自 宋·欧阳修《纵囚论》：“若夫纵而来归而赦之，可偶一为之尔。” P 排斥异己 排沙简金 拨开沙子来挑选金子，比喻从大量的东西中选取精华。 出自 南朝宋·刘义庆《世说新语·文学》：“潘文烂若披锦，无处不善；陆文若排沙简金，往往见宝。” 盘根究底 外顺内悖 表面顺从,内心悖逆 盘石之安 指极其安定稳固 先秦·荀况《荀子·富国》：“为名者否，为利者否，为忿者否，则国安于盘石，寿于旗翼。” 判若天渊 wán 高低差别就象天空和深渊那样悬殊。 出自清·朱庭珍《筱园诗话》：“不过用心于一两字间，斟酌而出，即判若天渊，个中分寸所争，毫厘千里。” 庞眉皓发/尨眉皓发 páng méi hào fà，意思是眉发花白，形容老人相貌。 出自《贺乐器表》。 旁搜博采 是指广泛地搜集。 出自 宋·魏了翁《苏和父墓志铭》：“其始也，淹贯诸子百家，旁及老释二氏，旁搜博采，晚而敛博归约，落华就实。” 袍笏登场/喷薄欲出 烹龙炮凤 pēng lóng páo fèng，意思是形容菜肴极为丰盛、珍奇。 出自 唐·李贺《将进酒》：“琉璃钟，琥珀浓，小槽酒滴真珠红，烹龙炮凤玉脂泣，罗帏翠幕围春风。” 朋比为奸 蓬户瓮牖 蓬生麻中 比喻生活在好的环境里，也能成为好人。 出自 先秦·荀况《荀子·劝学》：“蓬生麻中，不扶而直；白沙在涅，与之俱黑。” 披肝沥胆 比喻真心相见，倾吐心里话。也形容非常忠诚。 出自 唐·黄滔《启裴侍郎》：“沾巾堕睫，沥胆披肝，不在他门，誓于死节。” Lay bare one’s heart 披麻救火 披着麻去救火。比喻惹火烧身，自招灾祸。 出自《赚蒯通》。 披发左衽 pī fà zuǒ rèn，意思是头发披散着,衣襟开在左边。古代指北方少数民族的装束。 含落后,不开化意 出自《论语·宪问》。 被褐怀玉 pī hè huái yù，意思是身穿粗布衣服而怀抱美玉。比喻虽是贫寒出身，但有真才实学。 出自《老子·德经·七十章》：“知我者希，则我者贵，是以圣人被褐怀玉。” 皮肤之见 指肤浅的见解。 出自宋·阮逸《&lt;文中子&gt;序》。 皮里阳秋 “阳秋”即“春秋。 意思是藏在心里不说出来的言论。意含褒贬。 出自《晋书·褚裒传》。 胸中褒贬，曰～。 ◎宋·胡继宗《书言故事·事物譬类》 南朝·宋·刘义庆《世说新语·赏誉》：“褚季野皮里阳秋，谓其裁中也。” 宋欧阳修《上胥学士偃启》：裹阳秋于皮里，不言备乎四时，吞云梦于胸中，兼容尽于一介。 清 龚自珍《调笑令》词：烹茗，烹茗，闲数东南流品。美人俊辩风生，皮里阳秋太明。 琵琶别抱 旧时比喻妇女改嫁。 出自《琵琶行》。 偏听偏信 片面地听了一方面的话就信以为真，多指处理事情的态度不公正。 出自 汉·王符《潜夫论·明暗》。 惘然若失 心情不舒畅，好像丢掉了什么东西似的。 出自《后汉书·黄宪传》 贫贱骄人 身处贫贱，但很自豪。指贫贱的人蔑视权贵。 出自《史记·魏世家》。 战国时期，魏文侯攻占中山国，派太子击去驻守。太子击在路上碰见了文侯的老师田子方就上前打招呼，田子方不予理睬。太子击问他是富贵还是贫贱值得骄傲，田子方认为贫贱应该骄傲，诸侯骄傲就失国，贫贱之士的意见不被采纳还可以到别国去。 贫嘴恶舌 牝鸡司晨 pìn jī sī chén，即母鸡报晓，旧时比喻妇女窃权乱政。 牝鸡司晨，惟家之索，成语，读音为“pìn jī sī chén，wéi jiā zhī suǒ”，意思是母鸡在清晨打鸣，这个家庭就要破败。 比喻女性掌权，颠倒阴阳，会导致家破国亡。出自《尚书·牧誓》 萍踪浪迹 是像浮萍、波浪一般的无定。比喻到处漂泊，没有固定的住所。 出自《牡丹亭》第二十出。 have no fixed abode because of constant traveling 破竹建瓴 pò zhú jiàn líng 势如破竹，高屋建瓴。比喻居高临下，所向无敌。 剖腹藏珠 pōu fù cáng zhū，意思是破开肚子把珍珠藏进去；比喻为物伤身，轻重颠倒。 出自《资治通鉴·唐纪·太宗贞观元年》。 put the trivial above the important 裒多益寡 póu duō yì guǎ，裒：减少。益：增加。意思是拿多余的一方，增加给缺少的一方； 比喻多接受别人的意见，弥补自己的不足。 出自《易·谦》。 铺张扬厉 过分讲究排场。 出自 唐·韩愈《潮州刺史谢上表》 keep up appearances and be wasteful; set forth and praise one’s merit and virtue – cut a dash Q 七颠八倒 形容十分凌乱。 出自宋·释道原 《景德传灯录》卷二十一：“问如何是佛法大师，师曰：‘七颠八倒。’” be all at sevens and eights；all upside down；be at sixes and sevens；in great confusion； 欺人之谈 骗人的鬼话。 出自清·李宝嘉《官场现形记》。 deceptive talk 齐东野语 孟子蔑视农民，认为他们说的话没有根据，听信不得。比喻荒唐而没有根据的话。 出自《孟子·万章上》。 骑马找马 乞哀告怜 乞浆得酒 比喻得到的超过所要求的。出自《史通 书志》 企踵可待 很快就可以等到。 出自宋·司马光《上皇帝疏》。 企足矫首 qǐ zú jiǎo shǒu 企足：踮起脚后跟；矫：通“翘”，举起。踮起脚跟抬起头。比喻殷切地盼望 杞人之忧/杞人之虑 气冲霄汉 形容魄力非常大，有大无畏的精神和气节。 出自《南齐书·高帝纪上》。 弃甲曳兵 qì jiǎ yè bīng，指丢弃盔甲，拖着兵器逃跑。形容打了败仗狼狈逃跑的样子。 出自《孟子·梁惠王上》。 弃如敝履 泣血捶膺 qì xuè chuí yīng，意思是悲痛到极点。 出自清·李宝嘉《官场现形记》。 契若金兰 qì ruò jīn lán，意思是比喻朋友交情深厚，民间俚语中也含有女同性恋的意思。 出自《易·系辞上》。 器小易盈/小器易盈 器小易盈，汉语成语，拼音是qì xiǎo yì yíng，意思是指酒量小。后比喻器量狭小，容易自满。 出自《在元城与魏太子笺》 千金买骨 出自《战国策·燕策一·燕昭王收破燕后即位》，说的是古代一位侍臣为君王买千里马，却只买了死马的骨头回来，君王大怒而不解，侍臣解释说，如果大家看见君王连千里马的骨头都肯用重金买回来，就会认为君王是真正想要高价买千里马，就会自然而然把千里马送上门来。后来果真如侍臣所言，不到一年就有几匹千里马被呈送上来。 故事流传至今，意指十分渴望和重视人才。 千夫所指 是为众人所指责，形容触犯众怒，出自《汉书·王嘉传》 铅刀一割 铅刀虽不锋利，偶尔用得得当，也能割断东西。 比喻才能平常的人有时也能有点用处。多作请求任用的谦词。 出自《后汉书·班超传》。 前倨后恭 qián jù hòu gōng ，意思是以前傲慢，后来恭敬。 形容对人的态度改变。 出自《战国策·秦策一》。 前门拒虎，后门进狼 比喻赶走了一个敌人，又来了一个敌人 钳口结舌 qián kǒu jié shé，意思是闭口不说话，形容理屈词穷说不出话来，也指慑于淫威不敢讲话。 出自《潜夫论》。 敲冰戛玉 qiāo bīng jiá yù，意思是声音清脆，宛如敲击玉石和冰块发出的声响。 出自 宋·杨无咎《垂丝钓·邓端友席上赠吕倩倩》词：“听敲冰戛玉，恨云怨雨，声声总在愁处。” 翘足引领 qiáo zú yǐn lǐng，意思是踮塌郐，伸长脖子。形容盼望殷切。 出自《檄吴将校部曲文》 翘首引领、翘首企足 巧立名目/切中时弊 窃据要津 qiè jù yào jīn，意思是比喻用阴谋手段占据重要的职位。 出自《向国民党的十点要求》 craftily seize key posts 窃位素餐 qiè wèi sù cān，意思是旧指高级官员饱食终日，无所用心，后也用作谦词。 出自《汉书·杨恽传》。 擒奸擿伏 qín jiān tī fú，意思是捉拿暴露的坏人，揭发隐伏的歹徒。 出自《太平广记》。 寝不安席 食不甘味/沁人心脾/轻歌曼舞 轻裘缓带 qīng qiú huǎn dài，意思是轻暖的皮袍。 出自《晋书·羊祜传》。 清·陈忱《水浒后传》: 乐和选十个彪形大汉，各带弓刀，自己轻裘缓带，骑着白马；到城门边，果然大开，昂然而入。 轻世傲物 藐视世俗，为人傲慢。 出自《彩毫记·宫禁生谗》。 轻嘴薄舌 倾盖如故 偶然结识的新朋友却像友谊深厚的旧交一样。 出自汉·邹阳《狱中上书自明》。 倾箱倒箧 qīng xiāng dào qiè，意思是把大小箱子里的东西都倒出来，比喻全部拿出来或彻底翻脸。 出自《世说新语·贤媛》。 穷而后工 旧时认为文人越是穷困不得志，诗文就写得越好。 出自《梅圣俞诗集序》。 穷年累月 形容接连不断，历时久远。 出自《荀子·荣辱》。 for years on end;year after year 穷酸饿醋 qióng suān è cù ，旧指比喻穷酸至极的文人 现指穷困而生活无着落的寒酸相。 出处为《西厢记》。 穷原竟委/穷源竟委 qióng yuán jìng wěi，比喻深入探求事物的始末，出自西汉·戴圣《礼记·学记》。 穷源溯流 原指逆流而上探寻河流的源头。现比喻探究和追溯事物的原由。 出自《燃灯记闻》。 秋风过耳 像秋风从耳边吹过一样。 比喻与自己无关，毫不在意。 出自汉·赵晔《吴越春秋·吴王寿梦传》。 曲突徙薪 qū tū xǐ xīn，意思是把烟囱改建成弯的，把灶旁的柴草搬走。 比喻事先采取措施，才能防止灾祸。 出自《汉书·霍光传》 《艺文类聚》卷八十引 汉·桓谭《新论》：“淳于髡至邻家，见其灶突之直而积薪在傍，谓曰：‘此且有火’，使为曲突而徙薪。邻家不听，后果焚其屋，邻家救火，乃灭。烹羊具酒谢救火者，不肯呼髠。智士讥之曰：‘曲突徙薪无恩泽，燋头烂额为上客。’盖伤其贱本而贵末也”。突，烟囱。又见《汉书·霍光传》、汉·刘向《说苑·权谋》。 唐·杜牧《李给事》诗之一：“曲突徙薪人不会，海边今作钓鱼翁。” 清·黄遵宪《福州大火行》：“曲突徙薪广恩泽，愿亟靖海安天骄。” 梁启超《读书后》：“曲突徙薪，不达而归。”亦作“ 曲突移薪 ”。 清·李渔《玉搔头·媲美》：“曲突移薪计未忠，焦头烂额敢居功。”亦省作“ 曲突 ”。 三国·魏·应璩《百一诗》：“曲突不见宾，焦头为上客。” 宋·王安石《吴正肃公挽辞》之二：“曲突非无验，方穿有不行。” 王闿运《愁霖赋》：“邑犬之吠兮众所怪也，曲突之早谋客之害也。” 屈高就下 地位高的人降低身分，迁就地位低的人。 出自《单刀会》。 取精用弘 qǔ jīng yòng hóng 指从所占有的丰富资料中吸取精华 却病延年 què bìng yán nián 祛除疾病，延长寿命。却，通“祛”，褪去、祛除的意思，延，延长的意思。 明·冯梦龙《东周列国志》 Vent disease and prolong life 却之不恭 指对别人的邀请、赠与等，如果拒绝接受，就显得不恭敬 鹊巢鸠居/占 群策群力 意思是大家共同想办法，一起出力。形容遇到问题时大家团结一致，共同出力想办法。 出自汉·扬雄《法言·重黎》。 群蚁附膻 qún yǐ fù shān，许多蚂蚁趋附羊肉。比喻许多臭味相投的人追求不好的事物。 出自《庄子·徐无鬼》。 R 让枣推梨 ràng zǎo tuī lí，指小儿推让食物的典故，比喻兄弟友爱。 让枣推梨，长罢欢愉之日。 ★《南史·梁武陵王传》 《南史·王泰传》：“年数岁时，祖母集诸孙侄，散枣栗于床。群儿竞之，泰独不取。” 《后汉书·孔融传》注引《融家传》：“年四岁时，每与诸兄共食梨，融辄引小者。” 饶有兴味 人稠物穰 rén chóu wù ráng，形容城市繁荣昌盛的景象。 出自元·胡用和《粉蝶儿·题金陵景》。 人命危浅 形容寿命不长，即将死亡。 出自《陈情表》。 人莫予毒 rén mò yú dú，意思是再也没有人怨恨我、伤害我了。形容劲敌被消灭后高兴的心情。 出自《左传·宣公十二年》。 人寿年丰 人长寿，年成也好；形容太平兴旺的景象。 出自《文选·潘岳&lt;藉田赋&gt;》。 人心如面 指人的心思像人的面貌一样，各不相同。 出自《左传·襄公三十一年》。 人心惟危 rén xīn wéi wēi，意思指人心险恶难测。 出自《书·大禹谟》：“人心惟危，道心惟微。” man’s heart is incomprehensible 忍辱含垢 目不暇给 mù bù xiá jǐ，意思指东西多，眼睛都看不过来。 出自《世说新语·言语》。 日就月将 rì jiù yuè jiāng，意思是每天有成就，每月有进步；形容精进不止；也日积月累。 出自《诗经·周颂·敬之》。 日以继夜/柔肠寸断肉眼凡夫 如臂使指 rú bì shǐ zhǐ，像胳膊支配手指那样。比喻指挥如意，没有牵制。 出自《汉书·贾谊传》。 如操左券 rú cāo zuǒ quàn，意思是很有把握。 出自姚雪垠《李自成》。 如坠五里雾中 如牛负重 意为牛负担着沉重的东西，比喻生活负担极重。 出自《中国社会各阶级的分析》。 如蚁附膻 rú yǐ fù shān，意思是许多臭味相投的人追求不好的事物。也比喻许多人依附有钱有势的人。 出自《庄子·徐无鬼》。 官之接西官，如鼠遇虎；商之媚西商，如蚁附膻。 ★清·梁启超《变法通议·论译书》 like ants clinging on the putrid carcass 入境问俗 指进入别的国家，先问明有哪些禁止的事及风俗习惯，以免违犯。 出自《礼记·曲礼上》。 软囊羞涩 枘圆凿方 ruì yuán záo fāng，比喻格格不入，不协调，出自宋玉《九辨》。 S 三亲六故/三亲六眷 三纸无驴/博士买驴 桑枢瓮牖/瓮牖绳枢 桑榆暮景 夕阳的余辉照在桑榆树梢上，指傍晚，比喻晚年的时光。 出自《赠白马王彪》。 搔首踟蹰 sāo shǒu chí chú，意思是形容心情焦急、惶恐或犹豫。 出自《诗经·邶风·静女》“爱而不见，搔首踟蹰。” 色厉内荏 表强硬，内心虚弱。 出自《论语·阳货》。 杀敌致果 勇敢杀敌，建立功勋 出自《左传·宣公二年》 山肴野蔌 shān yáo yě sù，意思是野味野菜。 出处宋·欧阳修《醉翁亭记》。 闪烁其词 善为说辞 意思是很会讲话，后指替人说好话。 出自《孟子·公孙丑上》。 缮甲治兵/缮甲厉兵 shàn jiǎ zhì bīng，意思是指做军事准备。 出自《诗·郑风·叔于田序》。 上勤下顺 指作领导的勤奋工作，下面的人就会顺从他的领导。 出自 唐·韩愈《郓州溪堂诗》：“惟所令之不亦顺乎，上勤下顺遂济登兹，不亦休乎。” 舍本逐末 涉笔成趣 形容一动笔就画出或写出很有意趣的东西。 栩栩如生 清·李汝珍《镜花缘》第一百回：“心有余闲，涉笔成趣，每于长夏余冬，灯前月夕，以文为戏，年复一年，编出这《镜花缘》一百回。” 身心交瘁 shēn xīn jiāo cuì，意思是身体衰弱，精神不振。 出自《金陵野史·谭鑫培的“绝唱”》。 深闭固拒 shēn bì gù jù，意思是形容坚决不接受别人的意见。 出自《拟进呈&lt;元史新编&gt;序》 深文周纳 shēn wén zhōu nà，意思是指苛刻地或歪曲地引用法律条文，把无罪的人定成有罪；也指不根据事实，牵强附会地给人硬加罪名。 出自《史记·酷吏列传》。 carefully framed-up argument or accusation 深中肯綮 hēn zhòng kěn qìng，意思是比喻分析深刻，能击中要害，或能说到点子上。 出自《庄子集释》。 肯綮，是指骨肉相连的地方，比喻最重要的关键。“技经肯綮之未尝”，即“未尝技经肯綮” ，形容这位庖丁的技艺高超。比喻分析深刻，能击中要害，或能说到点子上。 神色自若 审己度人 shěn jǐ duó rén，意思是先审查自己，再估量别人。 慎始慎终 事情从开始到结束都谨慎小心。 出自《战国策·秦策五》。 慎终如始 谨慎收尾，如同开始时一样。指始终要谨慎从事。 出自《老子》。 生而知之 意思是生下来就懂得知识和道理，出处《论语·述而》。 生荣死哀 指活着受人尊敬，死了使人哀痛。用以赞誉受人崇敬的死者。 出自《论语．子张》。 生死相依 生息蕃庶 shēng xī fán shù 指生养繁殖人口。 声价十倍 意思是名誉地位一下子大大增高。 出自唐·李白《与韩荆州书》。 one’s reputation is tenfold higher 声气相求 shēng qì xiāng qiú，指志同道合，意气相投。 声如洪钟/声色狗马 声色俱厉 shēng sè jù lì ，意思是说话时声音和脸色都很严厉。 出自《晋书·明帝纪》。 笙歌鼎沸 形容乐声歌声非常热闹。 出自《梦粱录·卷二·清明节》，《琵琶记·新进士宴杏园》。 绳床瓦灶 指简陋的生活用具。形容非常贫穷。 出自《红楼梦》第一回。 绳锯木断 用绳当锯子，也能把木头锯断。比喻力量虽小，只要坚持下去，事情就能成功。 出自《鹤林玉露》。 绳墨之言 可作为准绳、合乎道德圣智的言论。比喻合乎法律、规矩的言论。 出自《庄子·人间世》。 绳其祖武 踏着祖先的足迹继续前进，比喻继承祖业。 出自《诗经·大雅·下武》：“昭兹来许，绳其祖武。” 绳愆纠缪 shéng qiān jiū miù，意思是指改正过失，纠正错误。 圣经贤传 shèng jīng xián zhuàn，意思是儒家的经典著作和阐释这些经典的权威性著述 出处 唐韩愈《答殷侍御书》：“圣经贤传，屏而不省，要妙之义，无自而寻。” 盛暑祁寒 qi 形容气候条件恶劣的季节 师老兵疲/诗朋酒友 诗礼传家 谓以儒家经典及其道德规范世代相传。 出自 元·柯丹丘《荆钗记·会讲》：“诗礼传家忝儒裔，先君不幸早倾逝。” 狮子搏兔 shī zǐ bó tù，意思是比喻对小事情也非常重视、用出全部力量。 出自《谨严第一》。 not stint the strength of a lion in wrestling with a rabbit 施不望报 放惠于人而不望报答，指轻财仗义。 出自 《三国志·吴志·朱治传》裴松之注引《吴书》：“折节为恭，留意于宾客，轻财尚义，施不忘报。”。 施谋用智/施朱傅粉 施仁布德/施恩布德 释义为做善事，给人以恩德，出自元·无名氏《看钱奴》。 十步芳草 十步之内，就有芳香的花草。比喻处处都有人才。 出自汉·刘向《说苑·谈丛》。 十羊九牧 十头羊倒用九个人放牧；比喻官多民少，赋税剥削很重；也比喻使令不一，无所适从。 出自《隋书·杨尚希传》。 什袭珍藏 shí xí zhēn cáng，意思是将物品层层包裹，珍重地藏好。形容极珍重地收藏物品。 出自《太平御览》。 石枯松老 石头干裂，松树老朽，形容历时极久。 出自 金·丘处机《水龙吟·道运》词：“海移山变，石枯松老。” 时乖命舛/时乖命蹇 chuan / jian 意思是时运不好，命运不佳；这是唯心主义宿命论的观点。 出自 元·白朴《墙头马上》第二折：“早是抱闲怨，时乖运蹇。又添这害相思，月值年灾。” 实繁有徒 意思是实在有不少这样的人 出自 《书·仲虺之诰》：“简贤附势，实繁有徒。” 拾遗补缺/阙 捡取遗漏，弥补缺失。 食不重味 吃饭不用两道菜肴，谓饮食节俭， 出自 《左传哀公元年》 《韩非子·外储说左下》：“食不二味，坐不重席。” 清·石玉昆《小五义》第98回：“却安于节俭，茅茨不剪，采椽不斫，后宫妃妾，衣不重彩，～。” 食不下咽 意思是食物虽在口中但咽不下去，形容忧心忡忡，不思饮食。 出自《张中丞传后叙》。 唐·韩愈《张中丞传后叙》：“霁云（南霁云）慷慨语曰：‘云来时，睢阳之人不食月余日矣！云虽欲独食，义不忍；虽食，且不下咽。’” 明 焦竑《玉堂丛语．卷二．筹策》：且方出师而以招抚 为计，有血气者，宜痛心疾首而食不下咽也。 明 冯梦龙《东周列国志》第九十三回：“肥义思李兑之言，夜不能寐，食不下咽，展转踌躇，未得良策，乃谓近侍高信曰：‘今后若有召吾王者，必先告我。’” 清 李汝珍《镜花缘》八九回：无非因他而起，以致日积月累，弄的食不下咽，无药可医，如今后悔已晚。 清 李海观 《歧路灯》第二十回：“就是谭孝移在日，极隆重的朋友，席面也不曾如此华奢丰盛。其如盛公子食不下咽，也不觉刍豢悦口。” 欧阳山《苦斗》七三：这顿饭虽说也有鸡、鸭、鱼、肉，可是当伙计的都提心吊胆，食不下咽。 食毛践土 意思是吃的食物和居住的土地都是国君所有。封建官吏用以表示感戴君主的恩德。 出自《左传·昭公七年》 食前方丈 意思是吃饭时面前一丈见方的地方摆满了食物。形容吃的阔气。 出自《孟子·尽心下》。 清·李宝嘉《文明小史》第五十七回：“见着老人家的食前方丈侍妾数百人的行径，不禁羡慕。” 元王实甫《西厢记》第一本楔子：“我想先夫在日，食前方丈，从者数百；今日至亲则这三四口儿，好生伤感人也呵！” 明 沉自徵 《鞭歌妓》：“老夫衰迈无能，食前方丈，侍妾数十人，当之有愧。” 清洪升《长生殿·献饭》：“寻常，进御大官，馔玉炊金，食前方丈，珍羞百味，犹兀自嫌他调和无当。” 食肉寝皮 食玉炊桂 指食品贵如玉石，燃料贵如桂木。比喻物价昂贵。 出自《战国策·楚策三》。 始乱终弃 世殊时异 shì shū shí yì，意思是指时代不同了，出自《又报孙权书》。 三国·魏·曹丕《又报孙权书》：“又前都尉浩周劝君遣子，乃实朝臣交谋，以此卜君，君果有辞，外引隗嚣遣子不终，内喻窦融守忠而已，世殊时异，人各有心。” 视如敝履/视若无睹 视为畏途 看成可怕的、危险的道路。也比喻看成困难的、可怕的事情。 出自《庄子·达生》 春秋时期，周威公与田开元谈论养生之道，田开元举出鲁国单豹与张毅两人养生的例子，强调要注意文化修养。庄子知道后感慨道：有人听说前面杀了人，于是视为畏途，告诫全家带上刀结伴而行是明智之举，纵情声色享受比杀人还可怕 拭面容言 接受别人的批评，正确对待自己的错误的意思 拭：擦；拭面：擦去别人吐在自己脸上的唾沫；容言：听取别人意见。泛指接受别人的批评，正确对待自己的错误。 出自 明·冯梦龙《东周列国志》第四十五回：“妇人轻丧武夫功，先轸当时怒气冲，拭面容言无愠意，方知嗣伯属襄公。” 【反义词】拒谏饰非 恃才矜己 shì cái jīn jǐ，意思是自恃有才，骄矜自负。 出自《隋书·炀帝纪下》：“恃才矜己，傲狠明德，内怀险躁，外示凝简，盛冠服以饰其奸，除谏官以掩其过。” 恃强凌弱 室迩人远/遐 shì ěr rén yuǎn，室：房屋；迩：近。 意思是房屋就在近处，可是房屋的主人却离得远了。多用于思念远别的人或悼念死者。 出自《诗经·郑风·东门之潬》：“其室则迩，其人甚远。” Room near person is far 室怒市色 意思是指在家里受气，到外边迁怒于人。 出自《左传·昭公十九年》。 室如悬磬 shì rú xuán qìng，意思是屋里就像挂着石磬一样。 形容穷得什么也没有。 出自《国语·鲁语上》：“室如悬磬，野无青草，何恃而不恐。” 舐糠及米 shì kāng jí mǐ，意思是舔米外的糠，一直舔到里面的米，比喻占据的地方再夺取政权，也比喻由表及里，逐步进逼。 出自《史记·吴王濞列传》。 西汉时期，各诸侯国不听中央的号令，各自为政，御史大夫晁错建议汉景帝削减各诸侯国的领地，把权力收归中央。实力最大的吴王刘濞野心勃勃地对其他诸侯国王说削减领地就像舐糠及米一样，号召其他六国起来反抗，历史上称七国之乱。 舐皮论骨 shì pí lùn gǔ，意思是比喻只看到一点表面现象就妄加评论。 出自《华盖集续编的续编·海上通信》。 噬脐莫及 shì qí mò jí，意思是像咬自己肚脐似的，够不着。比喻后悔也来不及。 出自《左传·庄公六年》。 春秋时期（公元前688年），楚文王向邓国借道攻打南申国，邓国的国王邓祁侯是楚文王的舅舅，他亲自迎接楚文王，他的大臣骓甥、聃甥和养甥要他提防这个外甥，可邓祁侯不听，让楚文王攻打南申国，可等他灭了南申国后回师途中就进灭邓国，邓祁侯真是后悔莫及。 守望相助 shǒu wàng xiāng zhù，意思是为了对付来犯的敌人或意外的灾祸，邻近各村落互相警戒，互相援助。 出自《孟子·滕文公上》。 守正不阿 shǒu zhèng bù ē ，正：公正；阿：偏袒。意思是形容处理事情公平正直，不讲情面。 出自《汉书·刘向传》。 首善之地/首善之区 意思是最好的地方；指首都。出自《汉书·儒林传序》。 首尾乖互 shŏu wĕi guāi hù，意思是比喻前后自相矛盾。 出自《宋书·徐谌之传》：“赍传之信，无有主名，所征之人，又已死没，首尾乖互，自为矛盾。” 寿陵失步 shòu líng shī bù，意思是比喻仿效不成，反而丧失了固有技能。 出自战国·宋·庄周《庄子·秋水》：“且子独不闻夫寿陵馀子之学行於邯郸与？未得国能，又失其故行矣，直匍匐而归耳。” 同“邯郸学步” 战国时期，赵国国都邯郸人走路姿势非常优美与潇洒，外地人很赞赏和羡慕。燕国寿陵一个少年，特别迷恋邯郸人走路的姿态，竟专门到邯郸学习，他非常用心观摩、效仿、练习，过了一段时间，他没学会他们走路的姿态，连自己的也全忘了 寿享期颐 shòu xiǎng qī yí，意思是享有百岁的寿命。 兽聚鸟散 像鸟兽一样时聚时散。比喻聚散无常。也比喻乌合之众。 出自《史记·平津侯主父列传》 书不尽意 意思是指文辞难充分达意。后多作书信结尾习用语。 出自《北齐书·文苑传·祖鸿勋》， 书剑飘零 本指做官或从军，离乡背井，飘流在外；后指因求取功名而出门在外、久游未归。 出自 元·王实甫《西厢记》一本一折：“小生书剑飘零，功名未遂，游于四方。” 书通二酉 shū tōng èr yǒu，意思是比喻读书甚多，学识丰富精湛。 出自《太平御览》卷四九引南朝·宋·盛弘之《荆州记》：“小酉山上石穴中有书千卷，相传秦人于此而学，因留之。” 相传当年秦始皇“焚书坑儒”时，朝廷博士官伏胜冒着生命危险，从咸阳偷运出书简千余卷，辗转跋涉，藏于二酉洞中，使先秦文化典籍得以流传后世。成语“学富五车，书通二酉”出于此。这些书简在秦灭汉兴时献给汉高祖刘邦，刘邦在获得伏胜所献大量秦前书简时大喜，亲自将二酉藏书洞封为“文化圣洞”，将二酉山立为“天下名山”。从此后，二酉山二酉洞就成为天下圣迹，成为读书人毕生向往和追求的地方。以后历朝历代文人墨客，前往二酉拜谒更是络绎不绝，留下了大量的诗词文章。山上一度建院立阁，修堂造亭，香火旺盛。为纪念伏胜修建的伏胜宫和为保护二酉洞修建的藏书阁就是典型的建筑代表。在山半石洞下方，留有京师大学堂总监督即北京大学第四任校长、湖南督学使者张亨嘉于清光绪六年（1890年）二月所立的榜书碑刻“古藏书处”四个大字。 菽水承欢 shū shuǐ chéng huān，意思指奉养父母，使父母欢乐。出自《礼记·檀弓下》。 菽水：豆和水，指普通饮食；承欢：侍奉父母使其欢喜。 《礼记注疏》卷十《檀弓》子路曰：“伤哉贫也。生无以为养，死无以为礼也。”孔子曰：“啜菽饮水，尽其欢，斯之谓孝。敛手足形，还葬而无椁，称其财。斯之谓礼。”汉·郑玄注：“王云：熬豆而食曰啜菽。”唐·孔颖达疏：“谓使亲尽其欢乐此之谓孝” 唐李商隐《李义山文集·祭韩氏老姑文》：“弓裘望袭，菽水承欢。” 宋陆游《湖堤暮归》诗：“俗孝家家供菽水，农勤处处筑陂塘。” 明 高明 《琵琶记·高堂称寿》：“入则孝，出则弟，怎离白发之双亲？到不如尽菽水之欢，甘齏盐之分。” 《群音类选·&lt;祝发记·分食寄姑&gt;》：“慈帏恩爱成抛闪，怎能够菽水承欢。” 清吴敬梓《儒林外史》第八回：“晚生只愿家君早归田里，得菽水承欢，这是人生至乐之事。” 郁达夫《再游高庄偶感续成》诗：“只愁母老羣儿幼，菽水蒲编供不周。” 输肝剖胆 shū gān pōu dǎn，意思是比喻诚心待人。 出自 唐·李白《行路难》诗：“君不见昔时燕家重郭隗，拥篲折腰无嫌猜，剧辛、乐毅感恩分，输肝剖胆效英才。” 蜀犬吠日/粤犬吠雪 鼠窃狗偷 shǔ qiè gǒu tōu，意思是象老鼠少量窃取，象狗钻油偷盗。指小偷小摸。 出自《史记·刘敬书孙通列传》：“此特群盗鼠窃狗盗尔，何足置之齿牙间。” 鼠牙雀角 意思是因为强暴者的欺凌而引起争讼。后比喻打官司的事。 出自《诗·召南·行露》。 《诗·召南·行露》：“谁谓雀无角，何以穿我屋？谁谓女无家，何以速我狱……谁谓鼠无牙，何以穿我墉？谁谓女无家，何以速我讼？” 原意是因为强暴者的欺凌而引起争讼。也比喻强暴势力 明·许自昌《水浒记·分飞》：“鼠牙雀角甚纵横，全仗你力周旋，这死生肉骨感何穷。指讼事或引起争讼的细微小事。 比喻打官司的事 宋·刘克庄《乙丑生日回启·莆田仙游两宰》：“万口诵龙筯凤髓之判，片言折鼠牙雀角之争。” 清·归庄《陈君墓表》：“君为人长厚有信义，里中人皆从而辨曲直，有鼠牙雀角之讼，往往以君一言而解。” 清·徐瑶《太恨生传》：“甘为奸人所卖，诚欲以礼相终始也。鼠牙雀角，适足增羞，抑岂令卖菜佣持我短长乎？” 清·严如熤《三省边防备览》：“ 川楚民情，本自好事，加以光棍包揽教唆，鼠牙雀角，便成讼端。” 清·《幼学琼林卷四．讼狱类 》：“与人构讼，曰鼠牙雀角之争；罪人诉冤，有抢天吁地之惨。” 数黑论黄意思是背后乱加评论，肆意诽谤别人。 出自 元·杨文奎《儿女团圆》第一折：“你入门来便闹起，有甚的论黄数黑。” 元末明初·罗贯中《三国演义》第四十三回 诸葛亮舌战群儒 鲁子敬力排众议：“……岂亦效书生，区区于笔砚之间，数黑论黄，舞文弄墨而已乎？” 那喫敲才怕不口里嚼蛆，那厮待～，恶紫夺珠。 ★元·王实甫《西厢记》第五本第四折 元．无名氏《千里独行．第四折》：「他那里说短论长，数黑论黄，断不了村沙莽撞，你心中自忖量。」 束马悬车 把马脚裹起来，把车吊上山去，形容走山路的艰险情况。 出自春秋·齐·管仲《管子·封禅》。 束身自修 意思是约束自己，不与坏人坏事同流合污。 出自《后汉书·卓茂传》：“[光武帝]乃下诏曰：‘前密令卓茂，束身自修，执节淳固，诚能为人所不能为。’” 述而不作 意思是指只叙述和阐明前人的学说，自己不创作。 出自《论语·述而》。 恕己及人/恕己及物 指以恕己之心恕人，像原谅自己一样原谅别人。 对别人就像对自己一样宽恕。 晋·葛洪《抱朴子·至理》：“慈心于物，恕己及人。” 宋·曾巩《节相制》：“束发修身，有恕己及人之志；历官行事，有承流宣化之勤。” 率尔操觚 shuài ěr cāo gū，原形容文思敏捷，后指没有慎重考虑，轻率地写。 出自 晋·陆机《文赋》：“或操觚以率尔，或含毫而邈然。” 率尔成章 意思是不加思索，下笔成文；形容写文章粗疏草率，不认真。 出自《唐语林·文学》。 宋·王谠《唐语林·文学》：“诗云：‘书后欲题三百颗，洞庭须待满林霜。’后人多说率尔成章，不知江左尝有人于纸尾寄洞庭霜三百颗。” [白居易]又有句云：‘回首语秋光，东来应不错。’人谓先生率尔成章，予谓先生的然有理。 ◎宋·胡仔《苕溪渔隐丛话后集·醉吟先生》 率土归心 意思指天下归心，同“率土宅心”。 出自《北齐书・文宣帝纪》：“故百僚师师，朝无秕政，网疏泽洽，率土归心。” 率由旧章 意思是一切按照老规矩办事。 出自 《诗经·大雅·假乐》：“不愆不忘，率由旧章。” 爽然若失 形容心中无主、空虚怅惘的神态。 出自 《史记·屈原贾生列传》：“读《鵩鸟赋》，同生死，轻去就，又爽然自失矣。” 《野叟暴言》第七十四回：“戴、刘二人俱爽然若失，愧谢自责，玉麟等亦俱豁然心服。” 叶圣陶《倪焕之》一九：“几天来国内的空气荡漾的厉害，蒋冰如自然也感觉震动；又听焕之这样说，对于他自己专办学校不问其他的信念，不禁爽然若失。” 那风，直扑到我怀里，一路疾苦，简直爽然若失了。 毕业大家自然都盼望的，但一到毕业，却又有些～。 ◎鲁迅《朝花夕拾·琐记》 原本到手的胜利又飞了，大家不觉爽然若失。 水陆毕陈 意思是各种山珍海味全都陈列出来。形容菜肴丰富。 出自 唐·白居易《轻肥》诗：“尊罍溢九酝，水陆罗八珍。”。 光禄寺排设筵宴，水陆毕陈，笙簧迭奏。 ★清·陈忱《水浒后传》第四十回 both land and sea food mixed together 西晋时期，荆州刺史石崇靠抢劫外地商人而积累了万贯家财，他在京城做卫尉，大肆挥霍。晋武帝的舅舅王恺想办法与石崇比富。王恺得到一株珊瑚十分得意，拿到石崇家。石崇拿出水陆毕陈的宝物送给王恺。王恺自叹不如。 水米无交 意思指没有吃过别人一点东西；比喻为官清廉，不妄取民物；也比喻双方毫无往来。 出自《谢天香》。 吮痈舐痔 shǔn yōng shì zhì，意思是只为人舔吸疮痔上的脓血。比喻卑劣地奉承人。 出自《庄子·列御寇》。 秦王有病召医，破痈溃座者得车一乘；舐痔者得车五乘。所治愈下，得车愈多。 《庄子·杂篇·列御寇》 《史记·佞幸列传》：“ 文帝 尝病痈， 邓通 常为帝唶吮之。”后遂以“吮痈舐痔”形容卑屈媚上的龌龊行为。 南朝宋鲍照《瓜步山楬文》：贩交买名之薄，吮癕舐痔之卑，安足议其是非！ 宋苏轼《渔樵闲话录》下篇：苟於进取以速利禄，吮疽舐痔无所不为者，非伥鬼欤？ 明王世贞《鸣凤记·严嵩庆寿》：附势趋权，不辞吮痈舐痔。 清梁绍壬《两般秋雨盦随笔·阮大铖祭文》：效吮痈舐痔之行，媚衔宪握爵之人。 （literal） to suck the ulcers and piles of another person to play the lickboot; to be bootlicker sycophancy 硕大无朋 意思是指大得没有可以与之相比的。形容极大。 出自《诗经·唐风·椒聊》：“椒聊之实，蕃衍盈升。彼其之子，硕大无朋。” gigantic 形容槁木 shuò bǐ xún jiē 搠笔：插着毛笔；巡街：在大街上走。 指贫穷的文人在街上卖诗文。 丝恩发怨 sī ēn fà yuàn，形容极细小的恩怨。 出处 《资治通鉴·唐纪·文宗太和九年》：“是时李训、郑注连逐三相，威震天下。于是平生丝恩发怨无不报者。” 丝来线去 比喻纠缠连挂 出处 宋·圆悟禅师《碧岩录》卷三：“~，一放一收。” 例句 宋·朱熹《朱子全书·论语》：“但颜子得圣人说一句，直是倾肠倒肚是了，更无许多廉纤缠绕，丝来线去。” 斯事体大 这件事性质重要，关系重大。 武王克殷，至周公相成王，始制礼乐。斯事体大，不可速成。 ★《隋书·音乐志中》 四海鼎沸 意思是形容天下大乱，出自 《晋书·祖逖传》：“若四海鼎沸，豪杰并起，吾与足下，当相避于中原耳。”” 四马攒蹄 sì mǎ cuán tí，意思是指两手两脚被捆在一起。 出自 明·吴承恩《西游记》第七十五回：“叫：‘小的们，拿绳来！’众头目即取绳索。三怪把行者扳翻倒，四马攒蹄捆住，揭起衣裳看时，足足是个弼马温。” Hands and feet are tied together 四体不勤 五谷不分 丈人曰：‘四体不勤，五谷不分，孰为夫子？’ 《论语·微子》 【解释】四体：指人的两手两足；五谷：通常指稻、黍、稷、麦、菽。 指不参加劳动，不能辨别五谷。形容脱离生产劳动，缺乏生产知识。 驷不及舌 sì bù jí shé，释义：一句话说出口，四匹马拉的车也追不回；比喻一句话说出来，再也无法收回。 《论语·颜渊》：“夫子之说君子也，驷不及舌。” 宋 岳珂 《桯史·爱莫助之图》：“﹝ 洵武 ﹞自度清议必弗贷，且有驷不及舌之虑，惧 文定 知之，未知所以回天者，忧形于色。” 元 陶宗仪《南村辍耕录．卷一四．四卦》：次三，驷不及舌，有悔。象曰：驷不及舌，滕口说也，一言之失，悔何追也。 明·东鲁古狂生《醉醒石》第十二回：酒自外入，机繇内泄。悔从醒生，驷不及舌。 清 和邦额《夜谭随录 猫怪三则》：“今偶脱于口，驷不及舌，悔亦何及。” 鲁迅 《忆刘半农君》：我那时还以老朋友自居，在序文上说了几句老实话，事后，才知道半农颇不高兴了，“驷不及舌”，也没有法子。 俟河之清 sì hé zhī qīng，等待黄河变清。比喻期望的事情不能实现。 出自《左传·襄公八年》：“《周诗》有之曰：‘俟河之清，人寿几何？’” 肆奸植党 放肆胡为，培植党羽势力。 出自《明史·冯恩传》。 肆行无忌 意思是恣意横行，无所顾忌。 出自《明史·石亨传》。 松柏之茂 意思是松柏的枝叶繁茂常青，经冬不凋。比喻长久不衰，经得起考验。 出自《诗经·小雅·天宝》：“如松柏之茂，无不尔或承。” 松筠之节 sōng yún zhī jié，意思是松与竹材质坚韧，岁寒不凋，因以“松筠之节”比喻坚贞的节操。 筠，竹。 出自《隋书·柳庄传》。 颂古非今 意思是指不加分析地颂扬古代的，否定现代的，出自《史记·秦始皇本纪》。 搜索枯肠 形容动脑筋极力思索（多指写诗文）。 出自唐·卢仝《走笔谢孟谏议寄新茶》诗：“三椀搜枯肠，唯有文字五千卷。” think hard 夙心往志 指平素的心愿，以往的志向。 出自《魏书·列女传》。 夙兴夜寐 宿将旧卒 意思是指久经战争的将领和士兵。 出自 三国·魏·曹植《求自试表》：“虽贤不乏世，宿将旧卒，犹习战也。” 宿学旧儒 意思为指老成博学的读书人。 出自 宋·胡仔《苕溪隐丛话前集·西昆体》：“老杜诗既为世所重，宿学旧儒犹不肯深与之。” 溯本求源 意思是追寻根本，探求起源，比喻寻根究底。 出自宋·周密《齐东野语·道学》：“其能发明先贤旨意，溯流徂源，论著讲介卓然自为一家者，惟广汉张氏敬夫、东莱吕氏伯恭、新安朱氏元晦而已。” Tracing the origin 酸文假醋 形容装出一副文雅有礼貌的样子。 出自《东篱赏菊》。 算无遗策 形容策划精密准确，从来没有失算。 出自 三国魏·曹植《王仲宣诔》：“算无遗策，画无失理。” 宋元君夜半而梦人被发窥阿门，曰：“予自宰路之渊，予为清江使河伯之所，渔者余且得予。”元君觉，使人占之，曰：“此神龟也。”君曰：“渔者有余且乎？”左右曰：“有”。君曰：“令余且会朝。”明日，余且朝。君曰：“渔何得？”对曰：“且之网得白龟焉，其圆五尺。”君曰：“献若之龟。”龟至，君再欲杀之，再欲活之，心疑，卜之，曰“杀龟以卜，吉。”乃刳龟以卜，七十二钻而无遗筴。仲尼曰：“神龟能见梦于元君，而不能避余且之网；知能七十二钻而无遗筴，不能避刳肠之患。如是，则知有所困，神有所不及也。虽有至知，万人谋之。鱼不畏网而畏鹈鹕。去小知而大知明，去善而自善矣。婴儿生无硕师而能言，与能言者处也。”画无失理也当出于《庄子·宋元君将画图》 隋侯之珠 比喻珍贵之物 在我国灿烂辉煌的古代历史上，有两件齐名天下、为历代帝王所必争的宝物，那就是和氏之壁与隋侯之珠。《韩非子》中关于这两件宝物有详尽的记载：“和氏之壁，不饰以五采；隋侯之珠，不饰以银黄，其质其美，物不足以饰。” 《吕氏春秋·贯生篇》则用“隋珠弹雀”来比喻大材小用的道理：“今有人以隋侯之珠弹千仞之雀，是何也？”每一种美好的事物，都伴随着一个动人的故事，和氏之壁与隋侯之珠也不例外。 关于和氏之壁的典故，人们或许已耳熟能详，而有关隋侯之珠的美丽传说，则知之甚少。 随俗浮沉 意思是自己没有一定的想法，随着潮流走。 出自 汉·司马迁《报任少卿书》：“故且从俗浮沉，与时俯仰，以通其狂惑。” 隋珠弹雀 suí zhū tán què，意思是用夜明珠去弹鸟雀。 比喻得不偿失。 出自《庄子·让王》。 明·冯梦龙《东周列国志》第一回：”犬彘何须辱剑铓？隋珠弹雀总堪伤！“ 晋 葛洪 《抱朴子·嘉遯》：“道存则尊，德胜则贵； 隋珠弹雀，知者不为。” 明 张居正《与南台长言中不干外政》：“ 隋珠弹雀，羣虎捕羊，殊可笑也。” 鲁哀公听说颜阖非常贤明，就派人给他送礼物请他出山。贫穷的颜阖不受。庄子就此事发表感慨，颜阖无意于富贵，富资送上门，他不欢迎。这样的人难得。而那些不惜牺牲生命去追求富贵就如同“以隋侯之珠，弹千仞之雀”一样不值得 岁丰年稔 suì fēng nián rěn，意思是指农业丰收。 出自《上宰相书》。 岁寒松柏 岁月不居 意思指时光流逝，用于感慨等 出自 汉·孔融《论盛孝章书》：“岁月不居，时节如流，五十之年，忽焉已至。” Time and tide wait for no man 所费不赀 suǒ fèi bù zī，意思是花费的钱财不计其数。 出自 宋·苏辙《乞诛窜吕惠卿状》：“惠卿张皇其数，牒转运司交割，妄言可罢馈运，其实所费不赀而无丝毫之利。 T 他山攻错 比喻拿别人的长处，补救自己的短处。 出自《诗经·小雅·鹤鸣》。 advice from others may help one to overcome one’s short comings as stones from other hills may serve to polish the jade of this mountain 太仓一粟/沧海一粟 泰极生否 tài jí shēng pǐ，意思是指事物在顺利到了极点时，就会产生不顺利的情况。 比喻乐极生悲。出自《周易·泰》。 泰山可倚 有如泰山一样可以倚靠。形容有强有力的靠山。 出自清·郑志鸿《常语寻源》。 唐玄宗李隆基十分宠爱杨贵妃，她的族兄杨国忠被任命为宰相，官吏们纷纷投靠杨国忠。有人劝说陕西进士张彖去投靠杨国忠，张彖说：“杨国忠不是泰山可倚，只不过是一座冰山，总有一天会化掉的。”就去嵩山隐居了。 贪多务得 原指学习上务求尽多地获得知识，后泛指对其他事物贪多并务求取得。 出自《进学解》 唐·韩愈《进学解》：“贪多务得，细大不捐。” 韩愈24岁中进士到京城长安做官，他在官场不得志，45岁时被贬回长安任国子监博士。他给学生讲课旁征博引，出口成章，很有欢迎。他在《进学解》中强调：“业精于勤荒于嬉，行成于思毁于随。”对待学业不能贪多务得。 清·方宗诚《〈古文简要〉序》：“而泛观古人之文则又博而寡要，且惧夫贪多务得而遂溺于文。” 《剪灯新话·申阳洞记》：“因乏药材，入山采拾，贪多务得，进不知止，不觉失足，误坠於斯，触冒尊灵，乞垂宽宥。” 孙犁《读冉淮舟近作散文》：“不要急于求成，不要贪多务得。” 郭沫若《洪波曲》一三章：“敌人是好大喜功，贪多务得的。” 贪贿无艺 意思是指反动的统治阶级无限制地搜刮民财。 出自《国语·晋语八》。 春秋时期，晋国人叔向去拜访卿韩宣子。韩宣子说他名义上是卿而实际上财富很少，叔向向他祝贺，他感到奇怪。叔向说以前栾武子做上卿时家里只有一个仆人和百十顷田，人们都尊敬他，而他的儿子继卿位贪财受贿，差一点招来杀身之祸。 贪天之功 把天所成就的功绩说成是自己的力量；现指抹杀群众或领导的力量，把功劳归于自己。 出自《左传·僖公二十四年》。 晋国公子重耳流亡19年后重新回国执政，成为晋文公。他对跟随他流亡的人论功行赏。唯独把割大腿肉熬汤给他喝的介子推给忘了。介子推很有气节，他称病回家隐居，侍奉老母，靠编草鞋为生，他认为那些受到奖赏的人是在贪上天的功劳。 谈辞如云 指谈话时言辞如飘云那样奔涌而出。 东汉时期，为官清廉的李膺从青州刺史做到乌桓校尉、长乐少府等，他疾恶如仇，惩治贪官绝不手软，很多士大夫们想结识他，得到他的接纳就是登龙门。符融去拜见李膺，双方谈得十分投机，相见恨晚，谈辞如云，遂结为好友。 【同韵词】寸铁杀人、惜老怜贫、祸福之门、百世一人、精力过人、恕己及人、借尸还魂、眉黛青颦、湮灭无闻、麻痹不仁 谈何容易 谈笑封侯 意思是说笑之间就封了侯爵。旧时形容获得功名十分容易。 出自 唐·杜甫《复愁》 胡虏何曾盛，干戈不肯休。闾阎听小子，谈笑觅封侯。 谈言微中 形容说话委婉而中肯。 出自《史记·滑稽列传》。 秦朝善于歌舞的小矮人优旃，他很会说笑话，他所说的笑话中包含着大道理，往往都是切中要害的精辟之言，深得秦始皇的信任。一次秦始皇想扩大御花园。优旃风趣地说可以多养鹿，用鹿角去顶撞敌人。秦始皇觉得想法不妥就打消这念头。 弹铗无鱼 tán jiá wú yú，意思是指处境窘困，有求于人。 出自《战国策 齐策四》：“齐人有冯谖者，贫乏不能自存，使人属孟尝君，愿寄食门下……居有顷，倚柱弹其剑，歌曰：‘长铗归来乎，食无鱼！’” 战国时期，齐国孟尝君的门客有几千人，他把他们分为三等，上等有肉吃出门有车，中等有鱼吃，下等只能吃蔬菜。冯谖属于下等门客，他靠在门柱上击剑抱怨没有鱼吃。孟尝君把他升为中等门客。他又抱怨没有车，接着升为上等，这才悉心辅佐孟尝君。 寒灯欹枕听夜雨，堪怜～。 ★明·张凤翼《红拂记·英豪羁旅》 痰迷心窍 意思是指痰证的一类。也形容一心贪图某一事物而失去理智。 出自《官场现形记》第一回。 清·吴敬梓《儒林外史》第四回：“话说老太太见这些家伙什物都是自己的，不觉欢喜，痰迷心窍，昏绝于地。” 清·李汝珍《镜花缘》第五十回：“刚才只因多饮几杯，痰迷心窍，酒后失言，只求夫人饶恕。” 《红楼梦．第四六回》：「上次南京信来，金彩已经得了痰迷心窍，那边连棺材银子都卖了，不知如今是死是活。」 《官场现形记．第二九回》：「平时同人谈天，不是骂军机，就是骂督抚，大众听了，都说他是痰迷心窍。」 伯皋夫妻也无可如何，只得请了许多著名的医生，替她诊治，有说邪入心经，恐成狂病的；有说痰迷心窍，痰清即愈。有的得大致相合的；有说的完全相反。(清·小说·八仙得道) 冯云山和陈开二人，不知钱江所笑何事，还当钱江听了这个恶信急得痰迷心窍。正待想出话来安慰，已见钱江停了笑声道：“我姓钱只怕立刻将我就地正法，或者一时不及措手。(民国·小说·大清三杰) 坦腹东床 意思是旧作女婿的美称。 出自《世说新语·雅量》。 故事一 东晋时期，书法家王羲之年轻时很有才华，太尉郗鉴很器重他，想把女儿嫁给他，于是派人向王羲之伯父王导求亲。王导领来人到东厢房去看，只有王羲之独自敞着衣服，露着肚子躺在东床上吃东西。来人回去向郗鉴汇报说东床袒腹的就是王羲之。 故事二 郄太傅在京口，遣门生与王丞相书，求女壻。丞相语郄信：“君往东厢，任意选之。”门生归白郄曰：“王家诸郎亦皆可嘉。闻来觅壻，咸自矜持；唯有一郎在东床上袒腹卧，如不闻。”郄公云：“正此好！”访之，乃是逸少，因嫁女与焉。 有一次，太尉郗鉴派门生来见王导，想在王家子弟中选位女婿。王导让来人到东边厢房里去看王家子弟。门生回去后，对郗鉴说：“王家子弟个个不错，可是一听到有信使来，都显得拘谨不自然，只有一个人坐在东床上，袒腹而食，若无其事。”郗鉴说：“这正是我要选的佳婿。”一打听，原来是王羲之。郗鉴就把女儿嫁给了他。 探骊得珠 指在骊龙的颔下取得宝珠；原指冒大险得大利；后常比喻文章含义深刻，措辞扼要，得到要领。 出自《庄子·列御寇》。 很久很久以前，有一户人家住在黄河边上，靠割芦苇、编帘子簸箕为生，日子过得非常贫困。 有一天，儿子在河边割芦苇，烈日当空，晒得他头昏眼花，于是他就坐下来休息。他望着眼前的河水在阳光下闪耀着粼粼波光，想起父亲说过，在河的最深处有许多珍宝，可是谁也不敢去，因为那里住着一条凶猛的黑龙叫骊龙，他想，要是潜到河底，找到珍宝，我们一家人就用不着像现在这样一天干到晚，三顿还吃不饱，不如豁出去试一试。他把心一横，三下两下脱了衣服，一头扎进冰冷的河里。 开始他还看得见四周的小鱼在游来游去，再往深处，光线变得越来越暗，水也越来越凉，最后，他什么都看不见了，四周一团漆黑。他心里有点害怕，不知该往哪儿游。就在这时，不远处有一个圆圆的物体在闪闪发光，定睛细看，啊，原来是明珠！他憋足一口气游过去，双手抱住明珠，使劲一拽，明珠就到了他怀里。他迅速浮出水面，上岸后撒腿就往家跑。 父亲一见明珠，就问他是从哪儿得到的。他把经过一五一十地向父亲讲述一遍。父亲听了说：“好险哪！这颗价值千金的明珠是长在黑龙下巴底下的，你摘它的时候黑龙必定是睡着了。它要是醒着，你可就没命了。” 探赜索隐 tàn zé suǒ yǐn，意思是探究深奥的道理，搜索隐秘的事情。 探：寻求，探测；赜：幽深玄妙；索：搜求；隐：隐秘。 出自《易·系辞上》。 近义词：钩深致远，钩深索隐，探赜洞微，探幽穷赜，通幽洞微 言语和顺，情意相谐。 出自《红楼梦》 倘来之物/傥来之物 tǎng lái zhī wù，意思是指意外得到的或非本分应得的东西。同“傥来之物”。 出自《东堂老》。 韬光养晦 说的是清白好话，做的是污浊坏事。形容人言行不一。 出自《命书》。 韬晦待时 指掩藏锋芒，隐匿踪迹，等待时机。 出自茅盾 《蚀·动摇六》。 剔肤见骨 剔：从骨头上把肉刮下来；肤：肌肤。把肉剔下来，一直剔到了骨头。 比喻对事物分析和解剖得非常深刻、彻底。 梯山航海 tī shān háng hǎi，意思是登山航海。比喻长途跋涉，经历险远的旅程。 出自 《宋书·明帝纪》：“日月所照，梯山航海，风雨所均，削衽袭带。” 踢天弄井 上天入地的事都能做。形容本事大，能力强。 也形容顽皮到极点。 出自 元·秦简夫《东堂老》第二折：“你道有左慈术踢天弄井，项羽力拔山也那举鼎。” 咱们城里的孩子，个个踢天弄井，鬼聪明倒是有的。 ★清·曹雪芹《红楼梦》第81回 《西游记》第二十回：“我老孙也捉得怪，降得魔。伏虎擒龙，踢天弄井，都晓得些儿。” 明 冯惟敏《感时》曲：“谁家猫犬怕闻腥，假意儿粧乾净，掩耳偷铃，踢天弄井，露面贼不自省。” 《醒世姻缘传》第三六回：“哄得汉子牢牢的信他是志诚老实的妇人，一些也不防闲，他却背后踢天弄井。” 元．无名氏《大战邳彤．第一折》：“任从你踢天弄井，敢教你片时间魄散魂惊。” 擿奸发伏 tī jiān fā fú，意思是揭露举发隐秘的奸人和坏事。 《三国志·任苏杜郑仓传》：“自太祖迄于咸熙，魏郡太守陈国吴瓘、清河太守乐安任燠、京兆太守济北颜斐、弘农太守太原令狐邵、济南相鲁国孔乂，或哀矜折狱，或推诚惠爱，或治身清白，或擿奸发伏，咸为良二千石。” 提纲挈领 tí gāng qiè lǐng ，比喻善于抓住问题的关键与要害。 出自 《韩非子·外储说右下》：“善张网者引其纲，不一一摄万目而后得。” 《荀子·劝学》：“若挈裘领，诎五指而而顿之，顺者不可胜数也。” 《宋史·职官志八》：“提纲而众目张，振领而群毛理。” 【近义词】纲举目张、一针见血 【反义词】不得要领、言不及义 啼饥号寒 因为饥饿寒冷而哭叫。形容挨饿受冻的悲惨生活。 出自《进学解》。 倜傥不羁 tì tǎng bù jī，形容洒脱豪放，不受拘束。 倜傥：洒脱，不拘束；羁：马笼头，比喻束缚、拘束。 出自 《晋书·袁耽传》。 be free,romantic and untrammeled in character 《晋书·袁耽传》：“耽字彦道，少有才气，俶傥不羁，为士类所称。”清 袁赋诚《睢阳尚书袁氏家谱》：“(袁可立)当为诸生时，倜傥不羁，睥睨一世。” 倜傥不群 形容洒脱豪放，饱有才学，与众不同。 涕泗交流/涕泗滂沱pang tuo 天覆地载 像天覆盖万物，地承受一切一样。比喻范围极广大。也比喻恩泽深厚。出自《礼记·中庸》。 天高地迥 形容极其高远。 出自《秋日登洪府滕王阁饯别序》。 天高听卑 典出《史记》卷三十八《宋微子世家》。原指上天神明可以洞察人间最卑微的地方，天帝虽高高在上，却能听到下面人世间的言语，而察知其善恶。歌颂帝王圣明，称好的帝王了解民情。 三国·魏·曹植《责躬》诗：“天高听卑，皇肯照微。” 《南齐书·王融传》：“皇鉴烛幽，天高地卑，赏片言之或善，矜一物之失时。” 《史记》卷三十八《宋微子世家》 三十七年，楚惠王灭陈。荧惑守心。心，宋之分野也。景公忧之。司马子韦曰：“可移于相。”景公曰：“相，吾之股肱。”曰：“可移于民。”景公曰：“君者待民。”曰：“可移于岁。”景公曰：“岁饥民困，吾谁为君！”子韦曰：“天高听卑。君有君人之言三，荧惑宜有动。”于是候之，果徙三度。 三十七年，楚惠王灭亡了陈国，火星侵占了心宿星区。心宿区是宋国的天区，景公十分担忧。司星子韦说：“可以把灾祸移到相国身上。”景公说：“不行，相国象是我的手足。”子韦又说：“可以移到百姓身上。”景公说：“也不行，国君靠的就是百姓。”子韦又说：“可以移到年成上。”景公说：“更不行，年成歉收，百姓贫困，我做谁的国君！”子韦说：“天虽高远却能听到下界细微的声音，您有这三句国君应该说的话，火星应该移动了。”于是仔细观测火星，火星果然移动了三度。 天理昭彰/天理昭然/天理昭昭 天人之际 指代天人关系。出自汉·司马迁《报任少卿书》。 天悬地隔 比喻两者相差极大。 出自《南齐书·陆厥传》： “一人之思，迟速天悬；一家之文，工拙壤隔。” 田父之获 tián fù zhī huò，意思是两者相争，第三者得利。 指不费力气而得到的利益. 出自《三国志·魏志·袁绍传》。 田连阡陌 恬不为意 tián bù wéi yì，意思是处之泰然，满不在乎， 出自 苏轼《上执政乞度牒赈济及因修廨宇书》。 恬淡寡欲 意思是心境清静淡泊，没有世俗的欲望。 出自 三国·魏·曹丕《与吴质书》：“而伟长独怀文抱质，恬然寡欲，有箕山之志，可谓彬彬君子者矣。” 调嘴弄舌/挑拨离间 意思是指背地里说人闲话，搬弄是非。 出自明·洪楩 《清平山堂话本·快嘴李翠莲记》 铁砚磨穿/通宵达旦/铜筋铁骨 铁中铮铮 比喻才能出众的人。 铮铮：金属器皿相碰的声音。 出自《后汉书·刘盆子传》：“卿所谓铁中铮铮，庸中佼佼者也。” 听而不闻 恫瘝在抱 tōng guān zài bào，意思是像病痛在自己身上一样。指把人民的疾苦放在心上。 出自 清·冯桂芬《与许抚部书》：“执事恫瘝在抱，诚欲继睢(suī）州、桂林之业。” show extreme concern over the people’s hardships 通衢广陌 四通八达的宽广大路。 出自唐·牛僧孺 《玄怪录·崔绍》 牛李之争的党魁.. 彤云密布 指很厚的云层布满天空，一般是下雪前的征兆。 出自《诗经·小雅·信南山》：“上天彤云，雨雪雰雰。” 《金瓶梅》第二回：“只见四下彤云密布，又见纷纷扬扬，飞来一天瑞雪来。” 《水浒传》 第十回正是严冬，彤云密布，朔风渐起，却早纷纷扬扬卷下一天大雪来。 明 施耐庵 《水浒传》第十一回：且说林冲与柴大官人别后，上路行了十数日，时遇暮冬天气，彤云密布，朔风紧起，又见纷纷扬扬，下着满天大雪。 明·许仲琳《封神演义》第八十九回 ：彤云密布，冷雾缤纷。 要言妙道 中肯的名言，深微的道理。 出自汉·枚乘《七发》。 铜琶铁板 形容气概豪迈，音调高亢的文辞。 出自宋·俞文豹《吹剑续录》。 东坡在玉堂日，有幕士善歌，因问：“我词何如柳七（柳永）？”对曰：“柳郎中词，只合十七八女郎，执红牙板，歌’杨柳岸晓风残月’；学士词，须关西大汉，铜琵琶，铁绰板，唱’大江东去’。”东坡为之绝倒。 北宋时期，苏轼带他随从外出郊游，他观赏山崖的金鸡菊，随从在一旁高唱苏轼的歌词。苏轼问他们自己与柳永的词有什么不同。随从说：柳郎中的词只可借17岁的女孩子执红牙拍板唱“杨柳外晓风残月”，您的歌词得请关西大汉持铁板唱“大江东去”。 痛痒相关 形容彼此关系密切。 出自明·杨士聪《玉堂荟记》 偷合苟容 出自《荀子·臣道》中的成语，贬义 奉承迎合别人，使自己能苟且地生活下去。 fall in with other’s wishes and acquire admittance 偷香窃玉 指善于勾引诱拐女人或男女暗中通情 ，出自《晋书·贾充传》。 明 冯梦龙 《醒世恒言·吴衙内邻舟赴约》：“安排布地瞒天谎，成就偷香窃玉情。” 清 曹雪芹 《红楼梦》第一回：再者，大半风月故事，不过偷香窃玉，暗约私奔而已，并不曾将儿女之真情发泄一二。 清 陈端生《再生缘》第十六回：“怎又起偷香窃玉，那心肠、真荒乱，实荒唐，年少为君败大纲！” 偷香的故事发生在晋代。据《晋书·贾充传》记载，韩谧的父亲叫韩寿，是西晋权臣贾充手下的一个幕僚。晋代贾充的女儿贾午，与韩寿相恋而私通，竟偷了其父收藏的晋武帝所赐之奇香送给韩寿。贾充发现后，便干脆把贾午嫁给了韩寿。所以，后来人们便把男女（主要是未婚男女）的偷情，叫做“偷香”；也叫“偷香窃玉”。窃玉和偷香一样，也有故事。大约是一位姓郑的男子所为，可惜其事已不可考了。只知道后人常把未婚青年男女的私相恋爱，叫做“郑生窃玉，韩寿偷香”，把恋爱的心愿，称为“偷香性，窃玉心”。 头角峥嵘 原比喻突出地显露才能和本领。后形容气概不凡才华出众，尤指青少年。 出自《柳子厚墓志铭》。 唐·韩愈《柳子厚墓志铭》：“虽少年，已自成人，能取进士第，崭然露头角。” 宋·子淳《和无尽居士牧牛颂》诗：“头角峥嵘未兆前，乱云深处任安眠。” 元·鲜于必仁《折桂令·蓟门飞雨》曲：“到处通津，头角峥嵘，溥渥殊恩。” 元．无名氏《黄鹤楼》第三折：那时头角峥嵘际，搅海翻江上九天。 明·沈受先《三元记·辞亲》：“你趁我两人在日，看你头角峥嵘，前呼后拥，显亲扬名，也胜是死后三牲五鼎之祭。” 蔡东藩 《清史演义》第一回：“那时父兄即临河眺望，果然岸傍有一少年，头角峥嵘，仪表英伟，不觉失声道：‘这是天生神人。’” be very promising ####头童齿豁 头顶秃了，牙齿稀了；形容人衰老的状态。 头秃齿缺 出自《讲学解》。 投畀豺虎 tóu bì chái hǔ，原指那种好搬弄是非的人，要把他扔出去喂豺狼虎豹；形容人民群众对坏人的愤恨。 出自《诗经·小雅·巷伯》。 投膏止火 用油去浇灭火，火反而烧得更旺。比喻举措失当，适得其反。 出自《新五代史·唐书·安重诲》 pour oil on the flames to put out a fire 投袂而起 形容精神振作，立即行动起来的神态。 出自《左传·宣公十四年》。 burst forth suddenly whisk one’s sleeves and depart 投闲置散 指不被重视或不被任用 突梯滑稽 自战国·楚·屈原《卜居》，释义为委婉顺从，圆滑而随俗。 战国·楚·屈原《卜居》：“将突梯滑稽，如脂如韦，以洁楹乎。” 徒陈空文 意思是只讲空话，而不实行。 出自汉·桓宽《盐铁论·非鞅》。 徒劳往返 屠门大嚼 是tú mén dà jiáo，意思是比喻心里想而得不到手，只好用不切实际的办法来安慰自己。 对着肉铺做出大口咀嚼的样子 出自《新论》。 土龙刍狗 tǔ lóng chú gǒu，意思是比喻名不副实。 出自《三国志·蜀书·杜微传》。 吐刚茹柔 tǔ gāng rú róu，意思是吐出硬的，吃下软的。比喻怕强欺弱。 出自《诗经·大雅·烝民》。 兔起鹘落/兔起凫举 tù qǐ hú luò，意思是指动作非常敏捷；比喻下笔快捷。 出自 宋苏轼《文与可画蒷筜谷偃竹记》：“急起从之，振笔直遂，以追其所见，如兔起鹘落，少纵即逝矣。” 推崇备至 推襟送抱 向对方表示殷勤的心意。 出自《南史·张充传》。 推贤进善 推荐贤士，引进好人。 出自《杜阳杂编》。 推燥居湿 tuī zào jū shī，意思是把干的地方让给幼儿，自己睡在湿的地方。形容抚育孩子的辛劳。 出自《孝经援神契》：“母之于子也，鞠养殷勤，推燥居湿，绝少分甘也。” 居湿推燥、推干就湿 拖紫垂青 指担任高官 拖：下垂。紫、青：古代高官系印用的绶（shuò）带颜色。汉制：诸侯为紫色，公卿为青色。 汉·扬雄《解嘲》：“纡青拖紫，朱丹其毂。” 《续古文苑·无名氏〈大隋车骑秘书郎张君之铭〉》：“昔年慷慨，拖紫垂青。”","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"成语缀辑II","date":"2016-04-09T11:21:54.000Z","path":"2016/04/09/成语缀辑II/","text":"H 含冤负屈 指遭受委曲，忍受冤枉。 出自 元·关汉卿《望江亭》第四折：“他只待强拆开我长搀搀的连理枝，生摆断我颤巍巍的并头莲。其实负屈衔冤。” 寒耕热耘 寒冷时耕种，炎热时除草，形容农事辛苦。 出自《管子·臣乘马》。 寒花晚节 比喻人的晚节仍高洁不污。 出自 宋·韩琦《九月水阁》诗：“虽惭老圃秋容淡，且看寒花晚节香。” 汗颜无地/号寒啼饥/毫厘不爽/豪横跋扈 旱魃为虐 指旱灾发生。 出自 《诗·大雅·云汉》：“旱魁为虐，如惔如焚。” The drought demon ran amok. 旱苗得雨 将要枯死的禾苗得到地场好雨，比喻在危难中得到援助。 出自《孟子·梁惠王上》。 A sweet rain falls on the parched seedlings. 悍然不顾 凶暴蛮横，不顾一切。 出自《醉醒石》第十一回。 蒿目时艰 hāo mù shí jiān，意思是指对时事忧虑不安。 出自 《庄子·骈拇》：“今世之仁人，蒿目而忧世之患。” 濠濮间想 濠：濠水，在今安徽凤阳县东北。濮：濮水，源出河南封丘县，流入山东境内。想：遐想。 意思是指闲适无为、逍遥脱俗的情趣。 “濠濮间想”，乃成为中国艺术中的一个重要境界，中国艺术家的一种重要情怀。中国艺术强调，和谐的根本在于人对自然的回归，在与自然的亲和中感受无上乐趣。中国艺术家认为，人和自然原本为一体，人就是这生机勃郁的自然界中的一分子。人没有必要将自己从自然中抽离开去，而扮演自然的观望者、控制者的角色。在中国艺术理论中有这样的观点，如果一个艺术家始终将自然对象化、外在化，那么一定会近在咫尺，却远隔重山。推之于人与人之间的关系也是如此。人如果一味在自己所创设的界限中生存，那么重重界限就会使人与世界处于无所不在的紧张之中，冲突、挤压、绝望，使人生失去快乐！“人于天地中，并无窒碍处”，是人自己为自己创设了障碍。“濠濮间想”的境界是一种自由的境界，和谐的境界。解脱人为的障碍，回到自己本然的生命之中，与山水林木共欢乐，伴鸟兽禽鱼同悠游，感受人与自然的通体和谐。“濠濮间想”者，云水之乐、山林之想也。其实，并不在山林云水本身，而在人的心态。心态自由、平和，当下即是云水，庙堂即是山林。 好语似珠 指诗文中警句妙语很多。 出自于 宋·苏轼《次韵答子由》：“好语似珠穿一一，妄心如膜退重重。”。 好谋无断 爱用计谋，但缺少决断。 形容人空有心计而没有胆略。 好问则裕 遇到疑难就向别人请教，学识就会渊博精深。 出自 《尚书·商书·仲虺之诰》：“好问则裕，自用则小。” 好整以暇 hào zhěng yǐ xiá，意思是形容既严整，又从容。也指事情虽多，仍旧从容不迫。 出自《左传·成公十六年》。 皓齿蛾眉/皓首苍颜 合浦珠还 比喻东西失而复得或人去而复回。出自《后汉书·循吏传·孟尝》。 东汉时，合浦郡沿海盛产珍珠。那里产的珍珠又圆又大，色泽纯正，一直誉满海内外，人们称它为“合浦珠”。当地百姓都以采珠为生，以此向邻郡交趾换取粮食。采珠的收益很高，一些官吏就乘机贪赃枉法，巧立名目盘剥珠民。为了捞到更多的油水，他们不顾珠蚌的生长规律，一味地叫珠民去捕捞。结果，珠蚌逐渐迁移到邻近的交趾郡内，在合浦能捕捞到的越来越少了。合浦沿海的渔民向来靠采珠为生，很少有人种植稻米。采珠多，收入高，买粮食花些钱不在乎。如今产珠少，收入大量减少，渔民们连买粮食的钱都没有，不少人因此而饿死。汉顺帝刘保继位后，派了一个名叫孟尝的人当合浦太守。孟尝到任后，很快找出了当地渔民没有饭吃的原因；下令革除弊端，废除盘剥的非法规定，并不准渔民滥捕乱采，以便保护珠蚌的资源。不到一年，珠蚌又繁衍起来，合浦又成了盛产珍珠的地方。 和璧隋珠比喻极珍贵的东西。 出自《韩非子·解老》：“和氏之璧，不饰以五采；隋侯之珠，不饰以银黄；其质之美，物不足以饰之。” 和盘托出/和衷共济 河落海干 比喻一点不剩；同“河涸海干”。 出自《红楼梦》。 河清难俟 hé qīng nán sì，很难等到黄河水清；比喻时间太长，难以等待。 出自《左传·襄公八年》。 河山带砺 黄河细得象条衣带，泰山小得象块磨刀石；比喻时间久远，任何动荡也决不变心。 出自《史记·高祖功臣侯者年表》。 Even the Huanghe River becomes as thin as a stripe and Mount Tai becomes as small as a grindstone. 涸辙之鲋 赫赫炎炎 意思是形容势焰炽盛热盛貌。 出自《诗经·大雅·云汉》：“旱既大甚，则不可沮，赫赫炎炎，云我无所。” 赫赫扬扬 显赫的样子。 出自《牡丹亭·诊崇》。 褐衣蔬食 穿的是粗布衣服，吃的是粗茶淡饭。形容生活困苦。 出自《史记·游侠列传》。 鹤发鸡皮 皮肤发皱，头发苍白；形容老人年迈的相貌。 出自 北周·庾信《竹杖赋》：“子老矣，鹤发鸡皮，蓬头历齿。” 唐玄宗《傀儡吟》：“刻木牵丝作老翁，鸡皮鹤发与真同。” a hoary head with wrinkled skin. 斑驳陆离 形容色彩杂乱不一。 出自 战国·楚·屈原《楚辞·离骚》：“纷总总其离合兮，斑陆离其上下。” many-hued.mixed colours or tints 恒河沙数/横拖倒拽 烘云托月 hōng yún tuō yuè，原指一种画月亮的传统手法，后比喻从侧面加以点染以烘托所描绘的事物。 元·王实甫《西厢记》第一本第一折金圣叹批：而先写张生者，所谓画家烘云托月之秘法。 闳中肆外 hóng zhōng sì wài，意思是指文章内容丰富，文笔又能尽量发挥。 出自 韩愈《进学解》 profound idea and a good style of writing 洪炉点雪 大火炉里放进一点雪，马上就会融化。比喻对问题领会极快。 出自 宋·王质《雪山集·大慧禅师正法眼藏序》：“余夜宿金山之方丈，不得寤，信手而抽几案文书，得此阅之，至洪炉点雪，恍然非平时之境。 鸿飞冥冥 大雁飞向远空，猎人就无法获得它了；比喻远走避祸。 出自《法言·问明》。 鸿稀鳞绝 比喻音信极少。 出自 元·王实甫《西厢记》第三本第一折：“自别颜范，鸿稀鳞绝，悲怆不胜。” 喉清韵雅 歌喉清脆响亮，韵味优美幽致。形容歌唱水平很高。 出自 清·曹雪芹《红楼梦》第七十五回：“便命取了一支紫竹箫来，命佩凤吹箫，文花唱曲，喉清韵雅，甚令人心动神移。” 侯服玉食 指穿王侯的衣服，吃珍贵的食物。 形容豪华奢侈的生活，出自汉 · 班固《汉书·叙传下》。 呼朋引类 指招引志趣相同的人。 出自 宋·欧阳修《憎苍蝇赋》：“奈何引类呼朋，摇头鼓翼。” 呼幺喝六 hū yāo hè liù，意思是掷骰子时的喊声。泛指赌博。也形容吆喝。 出自元·无名氏《气英布》 狐埋狐搰 hú mái hú hú，意思是狐性多疑，刚把东西埋下，又把挖出来看看；比喻疑虑过多，不能成事。 搰：挖掘 出自《国语·吴语》。 狐裘羔袖 hú qiú gāo xiù，意思是整体尚好，略有缺点。 裘：皮衣；羔：指小羊皮。狐皮衣服，羔皮袖子。 出自《左传·襄公十四年》。 good on the whole but not perfect 狐死首丘 古代传说狐狸如果死在外面，一定把头朝着它的洞穴。比喻不忘本或怀念故乡，也比喻对故国、故乡的思念。 出自《礼记注疏》。 鹘入鸦群 hú rù yā qún，意思是比喻骁勇无敌。 出自《北齐书·南安王思好传》。 鹘：同“隼”，一种凶猛的大鸟。 左盘右射红尘中，鹘入鸦群有谁敌。 ◎唐·韩翃《寄哥舒仆射》诗 虎尾春冰 意思是踩着老虎尾巴，走在春天将解冻的冰上。比喻处境非常危险。 出自 《尚书·君牙》：“心之忧危，若蹈虎尾，涉于春冰。” 虎啸风生,龙腾云起 意思是猛虎长鸣，则大风四起；比喻英雄人物顺应时代潮流而出现，并且对社会产生极大的影响；亦指豪杰奋起，大展宏图。 出自 《北史·张定和传论》：“虎啸生风，龙腾云起，英贤奋发，亦各因时。” 户枢不蠹/怙恶不悛 户限为穿 门槛都踩破了，形容进出的人很多。 出自《法书要录》。 划一不二 指按照定价卖出，不打折扣。形容做事刻板。 出自《汉书·曹参传》。 画脂镂冰 在凝固的油脂或冰上绘画雕刻，一旦融化，都化为乌有。比喻徒劳无功。 出自《盐铁论·殊路》。 draw on butter or carve ice 怀璧其罪 原指财能致祸。后也比喻有才能而遭受忌妒和迫害。 出自《春秋左传-桓公十年》。 an innocent man gets into trouble because of his wealth 【押韵词】托物连类、缺心少肺、卧榻岂容鼾睡、游戏三昧、出乎其类，拔乎其萃、私恩小惠、楛耕伤稼，楛耘失岁、知希之贵、汉皋解佩、如芒在背 当初，虞叔有块宝玉，虞公想要得到，虞叔没有给他，然后，虞叔为此而感到后悔，说：“周朝的时候有句谚语说：‘一个人本来没有罪，却因为拥有宝玉而获罪。’”于是就把宝玉献给了虞公。可是，虞公又来索要虞叔的宝剑，虞叔说：“这实在是贪得无厌。如此贪得无厌，将会给我带来杀身之祸。”于是就发兵攻打虞公。所以，虞公出奔到共池那个地方去了。在这段故事中，虞叔最初因为拥有宝玉招来贪得无厌之人的觊觎，这也是后续一连串事端的根由。 豹死留皮 豹死以后皮可以留存下来；比喻将好名声留传于后世。 出自 《新五代史·王彦章传》 五代时期，梁朝名将“王铁枪”王彦章跟随梁太祖朱温南征北战，屡立战功，深受重用。梁末帝朱贞继位后，唐军进攻梁国。王彦章受命御敌，但因寡不敌众被俘。唐庄宗劝王彦章归降。王彦章说：豹死留皮，人死留名，宁死不降。不久就被杀害。 怀瑾握瑜/淮橘为枳 怀铅握椠/怀觚握椠、怀铅提椠、怀铅握素 huái qiān wò qiàn，意思是常带书写工具，以备写作的需要。 出自 唐·刘知几《史通·采撰》：“自古探穴藏山之士，怀铅握椠之客，何尝不征求异说，采摭群言。” be ready to write down anything encountered 擐甲挥戈/擐甲操戈/擐甲持戈 huàn jiǎ huī gē，意思是身穿铠甲，手持武器；形容全副武装，英勇顽强；亦作“擐甲操戈”、“擐甲持戈”。 出自《左传·成公二年》。 黄卷青灯 黄茅白苇 连片生长的黄色茅草或白色芦苇；形容齐一而单调的情景。 出自 宋·苏轼《答张文潜书》：“惟荒瘠斥卤之地，弥望皆黄茅白苇，此则王氏之同也。” 黄童白叟 意思是黄发儿童，白发老人。泛指老人与孩子。 出自 唐·韩愈《元和圣德》诗：“黄童白叟，踊跃欢呀。” 黄钟毁弃瓦釜雷鸣 恢恢有余 意思是薄薄的刀刃插入骨节间，仍觉宽广，还有回旋余地。常形容本领大，技巧高，处理问题毫不费力。 出自 庄周《庄子·养生主》：“彼节者有间，而刀刃者无厚。以无厚入有间，恢恢乎其于游刃必有余地矣。” 回肠百转/回嗔作喜/回心向善/毁家纾难/讳疾忌医 诲淫诲盗 引诱别人做奸淫、盗窃的事。原意是财物不仔细保管，招致别人来偷盗；女子打扮得十分妖艳，也是引诱别人来调戏。 《周易·系辞上》：“慢藏诲盗，冶容诲淫。”。 惠而不费 意思是给人好处，自己却无所损失。出自《论语》。 蕙心纨质/蕙心兰质 huì xīn wán zhì，意思是蕙草样的心地，兰花似的本质。比喻女子心地纯洁，性格高雅。 出自 唐·王勃《王子安集·七夕赋》：“金声玉韵，蕙心兰质。” 昏定晨省 hūn dìng chén xǐng，意思是指旧时侍奉父母的日常礼节。 出自《礼记·曲礼上》 混俗和光 意思是同于尘俗，不露锋芒。指不求特异，与世无争。 出自 明·凌濛初《二刻拍案惊奇》卷四十：“典册高文，不晓是翰墨林中大手；淫词艳曲，多认作繁华队里当家。只得混俗和光，偷闲寄傲。见作开封监税，权为吏隐金门。” 火上弄冰 比喻易于败亡，事情很容易办到。 败不旋踵 bài bù xuán zhǒng，意思是还没来得及转动脚后跟，就失败了，形容很快就遭到失败。 出自 唐·卢照邻《三国论》：“然而丧师失律，败不旋踵，奔波谦瓒之间，羁旅袁曹之手，岂拙于用武，将遇非常敌乎？” 蠖屈求伸 huò qū qiú shēn，比喻人不遇时，则屈身求隐，待来日再展宏图。 盖闻～，非终于屈，龙潜或跃，匪固于潜。（明·刘基《诚意伯文集》第八卷） J 击节叹赏 jī jié tàn shǎng，意思是形容对诗文、音乐等的赞赏。 出自 晋·左思《蜀都赋》：“巴姬弹弦，汉女击节。” 机变如神 意思是机智权变，神奇莫测。 出自 宋·陆游《南唐书·宋齐丘传论》：“世言江南精兵十万，而长江天堑，可当十万；国老宋齐丘，机变如神，可当十万。” 计不旋踵 jì bù xuán zhǒng，意思是脚跟还未转过来，计议就定了下来，形容在极短的时间内就拿定主意，也比喻行动迅速，毫不犹豫。 出自 汉·司马相如《喻巴蜀檄》：“夫边郡之士……触白刃，早流矢，议不反顾，计不旋踵，人怀怒心，如报私仇。” 计：计议，打算；旋踵：旋转脚跟。 机不旋踵 jī bù xuán zhǒng，意思是时机短暂，旋踵，转过脚后跟。 出自 唐·皇甫枚《三水小牍·宋柔》：“机不旋踵，时不再来。必发今宵，无贻后悔。” 鸡争鹅斗 比喻吵吵闹闹，彼此不和。 出自清·曹雪芹《红楼梦》。 积弊如山 长期积累下来的弊端,弊病像山一样多 积不相能 意思是双方长期以来互不亲善，不和睦。 出自《左传·襄公二十一年》 积草屯粮/积功累行/积毁销骨/积微成著/积羽沉舟 积非成是 指长期所形成的错误，往往被当作正确的。出自《孟子字义疏证·原善序》。 many mistakes makes “right”;Accumulation of errors makes correctness 积习成癖 指习惯经历时间久了，会成为一种偏好。 积薪厝火 jī xīn cuò huǒ，意指把火种放在易燃的柴草下面，喻指所行之事隐藏着很大的危险，后患无穷 。 出自 清·张岱《越绝诗小序》：“积薪厝火，其焰立见。” 积羽沉舟 意思是指小小的坏事积累起来就会造成严重的后果 出自《战国策 魏策一》 铢积寸累/积铢累寸 zhū jī cùn lěi，意思是形容一点一滴地积累，也形容事物完成的不容易。 出自 宋·赵德麟《侯鲭录》。 accumulate little by little;build up bit by bit 赍志而没/赍志而殁、赍志以殁 jī zhì ér mò，意思是志愿没有实现就死了。 出自 南朝·梁·江淹《恨赋》：“赍志没地，长怀无已。” 畸轻畸重 jī qīng jī zhòng，意思是有时偏轻，有时偏重；形容事物发展不均衡，或对待事物的态度不公正。 出自《福惠全书》。 齑盐布帛 指粗衣蔬食 激贪厉俗 指抑制贪婪之风，劝勉良好的世俗。 出自《梁书·萧颖达传》。 及锋而试 原指乘士气高涨的时候使用军队，趁士气正旺时而及时使用。也比喻乘可行之际而行。 这句话出自《汉书·高帝纪上》 秦朝末年，群雄并起，各路义军同仇敌忾，一举推翻了秦王朝的残暴统治。公元前206年，刘邦首先率军攻进了秦都咸阳，秦王子婴投降。但因自己兵力弱小，无法跟势力强大的项羽抗衡，只好听从樊哙(kuai)和张良的劝告，查封了秦王朝的仓库，并约法三章，安抚百姓，然后撤出咸阳，率领军队回到灞(ba)上驻扎,等待项羽进城。项羽进咸阳后，俨然以义军盟主自居，学着周天子分封诸侯的办法，把六国旧贵族和反秦有功的将领一共封了十八个王。他自称西楚霸王，也就是霸主的意思，而将刘邦封在地处偏远的巴蜀(今四川省)和汉中(今陕西南部和湖北北部一带)，称为汉王。刘邦虽然很不满意，但也不敢和项羽计较，只得带着项羽拨给他的三万军队，和愿意跟随他的数万百姓来到封地南郑(今陕西汉中市东)。刘邦的部下都是内地人，来到这偏僻荒凉的地方，大家都很想家，差不多每天都有人开小差逃走，刘邦十分焦急。这时，韩信对刘邦说：“大王率先攻进咸阳，本来功劳最大，而项羽却偏偏把您封在这么个地方，这太不公平了。将士们日夜盼望回到老家，您正可以利用这种思乡情绪，趁着大家士气旺盛，号召他们打回老家去，和项羽争夺天下．一定会大获全胜。”刘邦采纳了韩信的建议，回师东进，真的打败了项羽，统一了全国，建立了汉朝。 及瓜而代 官任职期满，由人接代。 出自《左传·庄公八年》。 齐襄公的堂兄弟公孙无知的父亲去世得早，襄公的父亲齐釐公（又作齐僖公）很喜欢公孙无知，以太子的待遇对待他，齐襄公很妒忌。齐襄公一当了国君，马上就除去了公孙无知的待遇。十二后，齐襄公派连称、管至父去戍边（葵丘，今齐鲁长城穆陵关一带），瓜期时（七月）派他们去，答应等到第二年瓜期时就派人代替他们，让他们回来。可是一年过去了，瓜都烂在地里了，齐襄公也不派人去代替，有人提醒齐襄公，齐襄公也不管。这两个人很生气，于是联合公孙无知，带领部队回到都城，冲进王宫，杀了齐襄公，公孙无知自称齐王。后人就用“及瓜而代”比喻换人接替的日子快要到来，从今年食瓜之时，到明年瓜熟之日，一定找人替代。 就是要有诚信。故事中齐侯不守信用，终于被人推翻，说明做人要守信，否则会自讨苦吃的。 吉光片羽 比喻残存的珍贵文物。 出自《西京杂记》。 The inklings 极而言之 从最极端的情况来说。 出自 明·袁宏道《《与仙人论性书》 if the worst comes to the worst 极天际地 形容十分高大。出自《礼记·乐记》。 即景生情 对眼前的情景有所感触而产生某种思想情感。 出自《闲情偶寄·词曲部·词采第二》。 Memories revive at the sight of familiar places 即小见大 从小处或小事见到大道理。出自鲁迅《热风·即小见大》。 佶屈聱牙/诘屈聱牙 jí qū áo yá，意思是形容文词艰涩生僻、拗口难懂。 出自 唐·韩愈《昌黎集·进学解》：“周《诰》殷《盘》，佶屈聱牙。” 急脉缓受/急脉缓灸 意思是比喻用和缓的办法应付急事。也比喻诗文在进行中，故意放松一笔，以造成抑扬顿挫之势。 同“急脉缓灸”。 patiently attend to a grave problem 疾如旋踵 意思是快得就像转动一下脚跟。形容变化很快。 出自《机论上》。 疾首蹙额 jí shǒu cù é，意思是形容厌恶痛恨的样子。 出自《孟子·梁惠王下》。 with aching head and knitted brows 瘠己肥人 jí jǐ féi rén，是指严以律己宽以待人。 挤挤攘攘 攘攘：纷乱的样子。形容拥挤纷乱的样子。出于梁斌《红旗谱》 戟指嚼舌 jǐ zhǐ jiáo shé，意思是形容愤怒之极。出自《华盖集·“碰壁”之余》。 戟指：伸出食指、中指指人；嚼舌：咬破舌头。形容愤怒之极。 鲁迅《华盖集·“碰壁”之余》：“或则戟指嚼舌，喷血而亡。” 计出万全 形容计划非常稳当周密，决不会发生意外。 出自《汉书·晁错传》。 计功行赏 按功劳的大小给于奖赏。出自《韩非子·八说》。 计过自讼 检讨自己的过错而内心自责，出自《论语·公冶长》。 计穷力竭 意思是计谋、力量都用尽了。 出自明·吴承恩《西游记》第六十六回。 计日程功/指日可待 工作进度或成效可以按日计算，形容进展快，有把握按时完成，成功指日可待。 出自《礼记·儒行》 have the completion of a project well in sight 计日而待 可以数着日子等待。形容为时不远。 出自《出师表》。 be just round the corner 季布一诺 季孙之忧 指内部的忧患。出自《论语·季氏》。 Internal misery 济河焚舟/背水一战 jì hé fén zhōu，意思是渡过了河，把船烧掉。比喻有进无退，决一死战。 出自《左传·文公三年》。 公元前628年，秦国趁晋国大丧而出兵占领晋国滑城，晋国出兵将秦军全部消灭，主将孟明视靠晋文公夫人帮助才得以逃回秦国。3年后，秦穆公又派孟明视伐晋。孟明视从茅津渡河后将船全部烧毁，背水一战，大败晋军，占领王官等地。 济贫拔苦 指救援贫苦人家。出自《敦煌变文集·维摩诘讲经文》。 寂若无人 寂静得就像没有人一样。 南朝·宋·刘义庆《世说笺本·德行下》：“傅茂远泊然静处，不妄交游民，袁司徒第经其户，辄叹曰：‘’经其户寂若无人，披其帷，其人斯在。岂得非名贤。” 稷蜂社鼠jì fēng shè shǔ，意思是谷神庙里的马蜂，土地庙里的老鼠。 比喻倚势作恶手的人。 出自《韩诗外传》。 家道消乏 意思是家境贫寒，经济空乏。 出自明·冯梦龙《警世通言》。 家鸡野鹜 jiā jī yě wù，意思是晋人庾翼以家鸡喻自己的书法，以野雉喻王羲之的书法，比喻不同的书法风格；也比喻人喜爱新奇，而厌弃平常的事物。 出自《晋中兴书》。 东晋武将庾翼与王羲之一样都能写一手好书法，他看到自己的儿子与侄子不学他的书法改学王羲之的书法，心中十分不满，说儿子与侄儿不爱家鸡爱野鸡，要与王羲之比高低。后来他见了王羲之的一幅书法作品后就心服口服了。 家无担石 十斗为一石，两石为一担。形容家里没有存粮。比喻家境困难。 出自： 宋朝苏轼《乞赙赠刘季孙状》。 家学渊源 葭莩之亲 jiā fú zhī qīn，意思是比喻关系疏远的亲戚。出自《汉书·中山靖王传》。 嘉言懿行/瑰意琦行 jiā yán yì xíng，指有益的言论和高尚的行为。 fine words and lofty deeds 佳肴美馔 jiā yáo měi zhuàn ，意思是精致可口的饭菜或味道鲜美的食品 ，出自《水浒传》 假手于人 意思是借助别人来为自己办事。 出自《尚书·伊训》。 make a cat’s paw of somebody 假途灭虢 jiǎ tú miè guó，意思是泛指用借路的名义而灭亡这个国家。 出自《左传·僖公二年》。 attack the enemy by passing through a common neighbour 艰难竭蹶 兼弱攻昧 指兼并弱小、攻击愚昧的国家。 出自《尚书·仲虺之诰》。 缄口不言/缄口结舌 蒹葭倚玉 jiān jiā yǐ yù，意思是表示地位低的人依附地位高的人。 出自《二刻拍案惊奇》第17卷。 拣佛烧香 jiǎn fó shāo xiāng，比喻看人行事或待人有厚薄。 出自 唐·寒山《诗》之一五九。 剪烛西窗 见鞍思马 看见死去或离别的人留下的东西就想起了这个人。 出自 宋·石介《徂徕石先生文集·三·感兴》：“倚鞍思骏骨，抚辔念绿駬。” see the saddle and think of the horse 鉴貌辨色/见貌辨色 意思是根据对方的脸色、表情行事。 见兔放鹰 意思是看到野兔，立即放出猎鹰追捕。比喻行动及时，适合需要。 出自 宋 释普济《五灯会元》：“护圣不似老胡，拖泥带水，只是见兔放鹰，遇獐发箭。” take measures in time 见危授命 意思是在危急关头勇于献出自己的生命。出自《论语·宪问》。 子路问孔子怎样才能成为一个十全十美的人，孔子要他学鲁国的臧武仲、孟公绰、卞庄子、冉求他们的优点，同时加强礼乐的学习，见利不能忘义，看到别人遭到危险时能舍身去搭救，坚守信用，这样就能成为完美的人。 剑胆琴心 意思是比喻既有情致，又有胆识（旧小说多用来形容能文能武的才子）。 出自 元·吴莱《寄董与几》诗：“小榻琴心展，长缨剑胆舒。” 江心补漏/临渴掘井 意思是船到江心才补漏洞，指临到紧急关头才设法补救，为时已晚。 出自《救风尘》 将本求利 意思是用本钱谋求利润。用于经商等 出自《朱砂担》。 将勤补拙/将遇良才/交口称誉/交浅言深/骄奢淫逸/蛟龙得水 降格以求 降低标准去寻求。 出自《坟·灯下漫笔》。 降心相从 意思是降低自己去遵从别人。出自《左传·隐公十一年》。 胶柱鼓瑟 意思是用胶把柱粘住以后奏琴，柱不能移动，就无法调弦。比喻固执拘泥，不知变通。 出自《史记·廉颇蔺相如列传》。 赵孝成王听信了秦国间谍散布的谣言：秦军最怕马服君的儿子赵括担任将军。用赵括代替廉颇为将。蔺相如劝阻说：大王凭名声用赵括，就像是把胶把瑟上的弦柱粘住来弹瑟，音调不能变通一样，他不懂得随机应变。赵王不听。结果，赵军被秦军打败，40万大军被活埋。赵国几乎灭亡。 矫情镇物 意思是比喻故作镇静，使人无法猜度。 出自 《晋书·谢安传》：“既罢，还内，过户限，心喜甚，不觉屐齿之折，其矫情镇物如此。” 矫情自饰 意思是掩饰真情，粉饰自己。 出自《三国志·魏志·陈思王植传》：“文帝御之以术，矫情自饰，宫人左右，并为之说，故遂定为嗣。” 矫若游龙/搅海翻江/街谈巷议/结草衔环/截长补短 结驷连骑 意思是形容排场阔绰。出自《史记·仲尼弟子列传》。 桀犬吠尧 jié quǎn fèi yáo，意思是暴君夏桀的狗向圣王唐尧吠叫，比喻奴才只知道一心为他的主子效劳，而不分贤愚善恶。 出自《战国策·齐策》。 西汉景帝时，有个名叫邹阳的文士，“为人有智略，慷慨不苟合”。起初，他和文学家枚乘等人都在吴王刘濞手下做事。因他们不但有文才，而且也有口才，所以很受器重。后来，吴王阴谋叛乱，邹阳不愿随从，便上书劝谏。可吴王刘濞听不进去，邹阳便和枚乘等人一起投奔了梁孝王刘武。但是梁孝王的心腹公孙诡等人嫉妒邹阳，在梁孝王面前说了邹阳等不少的坏话。梁孝王一怒之下便将邹阳关进监牢，并准备把他处死。邹阳在狱中上书梁孝王，为自己辩白，这就是流传千古的名文《狱中上梁王书》。 邹阳在信中列举了大量历史上名人被疑甚至被迫害至死而实际上都是忠贞之士的事例，提醒梁孝王细察真情，重用贤才，不要冤枉好人。他还说道：“今人主（实指梁孝王）诚能去骄傲之心，怀可极之意，披心腹，见情素，堕肝胆，施德厚，终与之穷达，无爱于土，则桀之犬可使吠尧，跖之客可使刺由，何况因万乘之权，假圣王之资乎！” 截发留宾/投辖留宾、剪发留宾 意思是以之为贤母好客的典故。出自《世说新语·贤媛》。 东晋时期，范阳孝子范逵去陶侃家投宿，陶侃有名气，但家里清贫，与母亲湛氏相依为命，艰难度日。陶侃发愁了，湛氏把自己的长发剪下，让儿子拿到市场上卖了换回几斛米，另外劈柱与烧草垫招待客人，范逵对他们十分敬佩。 解衣推食 意思是把穿着的衣服脱下给别人穿，把正在吃的食物让别人吃。形容对人热情关怀。 出自《史记·淮阴侯列传》：“汉王授我上将军印，予我数万众，解衣衣我，推食食我。” show the utmost solicitude 借箸代筹 jiè zhù dài chóu，本义是借筷子来指画当前的形势，后比喻从旁为人出主意，计划事情。 出自《史记·留侯世家》。 清·刘鄂《老残游记》第七回：“～一县策，纳楹闲访百城书。 当年刘邦与项羽相持不下，有个叫郦食其的儒生给刘邦出了个主意，让他分封战国时期六国的后代。刘邦举棋不定，趁吃饭时，询问张良这个主意如何，张良立即表示坚决反对，从刘邦的食案上抓过一把筷子说：“请让我以这把筷子来为大王筹划。”接着条分缕析，从八个方面力驳这种主张的危害，每提出一个理由，都摆出一根筷子。这就是“借箸代筹”这个典故的由来，亦可称之为“张良借箸”。刘邦接受了张良的意见，收回成命，避免了分裂割据现象的出现，成就了两汉四百年的统一大业。后来，明朝的刘基（字伯温）曾有诗形容这一情节。朱元璋问刘基：“能诗乎？”刘答：“儒者末事，何谓不能？”时朱元璋正在进餐，便指面前的斑竹箸（筷子）令刘赋诗。刘即席口占曰：“一对湘江玉并看，二妃曾洒泪痕斑。”朱元璋皱眉不悦道：“秀才气味。”待后两句一出：“汉家四百年天下，尽在留候一借间！”朱元璋听完刘基的诗，大喜。 藉草枕块 jiè cǎo zhěn kuài，意思是指古时居父母之丧，坐卧在草垫上，枕着土块。形容悲痛欲绝。 出自清·曹雪芹《红楼梦》第六十四回。 今不如昔 意思是现在不如过去，多用于表示对世事的不满情绪。 出自《能改斋漫录·冷斋不读书》。 金波玉液 意思是比喻美酒。 出自明·罗贯中《三国演义》第八十八回。 海错山珍锦盘中，捧着龙肝凤胆；金波玉液银壶内，泛出青黄碧绿。 ★《粉妆楼》第七十九回 金谷酒数 意思是罚酒三斗的隐语，旧时泛指宴饮时罚酒的斗数。 出自 晋·石崇《金谷诗序》：“遂各赋诗，以叙中怀，或不能者，罚酒三斗。” drink three cups of wine as forfeit 金兰之契 qì，意思是指交情投合的朋友。 出自《周易·系辞上》。 宋·张孝祥《下定书》：“门馆游从，早托金兰之契；衣冠歆艳，共称冰玉之贤。” 金马玉堂 意思是供侍诏学士议事的地方。旧指翰林院或翰林学士。 出自汉·扬雄《解嘲》。 金马玉堂三学士，清风明月两闲人。 ★宋·欧阳修《会老堂致语》 金瓯无缺 意为金瓯没有残缺。比喻国土完整。 出自《南史·朱异传》 金声玉振 以钟发声，以磬收韵，奏乐从始至终，比喻音韵响亮、和谐，也比喻人的知识渊博，才学精到。 南朝〔齐〕王俭《褚渊碑文》：金声玉振，寥亮于区寓。 南朝〔梁〕刘勰《文心雕龙》：至若夫子继圣，独秀前哲，熔钧六经，必金声而玉振。 〔南北朝〕邢子才《广平王碑文》：我有徽猷；金声玉振；志犹学海；业比登山。 〔唐〕杨炯《从弟杨去溢墓志铭》：至如白雪回光，清风度曲，崔亭伯真龙之气，扬子云吐凤之才，莫不玉振金声，笔有馀力。 〔明〕谢榛《四溟诗话》卷一：诵之行云流水，听之金声玉振，观之明霞散绮，讲之独茧抽丝。此诗家四关。 太平天囯洪仁玕《英杰归真》：我天朝万万年作人之治，所由黼国黻家（fǔ guó fú jiā），天道无不彰之美；金声玉振，天理靡不畅之机。 金石为开 精诚所至，金石为开，意思是人的诚心所到，能感动天地，使金石为之开裂。 比喻只要专心诚意去做，什么疑难问题都能解决。 金石之言 意思是象黄金宝石那样珍贵的话语。比喻可贵而有价值的劝告。 出自《西厢记》。 金吾不禁 思是特指元宵佳节解除宵禁。 出自《西都杂记》。 金针度人 jīn zhēn dù rén，意思是比喻把高明的方法传授给别人。古指采娘七夕祭织女，得金针而刺绣越发长进。 出自 金·元好问《论诗》诗：“鸳鸯绣了从教看，莫把金针度与人。” teach others a knack of the trade 从前，有个少女叫采娘，人勤手巧，但她还不满足，便在家中书房摆上香炉，烧香祈祷织女显灵，共七天七夜．就在第七天晚上，一辆云霞托起的彩车来了，车上坐着织女，车停下后，织女问采娘：”你还祈祷什么福呢？”采娘说：”我希望自己能够更加心灵手巧。”织女就给她一根金针，只有一寸来长，扎在纸上，放在采娘衣裙中，并对她说：”三天不要讲话，三天后你就会变得特别灵巧。”三天以后，采娘果然比以前更巧了，什么都会做，远近都知道她的名声。 矜才使气/恃才傲物 jīn cái shǐ qì，意思是形容仗恃着有点能力就意气用事。 出自 清·夏敬渠《野叟曝言》第十五回：“先生学问渊博，矜才使气，医卜艺术之书，无不周览。” 矜持作态 形容故意做作的样子 &lt;做饭&gt; 大师的吃货哲学 最完整收录汪曾祺先生谈吃的散文集，首次录入汪曾祺的画作、书法作品。 中国最后一位士大夫，一位衔接现代文学与当代文学的散文大师。字里行间充满了“生之喜悦”。 汪是一文狐，修炼老成精。——贾平凹 记人事、写风景、谈文化、述掌故，兼及草木虫鱼、瓜果食物，皆有情致。间作小考证，亦可喜。娓娓而谈，态度亲切，不矜持作态。文求雅洁，少雕饰，如行云流水。春初新韭，秋末晚菘，滋味近似。 内容简介—— 汪曾祺是一位把口腹之欲和高雅文化之间的距离拉得最近的人，他自称喜欢逛菜市场：“到了一个新地方，有人爱逛百货公司，有人爱逛书店，我宁可去逛逛菜市。看看生鸡活鸭、新鲜水灵的瓜菜、彤红的辣椒，热热闹闹，挨挨挤挤，让人感到一种生之乐趣。”本书是最全的一本汪曾祺谈吃的美文集，收入的汪曾祺书画和汪曾祺细腻冲淡的美文相得益彰，借汪曾祺美文以成美书，以飨读者。 矜功自伐 jīn gōng zì fá， 指自以为有功劳而夸耀， 出自《三国志·魏书·邓艾传》 仅此而已/ 紧锣密鼓 / 尽人皆知 / 进退失据 / 进退首鼠 仅此而已: 意思是只是这样罢了。出自《平凡的世界》。 噤若寒蝉/经国之才/经纶济世/经文纬武 荆钗布裙 jīng chāi bù qún，意思指荆枝作钗，粗布为裙；形容妇女装束朴素。 出自《为江敩让尚公主表》。 have only a thorn for a hairpin and plain cloth for a skirt 东汉书生梁鸿读完太学回家务农，与县上孟财主的30岁女儿孟光结婚，婚后他们抛弃孟家的富裕生活，到霸陵山区隐居，后来帮皋伯通打短工。孟光用荆条作钗，穿着粗布衣服，举案齐眉，夫妻十分恩爱。 荆棘塞途/荆天棘地/旌旗蔽日/惊诧莫名/惊人之笔 荆棘铜驼 jīng jí tóng tuó，意思是世乱荒凉。出自《晋书》。 西晋是中国历史上一个短暂而又黑暗的王朝，公元265年，由晋武帝司马炎取代曹魏政权而建立，定都洛阳。统治集团既腐朽不堪，又激烈地争权夺利，很快亡国，为时仅51年，倘若从灭掉东吴开始计算，则仅36年。当时有一个名叫索靖的人，早早就看出了西晋存在的严重问题，对它的灭亡作出了精准的预言。 索靖，字幼安，敦煌龙勒（今属甘肃省）人，出生在一个官宦之家，是东汉著名书法家张芝的姐姐的孙子，父亲索湛担任过北地太守。索靖年少时就有“逸群之量”，与同乡汜衷、张彪、索介、索永在洛阳太学读书，因为才艺过人，驰名海内，时人称“敦煌五龙”。因为“博经史，兼通内纬”，索靖年纪轻轻就被举荐为官，拜驸马都尉，随后历任尚书郎、酒泉太守、大将军、荡寇将军、散骑常侍等官职，封安乐亭侯，靖看问题细致入微，目光长远。西晋建立不久，就出现了官僚争相夸富、政治腐败等种种社会现象。他认真分析这些现象，预见到天下行将大乱，晋朝将走向衰亡，但自己又无力改变这一局面，于是郁闷不已。一天，他指着洛阳宫门外设置的铜驼，叹息道：“我会看到你们卧伏在荆棘中？”后来，索靖的预言果然应验。公元291年，西晋发生了“八王之乱”，朝政昏暗，各方争战不休，持续时间长达16年，都城洛阳（今白马寺以东，即所说的汉魏故城）遭到严重破坏。 太安二年（公元303年），河间王司马颙等举兵进犯洛阳，索靖被任要职，率关陇义兵参加保卫洛阳之战，不幸在战斗中受伤而死，卒年65岁。死后，他被追赠“司空”，谥曰庄。 索靖还是中国历史上一位有重要影响的书法家，以善写草书闻名于世，尤精章草，自名其字势力“银钩虿尾”。评论者形容他的书法“如风乎举，鸷鸟乍飞”，以状其遒劲；或谓“如雪岭孤松，冰河危石”，认为“其书名与羲（王羲之）、献（王献之）相先后也”。 惊鸿游龙 出自曹植《洛神赋》，解释为惊飞的鸿雁，游动的神龙。 形容体态轻盈，姿态婀娜，动作迅捷优美。 惊猿脱兔 jīng yuán tuō tù，意思是如受惊的猿猴、脱逃的兔子，形容迅速奔逃出。 startled monkeys or hare 出自 清·吴敬梓《儒林外史》第四十三回：“还亏得苗子的脚底板厚，不怕巉岩荆棘，就如惊猿脱兔，漫山越岭的逃散了。” 径行直遂/径情直遂 jìng xíng zhí suí，意思是随心愿行事而顺利达到目的。 出自《礼记·檀弓下》。 敬恭桑梓 指热爱故乡和尊敬故乡的人，出自《诗经·小雅·小弁》。 《诗经·小雅·小弁》：“维桑与梓，必恭敬止。” 敬老尊贤/敬谢不敏/赳赳武夫 鸠形鹄面 jiū xíng hú miàn，形容人因饥饿而身体瘦削、面容憔悴。 出自《资治通鉴·梁纪·简文帝大宝元年》：“死者蔽野，富室无食，皆鸟面鹄形。” 久假不归 jiǔ jiǎ bù guī，假：借。意思是原指假借仁义的名义而不真正实行，后指长期借用而不归还。 出处《孟子·尽心上》。 Appropriate sth. borrowed for the own use 久历风尘 意思是经历过很多艰苦的日子。 久梦乍回 意思是比喻从不明的事理中刚刚明白过来。 出自 明·冯梦龙等《东周列国志》第五十四回：“楚兵人人耀武，个个扬威，分明似海啸山崩，天摧地塌。晋兵如久梦乍回，大醉方醒，还不知东西南北。” 酒有别肠 意思是指酒量大小，与身材高矮无关。 清·吴任臣《十国春秋·闽·景宗纪》：“帝曰：‘维岳身甚小，何饮酒之多？’左右曰：‘酒有别肠，不必长大。’” 旧雨重逢 意思是老朋友又相遇了。出自清·尹会一《与王罕皆太史》。 旧雨今雨 典出《全唐文》卷三百六十〈杜甫二·秋述〉。“常时车马之客，旧，雨来；今，雨不来。”原意是，旧时，每逢下雨宾客也来，而现在一遇雨就不来了。 后以“旧雨新雨”代指老友新交。亦指老朋友与新朋友。 就坡下驴/居大不易 驹齿未落 jū chǐ wèi luò，意思是人尚年幼。出自《北史·杨愔传》。 杨愔(?－560年)，字尊彦，弘农灵宝(今河南灵宝)人。小时就有才名，魏永安初拜为散骑将军。后跟随高欢，官至右丞。北齐天宝初，与太原长公主成亲，升为尚书令，拜为骠骑大将军，封开府王。乾明初，孝昭帝高演篡位，杨愔被杀。杨愔幼时即学史书，十一岁便读《诗》、《易》，尤其喜爱《左氏春秋》。他的父亲杨津于是为他在院内竹林边特意建一小屋，让他独自学习。杨愔的从父兄弟黄门侍郎杨昱特别器重他，对别人说：“这小家伙乳牙还没脱落呢，就是我家的千里驹了，十年以后，更当驰骋千里之外了。” 鞠躬如仪 按照礼仪所要求的弯腰鞠躬。意指非常恭敬有礼。 跼蹐不安/局蹐不安 jú jí bù ān 形容恐惧不安。跼，弯腰。蹐，後脚接前脚地小步走。 跼蹐不安形容紧张恐惧，不知所措的样子。 《三国演义》第五十四回 吴国太佛寺看新郎 刘皇叔洞房续佳偶 瑜曰：“子敬乃诚实人也。刘备枭雄之辈，诸葛亮奸猾之徒，恐不似先生心地。”肃曰：“若此，如之奈何？”瑜曰：“子敬是我恩人，想昔日指囷相赠之情，如何不救你？你且宽心住数日，待江北探细的回，别有区处。”鲁肃跼蹐不安。 《京本通俗小说·冯玉梅团圆》：“徐信闻言，甚跼蹐不安，将自己虞城失妻，到睢阳村店遇见此妇始末，细细述了。” 跼蹐无地 jú jí wú dì 形容惶恐不安、无地容身的样子 明·冯梦龙等《东周列国志》第九十九回：“异人跼蹐无地，即下跪曰：‘某以客中孤苦，妄想要先生割爱，实乃醉后狂言，幸勿见罪!’” 跼天蹐地 jú tiān jí dì，意思是天虽高，却不得不弯着腰；地虽厚，却不得不小步走。形容处境困窘，戒慎、恐惧之至。 出自《诗经·小雅·正月》。 举鼎拔山/举国若狂 举例发凡 意思是分类举例，说明全书的体例。 出自 晋·杜预《春秋左氏传序》：“其发凡以言例，皆经国之常制。” 举直错枉/ 举直厝枉、举直措枉 jǔ zhí cuò wǎng，意思是起用正直贤良，罢黜奸邪佞人。 出自《论语·为政》。 appoint upright officials and remove the crooked ones 踽踽独行 jǔ jǔ dú xíng，意思是孤零零地独自走着。形容非常孤独。 孤零零地独自走着。形容非常孤独 出自《诗经·唐风·杕杜》。 踽踽凉凉 jǔ jǔ liáng liáng，意思是形容孤独寡合的样子。 出自《孟子·尽心下》。 walk alone 拒谏饰非 jù jiàn shì fēi，形容拒绝接受别人的规劝，掩饰自己的错误。 出自 战国·赵·荀况《荀子·成相》：“拒谏饰非，愚而上同，国必祸。” 具体而微 形容事物的内容大体具备，不过规模形状要小一些。 出自《孟子·公孙丑上》。 聚讼纷纭 意思是许多人在一起对某一问题议论纷纷，不能决定哪种意见是正确的。 出自《后汉书·曹褒传》《后汉书·冯衍传下》。 聚蚊成雷， 意思是许多蚊子聚到一起，声音会象雷声那样大。比喻说坏话的人多了，会使人受到很大的损害。 出自《汉书·中山靖王传》。 西汉时期，吴楚七王叛乱之后，汉武帝采取种种限制诸侯的措施，官府的权力大过诸侯。他为了平衡诸侯王之间的关系，请他们在一块喝酒作乐，席间奏幽微哀伤的乐曲，中山靖王刘胜哀伤地倾诉，希望不要听信谗言，聚蚊成雷会使流言影响兄弟之间关系 涓埃之功 很小的功劳的意思，出自《周书·萧撝传》。 涓滴归公 意思是形容属于公家的财物全部缴公，不占为私有。出自《官场现形记》。 every cent goes to the public 眷眷之心 意思是表示挚爱、热爱、依恋之心。 出自《诗经·小雅·小明》。 nostalgic feeling 决断如流 意思是决策迅速，顺畅。 出自《周书·斐汉传》。 抉瑕掩瑜/吹毛求疵 jué xiá yǎn yú，意思是故意挑剔玉上的斑点，埋没它的光彩。 比喻刻意挑剔别人的缺点和短处，而抹煞其优点和长处。 出自 唐·严郢《驳议吕諲》：“今太常议荆南之政详矣……乃抉瑕掩瑜之论，非中适之言也。” 绝甘分少 jué gān fēn shǎo，意思是好吃的东西让给人家，不多的东西与人共享；形容自己刻苦，待人优厚。 出自 汉·司马迁《报任少卿书》：“愚以为李陵素与士大夫绝甘分少，能得人之死力，虽古名将不过也。” 绝妙好辞 绝世蔑俗 蔑俗世俗,与社会格格不入 K 开诚相见 kāi chéng xiāng jiàn，意思是形容待人诚恳，显示出真心实意。 出自 《后汉书·马援传》：“且开心见诚，无所隐伏，阔达多大节，略与高帝同。” 开门揖盗/引狼入室 kāi mén yī dào，意思是开门请强盗进来，比喻引来坏人，招致祸患。 出自 《三国志·吴志·吴主传》：张昭对十八岁刚刚死了哥哥的孙权说“况今奸宄竞逐，豺狼满道，乃欲哀亲戚，顾礼制，是犹开门而揖盗，未可以为仁也。” open the door to thieves-court disaster 三国时代，江东的孙策遭了暗算，重伤而死。他的弟弟孙权这时才18岁，天天啼哭，无法处理朝政。大臣们劝说没用，都很着急。谋士张昭对孙权说：“现在天下大乱，豺狼满道，如果你只顾悲啼，不理国事……这好比大开着房门，拱着手把强盗请来，必将自取其祸。”孙权觉得说的对，马上换了朝服，登朝理事，视察军队，安定了军心、民心。 开物成务 意思是通晓万物之理，得以办好各种事情。\\出自《易·系辞上》。 涉猎不休，经史百氏，开物成务，以发厥志。（宋·陈亮《祭俞德载知县文》） 明代科学家宋应星在所著的《天工开物》中对“开物”进行了解释，“开物”指人开发万物，即是通过人的努力奋斗使万物升值，也是中国古代天人合一思想的体现。 开柙出虎 kāi xiá chū hǔ，意思是原指负责看管的人未尽责任。后多比喻放纵坏人。 释义：柙：关猛兽的木笼 出处《论语·季氏将伐颛臾》 季康子是春秋时代鲁国的大夫,权势极大,甚至超过了当时的国君鲁哀公。季康子想攻打自己封地附近鲁国的一个附属国颛臾。 孔子的学生冉有和子路当时都是季康子的家臣,把这一消息告诉了孔子。孔子说:“恐怕要责备你们了吧?颛臾国还是当年先王封的,而且它是鲁国境内的一个附属国,为什么要去攻打它呢?”冉有说:“这是季康子的主意,我和子路都不想这样做。” 孔子说:“商朝的太史周任说:‘作大臣的要尽忠职守,否则不要呆在那个位置上。’盲人站立不稳却不扶一扶,跌倒了也不搀起来,那又何必要用助手呢?而且你的话也不对,老虎、犀牛逃出笼子伤人(虎兕(si)出于柙(xia)),龟甲、宝玉在匣子里毁坏了(龟玉毁于犊),是谁的过错呢?” “开柙出虎”指负责看管的人未尽责任。现多比喻放纵坏人。 开宗明义 指说话、写文章一开始就讲明主要意思。出自《孝经·开宗明义》。 欬唾成珠 ké tuò chénɡ zhū, 释义为言谈精当，议论高明或文词优美。 子不见夫唾者乎？喷则大者如珠，小者如雾。 语本《庄子·秋水》 另楚寒巫、血竭髯枯、糜鹿姑苏、鼻青眼乌、六尺之孤、白刀子进，红刀子出、粪土之墙不可杇、精神恍惚、一介之夫、负重吞污。 看人眉睫 比喻看人脸色 《北史·崔亮传》：”时陇西李冲当朝任事，亮从兄光往依之，谓亮曰：“安能久事笔砚，而不往托李氏也? 彼家饶书，因可得学。”亮曰：“弟妹饥寒， 岂容独饱? 自可观书于市，安能看人眉睫乎!“ 看朱成碧 意思是形容将红的看成绿的。形容眼睛发花，近似词：“看碧成朱”。 出自南朝·梁·王僧孺《夜愁示诸宾》。 科头跣足 kē tóu xiǎn zú，意思是光着头赤着脚。 出自《史记·张仪列传》。 科头：不戴帽子；跣足：光脚。 渴骥奔泉 kě jì bēn quán，意思是像口渴思饮的骏马，奔向甘泉；形容书法笔势矫健；也比喻迫切的欲望。 《新唐书·徐浩传》：“尝书四十二，幅屏，八体皆备，草隶尤工，世状其法曰：‘怒猊抉石，渴骥奔泉。’” 唐朝时期，中书舍人徐浩深得唐肃宗的信任，专门为朝廷起草重要文件，他才思敏捷，字写得好。他向肃宗提出许多建议得到采纳，被任命为国子祭酒。他对书法很有研究，精于楷法，写字圆劲厚重，自成一家，如渴骥奔泉。 [2] 克绍箕裘 kè shào jī qiú，意思是比喻能继承父、祖的事业。 出自《礼记·学记》。 be a worthy son to an able father 刻肌刻骨 kè jī kè gǔ，意思是形容感受极深刻。 出自 三国·魏·曹植《上责躬应诏诗表》：“刻肌画骨，迫思罪戾，昼分而食，夜分而寝。” 恪守不渝 意思是严格遵守，决不改变。 恪：谨慎,恭敬。 渝:改变。 客囊羞涩 意思是旅途中缺钱。 肯构肯堂/肯堂肯构 《尚书·大诰》：“以作室喻治政也。父已致法，子乃不肯为堂基，况肯构主屋乎？” 原意是儿子连房屋的地基都不肯做，哪里还谈得上肯盖房子。 后反其意而用之，指修缮房屋，用来比喻子承父业。 空谷足音 意思是在寂静的山谷里听到脚步声。 比喻极难得到音信、言论或来访,或事物 《诗经·小雅·白驹》 “皎皎白驹，在彼空谷。” 《庄子·徐无鬼》：“闻人足音跫然而喜也。” 孔席墨突/席不暇暖 kǒng xí mò tū，意思是孔子、墨子四处周游，每到一处，坐席没有坐暖，灶突没有熏黑，又匆匆地到别处去了。 形容忙于世事，各处奔走。 《淮南子·修务训》：“孔子无黔突，墨子无暖席。”汉·班固《答宾戏》：“是以圣哲之治，栖栖遑遑，孔席不暖，墨突不黔。” 春秋战国时期，孔子为了鼓吹他的治国之道，经常到处游说。墨翟反对恃强欺弱的战争，呼吁平等互爱，经常奔走各个诸侯国，到处宣传他的“非战”主张。他四处奔走，从来没有一个固定长住的住处。汉朝班固评价他们为：“孔席不暖，墨突不黔。” 口耳之学 指只知道耳朵进口里出的一些皮毛之见，而没有真正的学识。 口耳之学后也指从道听途说中获取的片断知识。 口惠而实不至 只在口头上答应给别人好处，而实际的利益却到不了别人身上 口尚乳臭 kǒu shàng rǔ xiù，意思是对年轻人的轻视。 出自东汉·班固《汉书·高帝纪上》。 口血未干 意思是古时订立盟约，要在嘴上涂上牲口的血；指订约不久就毁约。 出自《左传·襄公九年》。 口中雌黄/枯木死灰/哭天抹泪/阔步高谈 枯木朽株 kū mù xiǔ zhū，意思是指枯木头，烂树根；比喻衰弱的力量、势力，或衰老无用的人。 出自汉·邹阳《狱中上梁王书》。 宽猛相济 意思是指政治措施要宽和严互相补充。 出自《左传·昭公二十年》。 狂奴故态 意思是指所谓狂士的老脾气，出自《后汉书·严光传》。 汉朝严子陵与刘邦第九代孙子刘秀、长安侯霸三人结为非常要好的朋友。刘秀当上皇帝后，严子陵十分讨厌做官，有时故意刺激光武帝刘秀，但刘秀仍很尊敬他。侯霸当上大司徒以后，专门去请严子陵叙旧，他写信回绝，刘秀骂他是狂奴故态 《後汉书·逸民传·严光》：“司 徒侯霸与光素旧，遣使奉书。使人因谓光曰：‘公闻先生至，区区欲即诣造，迫於典司，是以不获。原因日暮，自屈语言。’光不答，乃投札与之，口授曰：‘君房足下，位至鼎足，甚善。怀仁辅义天下悦，阿谀顺旨要领绝。’霸得书，封奏之，帝笑曰：‘狂奴故态也。’” 大概意思是：东汉隐士严光跟光武帝刘秀本来是同学。司徒侯霸也严光是老朋友。有一次侯霸差人去请光相见，光投一札给来人，说：“君房（侯霸字）足下，位至鼎足，甚善。怀仁辅义天下悦，阿谀顺旨要领绝。”侯霸把这封信奏光武帝，帝笑曰：“狂奴故态也！” 揆情度理 kuí qíng duó lǐ，意思是按照情和理估量，推测。 出自《淮南子·兵略训》。 跬步不离 kuǐ bù bù lí，意思是指半步也不离开，形容关系十分密切。 出自《宋史·包恢传》。 昆弟之好 释义是兄弟般的情谊。 出自明·冯梦龙《东周列国志》。 L 兰艾同焚 lán ài tóng fén，意思是兰花跟艾草一起烧掉。 比喻不分好坏，一同消灭。 出自 《晋书·孔坦传》：“兰艾同焚，贤愚所叹。” 兰摧玉折 意思是原指守身贞洁而死。后多作哀悼人不幸夭折之辞。 出自《世说新语·言语》。 兰桂齐芳 意思是指儿孙同时显贵发达，又比喻子孙后代一起取得荣华富贵。 出自《群音类选·百顺记·王曾祝寿》 兰因絮果 意思是比喻男女婚事初时美满，最终离异。 The vicissitudes of life 狼奔豕突 láng bēn shǐ tū，意思是形容成群的坏人乱冲乱撞，到处骚扰。 出自《万古愁》。 run like a wolf and rush like a boar 劳而无功 意思指花费了力气，却没有收到成效。 出自《管子·形势篇》 老成持重/老王卖瓜/老于世故/乐天知命/冷若冰霜 老僧入定 意思是和尚静坐，使心定于一处，不起杂念，叫入定。 形容人静静地端坐着。 出自《孽海花》 乐不可言 意思是快乐到了极点，没法用语言来表达。 出自《大招》 冷语冰人 意思是用冷酷的话伤人，出自《类说·〈外史梼杌〉》。 离鸾别凤 lí luán bié fèng，意思是比喻夫妻离散。出自《湘妃》 礼让为国 意思是指以礼所提倡的谦让精神治理国家。 出自《论语·里仁》。 李代桃僵 意思是李树代替桃树而死，原比喻兄弟互相爱护互相帮助，后转用来比喻以此代彼或代人受过，在军事战略上，三十六计之一，指在敌我双方势均力敌，或者敌优我劣的情况下，用小的代价，换取大的胜利的谋略，类似于象棋中的“舍车保帅”战术。 出自北宋郭茂倩《乐府诗集·鸡鸣》。 have punished a wrong man;substitute one thing for another;palm off a substitute for the real thing;sacrifice oneself for another person 反义词尺布斗粟、兄弟参商、萁豆相煎 正确认识局部和全局的得失关系，有时需要牺牲局部利益，以减少更大的损失或换取全局的胜利。有时则需要放弃局部可得之微利，而去争取更大全局胜利。 理屈词穷/力不能支/力穷势孤 立地书厨/著脚书楼、硕学鸿儒 意思是比喻读书多学识广的人。 a walking encyclopedia 利口便舌 能言善辩,花言巧语 联翩而至 意思是形容人接连来到（多用于大的集会）。 出自 晋·陆机《文赋》：“滔藻联翩。” 梁孟齐眉/举案齐眉 量才录用 意思是根据才能大小安排一定工作。 出自《礼记·王制》。 聊报涓埃 姑且作一个小小的回报。多用为自谦。 涓： 细小的水流。埃： 尘土 聊复尔尔 意思是姑且如此而已。 出自《凤凰池》。 聊胜于无/聊以自慰 聊以塞责 liáo yǐ sè zé，意思是姑且应付一下，算是交代了责任。 出自《通鉴纪事本末》。 trump up so as to avoid blame 聊以卒岁 意思是勉强地度过一年。 出自《左传·襄公二十一年》。 撩云拨雨 意思是指人调弄风情。 出自《投梭记·折齿》。 列鼎而食 liè dǐng ér shí，意思是形容豪门贵族的奢侈生活。 出自《说苑·建本》。 子路对孔子说：“背著重物去远方，不会选择休息的地方，家里穷服侍父母，做官不考虑俸禄的多少。我从前侍奉父母时，吃灰菜，要到百里之外去背米。双亲去世後，我南来楚国做官，跟随的车马百辆，家里的粮食万石，累茵（几重埝子）而坐，列鼎而食，但我想吃灰菜、为父母背米，却再也不可能了。”孔子说：“子路侍奉双亲，可谓生前尽力，死後尽思。”（出自《孔子家语》卷二） 林下风气 意思是指女子态度娴雅、举止大方。 出自南朝·宋·刘义庆《世说新语·贤媛》。 临渴掘井 临难不苟/临难不屈/临难苟免 意思是遇到危难不苟且偷生。 出自《礼记·曲礼上》。 临深履薄 意思是面临深渊，脚踩薄冰。比喻小心谨慎，惟恐有失。 出自 《诗经·小雅·小旻》：“战战兢兢，如临深渊，如履薄冰。” 东汉明帝皇后马氏生性善良，深明大义，她十分喜欢贾妃所生的刘炟。刘炟继位成汉章帝，尊马氏为皇太后，多次提出加封马氏的兄弟，马后拒绝。而她的侄子马豫抱怨没得到更多的恩惠，杨终劝马廖面临深渊，脚踏薄冰，不能放纵儿子 临食废箸 意思是临到吃时却丢掉了筷子。形容心神不安的样子。 出自《东周列国志》。 throw down chopsticks at meals 临事不苟 lín shì bù gǒu。 碰到事情不苟且。形容做事认真 临崖勒马/凛然正气 麟肝凤髓/龙肝凤髓 意思是麒麟的肝，凤凰的骨髓。比喻珍稀的美味佳肴。 出自五代·王定保《唐摭言·载应不捷声价益振》 真个鹿脯豹胎，麟肝凤髓，无一不陈。 ★清·何镛《乘龙佳话·宾筵》 凌弱暴寡 意思是侵犯弱小的，欺侮孤单的。 出自《商君书·画策》。 羚羊挂角 意思是指羚羊夜宿时挂角于树，脚不着地，以避祸患，旧时多用该词语比喻诗的意境超脱。 出自陆佃的《埤雅·释兽》。 宋·严羽《沧浪诗话·诗辨》说：“诗者，吟咏情性也。盛唐诸人，惟在兴趣，羚羊挂角，无迹可求。故其妙处，透彻玲珑，不可凑泊。”他还用“空中之音、相中之色、水中之月、镜中之像”来形容这种“言有尽而意无穷”的空灵玄远的诗境。 零敲碎打 意思是形容以零零碎碎、断断续续的方式进行或处理。 出自《&lt;中国农村的社会主义高潮&gt;的序言一》 do sth. bit by bit;off and on; adopt a piecemeal approach; make two bites of a cherry 令出必行 指命令一发出，就必须贯彻执行。 令人齿冷 意思是比喻使人瞧不起。 出自《南史·乐预传》 溜之乎也 意思是溜走讽刺的、风趣的说法，出自清·吴趼人《痛史》 流波送盼 形容女子含情地看别人。 流风遗韵/流风余韵 流金铄石 liú jīn shuò shí，意思是形容天气酷热，好像金石都要熔化。 出自《楚辞·招魂》。 make rocks and metals melts 流离转徙/流年不利/流水不腐/柳陌花巷/柳陌花街/柳巷花街 六尺之孤 意思是指没有成年的孤儿。 出自《论语·泰伯》 六畜不安 意思是牲畜也不得安宁，形容骚扰得很厉害。 出自《老残游记》。 successive family misfortunes 六街三市 意思泛指大街小巷。 出自《资治通鉴·唐纪睿宗景云元年》。 六韬三略 中国古代重要的军事著作。后泛指兵书、兵法。 龙驹凤雏 lóng jū fèng chú 意思是比喻英俊秀颖的少年，常作恭维语。 出自《晋书·陆云传》。 晋朝时期，陆机的弟弟陆云六岁时就能作文，文气很好。因此年少时就与哥哥齐名，虽然文章没有陆机那么优美，但是论点十分犀利。一次吴尚书广陵闵鸿看见陆云感慨地说：“此儿若非龙驹，当是凤雏。” 龙眉凤目 意思是形容人英俊，气度不凡。 出自《水浒传》。 龙蛇飞动 意思是仿佛龙飞腾，蛇游动；形容书法气势奔放，笔力劲健。 出自《西江月·平山堂》。 龙吟虎啸/龙章凤姿 陋巷蓬门 镂冰雕朽 lòu bīng diāo xiǔ，意思是雕刻冰块和朽木。比喻劳而无功。 出处《北史 儒林传序》。 镂骨铭心 意思是铭刻在心灵深处。形容记忆深刻，永远不忘。 出自《颜氏家训·序政》。 be engraved in the bones and printed on the heart 镂月裁云 lòu yuè cái yún，意思是雕刻月亮，裁剪云彩；指手艺极精巧。 唐·李义府《堂堂词》：“镂月成歌扇，裁云作舞衣。” 清·赵翼《赠张吟芗》：“倚声绝艺似珠圆，镂月裁云过百篇。” 清·刘大观《玉磬山房诗集》卷九《和殷月圃&lt;白菊&gt;》：“镂月裁云劳化工，剪齐还藉一篱风。浮来酒面香无际，沁入诗脾味不同。开到岁寒弥皎洁，蕊为霜压复玲珑。花中亦有陶元亮，收敛才华作钝翁。” 泄露春光 鲁莽灭裂 粗鲁莽撞；灭裂：轻率。 形容行动粗鲁莽撞，做事草率，不负责任。 出自《庄子·则阳》。 鲁鱼帝虎/鲁鱼亥豕、鱼鲁帝虎 意思是指文字传抄错误。 出自 晋·葛洪《抱朴子》：“谚云：‘书三写，鱼成鲁，帝成虎。’” 勠力同心/旅进旅退/屡次三番/履薄临深 履霜坚冰 意思是踩着霜，就想到结冰的日子就要到来；比喻看到事物的苗头，就对它的发展有所警戒。 出自《周易·坤》：“初六，履霜坚冰至。象曰：履霜坚冰，阴始凝也；驯致其道，至坚冰也。” 履险如夷 鸾俦凤侣/燕侣莺俦 意思是指男女欢爱如鸾凤般相谐作伴。出自《好逑传》第16回。 鸾凤和鸣 意思是指鸾鸟凤凰相互应和鸣叫，比喻夫妻和谐。 出自《左传·庄公二十二年》。 乱箭攒心 鸾翔凤集 意思是鸾鸟在飞翔，凤凰成群地歇在这里。比喻优秀的人才汇聚到一起。 出自 晋·傅咸《申怀赋》：“穆穆清禁，济济群英。鸾翔凤集，羽仪上亲。” 乱琼碎玉 意思是雪花。 出自明·兰陵笑笑生《金瓶梅词话》。 掠人之美 lüè rén zhī měi，夺取别人的成绩、荣誉归自己所有。 出自《左传·昭公十四年》。 略识之无 意思是形容识字不多。 出自《与元九书》。 沦肌浃髓/沦浃肌髓 lún jī jiā suǐ，沦：浸没。浃：湿透。 意思是透入肌肉和骨髓，比喻感受深刻。 extreme gratitude 出自《淮南子·原道训》。 罗雀掘鼠 原指张网捉麻雀、挖洞捉老鼠来充饥的窘困情况，后比喻想尽办法筹措财物。 出自《新唐书·张巡传》。 捋臂揎拳 luō bì xuān quán，意思是卷起袖子，伸出拳头，准备动手。 出自《碧桃花》。 喜则眉花眼笑，怒则捋臂揎拳。 ★清·夏敬渠《野叟曝言》第四十七回 荦荦大者 luò luò dà zhě，意思是指明显的重大的方面。 出自《史记·天官书》。 落笔千言 落花有意流水无情/襄王有意神女无情 落落寡合 形容跟别人合不来。 出自明・名教中人《好逑传》 落落寡欢 形容孤单寂寞，心中不快 落魄不偶 古代一种迷信观念，认为偶数好，奇数不好。落魄：倒霉、潦倒；不偶：运气不好。 出处：明·罗贯中《三国演义》第三十五回：“吾久闻明公大名，何故至今犹落魄不偶耶？” 落魄：倒霉、潦倒；不偶：运气不好。 落拓不羁 luò tuò bù jī，意思是形容人性情豪放，行为散漫。 出自《北史·杨素传》。 unconventional and unre strained. M 马齿徒增 意思是马的牙齿有多少，就可以知道它的年龄有多大； 比喻自己年岁白白地增加了，学业或事业却没有什么成就。 出自《谷梁传·僖公二年》。 春秋时期，晋献公一心想吞并虢国，苦于没有路到达。大夫荀息建议用骏马和美玉作为交换条件，换取虞国借道。晋献公忍痛割爱拿出骏马和美玉。晋国轻而易举灭了虢国，荀息于是马上建议灭掉虞国，夺回了美玉和骏马，玉还是原来的玉只是骏马多长了几颗牙齿而矣 马耳东风 意思是比喻把别人的话当作耳边风。 出自《答王十二寒夜独酌有怀》。 马前泼水/覆水难收 意思是比喻夫妻离异，无法挽回。也是京剧经典曲目之一。 出自钱钟书《围城》。 汉朝书生朱买臣年轻时家里十分贫穷，每天靠打柴卖维持生计，但他坚持好学，经常边走边背诵书本。他的妻子以此为耻辱就离他而去。后来朱买臣考学当上太守，他的前妻要求复婚，他将水泼在马前，教她收回就复婚。 马首是瞻 意思原指作战时士卒看主将的马头行事，后比喻服从指挥或依附某人。 出自于《左传·襄公十四年》 春秋时期，秦国十分强大，常欺负那些弱小的诸侯国。引起了众诸侯国的强烈反感。公元前559年，晋悼公联合了其他诸侯国，组成联军去攻伐秦国。 诸侯联军的是晋国的中军帅荀偃。他原先估计，秦国得知诸侯联军来进攻，肯定会惊慌失措，战争很容易取胜。没想到联军内部各怀异志，并不齐心，士气也很低落，秦国得知这些情况，所以一点也不怕，根本就没有求和的表示。秦军还在泾河的上游放毒，毒死了不少联军的士兵。 看到这种情况，荀偃就想早点发动总攻，他向联军将领发布命令说：天亮鸡一叫，我们就准备出发，各军都要拆掉土灶，填平水井，以便布阵。作战时，大家都看着我的马头来行动，我指向哪里，大家就奔向哪里。 荀偃手下的将领听了他的话，觉得他太专横了，很反感。下军帅栾黶说：晋国从来就没有下过这种命令。你要向西去打秦国，那你自己去吧，我的马头可要向东，回到我们晋国去。 其它诸候国的将领看到晋国的将领带兵回国，也纷纷撤回自己国家去了。全军顿时不战自乱，荀偃眼看无法挽回，也只好狼狈地撤军了 买空卖空 意思是买卖双方都没有货款进出，只就进出之间的差价结算盈亏。也用来比喻政治上招摇撞骗的投机活动。 出自《宣宗圣训·清道光帝上谕》。 卖剑买牛/卖刀买犊 意思是指放下武器，从事耕种。后比喻改业务农或坏人改恶从善。 出自《汉书·龚遂传》。 sell one’s swords to buy oxen for farming 【近义词】：偃武修文、马放南山、刀枪入库 “惟有躬耕差可为，卖剑买牛悔不早。”宋·陆游《贫甚作短歌排闷》诗 。 “卖剑买牛吾欲老 ，杀鸡为黍子来无？”苏轼《常润道中有怀钱塘五首》之五。 “乞浆得酒人情好，卖剑买牛农事兴 ” 陆游《游近村》诗 。 “ 卖剑买牛真得计，腰金骑鹤恐非才。”元好问《示崔雷诗社诸人》诗。 “冠归农，剑买牛。繙图史，凿田畴，睢阳世世如金瓯。” 明 陈继儒《大司马节寰袁公（袁可立）家庙记》 卖儿鬻女 mài ér yù nǚ，意思是指生活无依，被迫卖掉自己的儿女。 出自《官场现形记》。 sell his son and daughter 卖官鬻爵/满面春风/漫不经意 蛮触之争 意思是在蜗牛两角的两个小国，因细小的缘故而引起的争端。出自《庄子·则阳》 传说古代有一只蜗牛的两个触角上有两个小国，左边的叫触氏国，右边的叫蛮氏国。两个国家因为争夺地盘而经常发生战争，有时竟伏尸百万，血流成河，造成民不聊生，怨声载道，蜗牛因此而丧失触觉功能 瞒心昧己 意思是形容违背良心干坏事。 出自《曲江池》。 满坑满谷 意思是充满了谷，充满了坑。形容多得很，到处都是。 出自《庄子·天运》。 慢藏诲盗 意思是收藏财物不慎，等于诱人偷窃。 慢藏：不认真掩藏；诲：教导。 出自《周易·系辞上》：“慢藏诲盗，冶容诲淫。” 芒刺在背/如坐针毡、六神无主、坐立不安、如芒在背、如芒刺背、忐忑不安 形容内心惶恐，坐立不安。 出自《汉书·霍光传》。 公元前87年汉武帝死后，他年仅8岁的小儿子刘弗陵即位。 史称汉昭帝。按照武帝的遗诏，由大司马大将军霍光、御史大夫桑弘羊等辅政，掌握朝廷军政大权：昭帝的寿命不长，21岁就死了。他没有儿子，于是霍光把武帝的孙子刘贺立为皇帝。后来，霍光发现刘贺生活放荡不堪，整天寻欢作乐，经与大臣们商量，把刘贺废掉，另立武帝的曾孙刘询为帝。这就是汉宣帝。不过刘询也很清楚，霍光的权势很大，自己的生死存废完全决定于他，因此对他很害怕。刘询即位后做的一件大事，就是去谒见祖庙。到了那一天，宣帝乘坐一辆装饰华丽的马车，霍光就坐在马车一侧陪侍，皇帝见霍光 身材高大，脸容严峻，不由自主地觉得非常畏惧，惶恐不安，就像有芒刺在背上那样难受。此后，宣帝见到霍光，总是小心翼翼。公元前68年霍光病死，乘车时再也没有他陪侍，宣帝才感到无拘无束，行动自由了 盲人瞎马/茫无头绪 猫鼠同眠 意思是猫同老鼠睡在一起，比喻官吏失职，包庇下属干坏事，也比喻上下狼狈为奸。 出自《新唐书·五行志》。 thieves and police work together,as the cat and the rat sleep together 毛举细故 指烦琐地列举小事情，加以责难或攻击。 出自《论治体札子》。 茅椽蓬牖 máo chuán péng yǒu 出自《红楼梦》第一回，解释为屋顶、窗子都是用茅草、蓬蒿搭盖。形容居住条件简陋，生活贫困 茅，指盖屋的草；椽：架在屋顶檩木上的木条。牖：窗户。蓬牖：用蓬草编成的窗户。 【示例】《红楼梦》第一回：“虽今日之茅椽蓬牖，瓦灶绳床，其晨夕风露，阶柳庭花，亦未有妨我之襟怀笔墨者。” 茅茨土阶 máo cì tǔ jiē，意思是茅草盖的屋顶，泥土砌的台阶;形容房屋简陋，或生活俭朴。 出自 汉·张衡《东京赋》：“慕唐虞之茅茨。思夏后之卑室。” 酕醄大醉 Máo táo dà zu 形容喝酒后醉得很厉害 酕醄：大醉的样子。 《东周列国志》六九回：“蔡候欢饮，不觉酕醄大醉。” 美意延年 měi yì yán nián，意思是对一切乐观的人，能够健康长寿。 出自 《荀子·致士》：“得众动天，美意延年。” 美玉无瑕/扪心无愧/扪心自问/昧己瞒心 孟光举案/举案齐眉 梦断魂劳 意思是睡梦中也想着，弄得心神不宁。 出自元·王元和《小桃红·题情》 弥天亘地 满天遍地，形容极大极多。 米珠薪桂/靡靡之音/觅衣求食 眠花卧柳 意思是比喻狎妓。同“眠花宿柳”。 出自《金瓶梅词话》。 那柳湘莲原系世家子弟，读书不成，父母早丧，素性爽侠，不拘细事，酷好耍枪舞剑，赌博吃酒，以至眠花卧柳，吹笛弹筝，无所不为。 ★《红楼梦》第四七回 面墙而立 意思是不学之人，如面对墙壁而立，一无所见。 出自《尚书·周官》 面是背非 意思是当面赞成，背后反对。 出自《尚书·益稷》。 面授机宜 意思是当面指示处理事务的方针、办法等 出自《官场现形记》。 苗而不秀 意思是指庄稼出了苗而没有抽穗；比喻人有好的资质，却没有成就。 出自《论语·子罕》。 苗：指庄稼出苗；秀：庄稼吐穗开花。 北周·庾信《伤心赋序》：“羁旅关河，倏然白首，苗而不秀，频有所悲。” 渺无人烟/渺无音讯 妙语解颐 意思是有趣的话引人发笑。 出自《汉书·匡衡传》。 灭此朝食 miè cǐ zhāo shí，意思是让我先把敌人消灭掉再吃早饭，形容急于消灭敌人的心情和必胜的信心。 出自《左传·成公二年》。 民不堪命 意思是指民众负担沉重，痛苦得活不下去。 出自《左传·桓公二年》 民和年丰/名公钜卿/名公巨卿/名流轶事/名缰利锁 名山事业 意思是多指著书立说。出自《史记·太史公自序》。 名下无虚 原意是名气大的人一定有真才实学，后比喻名不虚传。 出自唐·姚思廉《陈书·姚察传》。 明眸皓齿/明若观火/明正典刑/冥顽不灵/铭肌镂骨/冥思苦索 明效大验 意思是显著而又巨大的效验。 出自《汉书·贾谊传》。 明心见性 明心是发现自己的真心；见性是见到自己本来的真性。 见到自己本来的真性了，所以说是直指本心。明本心，见不生不灭的本性。 乃禅宗悟道之境界。言语道断、心行处灭。 明珠弹雀 意思是用珍珠打鸟雀，比喻得到的补偿不了失去的。 出自《太玄经·唐》 螟蛉之子 míng líng zhī zǐ，意思是比喻义子。 出自《诗经·小雅·小宛》。 酩酊大醉/烂醉如泥、酩酊烂醉 mǐng dǐng dà zuì，释义是形容醉得很厉害。 出自 北魏·郦道元《水经注·沔水》：“日暮倒载归，酩酊无所知。” 命蹇时乖 意思是指命运不济，遭遇坎坷。这是唯心主义宿命论的观点。 出自《金钱记》第三折。 谬种流传 miù zhǒng liú chuán，意思是泛指荒谬的东西一代代地传下去。 出自《宋史·选举志二》。 宋朝时期，何澹见当时科举考试制度不严，考场上贿赂成风，致使没有真才实学的人投机取得功名，他向朝廷上奏折，指出先科考试的种种弊端与危害。如果考试不严，所选人才质量就不高，隔几年由他们主持考试，那么就会让谬误的根子代代相传。 摩顶放踵 mó dǐng fàng zhǒng，意思是从头顶到脚跟都擦伤了；形容不辞劳苦，不顾身体。 出自《孟子·尽心上》。 摩肩挨背/摩肩接毂/摩肩接踵 磨砺以须 意思是磨快刀子等待。比喻做好准备，等待时机。 出自《左传·昭公十二年》。 末大必折 mò dà bì zhé，意思是指树木枝端粗大，必折其干。比喻下属权重，危及上级。 出自《左传·昭公十一年》 末路之难 意思是走最后一段路程是艰难的。比喻越到最后，工作越艰巨。也比喻保持晚节不易。 出自《战国策·秦策五》：“‘行百里路，半于九十’，此言末路之难。” 末学肤受 指学问没有从根本上下工夫，只学到一点皮毛。 出自汉·张衡《东京赋》：“若客所谓末学肤受，贵耳而践目者也。” 清·梁启超《饮冰室文集》原序：“而况乎末学肤受如鄙人者，偶有论述，不过演师友之口说，拾西哲余唾，寄他人之脑之舌于我笔端而已。” 莫此为甚 意思是指某件事情严重、厉害的程度。 出自《容斋三笔》 莫敢谁何 意思是没有谁敢怎么样。 汉·贾谊《过秦论》：“信臣精卒，陈利兵而谁何。 莫可名状 意思是不能用言语来形容。指事物极复杂微妙，无法描述。 出自清·张潮《虞初新志·林四娘记》 indescribable 莫可指数 释掰着指头也数不过来，形容数量很多 莫与为比 莫，没有什么。没有什么能够与之相比。 《初刻拍案惊奇》卷9：“那朝有个宣徽院使叫李罗，是个色目人……生自相门，穷极富贵，第宅宏丽，～。” △多作褒义，指已是最好，无可比拟。 莫予毒也 表示目空一切，认为谁也不能伤害我，或可以为所欲为的意思。 出自《左传·僖公二十八年》 春秋时期，城濮之战中楚军被晋文公打败，楚国名将子玉（成得臣）因而自杀。晋文公听了很高兴的说：“莫予毒也已。”意思是说，从此以后再也没有人能伤害我了。 墨突不黔 mò tū bù qián ，意思是原指墨翟东奔西走，每至一地，烟囱尚未熏黑，又到别处去了。后用其事为典。 形容事情繁忙，犹言席不暇暖。 “是以圣哲之治，栖栖遑遑。孔席不暖，墨突不黔。”——东汉·班固《答宾戏》 战国时期，大思想家墨翟反对恃强欺弱的战争，呼吁平等互爱，经常奔走各个诸侯国，到处宣传他的“非战”主张。由于他四处奔走，从来没有一个固定长住的住处。汉朝班固评价他为：“孔席不暖，墨突不黔。” 木本水源 意思是指树的根本，水的源头。比喻事物的根本或事情的原因。 出自《左传·昭公九年》。 puresim 目不暇给/目不暇接 目不忍睹 目光如豆 意思是眼光像豆子那样小，形容目光短浅，缺乏远见。出自清·钱谦益《列朝诗集小传·丁集下·茅待诏元仪》。 目击道存 意思是形容悟性好 出自《庄子·田子方》。 南朝宋．刘义庆《世说新语．栖逸》刘孝标注引《竹林七贤论》：「籍归，遂著大人先生论，所言皆胸怀闲本趣，大意谓先生与己不异也。观其长啸相合，亦近乎目击道存矣。」 目无余子 目指气使 用眼神和气色指使人。形容骄横傲慢的样子。 出自《说苑·君道》。 give order by look or glance 幕天席地 把天做幕，把地当席，指露天。原形容性情豁达，现形容在野外工作的艰苦生活。 也用来形容行为放旷。 出自 晋·刘伶《酒德颂》：“日月为扃牖，八荒为庭衢。行无辙迹，居无室庐。幕天席地，纵意所如。” 有大人先生，以天地为一朝，万期为须臾。日月为扃牖，八荒为庭衢。行无辙迹，居无室庐。幕天席地，纵意所如。止则操卮执觚，动则挈榼提壶。唯酒是务，焉知其余。有贵介公子，搢绅处士。闻吾风声，议其所以。乃奋袂攘襟，怒目切齿。陈说礼法，是非锋起。先生于是方捧罂承槽，衔杯漱醪。奋髯踑踞，枕曲藉糟。无思无虑，其乐陶陶。兀然而醉，豁尔而醒。静听不闻雷霆之声，熟视不泰山之形。不觉寒暑之切肌，利欲之感情。俯观万物，扰扰焉如江汉之载浮萍。二豪侍侧，焉如蜾蠃之与螟蛉。 白居易《小庭亦有月》：“客散有余兴，醉卧独吟哦。幕天而席地，谁奈刘伶何。” 马致远《陈抟高卧》第三折：“睡时节幕天席地，黑喽喽鼻息如雷。” 吴承恩《西游记》第六十三回：“众兄弟在星月光前，幕天席地，举杯叙旧。” N 拿糖作醋 摆架子，装腔作势 南箕北斗 nán jī běi dǒu，意思是比喻徒有虚名而无实用。 出自《诗经·小雅·大东》。 难乎为继 意思是难于继续下去。 囊萤映雪/逆耳利行 讷言敏行 nè yán mǐn xíng，意思是指说话谨慎，办事敏捷，出自于《论语·里仁》。 内顾之忧 旧时形容没有妻子，身在外又要顾虑家事。 现形容有内部的忧虑。 出处 晋·左思《咏史》诗：“外望无寸禄，内顾无斗储。” 内视反听 意思是指既能反省自己的言行，也能听取别人的意见。 出自《史记·商君列传》。 脑满肠肥/拈轻怕重 年高德劭 年纪大，品德好。出自《法言·孝至》。 念兹在兹 niàn zī zài zī，意思是泛指念念不忘某一件事情，出自《尚书·大禹谟》 袅袅婷婷 niǎo niǎo tíng tíng，意思是形容女子姿态柔美。 出自《隋唐演义》。 curvaceous and soft 涅而不缁 niè ér bù zī，意思是用涅染也染不黑。 比喻品格高尚，不受恶劣环境的影响。 春秋时期，孔子和他的政治理想在鲁国未受到珍视和重用，于是带领弟子们周游列国，先后在卫国、宋国等国家，也未被重视。在赴晋国的途中，子路劝他不要去投奔赵鞅这种小人。然而孔子相信自身的君子品格，会“磨而不磷，涅而不缁”，不会因外界而受影响，不会因赵鞅而改变，反而可以改变他人 牛溲马勃 niú sōu mǎ bó，意思是比喻一般人认为无用的东西，在懂得其性能的人手里可成为有用的物品。 唐·韩愈《进学解》：“玉札丹砂，赤箭青芝，牛溲马勃，败鼓 之皮，俱收并蓄，待用无遗者，医师之良也。” 唐朝文学家韩愈在任国子监祭酒时，经常给太学生讲课，要求他们“业精于勤，荒于嬉；行成于思，毁于随。”，同时要求他们注意社会实践，要兼收并蓄，“牛溲马勃、败鼓之皮”都有它们的用途，鼓励学生加强学习，灵活运用。 奴颜婢膝 驽马恋栈豆 nú mǎ liàn zhàn dòu 劣马贪恋马厩里的豆料。 比喻平庸的人目光短浅，贪恋禄位、家室等眼前利益。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"成语缀辑I","date":"2016-04-03T11:21:57.000Z","path":"2016/04/03/成语缀辑I/","text":"A 哀感顽艳 āi gǎn wán yàn。 顽：愚钝，指愚蠢的人。艳：美好，指聪慧的人。原指歌声和音乐哀婉凄恻，使愚钝的人和聪慧的人同样受到感动。后用来形容作品哀怨感人。 现多形容文艺作品具备哀怨、感伤、古拙、绮丽的风格。该成语出自《与魏文帝笺》。 三国·魏·繁钦《与魏文帝笺》：“咏北狄之遐征，奏胡马之长嘶，凄入肝脾，哀感顽艳。” 清．吴沃尧《二十年目睹之怪现状》第七十一回：“这封信却是骈四俪六的，足有三千多字，写的异常的哀感顽艳。” 张友鸾《章回小说大家张恨水》：“鸳鸯蝴蝶派，指的是那些作家专写才子佳人，男欢女爱，风花雪月，无病呻吟，自名为‘哀感顽艳’的作品。” 哀丝豪竹 āi sī háo zhú，意思是指悲壮的乐声。 出自 杜甫《醉为马坠诸公携酒相看》诗：“酒肉如山又一时，初筵哀丝动豪竹。” B 拔茅连茹 bá máo lián rú，比喻互相引进推荐，用一个人就连带引进许多人。 promote good men who will bring in their associates 拔犀擢象 bá xī zhuó xiàng，意思是比喻提拔才能出众的人。 出自《与丞相论郑武子状》 跋胡疐尾/跋前疐后/跋前踬后 bá hú zhì wěi，意思比喻陷入困境，进退两难 出自《诗经·豳风·狼跋》：“狼跋其胡，载疐其尾。” 意思是说狼向前进就踩着它的胡（下巴下面下垂的肉），往后退就伴着尾巴而跌倒。 惟信古太过，而欲为曲突徙薪之谋，故与物多违而每致跋胡疐尾之患。 —— 宋·李纲《谢复观文殿大学士表》 霸王风月 比喻用粗暴的态度对待幽雅的事情。 出自《镜花缘》。 白龙鱼服 bái lóng yú fú，意思是白龙化为鱼在渊中游。 比喻帝王或大官吏隐藏身份，改装出行。 出自西汉·刘向《说苑·正谏》。 吴王想请百姓一起饮酒，伍子胥劝谏说：“不能这样。从前白龙从天上下到清冷的池子里，变成鱼，渔夫豫且射中了它的眼睛。白龙向天帝告状，天帝问：‘在这个时候，你待在什么地方是什么样子？’白龙回答说：‘我下到清冷的池中，变成了鱼。’天帝说：‘鱼被渔夫所射是理所当然的，像这样，豫且有什么罪过呢？’那白龙是天帝豢养的珍贵动物，豫且是宋国身份低贱酶奴隶，白龙不变成鱼，渔夫就不敢射它。现在君王放弃国君的地位，而跟平民百姓一起饮酒，我担心将会有白龙被豫且射中一样的祸患了。”吴王这才放弃了这样的想法。 “白龙鱼服”这条成语，比喻的就是贵人隐藏身分，微服出行，也有时进一步指这样隐瞒身份，恐怕会给自己带来危险。 白首空归 白了头发，空手回来。比喻年纪已老，学无成就。 出自《后汉书·献帝纪》。 白头如新 意思是指交朋友彼此不能了解，时间虽久，仍跟刚认识一样。 出自《狱中上书自明》，《史记·鲁仲连邹阳列传》。 to remain aloof from each other though associated till the hair is white 西汉时期，邹阳受人诬陷被梁孝王关入死囚牢，他在狱中给梁孝王写信表明忠心。他列举了荆轲、卞和、李斯等事例，说“有白头如新，倾盖如故”，双方不了解，即使交往一辈子，到老了还是像刚认识一样。梁孝王深受感动并释放了他。 这个成语来源于《史记.鲁仲连邹阳列传》，谚曰：“有白头如新，倾盖如故。” 西汉时期，邹阳有一次因为受人诬陷，被梁孝王关进监牢，准备处死。邹阳十分激愤，他在狱中给梁孝王写了一封信，信中列举事实说明：“待人真诚就不会被人怀疑，纯粹是一句空话。”他写道：“荆轲冒死为燕太子丹去行刺秦始皇，可是太子丹还一度怀疑他胆小畏惧，不敢立即出发。卞和将宝玉献给楚王，可是楚王硬说他犯了欺君之罪，下令砍掉他的脚。李斯尽力辅助秦始皇执政，使秦国富强，结果被秦二世处死。所以谚语说：‘有白头如新，倾盖如故。’双方互不了解，即使交往一辈子，头发都白了，也还是像刚认识时一样；真正相互了解，即使是初交，也会像老朋友一样。” 梁孝王读了邹阳的信后，很受感动，立即把他释放，并做为贵宾接待。 白屋寒门 形容出身贫寒。 出自 元·高文秀 《谇范叔》。 an unpainted roughly built hut inhabited by the poor 元·高文秀《谇范叔》的故事取材于《史记》，并有所增饰。描写战国时辩士范雎随魏大夫须贾出使齐国，受到齐大夫驺衍的尊重，须贾却怀疑他与齐国有私。回国后，须贾向丞相魏齐告密，将范睢打得昏死后丢入厕坑。后来范睢逃往秦国，化名张禄，当了丞相。须贾奉使前去祝贺，风雪中见到化妆为贫士的范睢，发出了“范叔一寒如此哉”的嗟叹，赠以绨袍一领。范睢见须贾还有一点故人情义，又经各国使臣说情，便饶恕须贾，放他回国。 白衣秀士 指未曾获得功名的读书人。 出自 元·马致远《岳阳楼》第二折：“至如吕岩，当初是个白衣秀士、未遇书生，上朝求官。” 百无一失 形容有充分把握，绝对不会出差错。 出自《论衡·须颂》 no danger of anything going wrong (no risk at all; perfectly safe) 百代过客 指时间永远流逝。 出自《春夜宴从弟桃花园序》。 One hundred generations a visitor 百代文宗 指在久远的年代里堪为文人楷模的人物。 出自《晋书·陆机传》。 百端待举/理 很多事情要兴办。 出自《人民政协共同纲领草案的要点》。 百喙莫辩/百口莫辩 百里之才 指能治理方圆百里地区的人才。 出自《三国志·蜀志·蒋琬传》。 百伶百俐 形容非常聪明乖巧。 出自《醒世恒言》。 败不旋踵 败鼓之皮 指比喻虽微贱，却是有用的东西。 出自《进学解》。 牛溲马勃 原文: 先生曰：“吁，子来前！夫大木为杗，细木为桷，欂栌、侏儒，椳、闑、扂、楔，各得其宜，施以成室者，匠氏之工也。玉札、丹砂，赤箭、青芝，牛溲、马勃，败鼓之皮，俱收并蓄，待用无遗者，医师之良也。登明选公，杂进巧拙，纡馀为妍，卓荦为杰，校短量长，惟器是适者，宰相之方也。”——唐·韩愈《进学解》 译文: 国子先生（韩愈自称词）说：“唉，你到前面来！要知道那些大的木材做屋梁，小的木材做瓦椽，做斗栱，短椽的，做门臼、门橛、门闩、门柱的，都量材使用，各适其宜而建成房屋，这是工匠的技巧啊。贵重的地榆、朱砂，天麻、龙芝，车前草、马屁菌，坏鼓的皮，全都收集，储藏齐备，等到需用的时候就没有遗缺的，这是医师的高明之处啊。提拔人材，公正贤明，选用人才，态度公正。灵巧的人和拙笨的人都得引进，有的人谦和而成为美好，有的人豪放而成为杰出，比较各人的短处，衡量各人长处，按照他们的才能品格分配适当的职务，这是宰相的方法啊！ 败子回头/浪子回头 班功行赏 按照功劳大小，依次给予赏赐。 出自《后汉书·李云传》 班荆故道 班：铺开；道：叙说。用荆铺在地上坐在上面谈说过去的事情。形容老朋友在路上碰到了，坐下来谈谈别后的情况。 比喻：朋友路途相逢，共叙旧情。 班马文章 汉代史学家司马迁与班固的并称；泛指可与班固、司马迁相媲美的文章。 明·无名氏《鸣凤记·邹林游学》：“夔龙礼乐承先范，班马文章勘墨铅。” 清·刘璋《飞花艳想》第二回: 班马文章由夙慧，庾鲍诗句实前缘。 班师振旅 撤回军队，进行整顿。出自《尚书·大禹漠》。 斑驳陆离 形容色彩杂乱不一。 出自 战国·楚·屈原《楚辞·离骚》：“纷总总其离合兮，斑陆离其上下。” many-hued.mixed colours or tints 斑衣戏彩 意思是指身穿彩衣，作婴儿戏耍以娱父母；后以之为老养父母的孝亲典故。 出自《北堂书钞》。 搬唇递舌/搬口弄舌 阪上走丸 意思是比喻形势发展迅速或工作进行顺利。 出自《汉书·蒯通传》 板板六十四 形容不知变通或不能通融。板：即“版”，铸钱的模子。 出自《越谚·数目之谚》。 半明不灭 形容半明半暗，将要熄灭。 出自《红楼梦》。 半推半就 是一面推辞，一面靠拢上去。形容装腔作势假意推辞的样子。 出自《西厢记》。 半文不白 半新不旧 傍花随柳 形容春日游玩之乐。 出自 宋·程灏《春日偶成》：“云淡风轻近午天，傍花随柳过前川。” 傍人门户 比喻依赖别人，不能自立。 出自宋·苏轼《东坡志林》。 包办代替 指应该和有关的人一起商量或一起做的事，却独自办理，不让旁人参与。 出自《暴风骤雨》 do evevthing on behalf of somebody 包打天下 将打天下的整个任务承担下来，常指人逞强争胜。 出自 《求是》。 包揽词讼 指招揽承办别人的诉讼，从中谋利。 出自《红楼梦》。 褒衣博带 bāo yī bó dài，意思指着宽袍，系阔带；亦指古代儒生的装束。 出自《汉书·隽不疑传》。 饱经忧患 饱食终日，无所用心 整天吃得饱饱的，什么事也不干，什么事也不思考。 出自《论语·阳货》 抱关击柝 bào guān jī tuò，意思是守关巡夜的人。比喻职位卑下。 出自《孟子·万章下》。 be doorkeepers or night watchmen 《孟子·万章下》 “为贫者，辞尊居卑，辞富居贫。辞尊居卑，辞富居贫，恶乎宜乎？抱关击柝。” 《荀子.荣辱》 故仁人在上，则农以力尽田，贾以察尽财，百工以巧尽械器，士大夫以上至于公侯，莫不以仁厚知能尽官职。夫是之谓至平。故或禄天下，而不自以为多，或监门御旅，抱关击柝，而不自以为寡。故曰：”斩而齐，枉而顺，不同而一。”夫是之谓人伦。诗曰：”受小共大共，为下国骏蒙。”此之谓也。 《史记》卷三〈殷本纪〉～02～ 帝小乙崩，子帝武丁立。帝武丁即位，思复兴殷，而未得其佐。三年不言，政事决定于冢宰，以观国风。武丁夜梦得圣人，名曰说。以梦所见视群臣百吏，皆非也。于是乃使百工营求之野，得说于傅险中。是时说为胥靡，筑于傅险。见于武丁，武丁曰是也。得而与之语，果圣人，举以为相，殷国大治。故遂以傅险姓之，号曰傅说。唐·司马贞《史记索隐》：「旧本作『险』，亦作『岩』也。」唐·张守节《史记正义》引《括地志》云：「傅险即傅说版筑之处，所隐之处窟名圣人窟，在今陕州河北县北七里，即虞国虢国之界。又有傅说祠。注水经云沙水北出虞山，东南径傅岩，历傅说隐室前，俗名圣人窟。 译文 所以仁人处在君位上，那么农民就把自己的力量全部用在种地上，商人就把自己的精明全都用在理财上，各种工匠就把自己的技巧全都用在制造器械上，士大夫以上直到公爵、侯爵没有不将自己的仁慈宽厚聪明才能都用在履行公职上，这种情况叫做大治。所以有的人富有天下，也不认为自己拥有的多；有的人看管城门、招待旅客、守卫关卡、巡逻打更，也不认为自己所得的少。所以说：“有了参差才能达到整齐，有了枉曲才能归于顺，有了不同才能统于一。”这就叫做人的伦常关系。《诗》云：“接受小法与大法，庇护各国安天下。”说的就是这个道理啊。 [3] 抱恨终天 旧指因父母去世而一辈子感到悲痛。现指因做错某事而后悔一辈子。 出自《初刻拍案惊奇》。 抱素怀朴 bào sù huái pǔ， 借指民风淳厚，人心安定。 抱瓮灌园 bào wèng guàn yuán， 比喻安于拙陋的淳朴生活。 出自《庄子·天地》 【同韵词】宰相肚里好撑船、虎据龙蟠、四壁萧然、固阴沍寒、经验之谈、衾影何惭、造谋布穽、龙德在田、敢怒不敢言、话不虚传 传说孔子的学生子贡，在游楚返晋过汉阴时，看见一位老人一次又一次地抱着水瓮去浇菜，就建议他用机械汲水。老人不愿意，并且说：“这样做，为人就会有机心。我并不是不知道那样做，而是不愿那样做。” 抱玉握珠 比喻满腹经纶，富有才学。 出自三国·魏·曹植《与杨德祖书》：“当此之时，人人自谓握灵蛇之珠，家家自谓抱荆山之玉。” 抱玉握珠真博学，经天纬地实奇英。 ★《再生缘》第十一回 豹死留皮 豹死以后皮可以留存下来；比喻将好名声留传于后世。 出自 《新五代史·王彦章传》 五代时期，梁朝名将“王铁枪”王彦章跟随梁太祖朱温南征北战，屡立战功，深受重用。梁末帝朱贞继位后，唐军进攻梁国。王彦章受命御敌，但因寡不敌众被俘。唐庄宗劝王彦章归降。王彦章说：豹死留皮，人死留名，宁死不降。不久就被杀害。 鲍鱼之肆 卖渍鱼的店铺叫鲍鱼之肆，比喻小人集聚的地方。 出自汉刘向《说苑·杂言》。 a fish market 汉刘向《说苑·杂言》：与善人居，如入兰芷之室，久而不闻其香，则与之化矣。与恶人居，如入鲍鱼之肆，久而不闻其臭，亦与之化矣。 暴虎冯河 bào hǔ píng hé，比喻有勇无谋，鲁莽冒险。 出自《诗经·小雅·小旻》：“‘不敢暴虎，不敢冯河’。人知其一，莫知其他。” brash physical courage;attack a tiger unarmed and cross a river without a boat 暴戾恣睢 bào lì zì suī，意思是形容凶残横暴，想怎么干就怎么干，出自《史记·伯夷列传》 extremely cruel and despotic 春秋时期，齐鲁交界的柳下村成为诸侯战争的兵源地，展跖为逃避兵役而组织人马攻占启阳城，而后又占领鄫城，队伍扩大到9000人，官僚贵族们闻风丧胆，把展跖视为眼中钉、肉中刺，污蔑他为盗跖，说他“日杀不辜，肝人之肉，暴戾恣睢”。 暴殄轻生 指突然自杀身亡。暴：突然。殄：灭绝。 杯酒解怨 指通过饮酒消除嫌隙。 出自《新唐书·张延赏传》。 卑辞厚礼/卑辞厚币 意思是指言辞谦恭，礼物丰厚，待人谦卑恭顺。 出自《后汉书·许劭传》。 卑躬屈节 形容没有骨气，低声下气地讨好奉承。 出自 宋·魏了翁《江陵州丛兰精舍记》：“公卿大臣皆卑躬屈膝唯后，虽谢安石之贤也，而犹不能免。” bow and scrape 卑以自牧 指以谦卑自守。 出自《易·谦》 悲不自胜 bēi bù zì shèng，意思是指非常悲伤，自己无法承受起这种痛苦。 出自 汉·荀悦《汉纪·平帝纪》：“太后因号泣而言，左右莫不垂涕，舜百万不自胜。” 近义词悲痛欲绝、哀哀欲绝、黯然伤神、六神无主、失魂落魄 反义词喜不自胜、乐不可支、喜出望外、哀而不伤、乐不思蜀 北周·庾信《哀江南赋序》：“《燕歌》远别，悲不自胜。” 是年冬初，丽人无故，忽潸然泪下，悲不自胜，怪而问之，初则隐忍弗言，继则举声大恸。 ★明·李昌祺《剪灯余话·秋夕访琵琶亭记》 姚雪垠《李自成》第三卷二十七章：“他在提到他的皇上时，往往痛哭流涕，悲不自胜。” 清.蒲松龄《聊斋志异·吕无病》：”洛阳 孙公子，名麒，娶蒋太守女，甚想得。二十夭殂，悲不自胜。“ 悲愤填膺 北门锁钥/北门管钥 běi mén suǒ yuè，原指北城门上的锁和钥匙；后借指北方的军事要地。 出自《左传·僖公三十二年》。 北面称臣 古代君主面南而北，臣子拜见君主则面北，指臣服于人。 出自《史记·郦生陆贾列传》 南面称王 贝阙珠宫 bèi què zhū gōng，意思是指用珍珠宝贝做的宫殿，形容房屋华丽。 出自 战国·楚·屈原《九歌·河伯》：“鱼鳞屋兮龙堂，紫贝阙兮朱宫。” 你看那香焚宝鼎，紫雾漾漾，玉楼金殿，～，便如天宫之景也。（明·无名氏《庆长生》第四折） 备而不用 准备好了，以备急用，眼下暂存不用。 出自清·吴趼人《糊涂世界》。 背槽抛粪 bèi cáo pāo fèn，意思是像牲畜那样刚吃了槽里的食，就背过身拉屎。比喻以怨报德，忘恩负义。 元·关汉卿《调风月》一折：“一个个背槽抛粪，一个个忘恩负义。” 背城借一 在自己城下和敌人决一死战，多指决定存亡的最后一战。 出自《左传·成公二年》。 春秋时，晋、鲁、卫三国，于晋主将郤克之统率下，将来攻之齐军打败。齐顷公遂遣大臣国佐往晋处求和，克乘机苛求诸多条件，佐严辞以对曰：“晋如欲和谈，齐愿献宝玉与归鲁、卫之地。若以此为挟，吾国唯将‘背城借一’矣。”鲁、卫二国之将孙行父与孙良夫从旁相劝，克终依齐之求而签订和约。 亦作“背城一战”。 背山起楼 靠山建造楼房；比喻使人扫兴的事。 出自 宋·胡仔《茹溪渔隐丛话前集·西崑体》：“其一曰杀风景，谓清泉濯足，花上晒裤，背山起楼，烧琴煮鹤，对花啜茶，松下喝道。” 唐 李商隐《杂纂》上卷：“杀风景：花下晒裈，背山起楼。” 唐朝诗人李商隐很有才华，他的诗揭露和批判当时的黑暗现实及官场腐败。他在《杂纂》中列出大煞风景的事情，如“清泉濯足，花上晒禈，背山起楼，烧琴煮鹤，对花啜茶，松下喝道。”这些都是当时让人扫兴的事情。 build a building against the hill 倍道兼行 bèi dào jiān xíng，意思是每天加倍行进，一天走两天的路程；形容加速急行。 成语出自《孙子·军争》。 悖逆不轨 悖入悖出 用不正当的手段得来的财物，也会被别人用不正当的手段拿去。胡乱弄来的钱又胡乱花掉。 出自《礼记·大学》 奔走如市 bēn zǒu rú shì，意思是为某种目的而奔忙活动的人很多。 奔走之友 指彼此尽力相助的挚友。 出自《后汉书·党锢传·何顒》。 本同末异 意思是比喻事物同一本原，而派生出来的末流则有所不同。 出自《典论·论文》。 笨嘴笨腮 匕鬯不惊/匕鬯无惊 bǐ chàng bù jīng 匕：古代的一种勺子；鬯：香酒；匕和鬯都是古代宗庙祭祀用物。 意思是形容军纪严明，所到之处，百姓安居，宗庙祭祀，照常进行。 出自《周易·震》。 sacrificial offerings to ancestors at the ancestral shrines must not be disturbed 赣、宁之乱，坐镇上游，匕鬯不惊，指挥若定。（蔡东藩、许廑父《民国通俗演义》第三十六回） 唐杨炯《益州温江县令任君神道碑》：“束发登朝，匕鬯不惊于百里。” 文公直《辛亥革命运动中之新军》：“虽军事倥偬之际，而城中安堵如常，匕鬯不惊。” 黄远庸《弹劾案与新内阁》：“吾曹固甚望此震烁中外，匕鬯无惊之新阁出现者也。” 比而不党 意思是亲近而不偏私。出自《国语·晋语》。 比而不周 《论语 为政》子曰：君子周而不比，小人比而不周。周：普遍，公共利益；比：私人私利和偏党。 “君子周而不比，小人比而不周”就是：君子大公无私，小人结党营私。 比肩而事 意思是肩并肩做事，指共事、同事。出自《范增论》。 比屋而封 指上古之世教化遍及四海，家家都有德行，堪受旌表。后泛称风俗淳美。 出自《尚书大传》卷五：“周人可比屋而封。”汉·陆贾《新语·无为》：“尧舜之民，可比屋而封；桀纣之民，可比屋而诛者，教化使然也。” 比物连类 连缀相类的事物，进行对比。 出自《韩非子·难言》：“多言繁称，连类比物，则见以为虚而无用。” 每下笔，乃如文人才士就题，赋咏词源衮衮出于毫端，比物连类，激昂顿挫，无所不有。 ★宋·赵佶《宣和画谱·山水三》 笔饱墨酣 笔力饱满，用墨充足。 形容诗文酣畅浑厚 笔底生花 比喻文章写得生动、出色。 笔力扛鼎 bǐ lì gānɡ dǐnɡ 笔头的力量足以举起千斤之鼎。形容笔力高超，有很强的驾驭笔墨的能力。 俾昼作夜 指晨昏颠倒，常用在无限制地享乐，出自《诗经·大雅·荡》 币重言甘 意思是礼物丰厚，言辞好听。指为了能达到某种目的而用财物诱惑。出自《左传·僖公十年》。 必不得已 bì bù dé yǐ，意思为必然不能得止，指形势使得非如此不可，表示无可奈何。 出自《论语·颜渊》。 毕其功于一役 表示一次行动就完成所有本应分期做完的事。 accomplish the whole task at one stroke 出自孙中山《〈民报〉发刊词》：“夫欧、美社会之祸，伏之数十年，及今而后发现之，又不能使之遽去。吾国治民生主义者，发达最先，睹其祸害于未萌，试可举政治革命、社会革命，毕其功于一役，还视欧、美，彼且瞠乎后也。” 闭门却扫 闭门谢客，不和外界往来。 出自汉·应劭《风俗通·十反》。 live in complete seclusion 荜门圭窦/筚门圭窦 bì mén guī dòu，常用以喻指贫户居室 。 出自 宋·陈亮《畏羞于君子》：“此丈夫所当履其道，免笔诛口伐于荜门闺窦之间。” 魏书·逸士传·李谧》：“绳枢瓮牖之室，荜门圭窦之堂，尚不然矣。” 《左传·襄十年》：“荜门圭窦之人，而皆陵其上。” 《礼记·儒行》：“荜门圭窦，蓬户翁牖。 我不禁暗暗称奇，不料这荜门圭窦中，有这等明理女子。 ★清·吴趼人《二十年目睹之怪现状》第34回 a small door of bamboo–the house of a poor man 睥睨窥觎 bì nì kuī yú 暗中察看，希图乘机得手。 《宣和书谱·秋月帖》：“总戎马之权，居形势之地，有睥睨窥觎之意。” 碧落黄泉 指宇宙的各个角落。出自《长恨歌》。 碧血丹心 为正义事业而流的血；丹心：忠心。满腔正义的热血，一颗赤诚的红心。形容十分忠诚坚定。丹：红色。用来形容英雄豪杰。 周朝时期，刘文公的大夫苌弘一生忠于朝廷，不卑不亢，有浩然正气。他因为正直而得罪了朝中权贵，蒙冤被周人杀害，传说他被杀时，有人慕名收集他的血液藏在家里，三年后这些干血块全都化为碧玉。 闭明塞聪/蔽明塞聪 堵塞视听，指对外界事物不闻不问或不了解。出自《论衡·自纪》。 be out of touch with reality 弊绝风清 bì jué fēng qīng，形容坏事绝迹，社会风气良好。 出自 宋·周敦颐《拙赋》。 弊衣箪食/弊衣疏食 bì yī dān shí，意为破旧的衣服和粗粝的饭食，指生活清苦。 避繁就简 避开繁杂之处，从简易的地方入手。 避祸就福 避开凶险，趋向幸福。 出自战国·卫·商鞅《商君书·定分》。 pursue good fortune and avoid disaster 避坑落井 躲过了坑，又掉进井里。比喻躲过一害，又受一害。出自《晋书·褚翜传》。 避实击虚 指避开敌人的主力，找敌人的弱点进攻。又指谈问题回避要害。 出自《孙子·虚实》 stay clear of the enemy’s main force and choose to attack the vulnerable spot 髀肉复生 因为长久不骑马，大腿上的肉又长起来了。形容长久过着安逸舒适的生活，无所作为。 出自《三国志·蜀书·先主传》 变生肘腋 辩才无碍 本是佛教用语，指菩萨为人说法，义理通达，言辞流利，后泛指口才好，能辩论。 出自《华严经》 标同伐异 帮助意见相同的人，排斥意见不同的人。 搔首踟蹰 sāo shǒu chí chú，意思是形容心情焦急、惶恐或犹豫。 出自《诗经·邶风·静女》“爱而不见，搔首踟蹰。” 彪炳日月 biāo bǐng rì yuè 是形容伟大的业绩照耀千秋万代。 出自《歧路灯》。 表里山河 外有大河，内有高山。指有山河天险作为屏障。 出自《左传·僖公二十八年》。 Situated at the foot of a hill and beside a river 表里相济 泛指内外互相救助。出自晋·桓温《辞参朝政疏》。 表壮不如里壮 意思是为外表好看，不如里面结实 别鹤离鸾 bié hè lí luán，意思是指离别的鹤，孤单的鸾。比喻离散的夫妻。 别无二致 指区分不出两者的差别。出自郭沫若《海涛集·徐家埠》。 别有肺肠比喻人动机不良，故意提出一些与众不同的奇特的主张。 出自《诗经·大雅·桑柔》：“自有肺肠，俾民卒狂。” have evil intentions 别有会心 另有一种心领神会之处。指对别人没有明确表达出来的深层意思另有领悟 宾客盈门 意思是指来客很多。出自《旧唐书·窦威传》。 冰壑玉壶 像冰那样清澈的深山沟里的水，盛在晶莹的玉壶里。比喻人节操高尚，品性高洁。 杜甫《入奏行赠西山检察使窦侍御》：“窦侍御，骥之子，凤之雏，年未三十，忠义俱，骨绠绝代无，炯如一段清水出万壑，置在迎风露寒之玉壶。” 冰壶玉尺 比喻高尚纯洁的人品。出处于《元史·黄溍传》。 冰肌玉骨/冰清玉润 兵连祸结 指战争接连不断，带来了无穷的灾祸。出自《汉书·匈奴传》 秉烛待旦 早晨，手持点燃的蜡烛待天亮。 出自《陈抟高卧》。 明·罗贯中《三国演义》第二十五回：“关公乃秉烛立于户外，自夜达旦，毫无倦色。” 屏气敛息 bǐng qì liǎn xī，意思是指因心情紧张或注意力集中，暂时止住了呼吸。 出自《论语·乡党》 并蒂芙蓉 两朵荷花并生一蒂。比喻夫妻相亲相爱。也比喻两者可以相媲美。 出自杜甫 《进艇》诗：“俱飞蛱蝶元相逐，并蒂芙蓉本自双。” 并日而食 意思是为不能天天得食，两天三天才能得一天的粮食。形容生活穷困。 出自《礼记·儒行》 思惟北征，宜先入南，故五月渡泸，深入不毛，并日而食，臣非不自惜也，顾王业不可偏安于蜀都。 ★三国·蜀·诸葛亮《后出师表》 病骨支离 病中体瘦骨露，衰弱无力。 出自宋·陆游《病起书怀》。 拨云睹日/拨云见日 波澜老成 指形容文章气势雄壮，语句老练。 出自《敬赠郑谏议十韵》。 元朝汤编著的《画鉴·宋画》里记载着一个故事。宋朝有个名叫徐友的画家，有一次在常州太和寺佛殿后面的墙壁上，画了一幅描绘河水的壁画，题名《清济贯河》，其中有一笔从头到尾长达40丈，受到观众的特别注意。 汤对此发表评论说：“其实徐友的妙处并不在此。因为他功力深厚，笔法老练，线条连绵不断，像波涛起伏（原文是‘笔法既老，波澜起伏’），跟水势相结合，互相影响，就觉得越看越奇了。”后来，人们把“波澜老成”这个成语，来形容诗文气势雄壮，功力深厚。 剥肤椎髓/剥肤锥髓 bō fū chuí suǐ，意思是极其残酷地压榨和剥削。 剥：剥去；肤：皮肤；椎：捶击。 出自唐·韩愈《郓州溪堂诗》。 peel somebody’s skin and break his marrowbones 博采穷搜 尽力采集寻找 博洽多闻 bó qià duō wén，意思是知识丰富，见闻广博。出自《后汉书·杜林传》。 补苴罅漏 bǔ jū xià lòu，意思是指弥补文章理论等的缺漏，泛指弥补事物的缺陷。 出自 唐·韩愈《进学解》：“补苴罅漏，张皇幽眇。” 补偏救弊 bǔ piān jiù bì，意思是补救偏差漏洞，纠正缺点错误。 出自《汉书·董仲舒传》 remedy defects and rectify errors (rectify abuses) 补天浴日 指女娲炼五色石补天和羲和给太阳洗澡两个神话故事。后用来比喻人有战胜自然的能力。也同样形容伟大的功业。 出自《淮南子·览冥训》。 不辨菽麦 bù biàn shū mài，原意指愚昧无知，分不清豆子和麦子。现常用来形容脱离劳动，缺乏实际生产知识。 出自《左传·成公十八年》。 不测之祸 无法揣测的祸患，多指牢狱或杀身之祸。 出自《三国志·魏志·陆凯传》。 不差累黍 bù chā lěi shǔ，意思是形容丝毫不差。 出自《汉书·律历志上》。 不茶不饭 意思是不思饮食。形容心事重重。 出自《救风尘》 不逞之徒 bù chěng zhī tú，意思是因心怀不满而闹事捣乱的人。 出自《左传·襄公十年》 不孚众望 bù fú zhòng wàng。孚：信服。意思是不能使大家信服，未符合大家的期望。 出自于《诗经·大雅·下武》。 不负众望 为bù fù zhòng wàng，意思是指为人所信服，很争气，不辜负大家的期望。 出自《诗经·大雅·下武》。 不尴不尬 比喻左右为难，不好处理，也形容样子别扭。出自《赋半斋送张清分教嘉定》。 不敢告劳 意思是努力做事，不诉说自己的劳苦。比喻勤勤恳恳，不辞辛劳（多用在自己表示谦虚）。 出自《诗经·小雅·十月之交》：“黾勉从事，不敢告劳。” 不急之务 指无关紧要的或不急于做的事情。 出自《三国志·吴书·孙和传》。 不见经传 指经传上没有记载。后常指人没有名声或论述没有根据。 宋·罗大经《鹤林玉露》第六卷：“俗语云：’但存方寸地，留与子孙耕。’指心而言也。三字虽不见于经传，却亦甚雅。” 不教而诛 指事先不教育人，一犯错误就加以惩罚。出自《荀子·富国》。 punish without prior warning 不矜不伐 bù jīn bù fá，意思是指不自以为了不起，不为自己吹嘘。形容谦逊。 出自《尚书·大禹谟》。 不刊之论 刊：削除，修改。意思是比喻不能改动或不可磨灭的言论，用来形容文章或言辞的精准得当，无懈可击。 出自宋·吴曾《能改斋漫录·议论》。 不堪造就 没有培养前途。出自茅盾《蚀·追求》。 不可胜言 意思是非常多或到达极点。出自《史记·大宛列传》。 不可向迩 bù kě xiàng ěr，意思是不可接近。 出自 《尚书·盘庚上》。 迩：近。 不愧不怍 bù kuì bù zuò，意思是形容光明正大，问心无愧。 出自《孟子·尽心上》。 不愧屋漏 bù kuì wū lòu，原意是虽在宗庙里，但无愧畏之心。后比喻即使在暗中也不做坏事，不起坏念头。 出自《诗经·大雅·抑》。 不稂不莠 不吝珠玉 意思是不要舍不得好的东西，恳切希望别人给予指教的谦词。出自《初刻拍案惊奇》。 不露圭角 bù lù guī jiǎo，意思是指才干不外露。 出自 宋·欧阳修《张子野墓志铭》：“遇人浑浑，不见圭角。” 不落窠臼 不蔓不枝 不横生藤蔓，也不旁生枝，比喻说话或写文章简明，不芜杂，出自宋·周敦颐《爱莲说》。 not spread out, not grow miscellaneous branches 近义词: 珠圆玉润、一气呵成、文从字顺 反义词: 拖泥带水、节外生枝、画蛇添足 不宁唯是 意思是不只是这样，即不仅如此。出自《左传·昭公元年》。 春秋时期，楚国将军公子围与郑国的丰氏订立婚约，他想借迎亲的机会偷袭郑国，就带兵到郑国来，郑人识破他的诡计，坚持不让他不让他进城，公子围游说这样做会让他得到君主的重用，除此之外还会让天下人耻笑。郑人坚决不允，他只好独自进城完婚。 不平则鸣 始乱终弃 不期而会 bù qī ér huì，拼音是指未经约定而意外地遇见、未经约定而自动聚集。 出自《榖梁传·隐公八年》。 不期而然 意思是非常不希望这样，但是竟然这样。表示很出乎意料。出自《与景韦兄投宇文枢密书》。 不容之便 不容许别人进行辩解。指没有辩护的余地。 出自清·蒲松龄《聊斋志异·三生》。 be beyond all question 不塞不流，不止不行 （bù sè bù liú，bù zhǐ bù xíng）指不把这种东西打倒，什么新文化都是建立不起来的。 不衫不履 指不穿长衫，不穿鞋子。形容性情洒脱，不拘小节。 出自 《虬髯客传》。 不时之需 思是说不定什么时候会出现的需要。 出自 苏轼《后赤壁赋》：“我有斗酒，藏之久矣，以待子不时之需。” possible period of want or need need which mayarise any time in the future. 不识一丁 形容一个字也不认识。出自 《旧唐书·张弘靖传》 【押韵词】衔胆栖冰、东讨西征、富国强兵、屏气吞声、名公巨卿、荒谬不经、摧陷廓清、弦歌之声、歪嘴念邪经、摧毁廓清 do not know the simplest character; be completely illiterate; not know one’s ABC 不识之无 连 “之”字、“无”字都不认识；形容人不识字，文化水平很低。 出自唐·白居易《与元九书》：“仆始生六七月时，乳母抱弄于书屏下，有指‘无’字、‘之’字示仆者，仆虽口未能言，心已默识。” 唐朝时期，大诗人白居易从小就聪明过人，据《新唐书》记载他生下的第7个月就能指认“之无”两字，他的乳母百试不差。他给元稹的信证实：“仆始生六七月时，乳母抱弄于书屏下，有指‘无’字、‘之’字示仆者，仆虽口未能言，心已默识。” illiterate 不食周粟/不世之功 舐糠及米 shì kāng jí mǐ，意思是舔米外的糠，一直舔到里面的米，比喻占据的地方再夺取政权，也比喻由表及里，逐步进逼。 出自《史记·吴王濞列传》。 西汉时期，各诸侯国不听中央的号令，各自为政，御史大夫晁错建议汉景帝削减各诸侯国的领地，把权力收归中央。实力最大的吴王刘濞野心勃勃地对其他诸侯国王说削减领地就像舐糠及米一样，号召其他六国起来反抗，历史上称七国之乱。 不祧之祖 bù tiāo zhī zǔ，意思是不迁入祧庙的祖先，比喻创立某种事业而受到尊崇的人。 出自《宋史·礼志九》。 祧：古代帝王的远祖的祠堂。 不通水火 形容跟人不相往来。 出自 《汉书·孙宝传》。 不为已甚 bù wéi yǐ shèn，原意是不做太过分的事。后来泛指对人的责难批评，要适可而止。 出自《孟子·离娄下》。 不无小补 bù wú xiǎo bǔ，意思是多少有一点益处或多少有一点帮助。 出自《〈尚书〉一·纲领》。 be of some help 不舞之鹤 意思是不舞蹈的鹤；比喻名不副实的人；也用来讥讽人无能。 出自《世说新语·排调》。 the crane that does not dance–incapable 不一而足 指同类的事物不止一个而是很多，无法列举齐全。 出自《公羊传·文公九年》。 too many to enumerate 不以为意 意思是不把它放在心上。表示对人或事抱轻视态度。 出自《三国志·吴书·陆凯传》。 不易之论 意思是不可更改的言论，形容论断或意见非常正确，出自 宋·惠洪《冷斋夜话》。 perfectly sound proposition 不置可否 bù zhì kě fǒu，意思是说也行，不说也行。指不表明态度。 出自清·李宝嘉《官场现形记》。 不足为训 指不能当作范例或法则。 出自 明·胡应麟《诗薮续编》卷一：“君诗如风螭巨鲸，步骤虽奇，不足为训。” 布帛菽粟 bù bó shū sù，意思是指生活必需品。比喻极平常而又不可缺少的东西。 出自《论贵粟疏》。 daily necessities as food and clothing 布鼓雷门 bù gǔ léi mén，意思是在雷门前击布鼓；比喻在能手面前卖弄本领。 出自《汉书·王尊传》。 布衣蔬食 形容生活节俭朴素。 出自《汉书·王吉传》。 C 才薄智浅才疏智浅//才高学富 才疏意广/才高意广 意思是才干有限而抱负很大。 出自 《后汉书·孔融传》：“融负其高气，志在靖难，而才疏意广，迄无成功。” 孔融十六岁时，山阳人张俭因为揭发中常侍侯览的罪行，被四处通缉。张俭逃到山东时，来投奔孔融的哥哥孔曪，孔曪不在家。孔融见张俭窘迫，就收留了他。後来事情洩漏，张俭走脱，孔融全家被抓到官府。孔融说：“收留张俭的是我，应当治我的罪。”孔曪说：“张俭来找我，不是我弟弟的错，请治我的罪。”孔母说： “责任的应该是我这个长辈，你们治我的罪吧。”官府不能决。 孔融当北海郡太守时，被袁绍人马围攻，从春天打到夏天，孔融只剩下几百士兵了，袁绍人马放的箭像下雨一样，最后双方常常短兵相接，孔融隐几读书，谈笑自若。 孔融性情宽厚少忌，好士，喜欢提拔年轻人。他家常常宾客盈门，孔融说：“坐上客恒满，尊中酒不空，我就没有甚么担忧的了。” 孔融为曹操所不能容，建安十三年被杀，死时56岁。《后汉书》上说：“孔融抱负很大，志在靖难，可是才疏意广，所以没有成功。” 苏轼不同意这个观点，他说：“以成败论人物，所以曹操被称为英雄，而孔融却被称谓‘才疏意广’，真是太可悲了！” 财竭力尽 意思是钱财和力量全部用尽，比喻生活陷入困窘的境地。出自《黑龙见东莱对》。 采兰赠芍 cǎi lán zèng sháo，意思是比喻男女互赠礼物，表示相爱。 出自《诗经·郑风·溱洧》。 采薪之忧 意思是病了不能打柴；自称有病的婉辞。 出自《孟子·公孙丑下》。 彩凤随鸦 意思是美丽的凤鸟跟了丑陋的乌鸦。比喻女子嫁给才貌配不上的人。 出自《事文类聚》。 餐风沐雨/餐风露宿/餐风饮露 残民害物 思是摧残百姓，损害财物。 出自《淳熙己亥论盗贼札子》。 残篇断简/残山剩水/残渣余孽/蚕食鲸吞/惨淡经营/仓皇流离/苍翠欲滴 伧夫俗吏 cang 意思是是粗野庸俗的人和官吏，出自于钱钟书《围城》三。 苍黄翻覆 意思是常用来比喻变化不定，反复无常，出自春秋·鲁·墨翟《墨子·所染》。 藏器待时 意思是比喻学好本领，等待施展的机会。 出自《周易·系辞下》。 wait for the right moment to demonstrate one’s ability;store up sth, until it is wanted. 藏头露尾 cáng tóu lù wěi，意思是藏起了头，露出了尾；形容说话躲躲闪闪，不把真实情况全部讲出来。 出自《点绛唇·翻归去来辞》。 藏形匿影 cáng xíng nì yǐng，意思是隐藏形迹，不露真相。 出自《邓析子·无厚篇》。 go into hiding 藏踪蹑迹 cáng zōng niè jī，意思是隐秘行踪，悄悄行动。 出自 明·施耐庵《水浒全传》第六十四回：“且说张横将引三二百人，从芦苇中间，藏踪蹑迹，直到寨边，拨开鹿角，径奔中军。” 操刀必割 比喻办事必须及时。又比喻行事应果断，及时而动。 出自《左传·襄公三十一年》。 When a sword is being held 《六韬·守土》：“日中必彗，操刀必割，执斧必伐。日中不彗，是谓失时；操刀不割，失利之期；执斧不伐，贼人将来。” 草间求活 形容只求眼前能马马虎虎活下去。 草莽寒门/查无实据 察见渊鱼 意思是能看清深水中的鱼。比喻为人过于精明。 出自 《列子·说符》：“文子曰‘周谚有言：察见渊鱼者不祥，智料隐匿者有殃。” 馋涎欲滴 chán xián yù dī，意思是馋得连口水都要滴下来了。形容非常贪馋想吃的样子；也可以比喻看到好的东西，十分羡慕，极想得到(含贬义)。 语出 唐·柳宗元《招海贾文》：“垂涎闪舌兮，挥霍旁午。” 【近义词】垂涎三尺、口角流涎 【反义词】淡泊寡味 缠绵悱恻 chán mián fěi cè，意思是形容内心痛苦难以排解，也形容诗文音乐等婉转凄切。 出自 晋朝·潘岳《寡妇赋》：“思缠绵以瞀乱兮，心摧伤以怆恻。” 【近义词】悱恻缠绵、缠绵凄怆 【反义词】超然物外 蟾宫折桂/谄上傲下/长恶不悛 长林丰草 意思是指禽兽栖止的山林草野，旧常喻隐居之地。 出自 晋·稽康《与山巨源绝交书》：“虽饰以金镳、飨以嘉肴，逾思长林而志在丰草也。” 长绳系日 cháng shéng xì rì，意思是用长绳子把太阳拴住；比喻想留住时光。 出自 晋·傅玄《九曲歌》：“岁暮景迈群光绝，安得长绳系白日。” 唐 赵牧 《对酒》诗：“长绳系日未是愚，有翁临镜捋白须。” 宋 李甲 《过秦楼》词：“已蜨稀莺散，便拟把长绳系日无由。”亦作“ 长绳系景 ”。 《周书·萧大圜传》：“嗟乎！人生若浮云朝露，宁俟长绳系景，寔不愿之。” 长夜难明/肠肥脑满/常备不懈/怅然若失/超尘拔俗 超轶绝尘 chāo yì jué chén，意思是形容骏马飞驰神速，超越众马。 比喻才力非凡，无法企及。 出自《庄子·徐无鬼》。 《庄子·徐无鬼》：“天下马有成材，若恤若失，若丧其一，若是超轶绝尘，不知其所。” 宋·陆游《跋兰亭序》：兰亭刻石，虽佳本皆不免有可恨。此唐人响拓，乃独纵横放肆，不为法度拘窘，犹可想见茧纸，故书之超轶绝尘。 宋．张孝祥《吴尉》：执事潜心正学，志其远大，至于翰墨余事，犹超轶绝尘如此，真吾党之士所敬畏者。 《黄庭坚传》：苏轼尝见其诗文，以为超轶绝尘，独立万物之表，世久无此作，由是声名始震。 巢倾卵破 cháo qīng luǎn pò，意思是比喻灭门之祸，无一得免。亦以喻整体被毁，其中的个别也不可能幸存。 出自《后汉书·孔融传》 嘲风咏月 指描写风云月露等景象而思想内容贫乏的写作。 出自唐·白居易《与元九书》。 sing of the moon and the wind–write sentimental verse 宋朝时期，赵匡胤取南唐，南唐后主李煜主动投降，成为有名无实的“金吾大将军”，宋太宗赵光义信步到翰林苑，看到李煜在侍侯着原南唐旧臣徐铉等，觉得奇怪就问为什么，徐铉斜视李煜说他没能力治国，只会嘲风咏月，只配如此。 车马盈门 车子充满门庭，比喻宾客很多。 出自 元·马致远《青衫泪》第四折：“但得个车马盈门，这便是钱龙人家。” 明·谢谠《四喜记·乡荐荣欢》：“看连翩车马盈门，总不比旧时庭院。” 扯咸呱淡 说些无关紧要的闲话 掣襟露肘 chè jīn lù zhǒu，意思是接一下衣襟胳膊肘儿就露出来，形容衣服破烂，生活贫困。 出自《明史·刘应节传》。 be on one’s uppers (be out at elbows) 臣门如市 旧时形容居高位、掌大权的人宾客极多。出自《汉书·郑崇传》 沉李浮瓜 指吃在冷水里浸过的李子和瓜。形容夏天消暑的生活。也作“浮瓜沉李”。出自《与朝歌令吴质书》。 苏轼《答苏伯固三首》：“位计龙舒为多，大盆如命取去，为暑中浮瓜沉李之一快也。” 宋 沉与求 《秋日戏呈蒋达可检讨》诗：“西风槭槭舞庭櫰，沉李浮瓜事益乖。” 金 董解元 《西厢记诸宫调》卷一：“日转午，脱巾散发，沉李浮瓜，宝扇摇纨素。” 《金瓶梅词话》第二七回：“ 西门庆 令他安排酒来，不一时，冰盆内沉李浮瓜，凉亭上偎红倚翠。” 五代王仁裕《开元天宝遗事》：“唐都人伏天，于风亭水榭，雪槛水盘，浮瓜沉李，流杯曲沼，通夕而罢。” 明·凌蒙初《初刻拍案惊奇》：“这样时候，多少王孙公子雪藕调冰、浮瓜沉李也不为过。 ” 宋·李重元《忆王孙·夏词》：”过雨荷花满院香，沈李浮瓜冰雪凉 “ 宋 孟元老《东京梦华录·是月巷陌杂卖》：”雪槛冰盘，浮瓜沉李，……通夕而罢。“ 沉吟不决 形容人遇到难题时，自言自语地决定不下来。 出自 三国·魏·曹操《秋胡行》：“沉吟不决，遂上升天。” 沉冤莫白 长期得不到申雪的冤屈。 出自唐·于逖《灵应传》。 沉渣泛起 解释为已经沉到水底的渣滓又漂浮了起来。比喻已经绝迹了的腐朽、陈旧事物又重新出现。 陈陈相因 原指皇仓之粮逐年增加，陈粮上压陈粮；后多比喻沿袭老一套，无创造革新。 出自《史记·平准书》。 keep on doing the same thing over and over again 西汉初年，刘邦采取一系列措施恢复经济，使得农业生产突飞猛进。汉文帝和汉景帝仍坚持这个既定的国策，因此国库里钱币堆成山，粮库里积压的粮食无数，陈陈相因，仓库容纳不下，只好露天堆放，很多谷子腐烂不能再食用了。 称孤道寡 意思是指自封为王，也比喻狂妄地以首领自居。 出自《关大王独赴单刀会》。 style oneself king 瞠乎其后 chēng hū qí hòu，意思是在别人后面干瞪眼赶不上；形容远远落在后面。 出自《庄子·田子方》。 be left far behind, without any hope of catching up 成败利钝 指做事情可能有的各种情况或结果。 出自三国·蜀·诸葛亮《后出师表》。 成仁取义 为了崇高的事业而就义。 出自《论语 卫灵公》 城狐社鼠 意思是城墙上的狐狸，社庙里的老鼠；比喻依仗权势作恶，一时难以驱除的小人。 出自《晏子春秋·内篇问上》。 东晋晋武帝的女婿王敦在永嘉初年任扬州刺史，因受武帝宠臣刘隗的排挤，想办法消灭刘隗，请教于谢鲲。谢鲲说：“刘隗是城墙根下的狐狸，宗庙里的老鼠，我们不能用常规的挖掘和水灌的办法来对付。” 城下之盟 指在敌方兵临城下时被迫签订的屈服的和约。 出自 《左传·桓公十二年》。 a treaty signed under coercion 惩恶劝善 指惩罚恶人，劝他向善，出自《左传·成公十四年》。 乘坚策肥 坐牢固的车，驾肥壮的马。 出自《汉书·食货志上》。 跅弛不羁 tuò chí bù jī，意为放荡不受拘束。《汉书》:“夫泛驾之马，跅弛之士，亦在御之而已。” 也作 “跅弢不羁” tuò tāo bù jī 惩忿窒欲 chéng fèn zhì yù，意思是克制住愤怒。 出自《周易·损》。 齿若编贝 chǐ ruò biān bèi，出 自东汉·班固《汉书·东方朔传》。 If tine makes up shellfish 形容牙齿整齐洁白 赤舌烧城/赤口烧城 比喻毁谤或挑拔离间的话非常伤害人。 赤绳系足 chì shéng jì zú，旧指男女双方经由媒人介绍而成亲。 出自李复言《续玄怪录》。 古代杜陵少年韦固，一天在路上遇到一个靠着红布囊席地而坐的老人，觉得奇怪，就去问老人。老人说他是主管天下婚姻的，囊中的红绳是用来将夫妻的脚系在一起的，不管他们两人相隔多远，终究会走到一起的，如果断裂就夫妻离散。 赤县神州 赤子苍头 初生的婴儿,老年人. 泛指老百姓 冲州撞府 意思是冲到州里，撞到府里，指在外到处奔走。 出自 宋·无名氏《宦门子弟错立身·题目》：“冲州撞府妆旦色，走南投北俏郎君。” 元 石君宝《紫云庭》第三折：“这条冲州撞府的红尘路，是俺娘剪径截商的白草坡。” 明·施耐庵《水浒传》二十七回：“他们是冲州撞府，逢场作戏，赔了多少小心得来的钱物。” 明·施耐庵《水浒传》四十回：你倒鸟村，我们冲州撞府，那里不曾去，到处看出人。便是京师天子杀人，也放人看。你这小去处，砍得两个人，闹动了世界，我们便挨入来看一看，打甚么鸟紧！ 明·无名氏《宦门子弟错立身》第五出：“只得同欢共乐同鸳被,冲州撞府,求衣觅食。” Plunging the state and dashing the prefecture 重规叠矩 指前后相合，重叠的规矩与制度，比喻因袭、重复。出自《晋书·周访传赞》。 重宇别院 极言房屋院落之多。 别院： 正院之外的其他院落。 重足而立 意思是叠足而立，不敢迈步。形容恐惧。 出自 西汉·贾谊《过秦论》下：“故使天下之士，倾耳而听，重足而立，阖口而不言。” 汉朝时期，张汤因改定刑律法令而做了廷尉，太子洗马汲黯对他十分不满，说他不努力去降低犯罪使人们生活富足，而是陷人于罪，如果这样下去，将使天下人重足而立、侧目而视。汲黯因此被外放为淮阴郡太守 谈笑封侯 意思是说笑之间就封了侯爵。旧时形容获得功名十分容易。 出自 唐·杜甫《复愁》 胡虏何曾盛，干戈不肯休。闾阎听小子，谈笑觅封侯。 崇论吰议/崇论闳议/崇论宏议 chóng lùn hóng yì，意思是高明卓越的议论。 抽丁拔楔 chōu dīng bá xiē，比喻解决疑难。 出自 元·李寿卿《度柳翠》第四折：“大众恐有不能了达，心生疑惑者，请垂下问，我与他抽丁拔楔。”一本作“抽丁抽楔”。 抽丝剥茧 chōu sī bō jiǎn，意思是丝得一根一根地抽，茧得一层一层地剥；形容分析事物极为细致，而且一步一步很有层次。 出自 明·洪楩《清平山堂话本·蓝桥记》“安绶惘纪，无行云流水之势，但如抽丝剥茧之行而为之，故望此云，无望得众。” to make a painstaking investigation 抽薪止沸 抽掉锅底下的柴火，使锅里的水不再翻滚；比喻从根本上解决问题。 出自 汉·董卓《上何进书》：“臣闻扬汤止沸，不如灭火去薪。” 愁肠百结/出将入相/出没无常/出人意表/除恶务尽/除旧布新/锄强扶弱 出乖露丑 chū guāi lòu chǒu，意思是指在人前出丑。 出自《西厢记诸宫调》。 樗栎庸材 chū lì yōng cái，意思是比喻平庸无用的人；常用作谦词。 出自《庄子·逍遥游》：“吾有大树，人谓之樗，其大本拥肿而不中绳墨，其小枝卷曲而不中规矩。立之涂，匠者不顾。” 杵臼之交 chǔ jiù zhī jiāo，意思是比喻交朋友不计较贫富和身份。 出自《后汉书·吴祐传》。 追忆乾隆丙辰荐鸿博入都，在赵横山阁学处见美少年张君名顾鉴者，彼此订杵臼之交。 清·袁枚《随园诗话补遗》第六卷 东汉时，山东胶东书生公沙穆隐居在东莱山求学，为筹集求学经费，穿上粗布衣服到陈留郡长官吴祐吴大人家做舂米雇工，吴大人见其谈吐非凡，就与他结交为好友，并资助他继续求学。后来公沙穆学成成为一个有作为的正义官员。 础润而雨 chǔ rùn ér yǔ，意思是柱子的基石润湿了，就是要下雨的征候；比喻见到一点迹象，就能知道它的发展方向。 出自《淮南子·说林训》。 楚才晋用 楚弓楚得 意思是楚国人丢失弓，拾到的仍是楚国人。比喻自己的东西虽然丢了，拾到它的人并不是外人。 出自《说苑·至公》，《孔子世家·好生》。 怵目惊心/怵魄动心 使人十分害怕和震惊 穿壁引光 凿通墙壁，引进烛光，形容家贫读书刻苦。 出自 晋·葛洪《西京杂记》卷二：“匡衡字稚圭，勤学而无烛，邻舍有烛而不逮。衡乃穿壁引其光，以书映光而读之。” bore a hole in the wall in order to get some light from the neighbor’s house. 西汉宰相匡衡从小因为家贫，没有条件进学堂，他白头帮人干活，晚上没钱买灯油，就只好在家里土墙上凿一个洞，借隔壁的灯光来读书，甚至到有书的人家去免费帮工换取书本，他刻苦学习终于在汉元帝时期当上太子少傅。 穿云裂石 意思是穿破云天，震裂石头；形容声音高亢嘹亮。 出自 宋·苏轼《〈水龙吟〉序》：“善吹铁笛，嘹然有穿云裂石之声。” 传檄而定 比喻不待出兵，只要用一纸文书，就可以降服敌方，安定局势。 出自《史记·淮阴侯列传》 船到江心补漏迟 创巨痛深 意思是受了很大创伤，痛苦很深。 出自《礼记·三年问》。 窗明几净/怆地呼天 床上安床 意思是床上安张床，比喻不必要的重复。出自《续画品·毛棱》。 创业垂统 意思是创立功业，传给后代子孙。 出自《孟子·梁惠王下》。 炊金馔玉 chuī jīn zhuàn yù ，意思是形容丰盛的菜肴。 出自《帝京篇》。 炊沙作饭 chuī shā zuò fàn，指煮沙子作饭，比喻徒劳无功，白费气力。 出自唐代顾况《行路难》诗：“君不见担雪塞井徒用力，炊沙作饭岂堪吃？ 春树暮云 意思是表示对远方友人的思念。 出自 杜甫《春日忆李白》诗：“渭北春天树，江东日暮云。何时一樽酒，重与细论文。” 春蚓秋蛇 chūn yǐn qiū shé，意思是比喻字写得不好，弯弯曲曲，像蚯蚓和蛇爬行的痕迹。 出自 《晋书·王羲之传》：“行之若萦春蚓，字字如绾秋蛇。” 蜂腰鹤膝嘲希逸，春蚓秋蛇病子云。 ★宋·苏轼《和孔密州五绝·和流杯石上草书小诗》 椿萱并茂 chūn xuān bìng mào，意思是指椿树和萱草都茂盛，现比喻父母都健康，褒义词。 语出《庄子·逍遥游》。“上古有大椿者；以八千岁为春；八千岁为秋。”因大椿长寿，古人用以比喻父亲。《诗经·卫风·伯兮》：”焉得谖草，言树之背”。“谖”同“萱”，“萱草”为忘忧之草，古人用以比喻母亲。 莼羹鲈脍 chún gēng lú kuài，意思是味道鲜美的莼菜羹、鲈鱼脍，比喻为思乡的心情。 出自《晋书·张翰传》。 water shield soup and minced perch 意倦须还，身闲贵早，岂为莼羹鲈脍哉！ 宋·辛弃疾《沁园春·带湖新居将成》 转瞬西风又起，忽摇动莼鲈乡思。 晚清·徐自华《慧僧先生解职归见》 “张翰在洛，见秋风起，因思吴中菰菜羹、鲈鱼脍，曰：‘人生贵得适意尔，何能羁宦数千里以要名爵？’遂命驾归。”令张翰弃官而返乡的这道苏浙佳肴，就是“莼羹鲈脍”。鲈鱼产于近海，味道鲜美；莼菜者，多年生水草也。张翰系西晋文学家，江苏吴县人，他在北方做官，因秋风起而思念家乡的“莼羹鲈脍”，竟辞官归家，足见美食与乡愁的渊源了！ 唇焦舌敝 形容说话太多，费尽唇舌。出自《吴越春秋·夫差内传》。 鹑衣百结 chún yī bǎi jié，意思是形容衣服破烂不堪。 出自《荀子·大略》。 宋·李昉《太平广记》：“时有一人，鹑衣百结，颜貌憔悴，亦往庙所。 宋 苏轼《踏莎行·这个秃奴》：一从迷恋玉楼人，鹑衣百结浑无奈。 宋 赵蕃 《大雪》诗：“鹑衣百结不蔽膝，恋恋谁怜范叔贫？“” 清程麟《此中人语乞丐风流》：鹑衣百结走风尘，落魄谁怜此一身？ 《精忠岳传·第七十回》：“秦桧见那疯僧垢面蓬头，鹑衣百结，口嘴歪斜，手瘤足跛，浑身污秽。“” 高晓声《李顺大造屋》：“穷得家徒四壁，鹑衣百结，才独身至今。 范烟桥 《唐伯虎的故事·梅花梦》：“科头跣足，发挽双髻，鹑衣百结，可是丰神却是清朗飘逸。” 踔厉风发 chuō lì fēng fā，意思是形容精神振作，意气奋发。 出自 唐·韩愈《柳子厚墓志铭》：“议论证据今古，出入经史百子，中踔厉风发，率常屈其座人。” 词不达意 此唱彼和 意思是这里唱歌，那里相和。形容彼此相呼应。出自《明诗纪事·己签序》。 刺刺不休 cì cì bù xiū，意思说话唠叨，没完没了。出自《送殷员外序》。 踧踖不安 cù jí bù ān，意思是恭敬而不自然的样子。 出自 清·曹雪芹《红楼梦》第七十五回：“宝玉因贾政在坐，早已踧踖不安。” 烁烁的灯光迫得我们皱起了眉头，我们的风尘色全给它托出来了，这使我踧踖不安了。（朱自清《桨声灯影里的秦淮河》） 爨桂炊玉 cuàn guì chuī yù，意思为物价昂贵生活艰难，家里揭不开锅。 出自宋·司马光《答刘蒙书》。 摧陷廓清 cuī xiàn kuò qīng，意思是攻破敌阵，肃清残敌，比喻写文章打破陈规。 出自唐·李汉《昌黎先生集序》。 存而不论 指把问题保留下来，暂不讨论。 出自《庄子·齐物论》。 leave the question open；exclude a problem from consideration though aware of its existence；keep but do not discuss it；put the problem away 其源虽出于《洪范》，然既为术数之学，则治经者存而不论可矣。 ◎清·陈澧《东塾读书记·尚书》 三国 魏嵇康《难宅无吉凶摄生论》：“况乎天下微事，言所不能及，数所不能分，是以古人存而不论。” 唐 刘餗《序》：“释教推报应之理，余尝存而不论。” 《旧唐书·李绛传》：“圣旨所及，实辨邪源。但存而不论，弊斯息矣。” 《宋史·陈恕传》：“三教之兴，其来已久，前代毁之者多矣，但存而不论可也。” 鲁迅《准风月谈·答“兼示”》：“至于存而不论，那固然也可以，然而论及又有何妨呢？” 存亡继绝 意思是恢复灭亡的国家，延续断绝了的贵族世家。出自《论语·尧曰》。 寸积铢累 cùn jī zhū lěi，形容点点滴滴地积累，出自宋·李纲《与右丞相条具事宜札子》。 accumulate little by little 【近义词】：积少成多、集腋成裘、聚沙成塔 寸木岑楼 cùn mù cén lóu，意思是一寸长的木材同尖顶的高楼比；原意是起点不同就比不出高低，比喻轻重相比必须标准一样；后也比喻差距极大。 出自《孟子·告子下》。 有一位任国的人向孟子的学生屋庐子问礼与食哪个重要的问题，屋庐子随口答道“礼重要”。任人又问道：“娶妻与礼哪个重要？”屋庐子答道：“还是礼重要。” 随后，这位任人便一本正经地说道：“要是按着那些礼节去找吃的，恐怕就要挨饿、甚至饿死；如果不按着那些礼节去找吃的，可能就会有吃的。在这样的情况下，难道还要按着礼节去行事吗？再有，假如按照亲迎礼，就得不到妻子；要是不行亲迎礼，就能得到妻子，还一定要行亲迎礼吗？” 这一问，屋庐子没有答出来。第二天，便去邹国，转告了老师孟子。 孟子听后，说道：“回答这个问题有什么困难的？如果不揣度基地的高低是否一致，那么一寸长的小木头也可能比顶端的高楼还要高。说金子比羽毛重，但是，岂能说三钱多重的金子也比一车的羽毛还要重？拿吃的重要与礼的细节相比较，何止于吃的重要？拿娶妻的重要与礼的细节相比较，何止于娶妻重要？你去这样回答他：‘扭折了自己哥哥的胳膊而夺取了他的食品，自己便有了吃的；而不扭折，便得不着吃的，那么他会去扭折吗？越过东邻的墙去搂抱人家的女子，便得到了妻子；而不去搂抱，便得不着妻子，那么他会去搂抱吗？” 厝火积薪 cuò huǒ jī xīn，把火放到柴堆下面，比喻潜伏着很大危险。 西汉初年，著名的政治家贾谊多次向汉文帝上书陈述社会的弊端，写出了著名的《陈政事疏》，他认为当前的政治局势很不好，出现很多违背情理、伤害道义的事情，应该想办法革除。如果看不到的话就像厝火积薪一样危险。 措置裕如 cuò zhì yù rú，形容从容不迫，很有办法的样子。出自《提督因疾出缺请旨简放折》。 D 打躬作揖 dǎ gōng zuò yī，意思是弯身报拳行礼，表示恭敬顺从或恳求的样子。 出自《红楼梦》。 salute with folded hands and make deep bows 打鸡骂狗 大处落墨 原指画画或写文章要在主要部分下工夫。比喻做事从大处着眼，首先解决关键问题。出自《官场现形记》第二十回。 to pay attention to the important points；concentrate on the key points;place the stress on the main issues 大醇小疵 dà chún xiǎo cī，意思是大体纯正，而略有缺点。 出自《读〈荀子〉》。 great despite minor blemishes,a rough diamond 大而无当 意思是虽然大，却无底。原指大得无边际。后多用作表示大得不切合实际、不合用。 出自《庄子·逍遥游》。 be big but inappropriate 春秋时期，楚国狂士接舆对肩吾（古神话传说的人物）说北海有一座姑射仙山，山上的神仙可以让世界五谷丰登。肩吾认为接舆的话大而无当、不近人情，就对连叔说接舆在吹牛。连叔沉思了一会，对肩吾说接舆的话不一定是没有道理的。 大旱之望云霓 渴望解除困境。出自《孟子·梁惠王下》。 大谬不然 dà miù bù rán，意思是大错特错，与实际完全不符。 出自《报任少卿书》。 be absurd;be entirely wrong 西汉时期，著名的史学家司马迁因汉将李陵攻打匈奴失败被迫投降一事，为李陵说了情，遭到了宫刑并被关入大牢，面对这奇耻大辱，他只好给好友任安写信倾诉他的不幸：“身非木石，独与法吏为伍。”自己的忠心反而受摧残，真是大谬不然。 大张挞伐 dà zhāng tà fá，比喻大规模地攻击或声讨。 出自《诗经·商颂·殷武》：“挞彼殷武，奋伐荆楚。” 戴天履地 dài tiān lǚ dì，意思是头顶着天，脚踩着地，形容人活在天地之间。比喻恩德深广，如天高地厚。 出自《左传·僖公十五年》。 丹书铁券 殚见洽闻 dān jiàn qià wén，意思是该见的都见过了，该听的都听过了，形容见多识广，知识渊博。 出自 汉·班固《西都赋》：“元元本本，殚见洽闻。” 殚见洽闻，非后儒所能及矣。（清 陈澧《东塾读书记 礼记》） extensive experience and knowledge 殚精毕力 dān jīng bì lì，意思是尽心竭力。 出自 明·张居正《示季子懋修》：“甲辰下第，然后揣己力量，复寻前辙，昼作夜思，殚精毕力，幸而艺成。” 俾天下知功名之路，相率研求，～，以备干城之用。 ★清·薛福成《应诏陈言疏》 箪食瓢饮/刀耕火种/岛瘦郊寒 当行出色 dāng háng chū sè，意思是指做本行本业的事，成绩特别显著。 出自 明·王骥德《曲律·杂论》。 荡析离居 dàng xī lí jū，意思是家人离散，没有定居。 出自《尚书·盘庚下》。 become separated and live apart 蹈常习故/蹈常袭故/蹈故习常 按照老规矩和老办法办事。 出自 宋·苏轼《伊尹论》：“后之君子，蹈常而习故，惴惴焉惧不免于天下。” 倒廪倾囷/倒箧倾筐 dǎo lǐn qīng qūn，意思是倾倒出粮仓中全部储藏。比喻罄其所有、尽其所知。 出自 唐·韩愈《答窦秀才书》：“虽使古之君子，积道藏德，遁其光而不曜，胶其口而不传者，遇足下之请恳恳，犹将倒廪倾囷，罗列而进也。” 倒悬之急/倒悬之危 倒悬:像人被倒挂着一样。比喻处境极端困难。 得其三昧 dé qí sān mèi，解释为指在某方面造诣深湛，熟知精义。 出自 宋·苏轼《又赠老谦》：“泻汤旧得茶三昧。” 大贤天资颖悟，自能～，不能十分精通。应如何习学可以精通之处，尚求指教。 ★清·李汝珍《镜花缘》第十七回 德厚流光 指道德高，影响便深远。 出自《谷梁传·僖公十五年》 登山小鲁 指登上东山认为鲁国小了。 出自《孟子·尽心上》。 三皇内文，九鼎丹法，莫不究其条贯，犹登山而小鲁；践其户庭，若披云而见日。（唐·岑文本《京师至德观法主孟法师碑铭序》） 等量齐观 指对有差别的事物同等看待。 出自 清·况周颐《惠风词话》：“或带烟月而益韵；托雨露而成润，意境可以稍变，然而乌可等量齐观也。” 羝羊触藩 dī yáng chù fān，意思是公羊的角缠在篱笆上，进退不得；比喻进退两难。 出自《周易·大壮》。 in a dilemma 堤溃蚁孔 指堤坝因蚂蚁洞而崩溃。 比喻忽视小处会酿成大祸。 滴水成冰 涤瑕荡秽 dí xiá dàng huì，意思是清除旧的恶习。 汉·班固《东都赋》：“于是百姓涤瑕荡秽，而镜至清。” 扺掌而谈 “扺（zhǐ）掌而谈”一词出处为《国策·秦策一》：“见说赵王与华屋之下，抵掌而谈。” 此处“抵”字为通假字，现代用法为“扺”字。据1996年上海辞书出版社《辞海》2746页： “抵（zhǐ）“，同“扺”，参见“扺”。 “扺（zhǐ）“释义中解释：“扺（zhǐ）“与“抵”本为两字，后混为一。 解释：扺掌，击掌（表示高兴），指谈得很融洽。 talk pleasantly and intimately; have a close and intimate talk; have a pleasant conversation 近义词：抵足谈心、促膝谈心 同韵词： 门禁森严、众口交传、同日而言、别鹤孤鸾、忍辱求全、乞哀告怜、博闻辩言、推波助澜、玉砌雕阑、黄雀伺蝉 砥节砺行 dǐ jié lì xíng，意思是磨炼节操与德行。 出自 汉·蔡邕《郭有道林宗碑》：“若乃砥节砺行，直道正辞，贞固足以干事，隐括足以矫时。” 砥砺廉隅 dǐ lì lián yú，意思是通过磨炼而使品德端正不苟，同“砥厉廉隅”。 出自《礼记·儒行》。 掂斤播两 diān jīn bō liǎng ，比喻在小事情上过分计较。出自元·王实甫《西厢记》。 雕肝琢肾 比喻写作的刻意锤炼。 出自 唐·韩愈《赠崔立之评事》诗：“劝君韬养待征招，不用雕琢愁肝肾。” 雕章镂句 diāo zhāng lòu jù，意思指文章的词句刻意修饰。 出自 唐·白居易《议文章》：“今褒贬之文无核实，则惩劝之道缺矣；美刺之诗不稽政，则补察之义废矣。虽雕章镂句，将焉用之。” 吊古寻幽 凭吊古迹，寻找幽境，感怀旧事。 出自 明·冯梦龙《古今小说》第三十卷：“游山玩水，吊古寻幽，赏月吟风，怡情遣兴，诗赋文词，山川殆遍。” 吊民伐罪 慰问受苦的人民，讨伐有罪的统治者，征讨有罪者以抚慰百姓。 出自《孟子·滕文公下》 跌宕不羁/跌荡不羁/跌宕放言 形容人心胸开阔，心无羁绊，放浪形骸，不受拘束。 跌宕昭彰 dié dàng zhāo zhāng，意思指气势放纵不拘，文意显明。 出自《&lt;陶渊明集&gt;序》。 跌脚捶胸 diē jiǎo chuí xiōng，意思是以足跺地，以拳敲胸。 出自元·关汉卿《五侯宴》。 pound one’s feet and beat one’s breast 叠床架屋 比喻重复、累赘。也比喻办事重复，自找麻烦。 也作床上安床。 出自 北齐·颜之推《颜氏家训·序致》：“魏晋已来，所著诸子，理重事复，递相模学，犹屋下架屋，床上施床耳。” 清人袁枚《随园诗话补遗》卷六：“咏桃源诗，古来最多，意义俱被说过，作者往往有叠床架屋之病，最难出色。” 鼎鱼幕燕 dǐng yú mù yàn，意思是宛如鼎中游动的鱼，帷幕上筑巢的燕子。比喻处于极危险境地的人或事物。 出自南朝·梁·丘迟《与陈伯之书》 东床坦腹 意思指女婿，出自《世说新语·雅量》。 东风射马耳 射，也作吹。东风很快地吹过马耳，比喻把别人的话当作耳边风，充耳不闻，无动于衷。 东海扬尘 比喻时势变迁，世事变化很大。出自晋·葛洪《神仙传·麻姑》。 东鳞西爪/一鳞半爪、缺头少尾、支离破碎 dōng lín xī zhǎo，意思是比喻零星片段的事物。 出自《识某大令集尾》。 fragments 东食西宿 比喻贪婪的人各方面的好处都要。 出自《风俗通》。 齐国有一个年轻貌美的女子，东西两家公子同时来求婚，东家公子很富有但相貌丑陋，西家公子是一个英俊的穷书生，姑娘的父母很为难，叫姑娘自己定夺，她说两个都愿意嫁，白天在东家吃饭，晚上去西家睡觉。 冬裘夏葛 思是冬天穿裘，夏天穿葛，以应冬寒夏暑之气。比喻根据客观环境的变化，适当调整应对措施，最大限度地保护自己。 出自《公羊传·桓公八年》 动辄得咎 意思是动不动就受到责备或处分。出自唐·韩愈《进学解》。 唐朝时期，韩愈学识渊博，被任命监察御史，因反对宦官利用“宫市”敲诈百姓触怒了唐德宗一事被贬，后在唐宪宗时调回京城任吏部员外郎，他又因华州刺史之事被贬为国子监博士，他作《进学解》感慨自己：“跋前踬后，动辄得咎。” 洞察其奸 意思是对别人的阴谋诡计看得很清楚。 出自《明史·董传策传》。 斗筲之人/斗筲之辈 dǒu shāo zhī rén，意思是形容人的气量狭小，见识短浅。 出自《论语·子路》。 春秋时期，孔子带领弟子周游列国，在陈国闲居无事，与弟子讨论修身之事。他说做“士”要做到“仁者不忧、知者不惑、勇者不惧”三好，分“不辱君命，为国效力；孝悌兼备，乡邻模范；言信行果，千金一诺。”三类，“斗筲之人，何足算也。” 斗转参横 dǒu zhuǎn shēn héng，意思是北斗转向，参宿打横；指天快亮的时候。 出自《善哉行》。 三国·魏·曹植《善哉行》：“月没参横，北斗阑干。” 《宋史·乐志》：“斗转参横将旦，天开地辟如春。” 斗鸡走狗 使公鸡相斗，使狗赛跑。指旧时剥削阶级子弟游手好闲的无聊游戏。也说斗鸡走马。 出自《史记·袁盎晁错列传》。 独步当时 指在当时独一无二，没有可以相比的。出自《晋书·陆喜传》。 独夫民贼 指对国家人民有严重罪行的、残暴的统治者。出自《尚书·泰誓下》。 the autocrat and traitor to the people 独具只眼/独具慧眼 意思是具有独到的眼光和见解；形容眼光敏锐，能看到别人不易发现的事物，见解高超。 出自《送彭元忠县丞北归》。 笃近举远 dǔ jìn jǔ yuǎn，意思是对关系近的厚道，对关系远的举荐，指同等待人。 出自唐·韩愈《原人》。 睹物伤情 指看到东西就因想起它的主人而伤感动情，形容深切的怀念。 出自《醒世恒言》 杜门却扫/杜门谢客、闭门却扫 意思是关上大门，扫除车迹。指闭门谢客，不和外界往来。出自《北史·李谧传》。 妒贤嫉能/断编残简/堆山塞海/对床夜雨/顿挫抑扬/多财善贾/咄咄怪事 断鹤续凫 duàn hè xù fú，截断鹤的长腿去接续野鸭的短腿，比喻行事违反自然规律。 出自《庄子·骈拇》。 有个多事之人看到郊外一群群野鸭子和白鹤在水里啄食嬉戏。他发现鹤腿长，野鸭的腿很短。于是就故作姿态，把野鸭的腿接长，鹤腿截短，结果搞得它们都不能走路了 兔起鹘落/兔起凫举 tù qǐ hú luò，意思是指动作非常敏捷；比喻下笔快捷。 出自 宋苏轼《文与可画蒷筜谷偃竹记》：“急起从之，振笔直遂，以追其所见，如兔起鹘落，少纵即逝矣。” 遁世离羣/遁世离群 dùn shì lí qún，意思是犹言避世独处。出自《元史·隐逸传序》。 咄咄书空 duō duō shū kōng 形容失志、懊恨之态。 度德量力 duó dé liàng lì ，意思是衡量自己的德行是否能够服人，估计自己的能力是否能够胜任。 出自《左传·隐公十一年》 E 阿谀逢迎 ē yú féng yíng，意思是谄媚拍马，投合对方的心意。出自《二程全书·伊川易传一》。 阿尊事贵 ē zūn shì guì，意思是迎合和侍奉权贵。 出自《汉书·楚元王传》。 讹言谎语 é yán huǎng yǔ，意思是造谣说谎话。出自《冤家债主》。 峨冠博带 é guān bó dài，意思是高帽子和阔衣带，古代士大夫的装束。后来人们引用“峨冠博带”(高帽阔带)比喻穿着礼服。 出自元·关汉卿《谢天香》第一折：“必定是峨冠博带一个名士大夫。” Referring to official scholars；high cap and wide belt 蛾眉皓齿 恶积祸盈 è jī huò yíng，意思是罪恶成堆，祸害满贯；形容罪大恶极。 出自 南朝·梁·丘迟《与陈伯之书》：“北虏僭盗中原，多历年所，恶积祸盈，理至燋烂。” 饿殍遍野 è piǎo biàn yě，形容老百姓因饥饿而大量死亡的悲惨景象。 出自先秦·孟轲《孟子·梁惠王上》。 In the fields lay people starved to death. 耳鬓厮磨 ěr bìn sī mó，意思是耳与鬓发互相摩擦。形容亲密相处的情景。多指恋人相恋的亲密情景。 出自清·曹雪芹《红楼梦》 耳食之谈 意思是用耳朵吃东西，比喻没有经过思考轻信传言的话。 出自《史记·六国年表序》。 耳顺之年 意思是六十岁时听别人言语便可判断是非真假，指60岁的代称。 出自《论语·为政》。 F 发奸擿伏 fā jiān zhāi fú，意思是揭露隐蔽的坏人坏事。出自《后汉书·法雄传》 发蒙振落 意思是指把蒙在物体上的东西揭掉，把将要落的树叶摘下来。 比喻事情很容易做到，出自《史记·汲郑列传》。 西汉时，掌管封舜事务的主爵都尉汲黯，是位忠正耿直的大臣。他不考虑个人安危，经常向年轻的汉武帝直言进谏。有个名叫董仲舒的读书人向武帝提出建议，将诸子百家的学说作为邪说，予以禁止，独尊孔子及其儒家经典，以通过文化上的统治，达到政治上的统一。这就是所谓“罢黜百家，独尊儒术”。后来，武帝采纳这个建议，到处表示要以仁义治天下。 汲黯觉得武帝这种表示是言不由衷的。有一次，他当着许多儒生的面批评武帝说：“陛下内心的欲望很多，嘴上却说要以仁义治天下。这哪里像古代圣贤唐尧、虞舜的样子呢？” 武帝听了无言以答，非常难堪地离去。 有人对汲黯说，你这样当面得罪皇帝，迟早会出事的，汲黯不以为然地说：“皇帝设置百官，难道是为了让他们光说好活，而使皇帝陷入不义的污泥里去吗？” 不久，淮南王刘安准备反叛。他对公孙弘并不放在眼里，怕的倒是汲黯。为此，特地告诫手下人千万不要在汲黯那里露了马脚。他说，汲黯此人爱好直言进谏，能为节义而死，很难迷惑他。至于丞相公孙弘，对付他就像揭开蒙盖在眼睛上的障碍，振落树上的枯叶那样容易。 发扬蹈厉 fā yánɡ dǎo lì，意思是原指周初《武》乐的舞蹈动作；手足发扬，蹈地而猛烈，象征太公望辅助武王伐纣时勇往直前的意志；后比喻精神奋发，意气昂扬。 出自《礼记·乐记》。 发纵指示 fā zòng zhǐ shì，意思是发现野兽的踪迹，指示猎狗跟踪追捕，比喻暗中操纵指挥。 出自西汉·司马迁《史记·萧相国世家》。 unleash hunting dogs after a quarry 秦朝末年，刘邦起兵被封为沛公后，萧何成为刘邦的得力助手，他帮助刘邦保存秦朝的各种文献档案，留守关中，为刘邦提供军粮和新兵，引荐大将韩信。在汉朝建立后刘邦论功行赏时，他评论萧何是发踪指示的猎人，功劳最大。 伐功矜能 fá gōng jīn néng，意思是指吹嘘自己的功劳和才能；形容居高自大，恃才傲物。 出自《史记·太史公自序》。 伐毛洗髓/伐毛换髓、脱胎换骨、洗心革面 fā máo xǐ suǐ，意思是指刮去毛发，洗清骨髓。常以此言作贺语，赞其能够脱胎换骨，洗心革面。 出自《东方朔传》。 make a thoroughgoing change 伐罪吊民 意思是指讨伐有罪，拯救百姓，常用以作为发动战争的口号。 出自 南朝（梁）任方《百辟劝进今上笺》：“伐罪吊民，一匡靖乱。” punish the tyrants and comfort the people 罚不当罪 fá bù dāng zuì，指处罚和罪行不相当。出自《荀子·正论》。 法不阿贵 fǎ bù ē guì，意思是法律即使是对高贵的人，有权势的人也不徇情；形容执法公正，法律面前人人平等。 出自《韩非子·有度》。 The law does not protect the powerful persons. 反求诸己 成语“行有不得，反求诸己”的一部分。意思是（如果）行动没有达到预期的效果，就应该反省，从自己身上找原因。 出自《孟子·公孙丑上》， 反裘负刍 fǎn qiú fù chú，意思是形容贫穷劳苦。也比喻为人愚昧，不知本末。 出自《晏子春秋·杂上》 Wear coat inside out 反裘：反穿皮衣；负：背；刍：柴草。反穿皮袄背柴。形容贫穷劳苦。也比喻为人愚昧，不知本末。 饭囊衣架 指装饭的口袋，挂衣的架子。比喻无用之人。 出自《误入桃源》 饭糗茹草 fàn qiǔ rú cǎo，意思是吃的是干粮、野菜；形容生活清苦。 出自《孟子·尽心下》。 范张鸡黍 fàn zhāng jī shǔ，意思是比喻朋友之间情深义重。 出自《后汉书-独行列传》。 范：范式；张：张劭；鸡：禽类；黍：草本植物，指黍子。范式、张劭一起喝酒食鸡。比喻朋友之间含义与深情 方枘圆凿 fāng ruì yuán záo，意思是比喻格格不入、不相容、不适宜。也说圆凿方枘。 出自战国·楚·宋玉《九辨》。 芳兰竟体 比喻举止闲雅，风采极佳。 出自《南史·谢览传》。 放言高论 指毫无顾忌地大发议论。 出自《荀卿论》。 飞短流长 指散播谣言，中伤他人。 出自 唐·沈亚之《送韩北渚赴江西序》：“故有谀言顺容积微之谗，以基所毁，四邻之地，更效递笑，飞流短长，天下闻矣。 飞针走线 形容缝纫技术非常熟练。 出自 《祖堂集·洛甫和尚》：“问：‘孤灯不自照，室内事如何？’师云：‘飞针走线时人会，两边绣过却还稀。’” do needlework very skillfully 非驴非马 意思是不是驴也不是马。比喻不伦不类，什么也不像。 出自《汉书·西域传下》。 肥马轻裘 骑肥壮的马，穿轻暖的皮衣；形容阔绰。 出自《论语·雍也》。 ride stout horses and wear light fur coats–live an extravagant life 斐然成章 形容文章富有文采，很值得看。 出自《论语·公冶长》。 吠非其主 意思是狗朝着外人乱叫，旧比喻各为其主。 出自《战国策·齐策六》。 bark at everyone other than its master 吠形吠声 比喻跟在别人后面盲目附和。 出自 汉·王符《潜夫论·贤难》：“谚云：‘一犬吠形，百犬吠声’。” when one dog barks at a shadow all the others join in &lt; slavishly echo others&gt; 沸反盈天 意思是声音像水开锅一样沸腾翻滚，充满了空间。形容人声喧闹。 出自清·李宝嘉《中国现在记》。 分班序齿 fēn bān xù chǐ 语见：明.吴承恩《西游记》第二回：那在洞众猴，都一齐簇拥同入，分班序齿，礼拜猴王。 按年龄分先后次序. 分斤掰两 fēn jīn bāi liǎng，意思是比喻过分计较。 出自《红楼梦》 纷红骇绿 fēn hóng hài lǜ，意思是纷披散乱的红花绿叶，形容花草树木随风摆动。 出自 唐·柳宗元《袁空渴记》：“每风自四山而下，振动大木，掩苒众草，纷红骇绿，蓊郁香气。” 焚林而田 烧毁树林以猎取野兽；比喻取之不留余地，只顾眼前利益，不顾长远利益。 出自《韩非子·难一》。 粉妆玉琢 意思是白粉装饰的，白玉雕成的， 出自《金瓶梅》。 奋发蹈厉 fèn fā dǎo lì，意思是精神振奋，行动迅猛。 出自 唐·韩愈《柳子厚墓志铭》：“议论证据今古，出入经史百子，踔厉风发，率常屈其座人。” 奋袂而起 fèn mèi ér qǐ，意思是袖子一挥站起来。形容奋然而起。 辍食弃餐，奋袂攘祍，抚剑东顾，而心已驰于吴会矣。 三国·魏·曹植《求自试表》 庄王方进午膳，闻申舟见杀，投箸于席，奋袂而起。 明·冯梦龙《东周列国志》第五十五回 丰取刻与 指取之于民的多，用之于民的少。 出自《荀子·君道》。 丰神绰约/风姿绰约 指女子体态柔美丰满。 出自《初刻拍案惊奇》 风刀霜剑 形容气候寒冷恶劣，也比喻周围人际环境恶劣严酷。 出自 清·曹雪芹《红楼梦》第十七回中林黛玉的《葬花辞》：“一年三百六十日，风刀霜剑严相逼。 风骨峭峻 形容人很有骨气，刚直不阿，出自韩愈《感春五首》。 唐·韩愈《感春》诗：“孔丞别我适临汝，风骨峭峻遗尘埃。” 风流蕴藉 形容人风雅潇洒，才华横溢。也形容文章诗画意趣飘逸含蓄。 出自《北齐书·王昕传》。 风萍浪迹 比喻漂泊不定。出自柔石《二月》。 风清弊绝/弊绝风清 fēnɡ qīnɡ bì jué，意思是贪污、舞弊的事情没有了；形容坏事绝迹，社会风气良好。 出自 宋·周敦颐《拙赋》：“上安下顺，风清弊绝。” 风清月皎 轻风清凉，月光皎洁；形容夜景优美宜人。 出自《薛昭传》。 风树之感 比喻父母已亡故，不得孝养的感伤之情 风行草偃 fēng xíng cǎo yǎn。意思是风一吹草就倒下。比喻道德文教能感化人。 出自《论语·颜渊》。 Where the wind passes,the grass bends-the inferiors imitate the superiors. 风中之烛 在风里晃动的烛光。比喻随时可能死亡的人。也比喻随时可能消灭的事物。 出自 晋·王羲之《题卫夫人笔陈图后》：“时年五十有三，或恐风烛奄及，聊遗教于子孙耳。” 封豕长蛇 贪婪如大猪，残暴如大蛇；比喻贪暴者、侵略者。 封：大；封豕：大猪；长蛇：大蛇 出自《左传·定公四年》。 蜂缠蝶恋 蜜蜂纠缠不休，蝴蝶依恋不舍；比喻情和爱的干扰。 出自 清·曹雪芹《红楼梦》第一百十六回：“后来降几历劫，还报了灌溉之恩，今返归真境。所以警幻仙子命我看管，不令蜂缠蝶恋。” 蜂目豺声 fēng mù chái shēng，意思是眼睛像蜂，声音像豺。形容人相貌凶恶，声音可怕。 出自《左传·文公元年》 一、 传说春秋时期，楚王准备立他的大儿子商臣为太子，一时没有决定下来，便找令尹（宰相）子上来商量。子上说：“大王，你现在还很年轻，爱儿子的情感还不专一。如果你这样早就立了太子，将来移情爱另外一个儿子时，再废除这个太子，这样做容易发生祸乱。况且在楚国历代传统中，真正继承王位的常常是小儿子。就拿公子商臣的外貌来说，我觉得他眼睛长得像蜂眼似的可怕，说话声音像豺狼叫一样难听。依相法来说，这种相貌的人是凶残的，如果他做了太子，一定会做出不义的事来。” 楚王听了这话不以为然，还是将商臣立为太子。商臣听说子上在父亲面前说了他很多坏话，便对子上怀恨在心。有一次，他利用和别国打仗的机会，在楚王面前说子上受了敌国行贿，楚王不问情由便将子上赐死。 后来，楚王了解真相时已后悔莫及。不久，楚王真的就像子上说的那样开始讨厌商臣，而喜欢上了第二个儿子子职，并想改立子职为太子。商臣知道这事以后，便与老师潘崇合谋，率领宫中军队将王宫围住，逼死了父亲，自立为王，称作楚穆王。 二、 晋朝时期，潘阳仲见到幼年王敦的长相，便说：“你像蜂一样的眼睛已露出来，只是豺狼一样的声音还没有发出罢了，你今后一定会吃人，也一定会被别人吃掉。”后来王敦果然寡恩少义，多行杀戮。 逢人说项 比喻到处为某人某事吹嘘，说好话。 出自 唐·杨敬之《赠项斯》：“处处见诗诗总好，及观标格过于诗。平生不解藏人善，到处逢人说项斯。” 唐朝时期，江东年轻人项斯，字子迁，参加会考开始没有什么名气，别人拿他的卷子去给杨敬之看。杨敬之特别喜欢就作诗：“几度见诗诗尽好，及观标格过于诗，平生不解藏人善，到处逢人说项斯。”没多久，他就被长安方面录取。 讽一劝百 意思是委婉含蓄地批评，指责一个，使大家都受到教育。 出自《史记·司马相如列传》。 凤鸣朝阳 凤凰在早晨的阳光中鸣叫，比喻有高才的人得到发挥的机会。 出自《诗经·大雅·卷阿》：“凤凰鸣矣，于彼高冈；梧桐生矣，于彼朝阳。” 南朝·宋·刘义庆《世说新语·赏誉》：“张华见褚陶，语陆平原曰：‘君兄弟龙跃云津，顾彦先凤鸣朝阳。’” phoenix singing in morning sun 奉辞伐罪 奉严正之辞而讨有罪。出自《书·大禹谟》。 send an expedition to punish a guilty party 奉为圭臬 fèng wéi guī niè。 奉：信奉；圭臬：比喻事物的准则。比喻把某些言论或事当成自己的准则。出自清·钱大昕《六书音韵表序》 奉行故事/循规蹈矩 指按照老规矩办事。 出自东汉·班固《汉书·魏相传》。 佛口蛇心 意思是佛的嘴巴，蛇的心肠；比喻话虽说得好听，心肠却极狠毒。 出自《五灯会元》。 duplicitous 佛头着粪/佛头着粪 指佛性慈善，在他头上放粪也不计较。后多比喻不好的东西放在好东西上面，玷污的好的东西。 出自《景德传灯录》。 穆宗时期，崔群游览湖南东寺，见鸟雀在佛像头上拉屎，就对住持说鸟雀没有佛性，对佛大不敬，住持说鸟雀有佛性，它们选择在佛头上拉屎，是因为佛性慈善，容忍众生，对外物从不计较，鸟雀也明白这点 夫贵妻荣 指丈夫尊贵，妻子也随之光荣。 出自 唐·唐正辞《太子宾客赵夫人夏侯氏墓志》：“鱼轩象服，夫贵妻荣。” 肤受之言 意思是肤浅的，使人感受不深的言论。 出自《后汉书·杨璇传论》：“风景之赏未甄，肤受之言互及。” 敷衍塞责 fū yǎn sè zé，敷衍：马虎，不认真，表面上应付；塞责：搪塞责任。指工作不认真负责，表面应付了事。 出自 清·张集馨《道咸宦海见闻录》：“委员共知其事体之难，始克竣事，半属敷衍塞责。” 凫趋雀跃 fú qū què yuè 指像野鸭那样快跑，像鸟雀那样跳跃。 形容十分欢欣的样子。 出自 唐·卢照邻《穷鱼赋》：“渔者观焉，乃具竿索，集朋党，凫趋雀跃，风驰电往，竞下任公之钓，争陈豫且之网。” 扶倾济弱 fú qīng jì ruò，意思是遇到困境的人，扶助困难的人，救济弱小的人。 出自元·王子一《误入桃源》。 扶正黜邪 fú zhèng chù xié，意思是扶助正道，除去邪恶。 出自 汉·蔡邕《对诏问灾异》：“圣意勤勤，欲清流荡浊，扶正黜邪。” 浮家泛宅 形容以船为家，在水上生活，漂泊不定。 出自《新唐书·张志和传》。 宋 胡舜陟《渔家傲》词：“今我绿蓑青箬笠，浮家泛宅烟波逸。” 清 蒋士铨《第二碑·寻诗》：“老夫野鹤闲云，浮家泛宅，未足系人齿颊。” 李光 《题亚子〈分湖归隐图〉》诗：“浮家泛宅梨川梦，寻壑经邱栗里情。” 宋 胡仔《满江红》：“泛宅浮家何处好？苕溪清境。” 高阳《清宫外史》下册：“明太祖为惩罚叛逆，不准他们在岸上落脚，因而浮家泛宅在富春江上，以打鱼为生。” 浮语虚辞 意思是指大话、空话。 出自《东观汉记·隗嚣传》。 浮云朝露 意思是比喻时光易逝，人生短促。 出自 《周书·萧大圜传》：“人生若浮云朝露，宁俟长绳第景，实不愿之。” 吐刚茹柔 tǔ gāng rú róu，意思是吐出硬的，吃下软的。比喻怕强欺弱。 出自《诗经·大雅·烝民》。 浮踪浪迹 意思是飘浮不定的踪影，到处流浪的足迹。 出自元·王子一《误入桃园》。 桴鼓相应 fú gǔ xiāng yìng，意思是用鼓槌打鼓，鼓就响起来；比喻相互应和，配合得很紧密。 出自《吕氏春秋·季秋纪·知士》。 抚躬自问 意思是反躬自问，指自我反省。 出自 清·昭梿《啸亭杂录·朱白泉狱中上百朱二公书》：“今以愚昧，于此获罪，所知为之流涕，路人为之叹息。抚躬自问，为幸多矣！” Examine one’s own conscience 抚孤恤寡 fǔ gū xù guǎ 指养育孤儿，帮助寡妇 釜底游鱼/釜底之鱼 辅车相依 意思是像颊骨和牙床一样，互相依存，形容关系非常密切。出自《左传·僖公五年》 辅车相依，唇亡齿寒 负弩前驱 fù nǔ qián qū，谓背负弓箭，开路先行。古代迎接贵宾之礼。 出自西汉·司马迁《史记·司马相如列传》。 负屈含冤/负薪救火 负薪之忧 指背柴劳累，体力还未恢复。有病的谦词。 出自《礼记·曲礼下》 妇姑勃溪 fù gū bó xī，意思指婆媳间的争吵与不和，比喻因日常鸡毛蒜皮的小事而争吵。 出自《庄子·外物》。 附赘悬疣 fù zhuì xuán yóu，意思是比喻多余无用的东西。 出自《庄子·大宗师》。 附赘：附生于皮肤上的肉瘤；悬疣：皮肤上突起的瘊子。 复蹈前辙/重覆旧辙/复蹈其辙 fù dǎo qián zhé，重新踏上先前车轮辗过的痕迹。比喻不吸取教训，重犯错误。 今不想前事之失，复循覆车之轨。 《后汉书·窦武传》 东汉光武帝刘秀重用外戚梁冀一家，梁家横行无忌，毒死汉质帝刘瓒。汉桓帝刘志当皇帝后，利用身边的五个宦官除掉了无恶不作的梁家，将这五个宦官封侯，大将军窦武写信给汉桓帝不要重蹈覆辙，结果被宦官杀害 傅粉施朱/施朱傅粉 意思是搽粉抹胭脂。泛指修饰打扮。 出自 战国·楚·宋玉《登徒子好色赋》。 腹诽心谤 fù fěi xīn bàng，意思指心怀不满，暗中发泄。 出自《史记·魏其武安侯列传》。 腹心之疾 比喻祸患象要害处的疾病历害。出自《战国策·魏策三》。 腹有鳞甲 比喻人多巧诈的心。 出自《三国志·蜀书·陈震传》。 覆车之鉴 意思是把翻车作为镜子，比喻先前的失败，可以作为以后的教训。 出自《三国志·蜀志·后主传》。 覆盆之冤 指翻过来放的盆子，阳光照不到里面。形容无处申诉的冤枉。 出自《抱朴子·辨问》。 G 改过迁善 意思是改正错误，变成好的。指去恶就善。 出自《周易·益》：“君子以见善则迁，有过则改。” correct evil doings and revert to good deeds 改辕易辙 gǎi yuán yì zhé，意思是改变车辕的方向，走新的路。比喻改变原来的态度和做法。 出自 宋·魏庆之《诗人玉屑·张秦》：“其初改辕易辙，如枯弦敝轸，虽成声而跌宕不满人耳；少焉遂使师旷忘味，钟期改容也。” 干云蔽日 意思是冲上云霄，挡住太阳；形容树木或建筑物高大。 出自 南朝宋·范晔《后汉书·丁鸿传》：“干云蔽日之木，起于葱青。” 甘处下流 甘愿处于下流，比喻甘居落后。 出自清·俞樾《右台仙馆笔记·无锡杨氏女》。 rest content with lagging behind 甘棠遗爱/甘棠之爱 意思是旧时颂扬离去的地方官。出自《诗经·召南·甘棠》。 甘之如饴/肝胆照人/感今怀昔 感慨系之 gǎn kǎi xì zhī，意思是有所感触，慨叹不已。 出自 汉·刘桢《赠五官中郎将》诗：“秋日多悲怀，感慨以长叹。” 晋·王羲之《兰亭集序》：“及其所之既倦，情随事迁，感慨系之矣。” 旰食之劳 gàn shí zhī láo，意思是天色已晚才吃饭。形容勤于政事。 出自《晋书·郭璞传》。 刚毅木讷 gāng yì mù nè，意思是孔子称颂人的四种品质。 出自《论语·子路》。 Firm, resolute, plain and prudent 刚：坚强；毅：果决；木：质朴；讷：说话迟钝，此处指言语谨慎 纲举目张/提纲挈领 意思是提起鱼网上的大绳一抛，一个个网眼就都张开了。 比喻文章条理分明，也指抓住事物的关键，带动其他环节。 出自战国·吕不韦《吕氏春秋·用民》。 同韵词：规圜矩方、本地风光、兰桂腾芳、一人拼命，万夫难当、跗萼联芳、雪上加霜、重金袭汤、走乡随乡、野调无腔、深入膏肓 高材疾足 形容人才能出众，反应快，行事敏捷。 出自 《史记·淮阴侯列传》：“秦失其鹿，天下共逐之，于是高材疾足者先得焉。” 楚汉相争时期，刘邦与项羽争夺天下一直不分胜负，齐之名辩士蒯通劝成为齐王的韩信与他们三分鼎足，韩信却选择了帮助刘邦，结果天下基本平定后被吕后骗进长乐宫杀害。韩信到临死时才后悔没听蒯通的话，于是高祖回来知道韩信临终所言后捉来蒯通欲烹杀，蒯通辩解时便对高祖说出了一番话，其中包含此句，此句意在表明当时是群雄逐鹿，各诸侯及其党羽都是各为其主，并非针对高祖。于是高祖释放了他。 高城深池 指高高的城墙，深深的护城河。形容防守坚固。 出自《论贵粟疏》。 高飞远举/高飞远翔 飞得又高又远，比喻前程广大。 出自《说苑·八·尊贤·十三节》。 高文典册 意思指封建朝廷的重要文书、诏令。 出自《西京杂记》卷三。 高阳酒徒 秦末年代，谋士郦食其去追随刘邦时对自己的称呼。 现用以代指指嗜酒而放荡不羁的人。 出自《史记·郦生陆贾列传》 高阳：古乡名，在今河南杞县西南。秦末郦食其即此乡人，对刘邦自称“高阳酒徒”。用以指嗜酒而放荡不羁的人 高义薄云 原指文章表达的内容很有意义，后形容人很讲义气。 出自《宋书·谢灵运传论》。 高掌远跖 gāo zhǎng yuǎn zhí，意思是比喻规模巨大、气魄雄伟的经营。 出自 汉·张衡《西京赋》：“缀以二华，巨灵赑屃，高掌远跖，以流河曲。” 膏火自煎 gāo huǒ zì jiān，意思是有才学的人的人因才得祸。 出自《庄子·人间世》：“山木自寇也，膏火自煎也。 one who has talent incurs misfortune 膏粱锦绣 gāo liáng jǐn xiù，意思是形容富贵人家的奢华生活。 出自 清·曹雪芹《红楼梦》第四回：“所以这李纨虽青春丧偶，且居于膏粱锦绣之中，意如槁木死灰一般。” fat,fine grain and brocade 槁木死灰 gǎo mù sǐ huī，意思是枯干的树木和火灭后的冷灰；比喻心情极端消沉，对一切事情无动于衷，出自《庄子·齐物论》。 completely apathy 告贷无门 gào dài wú mén，形容经济十分困难，连借钱的地方都没有。 出自 明·瞿式耜《表急公绅士疏》。 割臂之盟 指用割破手臂立誓宁约（指男女秘订婚约）。 出自《左传·庄公三十二年》。 亘古未闻/更深人静/公私兼顾 更仆难数 gēng pú nán shǔ，意思是原意是儒行很多，一下子说不完，一件一件说就需要很长时间，即使中间换了人也未必能说完。 后形容人或事物很多，数也数不过来。 出自《礼记·儒行》。 be too numerous to count 绠短汲深 gěng duǎn jí shēn，意思是吊桶的绳子短，打不了深井里的水；比喻能力薄弱，难以担任艰巨的任务。 出自《庄子·至乐》。 公诸同好 指把自己所收藏的珍爱的东西拿出来，使有相同爱好的人都能欣赏。 出自三国·魏·曹植《与杨德祖书》：“虽未能藏之于名山，将以传之于同好。” 功成行满 指功德成就，道行圆满。 出自元·岳伯川《铁拐李》 攻苦食淡 意思是做艰苦的工作，吃清淡的食物。形容刻苦自励。 出自《史记·刘敬叔孙通列传》。 恭敬桑梓 桑梓：桑树和梓树，古时家宅旁边常栽的树木，比喻故乡。热爱故乡和尊敬故乡的人。 语出《诗经·小雅·小弁》：“维桑与梓，必恭敬之。” 躬逢其盛 意思是亲身经历那种盛况或指太平盛世。 出自《滕王阁序》。 躬自菲薄 gōng zì fěi bó，意思是指亲身实行俭约。 出自《文选·张衡〈东京赋〉》 钩深致远 意思是探取深处的，使远处的到来，比喻探讨深奥的道理。 出自 《周易·系辞上》：“探赜索隐，钩深致远。” 钩玄提要 gōu xuán tí yào，意思是指探取精微，摘出纲要。 出自 唐·韩愈《进学解》：“记事者必提其要，纂言者必钩其玄。” 钩章棘句 gōu zhāng jí jù，意思形容文辞艰涩拗口。 唐·韩愈：“钩章棘句，掐擢胃肾。” 篝火狐鸣 意思是夜里把火放在笼里，使隐隐约约象磷火，同时又学狐叫。这是陈涉、吴广假托狐鬼之事以发动群众起义的故事。 后用来比喻策划起义。 出自《史记·陈涉世家》。 苟合取容 gǒu hé qǔ róng，指苟且迎合，取悦于人。 出自明·冯梦龙《平妖传》。 苟且偷安 狗吠非主 意思是比喻臣子各忠于自己的君主。 出自《战国策·齐策六》。 狗彘不若 gǒu zhì bù ruò，意思是连猪狗都不如。 形容品行卑劣到连猪狗都不如的程度。 出自《荀子·荣辱》。 孤雏腐鼠 腐烂的孤独的鸟雏、老鼠。比喻微贱而不值得一说的人或事物。 出自《庄子·秋水》。 Regard humble things as lonely birdlings and putrid mice 汉朝时期，外戚窦宪靠后宫的势力，以贱价夺得沁水公主的田园，汉章帝闻知怒斥窦宪说：“公主的东西你都敢夺，何况别人的呢？你做得太令人吃惊了，须知国家抛弃你，就像抛弃孤独的小鸟和腐烂的老鼠一样。” 孤鸾寡鹤 gū luán guǎ hè，意思是指失去配偶的男子或女子。 出自《说岳全传》 姑息养奸 意思是无原则地宽容，只会助长坏人作恶。 出自《礼记·檀弓上》。 推贤进善 推荐贤士，引进好人。 出自《杜阳杂编》。 股肱之臣/骨鲠在喉 骨软筋酥 意思是骨头软了，肉也麻了，形容全身乏力，肢体瘫软的样子。 出自明·吴承恩《西游记》。 毂击肩摩 gǔ jī jiān mó，意思是肩膀和肩膀相摩，车轮和车轮相撞。形容行人车辆往来拥挤。 出自《战国策·齐策一》。 故态复萌 意思指旧的习气或毛病等又出现了。 出自《玉合记·嗣音》。 slip back into old habits 顾盼生姿 意思是回首抬眼之间就有美妙的姿色。 出自三国·魏·嵇康《赠秀才入军》 顾盼自雄 意思是寓意得意忘形，自以为了不起。 出自《阅微草堂笔记·姑妄听之》 ook about complacently. 顾曲周郎 原指周瑜业于音乐，后泛指通音乐戏曲的人，出自《三国志·吴书·周瑜传》。 顾影弄姿 对着自己的身影，做出各种姿态，形容卖弄身形，自我欣赏。 出自《聊斋志异·江城》 瓜李之嫌 瓜剖豆分 意思是象瓜被剖开，豆从荚里裂出一样。比喻国土被人分割。 出自 南朝·宋·鲍照《芜城赋》：“出入三代，五百余载，竟瓜剖而豆分。” 刮垢磨光 意思是刮去污垢，磨出光亮。比喻使事物重显光辉。也比喻仔细琢磨。 出自 唐·韩愈《劝学解》：“爬罗剔抉，刮垢磨光。” 怪力乱神 指关于怪异、勇力、叛乱、鬼神之事。 出自《论语·述而》。 关山迢递 guān shān tiáo dì，意思指路途遥远。 出自 明·王世桢《鸣凤记》第八出：“贤弟！无限别情，不胜凄怆，关山迢递，后会难期。” 观过知仁 意思是察看一个人所犯过错的性质，就可以了解他的为人。 出自《论语·里仁》。 观衅伺隙 guān xìn sì xì，意思是探察对方的破绽、漏洞，以待时机。 出自《三国志·吴书·陆逊传》 观者如堵/观者如垛/观者成堵 意思是观看的人像一堵墙一样。形容观看人数众多。 出自《礼记·射义》。 spectators formed a solid wall of humanity; be a mere spectator in the war 冠盖相望/冠盖相属 意思是形容政府的使节或官员往来不绝。 出自《战国策·魏策四》。 one official is succeeded by another 冠履倒置 意思是指帽子和鞋的位置换了；比喻上下位置颠倒，尊卑不分。 出自《后汉书·杨赐传》。 鳏寡孤独/管窥蠡测/管窥之见/管中窥豹 管宁割席 意思是比喻朋友间的情谊一刀两断，中止交往，或中止与志不同、道不合的人为朋友。 出自《世说新语 ·德行第一》。 灌夫骂座 guàn fū mà zuò，意思是指灌夫酒后骂人泄愤，形容为人刚直敢言。 出自《史记·魏其武安侯列传》。 公元前131年，安武侯田蚡娶燕王的女儿，失势的魏其侯窦婴与将军灌夫奉王太后的命令前去祝贺。灌夫给他们敬酒，田蚡及他的手下不理不睬，灌夫大骂他们，田蚡抓了灌夫全家。王太后出面杀了灌夫，窦婴也被流言蜚语所杀。 光风霁月 guāng fēng jì yuè。意思是形容雨过天晴时万物明净的景象，比喻开阔的胸襟和心地，也比喻太平清明的政治局面。 出自《豫章集·濂溪诗序》。 光复旧物 意思是收复曾被敌人侵占的祖国山河。 出自《晋书·桓温传》。 recover what has been lost (to an invader) 光阴荏苒/广土众民 归马放牛 意思是把作战用的牛马放牧。 比喻战争结束，不再用兵，出自《尚书·武成》 龟毛兔角 意思是比喻不可能存在或有名无实的东西。 A tortoise grows hair and a rabbit grows horns. 规矩绳墨 意思是指应当遵守的标准、法则。 出自《管子·七臣七主》。 规行矩步 意思是指严格按照规矩办事，毫不苟且；也指办事死板，不灵活。 出自 晋·潘尼《释奠颂》：“二学儒官，缙绅先生之徒，垂缨佩玉，规行矩步者，皆端委而陪于堂下，以待执事之命。” behave correctly and cautiously 佹得佹失 guǐ dé guǐ shī，意思是指得失出于偶然，也指有得有失。 出自《列子·力命》：“佹佹成者，俏成者也，初非成也。佹佹败者，俏败者也，初非败也。” 鬼蜮伎俩 guǐ yù jì liǎng，意思是比喻用心险恶，暗中伤人的卑劣手段。 出自《诗经·小雅·何人斯》 贵耳贱目 意思是重视传来的话，轻视亲眼看到的现实；比喻相信传说，不重视事实。 出自 张衡《东京赋》：“若客所谓，末学肤受，贵耳而贱目者也。” 桂林一枝 桂花林中的一枝花。原为晋时郤诜的自谦语。后称誉人才学出众。 出自《晋书·郤诜传》。 清赵翼《黄雨歌》：“桂林一枝定谁折，黄色上眉先报喜。”自注：“时诸生方乡试。” 清蒲松龄《与益都王禹臣亲家启》：“才得风檐片幅，已足当齐鲁之大观；行占桂林一枝，岂止坐僮仆之新敬。” 宋王禹偁《送鞠评事宰兰溪》诗：“科名旧捷仙人桂，县界遥看婺女星。” 宋 无名氏 《百字歌·寿张簿》词：“才华拔萃，早宜仙桂高折。” 唐杜甫《同豆卢峰知字韵》：“梦兰他日应，折桂早年知。” 宋张抡《满庭芳·寿杨殿帅》词：“流庆远；芝兰秀发，折桂争先。” 清李渔《夺锦楼》第一回：“那些未娶少年一发踊跃不过，未曾折桂，先有了月里嫦娥。” 王毓岱 《示和甫》诗：“撷芹复折桂，亲非由我显。” 国步艰难 过甚其辞 意思是指话说得过分，不符合实际情况。 出自《反正前后》。 过屠门而大嚼 比喻心里想而得不到手，只好用不切实际的办法来安慰自己。 过犹不及","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"LaTeX使用小记","date":"2016-03-21T09:34:25.000Z","path":"2016/03/21/LaTeX使用小记/","text":"历史渊源—出身显赫 “世界上只有一个TeX程序，它就叫做 “tex”, 它是由计算机科学家 D. E. Knuth 设计并且实现的。TeX 不仅是一个排版程序，而且是一种程序语言。 LaTeX 就是用这种语言写成的一个“TeX 宏包”，它扩展了 TeX 的功能，使我们很方便的逻辑的进行创作而不是专心于字体，缩进这些烦人的东西。 TeX 还有其它的大型宏包，它们和 LaTeX 一起都被叫做 “format”，现在还有一种常用的format叫做 ConTeXt, 用它能方便的作出极其漂亮的幻灯片，动态屏幕文档…… 我们通常用 TeX 都是在用 LaTeX, ConTeXt, 因为 TeX 的底层需要更多的知识才能了解，一般人不需要自己设计自己的格式。“ 更多关于TeX的内容,参见TeX — Beauty and Fun 安装 &amp; 使用 输入数学公式 VS Code 与 MacTex macOS 下基于 VS Code 的 LaTeX 环境配置 Latex mac vscode 数学公式 基于LaTeX书写简历 部分资源: 中英文通吃的 LaTeX 简历排版作品 非常实用漂亮的求职LaTeX简历模板 参考: 如何优雅的编辑数学公式？LaTeX公式入门 LaTeX公式编辑器 http://www.xiaomaidong.com/?p=1169","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"使用git打补丁的两种方式","date":"2016-03-15T15:52:18.000Z","path":"2016/03/15/使用git打补丁的两种方式/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"关于零拷贝","date":"2016-03-11T13:09:38.000Z","path":"2016/03/11/关于零拷贝/","text":"https://mlog.club/article/46258 https://gobea.cn/blog/detail/M5XWYqrd.html https://strikefreedom.top/pipe-pool-for-splice-in-go","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"谨慎使用strings.TrimLeft","date":"2016-03-09T13:56:54.000Z","path":"2016/03/09/谨慎使用strings-TrimLeft/","text":"123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; str := \"microsoftoffice\" rs := strings.TrimLeft(str, \"microsoft\") fmt.Println(rs)&#125; 预期输出为office,但实际输出为e 黑人问号 ??? 查看strings包中TrimLeft()方法的定义, 12345678910// TrimLeft returns a slice of the string s with all leading// Unicode code points contained in cutset removed.//// To remove a prefix, use TrimPrefix instead.func TrimLeft(s string, cutset string) string &#123; if s == \"\" || cutset == \"\" &#123; return s &#125; return TrimLeftFunc(s, makeCutsetFunc(cutset))&#125; 即TrimLeft会从字符串的左边开始，找包含待匹配字符子串中的任何最小字符，直到找不到为止, 然后把最后找到的一个字符的左边位置的字符串全部移除,返回剩下的部分. 上例中, 从microsoftoffice中寻找匹配microsoft中任何一个最小字符( 即m,i,c,r,o,s,f,t)任何一个,直到找不到为止. office中的o,f,i,c 都会被匹配,最后返回匹配不到的e 注释中也说了,想实现预期,可使用TrimPrefix To remove a prefix, use TrimPrefix instead. 如下: 123456789101112131415package mainimport ( \"fmt\" \"strings\")func main() &#123; str := \"microsoftoffice\" rs := strings.TrimPrefix(str, \"microsoft\") fmt.Println(rs)&#125; 输出为: 1office","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"bug","slug":"bug","permalink":"http://www.dashen.tech/tags/bug/"}]},{"title":"oh-my-zsh中git插件配置的别名","date":"2016-03-09T13:00:27.000Z","path":"2016/03/09/oh-my-zsh中git插件配置的别名/","text":"cat git.plugin.zsh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293## Functions## The name of the current branch# Back-compatibility wrapper for when this function was defined here in# the plugin, before being pulled in to core lib/git.zsh as git_current_branch()# to fix the core -&gt; git plugin dependency.function current_branch() &#123; git_current_branch&#125;# Pretty log messagesfunction _git_log_prettily()&#123; if ! [ -z $1 ]; then git log --pretty=$1 fi&#125;compdef _git _git_log_prettily=git-log# Warn if the current branch is a WIPfunction work_in_progress() &#123; if $(git log -n 1 2&gt;/dev/null | grep -q -c \"\\-\\-wip\\-\\-\"); then echo \"WIP!!\" fi&#125;# Check if main exists and use instead of masterfunction git_main_branch() &#123; if [[ -n \"$(git branch --list main)\" ]]; then echo main else echo master fi&#125;## Aliases# (sorted alphabetically)#alias g='git'alias ga='git add'alias gaa='git add --all'alias gapa='git add --patch'alias gau='git add --update'alias gav='git add --verbose'alias gap='git apply'alias gapt='git apply --3way'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gbda='git branch --no-color --merged | command grep -vE \"^(\\+|\\*|\\s*($(git_main_branch)|development|develop|devel|dev)\\s*$)\" | command xargs -n 1 git branch -d'alias gbD='git branch -D'alias gbl='git blame -b -w'alias gbnm='git branch --no-merged'alias gbr='git branch --remote'alias gbs='git bisect'alias gbsb='git bisect bad'alias gbsg='git bisect good'alias gbsr='git bisect reset'alias gbss='git bisect start'alias gc='git commit -v'alias gc!='git commit -v --amend'alias gcn!='git commit -v --no-edit --amend'alias gca='git commit -v -a'alias gca!='git commit -v -a --amend'alias gcan!='git commit -v -a --no-edit --amend'alias gcans!='git commit -v -a -s --no-edit --amend'alias gcam='git commit -a -m'alias gcsm='git commit -s -m'alias gcb='git checkout -b'alias gcf='git config --list'alias gcl='git clone --recurse-submodules'alias gclean='git clean -id'alias gpristine='git reset --hard &amp;&amp; git clean -dffx'alias gcm='git checkout $(git_main_branch)'alias gcd='git checkout develop'alias gcmsg='git commit -m'alias gco='git checkout'alias gcount='git shortlog -sn'alias gcp='git cherry-pick'alias gcpa='git cherry-pick --abort'alias gcpc='git cherry-pick --continue'alias gcs='git commit -S'alias gd='git diff'alias gdca='git diff --cached'alias gdcw='git diff --cached --word-diff'alias gdct='git describe --tags $(git rev-list --tags --max-count=1)'alias gds='git diff --staged'alias gdt='git diff-tree --no-commit-id --name-only -r'alias gdw='git diff --word-diff'function gdnolock() &#123; git diff \"$@\" \":(exclude)package-lock.json\" \":(exclude)*.lock\"&#125;compdef _git gdnolock=git-difffunction gdv() &#123; git diff -w \"$@\" | view - &#125;compdef _git gdv=git-diffalias gf='git fetch'alias gfa='git fetch --all --prune'alias gfo='git fetch origin'alias gfg='git ls-files | grep'alias gg='git gui citool'alias gga='git gui citool --amend'function ggf() &#123; [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force origin \"$&#123;b:=$1&#125;\"&#125;compdef _git ggf=git-checkoutfunction ggfl() &#123; [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force-with-lease origin \"$&#123;b:=$1&#125;\"&#125;compdef _git ggfl=git-checkoutfunction ggl() &#123; if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git pull origin \"$&#123;*&#125;\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull origin \"$&#123;b:=$1&#125;\" fi&#125;compdef _git ggl=git-checkoutfunction ggp() &#123; if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git push origin \"$&#123;*&#125;\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push origin \"$&#123;b:=$1&#125;\" fi&#125;compdef _git ggp=git-checkoutfunction ggpnp() &#123; if [[ \"$#\" == 0 ]]; then ggl &amp;&amp; ggp else ggl \"$&#123;*&#125;\" &amp;&amp; ggp \"$&#123;*&#125;\" fi&#125;compdef _git ggpnp=git-checkoutfunction ggu() &#123; [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull --rebase origin \"$&#123;b:=$1&#125;\"&#125;compdef _git ggu=git-checkoutalias ggpur='ggu'alias ggpull='git pull origin \"$(git_current_branch)\"'alias ggpush='git push origin \"$(git_current_branch)\"'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias gpsup='git push --set-upstream origin $(git_current_branch)'alias ghh='git help'alias gignore='git update-index --assume-unchanged'alias gignored='git ls-files -v | grep \"^[[:lower:]]\"'alias git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github $(git_main_branch):svntrunk'alias gk='\\gitk --all --branches'alias gke='\\gitk --all $(git log -g --pretty=%h)'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p'alias glgg='git log --graph'alias glgga='git log --graph --decorate --all'alias glgm='git log --graph --max-count=10'alias glo='git log --oneline --decorate'alias glol=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\"alias glols=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --stat\"alias glod=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\"alias glods=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset' --date=short\"alias glola=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --all\"alias glog='git log --oneline --decorate --graph'alias gloga='git log --oneline --decorate --graph --all'alias glp=\"_git_log_prettily\"alias gm='git merge'alias gmom='git merge origin/$(git_main_branch)'alias gmt='git mergetool --no-prompt'alias gmtvim='git mergetool --no-prompt --tool=vimdiff'alias gmum='git merge upstream/$(git_main_branch)'alias gma='git merge --abort'alias gp='git push'alias gpd='git push --dry-run'alias gpf='git push --force-with-lease'alias gpf!='git push --force'alias gpoat='git push origin --all &amp;&amp; git push origin --tags'alias gpu='git push upstream'alias gpv='git push -v'alias gr='git remote'alias gra='git remote add'alias grb='git rebase'alias grba='git rebase --abort'alias grbc='git rebase --continue'alias grbd='git rebase develop'alias grbi='git rebase -i'alias grbm='git rebase $(git_main_branch)'alias grbs='git rebase --skip'alias grev='git revert'alias grh='git reset'alias grhh='git reset --hard'alias groh='git reset origin/$(git_current_branch) --hard'alias grm='git rm'alias grmc='git rm --cached'alias grmv='git remote rename'alias grrm='git remote remove'alias grs='git restore'alias grset='git remote set-url'alias grss='git restore --source'alias grt='cd \"$(git rev-parse --show-toplevel || echo .)\"'alias gru='git reset --'alias grup='git remote update'alias grv='git remote -v'alias gsb='git status -sb'alias gsd='git svn dcommit'alias gsh='git show'alias gsi='git submodule init'alias gsps='git show --pretty=short --show-signature'alias gsr='git svn rebase'alias gss='git status -s'alias gst='git status'# use the default stash push on git 2.13 and newerautoload -Uz is-at-leastis-at-least 2.13 \"$(git --version 2&gt;/dev/null | awk '&#123;print $3&#125;')\" \\ &amp;&amp; alias gsta='git stash push' \\ || alias gsta='git stash save'alias gstaa='git stash apply'alias gstc='git stash clear'alias gstd='git stash drop'alias gstl='git stash list'alias gstp='git stash pop'alias gsts='git stash show --text'alias gstu='git stash --include-untracked'alias gstall='git stash --all'alias gsu='git submodule update'alias gsw='git switch'alias gswc='git switch -c'alias gts='git tag -s'alias gtv='git tag | sort -V'alias gtl='gtl()&#123; git tag --sort=-v:refname -n -l \"$&#123;1&#125;*\" &#125;; noglob gtl'alias gunignore='git update-index --no-assume-unchanged'alias gunwip='git log -n 1 | grep -q -c \"\\-\\-wip\\-\\-\" &amp;&amp; git reset HEAD~1'alias gup='git pull --rebase'alias gupv='git pull --rebase -v'alias gupa='git pull --rebase --autostash'alias gupav='git pull --rebase --autostash -v'alias glum='git pull upstream $(git_main_branch)'alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'alias gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify --no-gpg-sign -m \"--wip-- [skip ci]\"'alias gam='git am'alias gamc='git am --continue'alias gams='git am --skip'alias gama='git am --abort'alias gamscp='git am --show-current-patch'function grename() &#123; if [[ -z \"$1\" || -z \"$2\" ]]; then echo \"Usage: $0 old_branch new_branch\" return 1 fi # Rename branch locally git branch -m \"$1\" \"$2\" # Rename branch in origin remote if git push origin :\"$1\"; then git push --set-upstream origin \"$2\" fi&#125;","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"使用Wireshark分析网络协议","date":"2016-03-09T11:24:41.000Z","path":"2016/03/09/使用Wireshark分析网络协议/","text":"因特网中使用的是TCP/IP, 对 OSI 模型做了很多简化，如应用层没有对 表示层、会话层做严格的区分，数据链路层和物理层也没有做严格区分(这就是所谓的7层和4层) DNS 在浏览器地址栏输入 king.dashne.tech 在Wireshark中过滤 dns and ip.addr == 223.5.5.5 （关于过滤规则，可参考 Wireshark系列之5 显示过滤器） 先对请求的数据包进行分析： 从下到上分别是 应用层，传输层，网络层，数据链路层，物理层 物理层 帧编号为8194，帧长度为76字节(满足了最小帧长 为46字节的要求，故而不会被判断为无用帧) 其他字段可参考下图(原文点此) 数据链路层 目前主要有两种格式的以太网帧：Ethernet II（DIX 2.0）和IEEE 802.3 IP、ARP、EAP和QICQ协议使用Ethernet II帧结构，而STP协议则使用IEEE 802.3帧结构 给出了目的地址的Mac信息，以及源地址的Mac信息，类型 目标Mac地址，源Mac地址，类型，数据，FCS FSC即 帧校验序列，包含长度为4个字节的循环冗余校验值（CRC），由发送设备计算产生，在接收方被重新计算以确定帧在传送过程中是否被损坏 网络层 传输层-UDP协议 DNS是应用层协议，一般在传输层使用UDP协议 应用层 DNS协议的默认端口为53 响应的网络包大同小异 HTTP 传输层-TCP协议： 三次握手协议 将报文分解成多个段进行传输，到目的地后再重新装配这些段 通过 序号，确认序号，校验和， 来实现可靠传输 序号：Sequence Number，用来解决网络包乱序（reordering）问题 确认序号：Acknowledgement Number，即ACK——确认收到，用来解决丢包的问题 窗口Window：又叫Advertised-Window，即著名的滑动窗口（Sliding Window），用于解决流控 TCP Flag ：包的类型，主要用于操控TCP的状态机，如SYN Checksum：TCP数据段的校验和 1234567891011121314Transmission Control Protocol, Src Port: 21000, Dst Port:52529, Seq: 12936, ACK 183589 Len: 17 传输控制协议TCP的内容 Source port: 21000 源端口名称（端口号）（用于寻找发端应用进程） Destination port: 52529 目的端口 Sequence number: 0 (relative sequence number) 序列号（相对序列号，此序列号用来确定传送数据的正确位置，且序列号，用来侦测丢失的包）； [Next sequence number: 215 (relative sequence number)] #下一个序列号 Acknowledgement number :183589 是32位确认序号，确认其有效； Header length: 32 bytes 头部长度 Flags: 0x02 (SYN) TCP标记字段（本字段是SYN，是请求建立TCP连接） Window size value: 6364 流量控制的窗口大小 Checksum: 0xf73b [correct] TCP数据段的校验和 Options: (12 bytes) 可选项 源端口和目的端口： 各占2个字节，16比特的端口号加上32比特的IP地址，共同构成相当于传输层服务访问点的地址 Seq序号： 占4个字节，是本报文段所发送的数据部分第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。 1、假设某时序号为300，简单的理解就是发送方告诉接收端“我发送的数据是从第300开始的”。 2、假设起数据len=100字节，则下一个报文段的序号就是400； ACK 确认序号： 占4字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号； 1、确认序号是上一次已经成功接收到数据字节序号加1。还可理解为接收端告诉发送端下一次想接收开始序号。假设某时确认序号为1000，简单理解就是接收方告诉发送方“我已经收到第999序号了，我下一次想接收的数据是从1000开始的”。 2、由于序号字段有32 bit 长，可以对4GB的数据进行编号，这样就可保证当序号重复使用时，旧序号的数据早已在网络中消失了； 在数据传输过程中： 第一个报文发送：Seq1=1 ACK1=1 len1=359 收到第一个报文回复：Seq2 =1 ACK2=Seq1+ ACK1= 360， len1=17 下一个报文发送：Seq3=ACK2 =Seq1 （上一个发送的报文seq1 +上一个发送的报文len1）=360 ACK3=Seq1+ ACK1 =18 len3=0 两次ACK一样：你应该发数据，但我们没有收到数据，所以你还得同样ack继续发送 Header length首部长度（4位）： 报文头长度（单位：位）/32 1000（转化为10进制为8，8*32/8 = 32，该报文报头长度为32个字节） 存在该字段是因为TCP报头中任选字段长度可变 报头不包含任何任选字段则长度为20字节；4位所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节 Flag标志位： Flages字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. SYN：表示建立连接， 同步序号用来发起一个连接,在建立连接时使用，当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，在发回的报文段中使SYN=1和ACK=1。因此，SYN=1表示这是一个连接请求或连接接受报文，而ACK的值用来区分是哪一种报文； ACK：ACK表示响应,确认 序号有效,只有当ACK=1时，确认序号字段才有意义； PSH：PSH表示有DATA数据传输， 当PSH=1时，表明请求地TCP将本报文段立即传送给其应用层，而不要等到整个缓存都填满了之后再向上交付。 FIN：表示关闭连接 发端完成发送任务（主动关闭）,用来释放一个连接，当FIN=1时，表明欲发送的字节串已经发完，并要求释放传输连接； RST：表示重建连接 当RST=1时，表明出现严重差错，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个非法的报文段或拒绝打开一个连接； Nonce Sum：有效排除潜在的ECN滥用，RFC 3540 Congestion Window Reduced（CWR）：拥塞窗口减少标志 ECN-Echo：ECE / ECN标志 URG: 紧急指针有效（urgentpointer） 当URG=1时，表明此报文应尽快传送，而不要按原来的排队顺序来传送。与“紧急指针”字段配合使用，紧急指针指出在本报文段中的紧 急数据的最后一个字节的序号，使接收方可以知道紧急数据共有多长； 1234567891)、、其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应， 如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。2）、SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。3）、RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。 一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。4）、PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。 window窗口大小（2字节）： TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序 号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65535字节 Checksum检验和（2字节）： 检验和覆盖整个TCP报文段；强制字段，由发送端计算存储，由接收端进行验证 Urgent pointer 紧急指针（2字节）： 当Urgent标志置1时，紧急指针才有效 Options选项 ： 选项字段 允许每台主机设定能够接受的最大TCP载荷能力(缺省536字节) 。 更多关于TCP的 窗口控制，重传机制，可参见 TCP/IP第四层–传输层TCP和TPC数据报文详解 这一篇TCP总结，请务必收下","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"golang之interface入门","date":"2016-03-02T15:21:38.000Z","path":"2016/03/02/golang之interface入门/","text":"系列文章： golang实现多态 golang利用组合实现继承,和php或java面向对象的继承有何不同 Golang类型断言 golang之interface入门 interface,鸭子类型与泛型 本篇是对「Go语言底层原理剖析」的学习与记录 1. 入门 Go语言没有任何形式的基于类型的继承，取而代之的是使用接口来实现扁平化、面向组合的设计模式。 在Go语言中，interface是 其他类型可以实现的方法签名的集合。 有两种类型，实现原理有很大不同：一种是带方法签名的接口(一般称为接口)，一种是空接口(一般称为空接口) 一般最佳实践(官方库&amp;知名项目)： 接口又嵌入接口，保持深度在0或1为最佳。 接口中直接定义的方法数量10个之内最佳。 理解Go接口的实际应用 (下面把自定义的接口成为一级接口，其包含的接口成为二级接口，以此类推)嵌入的接口的数量： 标准库中接口绝大多数都不会再嵌套接口，少数会再嵌套一层接口，最多嵌套的数量为4，是mime/multipart.File中的File接口：123456type File interface &#123; io.Reader io.ReaderAt io.Seeker io.Closer&#125;131个接口为0，27个为1，8个为2，3个为3，1个为4嵌入的接口深度： 接口嵌入接口，嵌入的接口再嵌入接口..较深的接口降低了代码的可读性，提高了代码复杂度。标准库中不使用太深的嵌入方式，少量接口有一层嵌入131个接口没有嵌入，29个接口嵌入了一层 (和上面相对应)接口中直接定义的方法的数量： (一级接口)直接定义的方法的数量，不包括嵌入接口引入的方法。标准库中接口定义的直接方法的数量都很少，不会设置很多方法，接口都比较精巧干练。 比较特殊的是reflect/Type接口，定义了31个直接方法接口中总的方法的数量：把（一级接口）直接定义的方法和嵌入接口引入的方法加和标准库中接口的总方法数量基本都在8个以下，最多的当然还是reflect/Type接口，31个(直接)方法 2. 接口实现 和其他需要显式声明接口实现类 的语言不同，Go语言接口实现是隐式的，不用明确地指出某一个类型实现了某一个接口，只有在某一类型的方法中实现了接口中 全部的方法签名，就意味着此类型实现了这一接口。 如 定义一个图形接口Shape，此接口包含求周长的perimeter方法和求面积的area方法： 123456type Shape interface &#123; perimeter() float64 area() float64&#125; 任何自定义类型要实现Shape接口都很简单，只需实现Shape内部所有的方法签名即可。 现在创建一个自定义类型Rectangle来标识一个矩形，a，b分别代表长和宽： 123type Rectangle struct &#123; a, b float64&#125; 接着为该类型实现perimeter和area方法： 1234567func (r Rectangle) perimeter() float64 &#123; return (r.a + r.b) * 2 //矩形周长公式：(长+宽)*2&#125;func (r Rectangle) area() float64 &#123; return r.a * r.b //矩形面积公式：长*宽&#125; 再创建一个自定义类型Rectangle来标识一个三角形，a，b，c分别代表三条边： 1234type Triangle struct &#123; a, b, c float64&#125; 也为该类型实现perimeter和area方法： 123456789func (t Triangle) perimeter() float64 &#123; return t.a + t.b + t.c&#125;func (t Triangle) area() float64 &#123; //海伦公式 p := (t.a + t.b + t.c) / 2 return math.Sqrt(p*(p-t.a) + p*(p-t.b) + p*(p-t.c))&#125; 实例化一个矩形和三角形，计算其周长和面积： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"math\")func main() &#123; cacl()&#125;// Shape 图形type Shape interface &#123; perimeter() float64 area() float64&#125;type Rectangle struct &#123; a, b float64&#125;func (r Rectangle) perimeter() float64 &#123; return (r.a + r.b) * 2 //矩形周长公式：(长+宽)*2&#125;func (r Rectangle) area() float64 &#123; return r.a * r.b //矩形面积公式：长*宽&#125;func cacl() &#123; var juxing = Rectangle&#123; 3, 4, &#125; var sanjiaoxing = Triangle&#123; 3, 4, 5, &#125; fmt.Printf(\"矩形周长为%f,面积为%f\\n\", juxing.perimeter(), juxing.area()) fmt.Printf(\"三角形周长为%f,面积为%f\\n\", sanjiaoxing.perimeter(), sanjiaoxing.area())&#125;type Triangle struct &#123; a, b, c float64&#125;func (t Triangle) perimeter() float64 &#123; return t.a + t.b + t.c&#125;func (t Triangle) area() float64 &#123; //海伦公式 p := (t.a + t.b + t.c) / 2 return math.Sqrt(p*(p-t.a) + p*(p-t.b) + p*(p-t.c))&#125; 执行： 12矩形周长为14.000000,面积为12.000000三角形周长为12.000000,面积为6.000000 3. 接口动态类型 一个接口类型的变量，能够接收任何实现了此接口的 (开发人员)自定义的类型。 一般把存储在接口中的类型(如Rectangle，Triangle，即隐式实现Shape中所有方法的结构体) 称为接口的动态类型，而将接口本身的类型称为接口的静态类型(如Shape) 123 var s Shapes = Rectangle&#123;3, 4&#125;s = Triangle&#123;3, 4, 5&#125; 4. 接口的动态调用 当接口变量(如Shape)中存储了具体的动态类型时，可以调用接口中所有的方法: 1234 var s Shapes = Rectangle&#123;3, 4&#125;s.perimeter()s.area() 接口动态调用的过程实质上是 调用当前接口动态类型中具体方法的过程。如下，接口动态调用表现出不同动态类型的行为: 12345 var s Shapes = Rectangle&#123;3, 4&#125;fmt.Printf(\"矩形周长为%v,面积为%v\\n\", s.perimeter(), s.area())s = Triangle&#123;3, 4, 5&#125;fmt.Printf(\"三角形周长为%f,面积为%f\\n\", s.perimeter(), s.area()) 输出为： 12矩形周长为14,面积为12三角形周长为12.000000,面积为6.000000 在对接口变量进行动态调用时，调用的方法只能是接口中具有的方法。如Rectangle类型还有另外的方法getHeight，接口变量在调用时，编译不会通过: 123456var s Shapes = Rectangle&#123;3, 4&#125;area := s.area()hight := s.getHeight()fmt.Println(area,hight) 1s.getHeight undefined (type Shape has no field or method getHeight) 5. 多接口 一个类型可以同时实现多个接口，如标准库中src/os/types.go中的 1234// File represents an open file descriptor.type File struct &#123; *file // os specific&#125; 其实现了src/io/io.go中的Reader接口和Writer接口 6. 接口的组合 定义的接口可以是其他接口的组合，如理解Go接口的实际应用中提到的标准库src/io/io.go中的ReadWriter,ReadCloser,WriteCloser等几个接口。 以ReadWriter为例,其组合了Reader接口和Writer接口。 当类型实现了ReadWriter时，意味着次类型既可读又可写。 12345678910111213141516171819// ReadWriter is the interface that groups the basic Read and Write methods.type ReadWriter interface &#123; Reader Writer&#125;...// Implementations must not retain p.type Reader interface &#123; Read(p []byte) (n int, err error)&#125;...// Implementations must not retain p.type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 一个方法包含越多的方法，其抽象性就越低，表达的行为就越具体 7. 接口类型断言 更多参考 Golang类型断言 8. 空接口 如果接口中没有任何方法签名，则这是Go中另一类特殊接口,即空接口 空接口可以存储结构体,字符串,整型等任何数据类型,是很多函数的入参,如fmt.Println： 123456// Println formats using the default formats for its operands and writes to standard output.// Spaces are always added between operands and a newline is appended.// It returns the number of bytes written and any write error encountered.func Println(a ...interface&#123;&#125;) (n int, err error) &#123; return Fprintln(os.Stdout, a...)&#125; 使用 i.(type)获取空接口中的动态类型 i代表接口变量，type是固定关键字，和带方法接口的类型断言不是一回事。 这个语法仅在switch语句中有效，如Println源码中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Some types can be done without reflection.switch f := arg.(type) &#123;case bool: p.fmtBool(f, verb)case float32: p.fmtFloat(float64(f), 32, verb)case float64: p.fmtFloat(f, 64, verb)case complex64: p.fmtComplex(complex128(f), 64, verb)case complex128: p.fmtComplex(f, 128, verb)case int: p.fmtInteger(uint64(f), signed, verb)case int8: p.fmtInteger(uint64(f), signed, verb)case int16: p.fmtInteger(uint64(f), signed, verb)case int32: p.fmtInteger(uint64(f), signed, verb)case int64: p.fmtInteger(uint64(f), signed, verb)case uint: p.fmtInteger(uint64(f), unsigned, verb)case uint8: p.fmtInteger(uint64(f), unsigned, verb)case uint16: p.fmtInteger(uint64(f), unsigned, verb)case uint32: p.fmtInteger(uint64(f), unsigned, verb)case uint64: p.fmtInteger(f, unsigned, verb)case uintptr: p.fmtInteger(uint64(f), unsigned, verb)case string: p.fmtString(f, verb)case []byte: p.fmtBytes(f, verb, \"[]byte\")case reflect.Value: // Handle extractable values with special methods // since printValue does not handle them at depth 0. if f.IsValid() &amp;&amp; f.CanInterface() &#123; p.arg = f.Interface() if p.handleMethods(verb) &#123; return &#125; &#125; p.printValue(f, verb, 0)default: // If the type is not simple, it might have methods. if !p.handleMethods(verb) &#123; // Need to use reflection, since the type had no // interface methods that could be used for formatting. p.printValue(reflect.ValueOf(f), verb, 0) &#125;&#125; 即 使用switch语句嵌套i.(type)语法，获取空接口中的动态类型，并根据动态类型不同进行不同的格式化输出。 9. 接口的比较性 两个接口之间可以通过 == 或 !=来比较，规则为： 动态值为nil的接口变量相等 如果只有一个接口为nil，则比较结果为false 两个接口不为nil，且接口变量具有相同的动态类型和动态类型值，则两接口相同 如果接口存储的动态类型值是不可比较的，则运行时会报错","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"竹西怀古","date":"2016-02-27T15:27:02.000Z","path":"2016/02/27/竹西怀古/","text":"丙申庚寅卯日，余至维扬．杨柳新开，梅花半放．漫东关街，彩幌若云，游人如织．过琼花观，暮色弥望，钟声振荡．旧时运河明珠，隋唐今之京沪，三分明月得其二，李杜白苏竞叹．盛况难复，予怀喟然．酒酣饭足，步古运河．灯火依稀，沿道缓行．晚风习习拂柳，霡霂悄悄落河．柳条黄青年复年，河水无声南去，思过往隋炀小杜忠靖之事，心潮不平如登幽州台，遂效前人，赋词一首，名曰＜鹧鸪天 竹西怀古＞．海西锦绣地，不才之作有关门舞刀之感：晚风拂夜柳，微雨落轻尘。旧时红药为谁哉？杜郎今又来。匹马过荒村，明月照孤坟。犹有流萤绕雷塘，萧氏在何方？ 是为＜鹧鸪天 竹西怀古＞。 小注： ①第一句化自王维＜渭城曲＞。 ②杜郎为小杜．其在扬州多年，与此城有不解之缘。 戳此查看更多 其＜寄扬州韩绰判官＞： 青山隐隐水迢迢，秋尽江南草未凋。 二十四桥明月夜，玉人何处教吹箫． 二十四桥又名红药桥．词中“红药”即红色的芍药花．小杜此篇常被吟诵扬州的后辈文人化用： 南宋大音律家姜夔的代表作＜扬州慢·淮左名都＞下半阙＇杜郎俊赏，算而今重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡、冷月无声。念桥边红药，年年知为谁生？ ＇。 今人许嵩在＜庐州月＞中有＇桥上的恋人入对出双，桥边红药叹夜太漫长＇，庐州为其家乡合肥并非扬州，此曲意指庐州的月亮依然是当时月亮，但是当年月光下的两个人已经各奔东西．虑小杜《怅诗》’自是寻春去校迟，不须惆怅怨芳时．狂风落尽深红色，绿叶成阴子满枝’，时代虽异事虽不同然有异曲同工之处． ＇杜郎今又来＇句化用自刘禹锡＜再游玄都观＞＇种桃道士归何处，前度刘郎今又来＇，这是桀骜的他在被贬而来写就＜玄都观桃花 ＞＇玄都观里桃千树，尽是刘郎去后栽＇又被贬又归来后的作品． 提及扬州和刘禹锡，不得不提及他著名的＜酬乐天扬州初逢席上见赠＞： 巴山楚水凄凉地，二十三年弃置身。怀旧空吟闻笛赋，到乡翻似烂柯人。 沉舟侧畔千帆过，病树前头万木春。今日听君歌一曲，暂凭杯酒长精神。 这是我特别喜欢的一首诗．而唱和的对象，是大唐诗坛的三号人物，这位写就＜卖炭翁＞＜琵琶行＞悲天悯人的大诗人，同时也是大唐诗坛最浪荡风流的一位，在此能与之媲美的大概只有当世与其并称元白的好友，以哀悼亡妻闻名的元稹和留下＇十年一觉扬州梦，留得青楼薄幸名＇的杜牧． 刘禹锡的贬谪，还能从课本中所学柳宗元在湖南永州所写＜永州八记＞中的＜小石潭记＞与后来在广西柳州所写＜登柳州城楼寄漳汀封连四州＞中窥见一斑： 城上高楼接大荒，海天愁思正茫茫。 惊风乱飐芙蓉水，密雨斜侵薜荔墙。 岭树重遮千里目，江流曲似九回肠。 共来百越文身地，犹自音书滞一乡。 题目中＇连州＇即刘禹锡贬谪之地，此处还有一段二人间往事． 戳此查看更多 ③匹马过荒村，明月照孤坟。犹有流萤绕雷塘，萧氏在何方？ 我独自走过荒郊无人的村落来到埋葬隋炀的雷塘，清幽的月光静静照映在孤坟上．仍然可以看到飘动的萤火虫在这里飞来绕去，可是萧皇后现在在哪里呢？ ④雷塘：在今扬州城北．隋唐时为风景胜地。隋炀帝死于江都，李渊建唐以后，以帝王之礼将隋炀帝葬于此 ⑤萧氏：即萧后，隋炀帝皇后，一生历经六位帝王．被称＇＇六位帝皇玩＇＇．萧后贤淑，本不逊长孙，马氏，嫁与唐宗洪武则为一代贤后，嫁与隋炀则成＇祸水红颜＇背亡国之锅，＇＇六位帝皇玩＇＇成其摆脱不掉的名号，可见女怕错郎，自古已然． ⑥今人古文水平自然远不及古人，另则生逢四海康平日，生活平淡安稳．缺少写出杜甫辛弃疾那般慷慨悲壮诗词的大背景和大环境，也很庆幸这种缺失．故而今人很难再写出一流古诗词，而现代化的交通和通讯，思乡也不像过去那个时代那般强烈．今人所能写，无非像晏殊慨叹时间匆匆年华不再，或像陈子昂咏怀古迹．此间所写，只是记载一时自娱自乐．","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"网络相关的命令行工具汇总","date":"2016-02-12T13:35:35.000Z","path":"2016/02/12/网络相关的命令行工具汇总/","text":"curl curl有一个w参数，可以用来测量TCP握手和SSL握手的具体耗时 123 curl -w \"TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\\n\" -so /dev/null https://dashen.techTCP handshake: 0.041443, SSL handshake: 0.139437 SSL延迟有多大？","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"茶与酒","date":"2016-02-07T13:27:23.000Z","path":"2016/02/07/茶与酒/","text":"茶是一种生活。 在含阴笼雾的日子里，有一间干净的小屋，小屋里有扇稍大些的窗子，窗子里有不大聒噪的风景，便可以谈茶。 茶要的不多：壁龛里按季节插的花只是一朵，不是一束；只是含苞未吐的一朵，不是瓣舞香烈的一束；只是纯白的一朵，不是色闹彩喧的一束。茶要的不浓：备茶的女人素面青衣，长长的头发用同样青色的布带低低地系了，宽宽地覆了一肩，眉宇间的浅笑淡怨如阴天如雾气如茶盏里盘旋而上的清烟如吹入窗来的带地气的风如门外欲侵阶入室的苍苔。茶要的不乱：听一个老茶工讲，最好的茶叶要在含阴笼雾的天气里，由未解人事的女孩子光了脚上茶山上去采；采的时候不用手，要用口。不能用牙，要用唇去含下茶树上刚吐出的嫩芽。茶要的不烦：茶本含碱，本可以清污去垢，而在这样的小屋里饮这样一杯茶，人会明白什么叫清乐忘忧，会明白有种溶剂可以溶解心情，可以消化生活。 只要茶的神在，也不一定要这么多形式。 比如心里有件大些的事，一通电话，便会有三、俩个平日里也不甚走动的朋友把小屋填满，一杯茶后，我们便是饱食终日，无所专心，所以来谈谈棋的神仙，屋顶上的天空或是屋门外的世间便是我们着子的棋盘。待茶渐无味，天渐泛白，心里的事情便已被分析得透彻，一个近乎完美的计划便已成型。走出屋子，这盘棋一定会下得很出色。 再比如，心里实在不安闲，七个号码接通那个女孩：“心里烦，来喝杯茶，聊聊好吗？”假如人是长在时间里的树，假如熟悉的朋友经过的事是树上的叶子，她和我之间有过的点点滴滴的小事，说过的云飞雪落不经意却记得的话便是茶；这个时候，你我之间不属于尴尬的沉默便是泡茶的水了。话不会很多，声调也不会很高，我可以慢慢地谈我所体会到的一切精致包括对她的相思，而不会被她笑成虚伪。 这茶也可以一个人喝。“寒夜兀坐，幽人首务”，自古以来，一个人喝茶是做个好学生的基本功。一杯泛青的茶一卷发黄的史书，便可以品出志士的介然守节，奸尤的骄恣奢僭，便可以体会秦风汉骨，魏晋风流。不用如孔丘临川，看着茶杯中水波不兴，你也可以感知时光流转，也可以慨叹：“逝者如斯夫！” 酒是另一种生活。 阳光亮丽，天气好得让人想唱想跳想和小姑娘打情骂俏想跟老大妈们打架骂街。小酒馆不用很堂皇，甚至不用很干净，但是老板娘一定要漂亮一定要解风情，至少在饱暖之后能让你想起些什么。“垆边人似月，皓腕凝霜雪”，发髻要挽得一丝不乱梳得油光水滑，衣服要穿得不松不紧，至少在合适的角度可以看见些山水。菜的量很足，酒的劲很大，窗外的人很吵，偶然闪过的花裙倩影可以为之尽一大杯。人很多，店很乱，假如喝多了吐出些什么没人会厌恶，假如用指甲清清牙缝或是很响地打打饱嗝没人会在意。 这样的时候，最好有朋友，可以一起大块吃肉大碗喝酒，憧憬着将来可以一起大分金分骗来的小姑娘。高渐离是酒保，樊哙是屠夫，刘邦是小官吏，刘备是小业主，朱元璋是野庙里的花和尚，努尔哈赤是林子里的残匪头目。杯中无日月，壶中有乾坤，我们可以煮酒论英雄，说“儿须成名酒须醉”。看着窗外的俗汉，想起自己的老板，想起小报里的名流，“唉，世无英雄，方使竖子成名！”看着窗外的丑妇，说起办公室满脸旧社会的女孩，说起黄色边缘上的杂志封面，“唉，世无美人，方使竖子得宠！” 这样的时候，也可以和自己的老婆喝。有些女人是天生的政治家，有些女人是天生的酒鬼，只是这两种才能很少能在这个男人统治的世界里表现。酒能让女人更美，能让她颊上的桃红更浓；酒能让女人更动人，能让她忘记假装害羞，可以听你讲能让和尚对着观音念不了经的黄故事，而不觉得你如何下流。 这样的时候，也不妨一个人干三大杯，唱“把酒当歌，人生几何”，捡几个自己赔得起的杯子摔摔。 茶是一种生活，酒是一种生活。都是生活，即使相差再远，也有相通的地方。 酒是火做的水，茶是土做的水。 筹桄之后，人散夜阑灯尽羹残，土克火，酒病酒伤可以用杯清茶来治；茶喝多了，君子之间淡如水，可以在酒里体会一下小人之间的暖和以及市井里不精致却扎实亲切的活法。酒要喝陈，只能和你喝一两回的男人是不能以性命相托的酒肉朋友；只能和你睡一两回的女人是婊子。茶要喝新，人不该太清醒，过去的事情就让它过去，不必反复咀嚼。酒高了，可以有难得的放纵，可以上天摘星，下海揽月；茶深了，可以有泪在脸上静静地流，可以享受一种情感叫孤独。 不是冤家不聚头，说不尽的茶与酒。在这似茶般有味无味的日月中，只愿你我间或有酒得进。 (作者不详)","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"为Github/Gitlab项目设置徽章","date":"2016-02-07T13:15:18.000Z","path":"2016/02/07/为Github-Gitlab项目设置徽章/","text":"github 一般只能在README.md 文件的开头进行添加，最常用的GitHub 徽标网站是 shields.io 相关操作可参考 为你的Github仓库添加徽章 GitHub 上 readme 中那些好看的徽章是怎么生成的？ github上的CI/CD操作，可参考 GitHub 项目徽章的添加和设置 gitlab gitlab添加badge的方式较多 README.md中添加： 设置–&gt;CI/CD–&gt;流水线通用设置–&gt;Pipeline status 复制相应的Markdown内容到README.md 另外，不论那种方式，想要测试覆盖率 Coverage report有具体数值而非unknown，都需要在上方的测试覆盖率解析添加正则匹配，如test coverage is (\\d+.\\d+\\%) 测试覆盖率示例 在徽章选项中添加 设置–&gt;通用–&gt;徽章 可按照示例添加，如： 名称：Pipeline status (在徽章上显示的文字)链接：https://gitlab.com/%{project_path}/-/pipelines/?page=1&amp;scope=all&amp;ref=%{default_branch} (点击徽章跳转的链接)徽章图片网址：https://gitlab.com/%{project_path}/badges/%{default_branch}/pipeline.svg (徽章图片来源) Project badges","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go使用通配符删除文件","date":"2016-02-05T13:27:42.000Z","path":"2016/02/05/Go使用通配符删除文件/","text":"在shell中常使用命令通配符*操作文件，如可使用 rm 20160101.* 来批量删除前缀为20160101的全部文件： 但在Go中，使用如下代码居然无效: 12345678package mainimport \"os\"func main() &#123; os.RemoveAll(\"/Users/fliter/lab/log/20160101.*\")&#125; rm xxx通配符是 shell的一个功能，而非操作系统，其他编程语言一般不会提供类似的支持（即能否可以按通配符来删除文件） 在Go中可以使用 Glob功能模糊匹配到想要删除的文件，然后再进行删除，如下： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"os\" \"path/filepath\")func main() &#123; files, err := filepath.Glob(\"/Users/fliter/lab/log/20160101.*\") if err != nil &#123; panic(err) &#125; fmt.Println(\"匹配到的文件为：\", files) for _, f := range files &#123; if err := os.RemoveAll(f); err != nil &#123; panic(err) &#125; &#125;&#125; 打印出： 匹配到的文件为： [/Users/fliter/lab/log/20160101.debug /Users/fliter/lab/log/20160101.error /Users/fliter/lab/log/20160101.info /Users/fliter/lab/log/20160101.warning] 同时20160101开头的文件都已被删掉","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Makefile书写小结","date":"2016-01-30T13:14:39.000Z","path":"2016/01/30/Makefile书写小结/","text":"本篇是对阮一峰-Make 命令教程的学习与记录 基本规则 target必不可少 1234567&lt;target1&gt; : &lt;前置条件(可选)&gt; [tab] &lt;command1&gt;[tab] &lt;command2&gt;&lt;target2&gt; : &lt;前置条件(可选)&gt; [tab] &lt;command_x&gt;[tab] &lt;command_y&gt; 如 1234clean: rm *.txtclone: git clone git@github.com:cuishuang/kit.git 一个目标（target）就构成一条规则,执行make clean,则将执行该规则。 如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标， 如对于上面的makefile，make 就相当于 make clean .PHONY的作用 如果当前目录中，正好有一个文件叫做clean，那么make clean命令将不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建，也就不会执行后面的命令 这时就需要使用.PHONY,明确声明clean是”伪目标”: 123.PHONY: cleanclean: rm *.txt 声明clean是”伪目标”后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。 像.PHONY这样的内置目标名还有不少，可查看手册 前置条件（prerequisites） 具体命令 由一行或多行的Shell命令组成 每行命令之前必须有一个tab键。 如果想用其他键，可以用内置变量.RECIPEPREFIX声明。 每行命令在一个单独的shell中执行,之间没有继承关系 具体语法 1.注释 2.回声（echoing） 3.通配符 4.模式匹配 5.变量和赋值符 6.内置变量（Implicit Variables） Makefile.defs即Makefile定义的变量,一般会在Makefile头部引入…分开写清晰一些 LD_FLAGS=-ldflags “-X main.commit=$(git_commit)”是把这个值，注入到main的commit变量里 7.自动变量（Automatic Variables） 8.判断和循环 9.自己写的函数 10.内置函数 Makefile中可用的函数 strip 实战一下 1234567891011121314151617.PHONY: all build deploy syncCloudall:build deploy syncCloudbuild: hexo g echo \"----------构建完成----------\"deploy: hexo d echo \"----------部署完成----------\"# 发送到icloudsyncCloud: cp -rf /Users/fliter/blog/source/* /Users/fliter/Documents echo \"----------同步完成----------\" 进阶： 阮一峰-使用 Make 构建网站 如何调试MAKEFILE变量 跟我一起写 Makefile–陈皓","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"从A仓库拉取Docker镜像，推送至B仓库","date":"2016-01-29T14:20:24.000Z","path":"2016/01/29/从A仓库拉取Docker镜像，推送至B仓库/","text":"需要构建一个用于gitlab pipeline的镜像，当在公司提供的构建机器上，因为网络限制，构建过程中在下载一些依赖时总会超时。 由于最终只需要用到镜像，在我自己的一台网络畅通的服务器上，build成功，并push到了docker hub。 公司有基于harbor搭建的私有镜像仓库。 初步想法是在公司服务器上，将刚刚push到docker hub的镜像pull下来，然后再push到公司私有镜像仓库 可使用如下命令： 123docker tag 从A仓库pull下来的镜像的id 公司私有镜像仓库的地址/镜像名称:tagdocker push 公司私有镜像仓库的地址/镜像名称:tag 之后在公司私有镜像仓库，可如预期看到刚刚push的镜像 更多可参考 Docker 操作：从 A 仓库拉镜像推送到 B 仓库","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"gomonkey 使用小结","date":"2016-01-29T05:53:45.000Z","path":"2016/01/29/gomonkey-使用小结/","text":"猴子补丁相关介绍见前文 Go实现猴子补丁 golang三大基础mock大法 手把手教你如何进行 Golang 单元测试 Go单测从零到溜系列—3.接口测试 gomonkey私有方法打桩","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Golang单元测试","date":"2016-01-28T14:41:07.000Z","path":"2016/01/28/Golang单元测试/","text":"单测的成本与收益 搞定Go单元测试（一）——基础原理 测试单个文件，一定要带上被测试的原文件，如果原文件有其他引用，也需一并带上。https://www.cnblogs.com/Detector/p/10010292.html 1234567func ConvertStrToInt(str string) (int, error) &#123; rs, err := strconv.Atoi(str) if err != nil &#123; return 0, err &#125; return rs, nil&#125; 并对此函数写一个单测： 12345678910111213141516171819package serviceimport ( \"github.com/stretchr/testify/assert\" \"testing\")func TestConvertStrToInt(t *testing.T) &#123; rs1, err1 := ConvertStrToInt(\"1234\") assert.Equal(t, 1234, rs1) assert.Equal(t, nil, err1) rs2, err2 := ConvertStrToInt(\"123d\") assert.Equal(t, 0, rs2) assert.NotEqual(t, nil, err2)&#125; 运行cron/service中的Test..,得到： 使用覆盖率运行cron/service中的Test..,得到： 可以看到项目整体的测试覆盖率，以及具体某个目录和文件的覆盖率 且在对应文件里，可以看到不同颜色标注的哪些被ut覆盖(绿色)，哪些没有被覆盖(红色) 也可以用命令行 go test ./...执行： 用命令行 go test -v ./...可以看到详细信息： 用go test ./... -v -covermode=count展示项目所有文件的覆盖率： 用go test ./... -v -coverprofile=count.out展示测试覆盖率,并生成覆盖统计文件到 count.out 该文件中详细展示了每个文件测试时某一行,执行的次数及其他信息： 可以有go tool来分析 count.out 文件并生成想要的结果： func 生成每个函数的覆盖率 go tool cover -func=count.out 展示每一个函数单元测试的覆盖率,若100% 则测试完整,若0.0% 则没有测试 html 生成 html 文件,以图形方式展示每个函数,每一行代码的覆盖率 go tool cover -html=count.out 会打开默认浏览器,图形化展示测试覆盖率 可切换当前库下的每个文件,看每一行代码是否测试执行。没有执行的显示为红色, 灰色是不需要测试的, 亮绿色是测试通过的 https://youwu.today/skill/backend/how-to-test-your-go-code/ https://deepzz.com/post/the-command-flag-of-go-test.html https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter09/09.1.html http://c.biancheng.net/view/124.html https://brantou.github.io/2017/05/24/go-cover-story/ https://qiubo.ink/2019/06/27/Golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8A%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/ http://t.zoukankan.com/-wenli-p-14256142.html https://blog.csdn.net/weixin_31328555/article/details/112099739 https://www.codercto.com/a/44507.html https://www.cnblogs.com/-wenli/p/14256142.html https://www.jianshu.com/p/ad46bbbf877c https://www.cnblogs.com/JenningsMao/p/9240965.html https://studygolang.com/articles/28166","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"单元测试之断言","date":"2016-01-26T13:23:02.000Z","path":"2016/01/26/单元测试之断言/","text":"没有断言的单测是没有灵魂的 关于断言 在单元测试时，开发者预计程序运行到某个节点位置，需判断某些条件必须满足，这样下面的一些逻辑才可以进行下去，如果不满足，程序就会&quot;报错&quot;甚至&quot;崩溃&quot; 单元测试实际上就是使用一些“断言”（assert）代码，测试程序员自己写的一小片段代码是否ok Go中的断言（testify） Go标准包中没有断言,官方在FAQ里解释是担心被滥用,使用户懒于思考良好的错误处理 目前Go生态最知名的第三方断言库当属testify, GIN框架的单元测试用的就是testify testify中提供了assert和require： assert底层使用的是Fail系，所以失败时不会导致退出测试;而require底层用的是Fatal系，会直接终止测试。 两者提供了很多(名称相同的)的Helper函数 常用的如: assert.Equal assert.NotEqual assert.Zero assert.NotZero assert.Nil assert.NotNil 还有如： assert.Implements assert.Contains assert.InDelta 例如，有这样一个函数，其作用是从url中获取port： 12345678910func GetPortFromURL(urlStr string) string &#123; if !strings.HasPrefix(urlStr, \"http\") &#123; urlStr = \"https://\" + urlStr &#125; u, err := url.Parse(urlStr) if err != nil &#123; return \"\" &#125; return u.Port()&#125; 其对应单测可以这样写： 12345678910111213141516func TestGetPortFromURL(t *testing.T) &#123; cases := []struct &#123; Input string Expect string &#125;&#123; &#123;\"10.0.0.1:7125\", \"7125\"&#125;, &#123;\"https://10.0.0.1:7126\", \"7126\"&#125;, &#123;\"http://10.0.0.1:7127\", \"7127\"&#125;, &#125; for _, item := range cases &#123; result := GetPortFromURL(item.Input) assert.Equal(t, item.Expect, result) &#125;&#125; 这样会正常通过测试 而如果得到的结果和预期不同，如： 1234567891011121314151617func TestGetPortFromURL(t *testing.T) &#123; cases := []struct &#123; Input string Expect string &#125;&#123; &#123;\"10.0.0.1:7125\", \"7125\"&#125;, &#123;\"https://10.0.0.1:7126\", \"7126\"&#125;, &#123;\"http://10.0.0.1:7127\", \"7127\"&#125;, &#123;\"http://10.0.0.1:1111\", \"1122\"&#125;, &#125; for _, item := range cases &#123; result := GetPortFromURL(item.Input) assert.Equal(t, item.Expect, result) &#125;&#125; 则会报错： 123456789101112131415161718 Error Trace: xxxx_test.go:xx Error: Not equal: expected: \"1122\" actual : \"1111\" Diff: --- Expected +++ Actual @@ -1 +1 @@ -1122 +1111 Test: TestGetPortFromURL--- FAIL: TestGetPortFromURL (0.00s)预期:1122实际:1111&lt;点击以查看差异&gt; 而如果不用断言，如何判断运行结果和预期值是否一致？需要非常多的if..else testify的常用操作 Equal操作 Equal123456789101112131415161718package userimport ( \"github.com/stretchr/testify/assert\" \"testing\")func TestAssertEqual(t *testing.T) &#123; expect := 3 actual := 2 assert.Equal(t, expect, actual) //require.Equal(t, expect, actual) //若果用require，则直接FAIL，下面的将得不到执行 actual = 3 assert.Equal(t, expect, actual) assert.Equal(t, int32(1), int64(1))&#125; 结果： 12345678910111213141516171819=== RUN TestAssertEqual testfy_test.go:11: Error Trace: testfy_test.go:11 Error: Not equal: expected: 3 actual : 2 Test: TestAssertEqual testfy_test.go:16: Error Trace: testfy_test.go:16 Error: Not equal: expected: int32(1) actual : int64(1) Test: TestAssertEqual--- FAIL: TestAssertEqual (0.00s)预期:int32(1)实际:int64(1)&lt;点击以查看差异&gt; Nil &amp; NotNil 12345678910111213141516package userimport ( \"errors\" \"github.com/stretchr/testify/assert\" \"testing\")func ReturnErr() error &#123; return errors.New(\"测试出错\")&#125;func TestAssertNil(t *testing.T) &#123; assert.NotNil(t, ReturnErr()) assert.Nil(t, ReturnErr())&#125; 结果： 12345678=== RUN TestAssertNil testfy_test.go:15: Error Trace: testfy_test.go:15 Error: Expected nil, but got: &amp;errors.errorString&#123;s:\"测试出错\"&#125; Test: TestAssertNil--- FAIL: TestAssertNil (0.00s)FAIL Contains &amp; NotContains 操作 1234567891011package userimport ( \"errors\" \"github.com/stretchr/testify/assert\")func TestAssertContain(t *testing.T) &#123; assert.Contains(t, []string&#123;\"zhangsan\", \"lisi\"&#125;, \"wangwu\") assert.NotContains(t, []string&#123;\"zhangsan\", \"lisi\"&#125;, \"wangwu\")&#125; 结果： 12345678=== RUN TestAssertContain testfy_test.go:10: Error Trace: testfy_test.go:10 Error: []string&#123;\"zhangsan\", \"lisi\"&#125; does not contain \"wangwu\" Test: TestAssertContain--- FAIL: TestAssertContain (0.00s)FAIL File操作 123456func TestAssertFile(t *testing.T) &#123; //断言文件存在 assert.FileExists(t, \"/a.txt\", \"file not exists\") //断言目录存在 assert.DirExists(t, \"/hello\", \"dir is not exists\")&#125; Type操作 12345678910111213func TestAssertType(t *testing.T) &#123; //断言两个对象是相同的类型 assert.IsType(t, (*bytes.Buffer)(nil), &amp;bytes.Buffer&#123;&#125;) //断言继承接口 assert.Implements(t, (*fmt.Stringer)(nil), &amp;bytes.Buffer&#123;&#125;) //断言两个yaml相等 assert.YAMLEq(t, \"&#123;name:\\n zhangsan&#125;\", \"&#123;#####dddas\\n name:\\n zhangsan&#125;\") //断言两个json相等 assert.JSONEq(t, \"&#123;\\\"name\\\":\\\"zhangsan\\\"&#125;\", \"&#123;\\\"name\\\" : \\\"zhangsan\\\"&#125;\")&#125; 结果： 123=== RUN TestAssertType--- PASS: TestAssertType (0.00s)PASS Exception操作 1234567891011121314151617181920func TestAssertException(t *testing.T) &#123; //断言会发生panic fpc := func() &#123; panic(errors.New(\"panic error\")) &#125; assert.Panics(t, fpc) //断言会发生panic,并且panic的值相等 fpc1 := func() &#123; panic(\"new error\") &#125; assert.PanicsWithValue(t, \"new error\", fpc1) //输出错误日志 assert.Fail(t, \"print error message\") //断言error string相等 assert.EqualError(t, errors.New(\"err\"), \"err\", \"new error string is err\") //断言fail,立刻停止执行测试 assert.FailNow(t, \"fail now, next testing will not be exec\")&#125; 结果： 123456789101112=== RUN TestAssertException testfy_test.go:84: Error Trace: testfy_test.go:84 Error: print error message Test: TestAssertException testfy_test.go:90: Error Trace: testfy_test.go:90 Error: fail now, next testing will not be exec Test: TestAssertException--- FAIL: TestAssertException (0.00s)FAIL Http操作 12345678910111213141516func TestAssertHttp(t *testing.T) &#123; f := func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(\"goland\")) writer.WriteHeader(http.StatusOK) &#125; //断言http body中包含字符串(method,url,values可以自定义传入, writer根据传入参数进行选择并返回) assert.HTTPBodyContains(t, f, \"GET\", \"www.baidu.com\", nil, \"goland\") //断言http body中不含字符串 assert.HTTPBodyNotContains(t, f, \"GET\", \"www.baidu.com\", nil, \"goland\") //断言http请求返回error(400以上) assert.HTTPError(t, f, \"GET\", \"www.baidu.com\", nil, \"return error\") //断言http请求返回正常（200-206） assert.HTTPSuccess(t, f, \"GET\", \"www.baidu.com\", nil) //断言返回重定向（300-307） assert.HTTPRedirect(t, f, \"GET\", \"www.baidu.com\", nil)&#125; 结果： 12345678910111213141516=== RUN TestAssertHttp testfy_test.go:101: Error Trace: testfy_test.go:101 Error: Expected response body for \"www.baidu.com?\" to NOT contain \"goland\" but found \"goland\" Test: TestAssertHttp testfy_test.go:103: Error Trace: testfy_test.go:103 Error: Expected HTTP error status code for \"www.baidu.com?\" but received 200 Test: TestAssertHttp testfy_test.go:107: Error Trace: testfy_test.go:107 Error: Expected HTTP redirect status code for \"www.baidu.com?\" but received 200 Test: TestAssertHttp--- FAIL: TestAssertHttp (0.00s)FAIL Math操作 1234567891011121314151617181920212223242526272829303132333435func TestAssertMath(t *testing.T) &#123; type Z int //断言0值 assert.Zero(t, Z(0), \"type z(0) value is not 0?\") //断言非0值 assert.NotZero(t, Z(0), \"type z(0) value is 0\") //断言大于, 并带返回结果（true/false） assert.Greater(t, 1, 2) //断言大于或者等于, 并带返回结果(true/false) assert.GreaterOrEqual(t, 1, 2) //断言小于, 并带返回结果(true/false) assert.Less(t, 2, 1) //断言小于或者等于, 并带返回结果(true/false) assert.LessOrEqualf(t, 2, 1, \"2 is not less equal 1\") //断言两个数字差值不超过指定值 assert.InDelta(t, 0.12346, 0.12345, 0.00001) //断言多个数字差值不超过指定值（比较的两个map必须有相同的key） assert.InDeltaMapValues(t, map[string]float32&#123;\"1\": 1.01, \"2\": 2.0&#125;, map[string]float32&#123;\"1\": 1.0, \"2\": 2.01&#125;, 0.01) //断言多个数字差值不超过指定值（比较的两个切片必须一一对应） assert.InDeltaSlice(t, []float32&#123;1, 2.01&#125;, []float32&#123;1.01, 2&#125;, 0.01) //断言两个数字相对差不超过指定值（相对于第一个数） assert.InEpsilon(t, 2.1, 2.2, 0.1) //断言两个数字相对差不超过指定值（比较的两个切片必须一一对应） assert.InEpsilonSlice(t, []float32&#123;1, 2.01&#125;, []float32&#123;1.01, 2&#125;, 0.01) //断言两个时间点间隔不超过指定时间段 t1 := time.Now() assert.WithinDuration(t, t1, t1.Add(time.Hour*8), time.Hour*9) //断言正则匹配 assert.Regexp(t, regexp.MustCompile(\"^it\"), \"it's starting\")&#125; 结果： 1234567891011121314151617181920212223242526272829=== RUN TestAssertMath testfy_test.go:116: Error Trace: testfy_test.go:116 Error: Should not be zero, but was 0 Test: TestAssertMath Messages: type z(0) value is 0 assertion_compare.go:313: Error Trace: testfy_test.go:119 Error: \"1\" is not greater than \"2\" Test: TestAssertMath Messages: [] assertion_compare.go:323: Error Trace: testfy_test.go:121 Error: \"1\" is not greater than or equal to \"2\" Test: TestAssertMath Messages: [] assertion_compare.go:332: Error Trace: testfy_test.go:123 Error: \"2\" is not less than \"1\" Test: TestAssertMath Messages: [] assertion_compare.go:342: Error Trace: testfy_test.go:125 Error: \"2\" is not less than or equal to \"1\" Test: TestAssertMath Messages: [2 is not less equal 1]--- FAIL: TestAssertMath (0.00s)FAIL 123456789101112131415package userimport ( \"github.com/stretchr/testify/assert\" \"testing\")func TestAssertInDelta(t *testing.T) &#123; expect := 0.5 actual := 0.47 assert.InDelta(t, expect, actual, 0.02) assert.InDelta(t, expect, actual, 0.03) assert.InDelta(t, expect, actual, 0.04)&#125; 结果： 123456789101112=== RUN TestAssertInDelta testfy_test.go:11: Error Trace: testfy_test.go:11 Error: Max difference between 0.5 and 0.47 allowed is 0.02, but difference was 0.030000000000000027 Test: TestAssertInDelta testfy_test.go:12: Error Trace: testfy_test.go:12 Error: Max difference between 0.5 and 0.47 allowed is 0.03, but difference was 0.030000000000000027 Test: TestAssertInDelta--- FAIL: TestAssertInDelta (0.00s)FAIL 浅谈软件单元测试中的“断言” (assert) – 从石器时代进步到黄金时代 Golang单元测试快速上手(二) 断言与测试替身 搞定Go单元测试（三）—— 断言（testify） Go test预判工具Testify","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"基于alpine构建体积更小的Docker镜像","date":"2016-01-26T11:43:15.000Z","path":"2016/01/26/基于alpine构建体积更小的Docker镜像/","text":"1234567891011121314FROM golang:1.14.14-alpineRUN echo '这是爽哥构建的一个工具'RUN apk add gitRUN apk add python3RUN wget https://bootstrap.pypa.io/get-pip.pyRUN python3 get-pip.pyRUN pip3 install diff_coverRUN go env -w GOPROXY=\"https://goproxy.cn,direct\"RUN go envRUN go get github.com/boumenot/gocover-coberturaRUN go get gotest.tools/gotestsumRUN go get github.com/axw/gocov/...RUN go get github.com/AlekSi/gocov-xml https://www.jianshu.com/p/c4e6c477b44d","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Docker构建自定义镜像","date":"2016-01-25T14:32:38.000Z","path":"2016/01/25/Docker构建自定义镜像/","text":"在在Gitlab Pipeline中集成进ut覆盖率和测试报告中提到存在可改进之处，即单次CI耗时过长。 耗时主要在下载diff_cover(需要下载pip)，以及Golang(用的是docker image)以及gocover-cobertura和gotestsum 考虑将这些工具打包在一起，构建成一个新的镜像，CI阶段就可以大幅度降低耗时 Dockerfile如下： 1234FROM golang:latestRUN echo '这是一个爽哥构建的一个工具'RUN apt-get update &amp;&amp; apt install python3-pip -y &amp;&amp; pip3 install diff_cover &amp;&amp; go env -w GOPROXY=\"https://goproxy.cn,direct\" &amp;&amp; go get github.com/boumenot/gocover-cobertura@v1.2.0 &amp;&amp; go get gotest.tools/gotestsum@v1.7.0 因为Docker是分层下载，每一个RUN就是单独一层。所以尽可能如上这样写，而不要写多个RUN 执行docker build -t ci_tool:v1 . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[+] Building 547.2s (4/7) [+] Building 547.6s (4/7) [+] Building 548.0s (4/7) [+] Building 635.7s (7/8) [+] Building 635.9s (7/8) [+] Building 636.0s (7/8) [+] Building 636.2s (7/8) [+] Building 636.3s (7/8) [+] Building 685.9s (7/8) =&gt; =&gt; extracting sha256:94a23d3cb5be24659b25f17537307e7f568d665244f6a383c1c6e51e31080749 1.5s =&gt; =&gt; sha256:499ac46314c257f999ffe452e3a4ac1c8bc46c373f461074d4737870caca50bd 102.65MB / 102.65MB 144.3s[+] Building 687.3s (7/8) [+] Building 694.8s (9/9) FINISHED =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 342B 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load metadata for docker.io/library/golang:latest 5.4s =&gt; [auth] library/golang:pull token for registry-1.docker.io 0.0s =&gt; [1/3] FROM docker.io/library/golang:latest@sha256:0fa6504d3f1613f554c42131b8bf2dd1b2346fb69c2fc24a312e7cba6c87a71e 627.8s =&gt; =&gt; resolve docker.io/library/golang:latest@sha256:0fa6504d3f1613f554c42131b8bf2dd1b2346fb69c2fc24a312e7cba6c87a71e 0.0s =&gt; =&gt; sha256:ac9d381bd1e98fa8759f80ff42db63c8fce4ac9407b2e7c8e0f031ed9f96432b 5.14MB / 5.14MB 11.6s =&gt; =&gt; sha256:aa9c5b49b9db3dd2553e8ae6c2081b77274ec0a8b1f9903b0e5ac83900642098 10.66MB / 10.66MB 26.6s =&gt; =&gt; sha256:0fa6504d3f1613f554c42131b8bf2dd1b2346fb69c2fc24a312e7cba6c87a71e 2.35kB / 2.35kB 0.0s 0.4s =&gt; =&gt; sha256:89b5d1fa04af24c4cae53f775b9382755b2ba1082bda77b9f8febaa8676b54cb 1.80kB / 1.80kB 0.0s =&gt; =&gt; sha256:cac175c1423a6f67bcf70033345b7dc7d733176ab28932904a3e457acc6f5c56 7.08kB / 7.08kB 0.0s =&gt; =&gt; sha256:94a23d3cb5be24659b25f17537307e7f568d665244f6a383c1c6e51e31080749 53.60MB / 53.60MB 84.6s =&gt; =&gt; sha256:841dd868500b6685b6cda93c97ea76e817b427d7a10bf73e9d03356fac199ffd 54.67MB / 54.67MB 618.3s 0.4s =&gt; =&gt; sha256:627b3401fb617535edd16e96bd5941ecea7fe10ce6087bd47707602cfc396c2b 81.01MB / 81.01MB 157.3s =&gt; =&gt; extracting sha256:94a23d3cb5be24659b25f17537307e7f568d665244f6a383c1c6e51e31080749 1.5s =&gt; =&gt; sha256:499ac46314c257f999ffe452e3a4ac1c8bc46c373f461074d4737870caca50bd 102.65MB / 102.65MB 144.3s =&gt; =&gt; extracting sha256:ac9d381bd1e98fa8759f80ff42db63c8fce4ac9407b2e7c8e0f031ed9f96432b 0.1s =&gt; =&gt; extracting sha256:aa9c5b49b9db3dd2553e8ae6c2081b77274ec0a8b1f9903b0e5ac83900642098 0.2s =&gt; =&gt; sha256:63c2674d92dba6ae349f7ae5d7460b37a9dc8744644dedd1f83d0ed1dbd7c806 124B / 124B 145.7s =&gt; =&gt; extracting sha256:841dd868500b6685b6cda93c97ea76e817b427d7a10bf73e9d03356fac199ffd 1.7s =&gt; =&gt; extracting sha256:627b3401fb617535edd16e96bd5941ecea7fe10ce6087bd47707602cfc396c2b 2.2s =&gt; =&gt; extracting sha256:499ac46314c257f999ffe452e3a4ac1c8bc46c373f461074d4737870caca50bd 3.0s =&gt; =&gt; extracting sha256:63c2674d92dba6ae349f7ae5d7460b37a9dc8744644dedd1f83d0ed1dbd7c806 0.0s =&gt; [auth] library/golang:pull token for registry-1.docker.io 0.0s =&gt; [2/3] RUN echo '这是一个爽哥构建的一个工具' 0.4s =&gt; [3/3] RUN apt-get update &amp;&amp; apt install python3-pip -y &amp;&amp; pip3 install diff_cover &amp;&amp; go env -w GOPROXY=\"https://goproxy.cn,direct\" &amp;&amp; go get github.com/boumenot/gocover-cobertura@v1.2.0 &amp;&amp; go get gotest.tools/gotestsum@ 59.3s =&gt; exporting to image 1.6s =&gt; =&gt; exporting layers 1.6s =&gt; =&gt; writing image sha256:28a8ad1ca810ef0c17b80390c809d7fe3fc327e6dc8c4a8a994df1d9b69d057f 0.0s =&gt; =&gt; naming to docker.io/library/ci_tool:v1 0.0sUse 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them 启动，而后执行docker exec -it 容器id /bin/sh 进入容器， 可见符合预期~ 将其push到dockerhub时报错，denied: requested access to the resource is denied 这是因为构建时要在前面加上自己的dockerhub的username 执行docker build -t cuishuang/ci_tool:v1 . 重新构建并push 之后在hub.docker.com/就能够看到 发现上面的Dockerfile漏了go get github.com/axw/gocov/…和go get github.com/AlekSi/gocov-xml这两步，在Dockerfile加上， 1234FROM golang:latestRUN echo '这是一个爽哥构建的一个工具'RUN apt-get update &amp;&amp; apt install python3-pip -y &amp;&amp; pip3 install diff_cover &amp;&amp; go env -w GOPROXY=\"https://goproxy.cn,direct\" &amp;&amp; go get github.com/boumenot/gocover-cobertura@v1.2.0 &amp;&amp; go get gotest.tools/gotestsum@v1.7.0 &amp;&amp; go get github.com/axw/gocov/... &amp;&amp; go get github.com/AlekSi/gocov-xml 并docker build -t cuishuang/ci_tool:v2 . 重新构建，而后push到dockerhub 而后便可改造之前项目的.gitlab-ci.yml 并进行提交 发现Pipeline-Unittest阶段失败 具体原因为： failed to pull image &quot;cuishuang/ci_tool:latest&quot; with specified policies [always]: Error response from daemon: manifest for cuishuang/ci_tool:latest not found: manifest unknown: manifest unknown (manager.go:203:19s) 将image: cuishuang/ci_tool:latest改为image: cuishuang/ci_tool:v2并提交。 发现可以pull到该镜像，但执行一些命令时失败： 在实际跑gitlab-runner的ubuntu机器上(amd架构)，启动上面构建的镜像： docker run --name shuang_tool -d cuishuang/ci_tool:v2 而后进入，发现镜像启动失败 在本机(Mac M1,arm架构)启动，却没有该问题。 参考这篇，应该是arm和amd架构导致的问题 在ubuntu机器上新建Dockerfile，docker build -t cuishuang/ci_tool:v3 .进行构建 而后push到dockerhub。 但在ubuntu上apt-get update命令总失败 尝试看下docker能不能像go build一样可以交叉编译 跨平台构建 Docker 镜像新姿势，x86、arm 一把梭 继续解决apt-get update命令失败的问题，换一下源就可以了 docker ubuntu 换源 如果更换后出现类似The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 3B4FE6ACC0B21F32 这样的错误，可通过sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys xxxxxx 解决 一番尝试后，发现apt-get update及之后pip3 install diff_cover有各种各样的坑…。 (可以将相关的去掉然后构建，进入容器中去执行，发现报的这些依赖问题依然不好解决) 为绕过这些坑，聚焦主线，将之前的使用到diff-cover工具的部分去掉 (另外为了方便找到失败的原因，可将之前写在一个RUN里的多条命令拆开，一个命令一个RUN，这样容易获悉是哪一条命令执行出错) 同时将在ubuntu上构建出的镜像上传到docker hub 将改动提交，而后进入pipeline流程，可以看到shuang-unit-test阶段的job执行成功 这样就把CI的shuang-unit-test阶段用到的各种工具放在了一起，只需要拉取这个镜像即可~ (pull这个镜像比那各种现场apt update，go get要快太多了…) docker镜像采用分层机制，在默认的官方golang镜像基础上，添加新的工具~ 而官方的golang镜像默认是基于ubuntu系统，体积较大，拉取时间较长 构建后的镜像达到了1.05GB，压缩后也近400MB 一般都用基于精简款linux的alpine的来构建，可参考这篇 基于alpine构建体积更小的Docker镜","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Go实用mock工具","date":"2016-01-23T13:29:31.000Z","path":"2016/01/23/Go实用mock工具/","text":"单元测试一般不允许有任何外部依赖（文件依赖/网络依赖/数据库依赖等），不会(or不能)在测试代码中去真正 连接数据库/调用api等。这些外部依赖在执行测试时需被模拟(mock/stub)。在测试时，使用模拟的对象来模拟真实依赖下的各种行为。如何运用mock/stub来模拟系统真实行为，算是单元测试道路上的一只拦路虎 Mock（模拟）和Stub（桩）是在测试过程中，模拟外部依赖行为的两种常用的技术手段。 通过Mock和Stub我们不仅可以让测试环境没有外部依赖，而且还可以模拟一些异常行为，如数据库服务不可用，没有文件的访问权限等等。 –搞定Go单元测试（一）——基础原理 之利用mock/stub 技术破除外部依赖 单元测试中只是针对单个函数的测试，关注其内部的逻辑，对于网络/数据库访问等，需要通过相应的手段进行 mock gomock基础用法 gomock 是Go官方开源的golang测试框架：“GoMock is a mocking framework for the Go programming language”。 通过mockgen命令生成包含mock对象的.go文件，其生成的mock对象具备mock+stub的强大功能 安装： go install github.com/golang/mock/mockgen@v1.6.0 mockgen:mockgen has two modes of operation: source and reflect.Source mode generates mock interfaces from a source file.It is enabled by using the -source flag. Other flags thatmay be useful in this mode are -imports and -aux_files.Example: mockgen -source=foo.go [other options]Reflect mode generates mock interfaces by building a programthat uses reflection to understand interfaces. It is enabledby passing two non-flag arguments: an import path, and acomma-separated list of symbols.Example: mockgen database/sql/driver Conn,Driver -aux_files string (source mode) Comma-separated pkg=path pairs of auxiliary Go source files. -build_flags string (reflect mode) Additional flags for go build. -copyright_file string Copyright file used to add copyright header -debug_parser Print out parser results only. -destination string Output file; defaults to stdout. -exec_only string (reflect mode) If set, execute this reflection program. -imports string (source mode) Comma-separated name=path pairs of explicit imports to use. -mock_names string Comma-separated interfaceName=mockName pairs of explicit mock names to use. Mock names default to ‘Mock’+ interfaceName suffix. -package string Package of the generated code; defaults to the package of the input with a ‘mock_’ prefix. -prog_only (reflect mode) Only generate the reflection program; write it to stdout and exit. -self_package string The full package import path for the generated code. The purpose of this flag is to prevent import cycles in the generated code by trying to include its own package. This can happen if the mock’s package is set to one of its inputs (usually the main one) and the output is stdio so mockgen cannot detect the final output package. Setting this flag will then tell mockgen which import to exclude. -source string (source mode) Input Go source file; enables source mode. -version Print version. -write_package_comment Writes package documentation comment (godoc) if true. (default true)2017/02/15 10:56:34 Expected exactly two argumentsmockgen 有两种操作模式：source 和 reflect。源模式从源文件生成模拟接口。它通过使用 -source 标志启用。其他标志在这种模式下可能有用的是 -imports 和 -aux_files。例子： mockgen -source=foo.go [其他选项]Reflect模式通过构建程序生成mock接口使用反射来理解接口。它已启用通过传递两个非标志参数：一个导入路径和一个逗号分隔的符号列表。例子： mockgen 数据库/sql/driver Conn,Driver - aux_files 字符串 （源模式）逗号分隔的 pkg=辅助 Go 源文件的路径对。 - build_flags 字符串 （反射模式）go build 的附加标志。 - copyright_file 字符串 用于添加版权标题的版权文件 - debug_parser 仅打印解析器结果。 - 目标字符串 输出文件;默认为标准输出。 - exec_only 字符串 （反射模式）如果设置，则执行此反射程序。 - 导入字符串 （源模式）逗号分隔的名称=要使用的显式导入的路径对。 - mock_names 字符串 逗号分隔的 interfaceName=mockName 要使用的显式模拟名称对。模拟名称默认为 ‘Mock’+ interfaceName 后缀。 - 包字符串 生成的代码包；默认为带有“mock_”前缀的输入包。 - prog_only （反射模式）只生成反射程序；将其写入标准输出并退出。 - self_package 字符串 生成代码的完整包导入路径。此标志的目的是通过尝试包含自己的包来防止生成代码中的导入循环。如果将 mock 的包设置为其输入之一（通常是主包）并且输出是 stdio，则可能会发生这种情况，因此 mockgen 无法检测到最终输出包。设置此标志将告诉 mockgen 要排除哪个导入。 - 源字符串 （源模式）输入Go源文件；启用源模式。 - 版本 印刷版。 - write_package_comment 如果为真，则写入包文档注释 (godoc)。 （默认为真） 如对于user.go: 123456789101112package user// User 表示一个用户type User struct &#123; Name string&#125;// UserRepository 用户仓库type UserRepository interface &#123; // FindOne 根据用户id查询得到一个用户或是错误信息 FindOne(id int) (*User, error)&#125; 执行mockgen -source user.go -destination user_mock.go -package user， - source：指定需要模拟(mock)的接口文件- destination：设置生成的mock文件名。若不设置则打印到标准输出中- package：设置mock文件的报名。若不设置，则为 mock_前缀加文件名 之后会在同目录下，生成一个user_mock.go: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Code generated by MockGen. DO NOT EDIT.// Source: user.go// Package user is a generated GoMock package.package userimport ( reflect \"reflect\" gomock \"github.com/golang/mock/gomock\")// MockUserRepository is a mock of UserRepository interface.type MockUserRepository struct &#123; ctrl *gomock.Controller recorder *MockUserRepositoryMockRecorder&#125;// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.type MockUserRepositoryMockRecorder struct &#123; mock *MockUserRepository&#125;// NewMockUserRepository creates a new mock instance.func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository &#123; mock := &amp;MockUserRepository&#123;ctrl: ctrl&#125; mock.recorder = &amp;MockUserRepositoryMockRecorder&#123;mock&#125; return mock&#125;// EXPECT returns an object that allows the caller to indicate expected use.func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder &#123; return m.recorder&#125;// FindOne mocks base method.func (m *MockUserRepository) FindOne(id int) (*User, error) &#123; m.ctrl.T.Helper() ret := m.ctrl.Call(m, \"FindOne\", id) ret0, _ := ret[0].(*User) ret1, _ := ret[1].(error) return ret0, ret1&#125;// FindOne indicates an expected call of FindOne.func (mr *MockUserRepositoryMockRecorder) FindOne(id interface&#123;&#125;) *gomock.Call &#123; mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindOne\", reflect.TypeOf((*MockUserRepository)(nil).FindOne), id)&#125; 在该目录下新建user_test.go文件，来写测试函数 设置函数的返回值 user_test.go: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package userimport ( \"errors\" \"github.com/golang/mock/gomock\" \"log\" \"testing\")// 静态设置返回值func TestReturn(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() // 在go 1.14+后，如果已将*testing.T对象传入Controller，可以不用主动调用Finish() repo := NewMockUserRepository(ctrl) // 期望FindOne(1)返回 Alex repo.EXPECT().FindOne(1).Return(&amp;User&#123;\"Alex\"&#125;, nil) // 期望FindOne(2)返回 Bob repo.EXPECT().FindOne(2).Return(&amp;User&#123;Name: \"Bob\"&#125;, nil) // 期望FindOne(3)返回 user not found 的错误 repo.EXPECT().FindOne(3).Return(nil, errors.New(\"user not found\")) // 结果验证 log.Println(repo.FindOne(1)) // &amp;&#123;Alex&#125; &lt;nil&gt; log.Println(repo.FindOne(2)) // &amp;&#123;Bob&#125; &lt;nil&gt; log.Println(repo.FindOne(3)) // &lt;nil&gt; user not found //log.Println(repo.FindOne(4))&#125;// 动态设置返回值func TestReturnDynamic(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() repo := NewMockUserRepository(ctrl) // 常用方法之一：DoAndReturn()，动态设置返回值 repo.EXPECT().FindOne(gomock.Any()).DoAndReturn(func(i int) (*User, error) &#123; if i == 0 &#123; return nil, errors.New(\"user not found\") &#125; if i &lt; 100 &#123; return &amp;User&#123; Name: \"小于100\", &#125;, nil &#125; else &#123; return &amp;User&#123; Name: \"大于等于100\", &#125;, nil &#125; &#125;) log.Println(repo.FindOne(126)) // &amp;&#123;大于等于100&#125; &lt;nil&gt; //log.Println(repo.FindOne(29)) //log.Println(repo.FindOne(0))&#125; 基本使用： 首先要把需要 mock 的地方，写成接口（mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类） 执行 mockgen 生成xx_mock.go代码 在单元测试中(xx_test.go)，先执行 ctrl := gomock.NewController(t), 然后 defer ctrl.Finish() 使用 NewMockXXX 生成 mock 对象 调用 EXPECT() 方法，开始设置断言，对于参数，如果输入具体类型，则执行时就要传入相应类型； 如输入 gomock.Any()，则会忽略参数类型(还有 gomock.Eq, gomock.Len, gomock.All等..) 可以通过 Return 设置返回结果 可以通过 Times 设置调用次数( 另外还有 AnyTimes 不限次数，MaxTimes 最多执行次数，MinTimes 最少执行次数) 可以通过 After或InOrder 设置执行顺序 调用次数检测 user_test.go: 123456789101112131415161718192021222324252627func TestTimes(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() repo := NewMockUserRepository(ctrl) // 默认期望调用一次 repo.EXPECT().FindOne(222).Return(&amp;User&#123;Name: \"Alex\"&#125;, nil) // 期望调用两次 repo.EXPECT().FindOne(333).Return(&amp;User&#123;Name: \"Bob\"&#125;, nil).Times(2) // 可以调用任意次(包括0次) repo.EXPECT().FindOne(666).Return(nil, errors.New(\"出错了\")).AnyTimes() // 验证结果 log.Println(repo.FindOne(222)) log.Println(repo.FindOne(333)) log.Println(repo.FindOne(333)) // 期望FindOne(333)调用两次，如果注释此行，则测试将不通过. 报错信息为：aborting test due to missing call(s) log.Println(repo.FindOne(666)) // 不限调用次数，注释掉这些行也能通过测试 log.Println(repo.FindOne(666)) // 不限调用次数，注释掉这些行也能通过测试 log.Println(repo.FindOne(666)) // 不限调用次数，注释掉这些行也能通过测试 log.Println(repo.FindOne(666)) // 不限调用次数，注释掉这些行也能通过测试&#125; 调顺序数检测 user_test.go: 123456789101112131415161718192021222324func TestOrder(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() repo := NewMockUserRepository(ctrl) o1 := repo.EXPECT().FindOne(222).Return(&amp;User&#123;Name: \"Alex\"&#125;, nil) o2 := repo.EXPECT().FindOne(333).Return(&amp;User&#123;Name: \"Bob\"&#125;, nil) o3 := repo.EXPECT().FindOne(666).Return(nil, errors.New(\"出错了\")).AnyTimes() // 设置调用顺序 gomock.InOrder(o1, o2, o3) // 验证 log.Println(repo.FindOne(222)) log.Println(repo.FindOne(333)) log.Println(repo.FindOne(666)) // 如果调整调用顺序，则测试将不能通过 //log.Println(repo.FindOne(666)) //log.Println(repo.FindOne(222)) //log.Println(repo.FindOne(333))&#125; 如果不按设置的顺序调用，则会报错： doesn’t match the argument at index 0. doesn’t have a prerequisite call satisfied: 内容参考自 搞定Go单元测试（二）—— mock框架(gomock) 使用 gomock 测试 Go 代码 更多使用技巧，参考 文档 gomock教程 “单元测试要做多细？” Go语言使用：GoMock的基础知识 gomock其他用法 除去使用mockgen -source=xxx.go，指明从哪个源文件生成,还可以通过mockgen database/sql/driver Conn,Driver指明mock的目标是哪个包的哪些接口 另外，还可以 以 go:generate 的方式写，然后执行 go generate generate.go:1234567891011121314151617181920212223package userimport ( \"fmt\")//go:generate mockgen -source=./generate.go -destination mock_generate.go -package usertype Foo interface &#123; SayHi(sth string) error&#125;type foo struct&#123;&#125;func (f *foo) SayHi(sth string) error &#123; fmt.Printf(\"sth: %s\\n\", sth) return nil&#125;func main() &#123; f := foo&#123;&#125; f.SayHi(\"hi foo\")&#125; 执行go generate后会生成mock_generate.go： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Code generated by MockGen. DO NOT EDIT.// Source: ./generate.go// Package user is a generated GoMock package.package userimport ( reflect \"reflect\" gomock \"github.com/golang/mock/gomock\")// MockFoo is a mock of Foo interface.type MockFoo struct &#123; ctrl *gomock.Controller recorder *MockFooMockRecorder&#125;// MockFooMockRecorder is the mock recorder for MockFoo.type MockFooMockRecorder struct &#123; mock *MockFoo&#125;// NewMockFoo creates a new mock instance.func NewMockFoo(ctrl *gomock.Controller) *MockFoo &#123; mock := &amp;MockFoo&#123;ctrl: ctrl&#125; mock.recorder = &amp;MockFooMockRecorder&#123;mock&#125; return mock&#125;// EXPECT returns an object that allows the caller to indicate expected use.func (m *MockFoo) EXPECT() *MockFooMockRecorder &#123; return m.recorder&#125;// SayHi mocks base method.func (m *MockFoo) SayHi(sth string) error &#123; m.ctrl.T.Helper() ret := m.ctrl.Call(m, \"SayHi\", sth) ret0, _ := ret[0].(error) return ret0&#125;// SayHi indicates an expected call of SayHi.func (mr *MockFooMockRecorder) SayHi(sth interface&#123;&#125;) *gomock.Call &#123; mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SayHi\", reflect.TypeOf((*MockFoo)(nil).SayHi), sth)&#125; 编写可mock的代码 mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。不直接依赖实例，而是使用依赖注入降低耦合。 如果这样写，是无法mock的 12345678func GetFromDB(key string) int &#123; db := NewDB() if value, err := db.Get(key); err == nil &#123; return value &#125; return -1&#125; 而如果将接口 db DB 通过参数传递到 GetFromDB()，那么就可以轻而易举地传入 Mock 对象 123456789101112// db.gotype DB interface &#123; Get(key string) (int, error)&#125;func GetFromDB(db DB, key string) int &#123; if value, err := db.Get(key); err == nil &#123; return value &#125; return -1&#125; 参考自： Go Mock (gomock)简明教程","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"增加项目的单元测试覆盖率","date":"2016-01-22T13:35:18.000Z","path":"2016/01/22/增加项目的单元测试覆盖率/","text":"可以先从单个文件开始， 测试单个文件，一定要带上被测试的原文件，如果原文件有其他引用，也需一并带上。 go test project/utils/utils_test.go project/utils/utils.go project/utils/utils_mock.go -v -coverprofile=count.out 而后 go tool cover -func=count.out","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Linux tee命令","date":"2016-01-19T13:50:16.000Z","path":"2016/01/19/Linux-tee命令/","text":"https://www.runoob.com/linux/linux-comm-tee.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Shell的pushed和popd命令","date":"2016-01-17T14:34:55.000Z","path":"2016/01/17/Shell的pushed和popd命令/","text":"pushd 和 popd 命令根据 ‘LIFO’（后进先出）原则工作。在该原则之下，只有两个操作是允许的：把一个目录压入栈，以及把一个目录弹出栈。 利用好这两个命令，可以来进行(比cd更)高效的目录导航 pushd 命令会增加一个目录到栈顶，而 popd 命令会从栈顶移除一个目录。 dirs -v 可以显示目录栈中的历史目录，如下： 可以通过pushd +数字方式，快速进入某个目录 popd 命令则相反，其作用是从栈顶或历史中移除一个目录。 为了列出目录栈中的所有目录，只需输入 popd 为了从目录栈中移除一个目录，可以使用 popd +数字 或 popd -数字 命令","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"在Gitlab Pipeline中集成进ut覆盖率和测试报告","date":"2016-01-12T12:37:44.000Z","path":"2016/01/12/在Gitlab-Pipeline中集成进ut覆盖率和测试报告/","text":"基础篇 在上一篇Gitlab Pipeline的项目代码中新增一个ConvertStrToInt函数： 1234567func ConvertStrToInt(str string) (int, error) &#123; rs, err := strconv.Atoi(str) if err != nil &#123; return 0, err &#125; return rs, nil&#125; 并对此函数写一个单测： 12345678910111213141516171819package serviceimport ( \"github.com/stretchr/testify/assert\" \"testing\")func TestConvertStrToInt(t *testing.T) &#123; rs1, err1 := ConvertStrToInt(\"1234\") assert.Equal(t, 1234, rs1) assert.Equal(t, nil, err1) rs2, err2 := ConvertStrToInt(\"123d\") assert.Equal(t, 0, rs2) assert.NotEqual(t, nil, err2)&#125; 运行cron/service中的Test..,得到： 使用覆盖率运行cron/service中的Test..,得到： 可以看到项目整体的测试覆盖率，以及具体某个目录和文件的覆盖率 且在对应文件里，可以看到不同颜色标注的哪些被ut覆盖(绿色)，哪些没有被覆盖(红色) 还可以用go test ./... -v -coverprofile=count.out展示测试覆盖率,并生成覆盖统计文件到 count.out 该文件中详细展示了每个文件测试时某一行,执行的次数及其他信息： 可以用go tool来分析 count.out 文件并生成想要的结果： func 生成每个函数的覆盖率 go tool cover -func=count.out 展示每一个函数单元测试的覆盖率,若100% 则测试完整,若0.0% 则没有测试 html 生成 html 文件,以图形方式展示每个函数,每一行代码的覆盖率 go tool cover -html=count.out 会打开默认浏览器,图形化展示测试覆盖率 可切换当前库下的每个文件,看每一行代码是否测试执行。没有执行的显示为红色, 灰色是不需要测试的, 亮绿色是测试通过的 go test更详细使用可参考 Golang单元测试 这些都是在本地人工执行的结果。现在想将其集成到CI里，每次提交/合并时自动触发，去执行相关操作 在上篇.gitlab-ci.yml文件中lint之后新增unittest任务，最新文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# This file is a template, and might need editing before it works on your project.#image: hub-mirror.c.163.com/library/golang:latestimage: golang:latest.go-cache: variables: GOPATH: $CI_PROJECT_DIR/.go cache: paths: - .go/pkg/mod/variables: OUTPUT_NAME: helloworld-appstages: - lint - unittest - build - deploybefore_script: - echo \"before_script\" - echo \"变量名为:\" - echo $OUTPUT_NAME - git version #- go env -w GOPRIVATE=code.haiziwang.com - mkdir -p .go - go version - go env -w GO111MODULE=on - go env -w GOPROXY=\"https://goproxy.io,direct\"golangci-lint: image: golangci/golangci-lint:v1.27.0 stage: lint extends: .go-cache allow_failure: true script: #- golangci-lint run -v - golangci-lint run -v -D errcheck,staticcheck tags: - csshuang-unit-test: stage: unittest extends: .go-cache script: - go test ./... -v -coverprofile=count.out - go tool cover -func=count.out &gt; coverage.txt - go tool cover -html=count.out -o coverage.html - tail -1 coverage.txt | awk '&#123;printf \"test coverage is %s\\n\", $3&#125;' #可以在界面输出覆盖率 tags: - cs artifacts: paths: - coverage.txt - coverage.htmlcompile: stage: build extends: .go-cache script: - go mod download - cd cmd/ - go build -race -o $OUTPUT_NAME artifacts: paths: - cmd/$OUTPUT_NAME tags: - csdeploy-dev: stage: deploy script: - echo \"deploy dev environment\" tags: - cs 提交后自动触发pipeline 下载生成的作业产物 可以复制下方位置的内容，放在README.md的开头，就可以有相应的徽标 Unit test reports 进阶篇 gocover-cobertura 使用 github.com/boumenot/gocover-cobertura 这个工具，可以在merge界面，看到哪些方法(其实是行)有ut覆盖(绿色)，哪些没有(红色) 入参是 go test生成的xxxx.out文件，执行gocover-cobertura &lt; count.out &gt; cover.xml , 返回一个xml文件,将其填在.gitlab-ci.yml文件的reports那位置即可 .gitlab-ci.yml改动如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# This file is a template, and might need editing before it works on your project.#image: hub-mirror.c.163.com/library/golang:latestimage: golang:latest#.go-cache:# variables:# GOPATH: $CI_PROJECT_DIR/.go# cache:# paths:# - .go/pkg/mod/variables: OUTPUT_NAME: helloworld-appstages: - lint - unittest - build - deploybefore_script: - echo \"before_script\" - echo \"变量名为:\" - echo $OUTPUT_NAME - git version #- go env -w GOPRIVATE=code.haiziwang.com - mkdir -p .go - go version - go env -w GO111MODULE=on - go env -w GOPROXY=\"https://goproxy.io,direct\"golangci-lint: image: golangci/golangci-lint:v1.27.0 stage: lint #extends: .go-cache allow_failure: true script: #- golangci-lint run -v - golangci-lint run -v -D errcheck,staticcheck tags: - csshuang-unit-test: stage: unittest #extends: .go-cache before_script: #- go env - go env -w GOPROXY=\"https://goproxy.cn,direct\" # 否则会报 Get \"https://proxy.golang.org/github.com/boumenot/gocover-cobertura/@v/v1.2.0.info\": dial tcp 142.251.43.17:443: i/o timeout - export PATH=$&#123;PATH&#125;:/go/bin # 否则会报错 /bin/bash: line 134: gocover-cobertura: No such file or directory; 另外需注意，runner其实会拉取一个新的镜像(即上方指定的image: golang:latest)，去执行这些操作；官方的golang:latest的gopath是\"/go\"，而不是~/go (调试时亲测，实际是GOPATH=\"/builds/fliter/crontab/.go\"；这是因为上面的.go-cache:里定义了GOPATH: $CI_PROJECT_DIR/.go) - go get github.com/boumenot/gocover-cobertura@v1.2.0 script: #- go env - go test ./... -v -coverprofile=count.out - go tool cover -func=count.out &gt; coverage.txt - go tool cover -html=count.out -o coverage.html - tail -1 coverage.txt | awk '&#123;printf \"test coverage is %s\\n\", $3&#125;' #可以在界面输出覆盖率 - gocover-cobertura &lt; count.out &gt; cover.xml # 如果不加上面 export PATH这行，此处需要 /go/bin/gocover-cobertura tags: - cs artifacts: paths: - coverage.txt - coverage.html reports: cobertura: cover.xmlcompile: stage: build #extends: .go-cache script: - go mod download - cd cmd/ - go build -race -o $OUTPUT_NAME artifacts: paths: - cmd/$OUTPUT_NAME tags: - csdeploy-dev: stage: deploy script: - echo \"deploy dev environment\" tags: - cs 新切一个分支，并写两个函数，在相应的xxx_test.go里，给一个写单测，一个不写。 提交并进行merge，流水线跑完后，可以看到会在gitlab的界面上标注出某行是否被覆盖到 gotestsum 用 gotest.tools/gotestsum 这个工具，可以在流水线界面及merge时的界面生成测试报告 (用gotestsum代替之前的go test生成xxx.out这一步） gotestsum --junitfile report.xml --format testname -- -race -gcflags=-l -coverprofile=文件名.out ./... 该命令生成一个report.xml, 填在reports那里即可 diff-cover diff-cover是Python写的一个工具，入参目前只能是xml文件.可以分析该xml文件，本次提交新增代码和上次的对比情况 pip3 install diff_cover 因为 go test生成的xxx.out文件需要转成diff-cover需要的xml格式，所以用到了github.com/axw/gocov/ 和github.com/AlekSi/gocov-xml工具 会生成一个report.html，可以在artifacts:paths:下写上从而可以作为作业产物导出 最终完整的yaml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# This file is a template, and might need editing before it works on your project.#image: hub-mirror.c.163.com/library/golang:latestimage: golang:latest#.go-cache:# variables:# GOPATH: $CI_PROJECT_DIR/.go# cache:# paths:# - .go/pkg/mod/variables: OUTPUT_NAME: helloworld-appstages: - lint - unittest - build - deploybefore_script: - echo \"before_script\" - echo \"变量名为:\" - echo $OUTPUT_NAME - git version #- go env -w GOPRIVATE=code.haiziwang.com - mkdir -p .go - go version - go env -w GO111MODULE=on - go env -w GOPROXY=\"https://goproxy.io,direct\"golangci-lint: image: golangci/golangci-lint:v1.27.0 stage: lint #extends: .go-cache allow_failure: true script: #- golangci-lint run -v - golangci-lint run -v -D errcheck,staticcheck tags: - csshuang-unit-test: stage: unittest #extends: .go-cache before_script: - go env - go env -w GOPROXY=\"https://goproxy.cn,direct\" # 否则会报 Get \"https://proxy.golang.org/github.com/boumenot/gocover-cobertura/@v/v1.2.0.info\": dial tcp 142.251.43.17:443: i/o timeout - export PATH=$&#123;PATH&#125;:/go/bin # 否则会报错 /bin/bash: line 134: gocover-cobertura: No such file or directory; 另外需注意，runner其实会拉取一个新的镜像(即上方指定的image: golang:latest)，去执行这些操作；官方的golang:latest的gopath是\"/go\"，而不是~/go (调试时亲测，实际是GOPATH=\"/builds/fliter/crontab/.go\"；这是因为上面的.go-cache:里定义了GOPATH: $CI_PROJECT_DIR/.go) - go get github.com/boumenot/gocover-cobertura@v1.2.0 # 用于merge时可以用红/绿色标识该行有没有被覆盖到 - go get gotest.tools/gotestsum@v1.7.0 # 用于在流水线界面生成报告 - apt-get update &amp;&amp; apt install python3-pip -y # 如果出现Unable to connect to deb.debian.org:http报错，需多试几次 - pip3 install diff_cover # 用于比较两次提交ut覆盖率的变动 - go get github.com/axw/gocov/... - go get github.com/AlekSi/gocov-xml script: - if [ $&#123;CI_COMMIT_BRANCH&#125; == \"main\" ]; then COMPARE_BRANCH=main; else COMPARE_BRANCH=$CI_DEFAULT_BRANCH; fi - git fetch --depth 1 origin $COMPARE_BRANCH #这几个都是gitlab ci默认定义的变量 - go env #- go test ./... -v -coverprofile=count.out - gotestsum --junitfile report.xml --format testname -- -race -gcflags=-l -coverpkg=./... -coverprofile=count.out ./... - go tool cover -func=count.out &gt; coverage.txt - go tool cover -html=count.out -o coverage.html - tail -1 coverage.txt | awk '&#123;printf \"test coverage is %s\\n\", $3&#125;' #可以在界面输出覆盖率 - gocover-cobertura &lt; count.out &gt; cover.xml # 如果不加上面 export PATH这行，此处需要 /go/bin/gocover-cobertura - gocov convert count.out | gocov-xml &gt; coverage.xml - diff-cover coverage.xml --compare-branch=origin/$&#123;COMPARE_BRANCH&#125; --html-report report.html --fail-under=0 tags: - cs artifacts: paths: - coverage.txt - coverage.html - report.html reports: cobertura: cover.xml junit: report.xmlcompile: stage: build #extends: .go-cache script: - go mod download - cd cmd/ - go build -race -o $OUTPUT_NAME artifacts: paths: - cmd/$OUTPUT_NAME tags: - csdeploy-dev: stage: deploy script: - echo \"deploy dev environment\" tags: - cs 可改进之处 单次CI耗时过长(像shuang-unit-test这个任务，经常需要10几分钟甚至20几分钟才能跑完)，主要花在下载各种工具上面。 这一点还有待优化 以及怎样在此展示单测的提升率？","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Gitlab Pipeline","date":"2016-01-08T14:22:03.000Z","path":"2016/01/08/Gitlab-Pipeline/","text":"xx公司 CI阶段在gitlab完成xx的git flow： 所有feature基于master切出，完成开发后（uat环境，pre环境，原则上只能部署类似creative/test、creative/pre，creative-job/test，creative-job/pre这样的分支）。 用test（或pre分支）分支merge feature分支，部署test(或pre)进行测试。如果多人开发中有冲突，则解决。 最后用master来merge这个feature分支 (即将feature分支合入master；feature一般如 creative/add_note_switch这样来命名)。之后到gitlab页面，会有一合入master的选项。 代码提交后会ep机器人自动进行一系列检查(即所谓的pipeline)，如fmt，lint，unit-test覆盖率等check。如果必须通过的check都通过，同时还有两位(包含你自己)reviewers点赞，则会自动合入master。（有些必过check不过，也可以通过approvers强制合入，但一般这种属非正常流程。 角色的定义在项目OWNER文件中） 在此亲自实现这样一个功能：即代码提交后可实现自动lint，可进行单元测试覆盖率统计，进行构建和部署等 将前文介绍的Go静态代码检查工具GolangCI-Lint，集成进gitlab，每次有新的push或merge，自动触发该操作 在项目根目录 创建一个 .gitlab-ci.yml 文件 通过配置.gitlab-ci.yml文件来告诉CI要对项目做些什么。.gitlab-ci.yml位于仓库的根目录下 仓库一旦收到任何推送，GitLab将立即查找.gitlab-ci.yml文件，并根据文件的内容在Runner上启动作业 关于该文件的具体写法，可参考Gitlab CI yaml官方配置文件翻译. 官方文档 或参考 Gitlab CI 配置文件 .gitlab-ci.yaml 详解（上） GitLab-CI：从零开始的前端自动化部署 另外还需要一个Runner去实地跑这些任务（如lint，build等），Runner可以二进制安装(支持多个平台)，也可以通过docker方式 （GitLab与Runner之间通过API进行通信，因此只需要Runner所在的机器有网络并且可以访问GitLab服务器即可） 关于Runner的安装与使用，参考前文 gitlab-runner的安装与配置 在ubuntu服务器(或其他机器)，使用docker方式启动runner，并进入容器中新建一个name为testttt，tags为cs的runner，如下： 参考 golang项目 配置Gitlab CI .gitlab-ci.yml文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# This file is a template, and might need editing before it works on your project.image: hub-mirror.c.163.com/library/golang:latest.go-cache: variables: GOPATH: $CI_PROJECT_DIR/.go cache: paths: - .go/pkg/mod/variables: OUTPUT_NAME: helloworld-appstages: - lint - build - deploybefore_script: - echo \"before_script\" - git version #- go env -w GOPRIVATE=code.haiziwang.com - mkdir -p .go - go version - go env -w GO111MODULE=on - go env -w GOPROXY=\"https://goproxy.io,direct\"golangci-lint: image: golangci/golangci-lint:v1.27.0 #使用docker方式安装golangci-lint，也可以用二进制方式；前者更方便一些 stage: lint extends: .go-cache allow_failure: true script: - golangci-lint run -v tags: - cscompile: stage: build extends: .go-cache script: - go mod download - go build -race -o $OUTPUT_NAME artifacts: paths: - $OUTPUT_NAME tags: - csdeploy-dev: stage: deploy script: - echo \"deploy dev environment\" tags: - cs 当有新的提交push时，会自动触发Pipeline 可见由于代码没有通过lint，故而lint的流水线失败 因为lint部分有 allow_failure: true配置，即该job允许失败，不影响后面job的进行；compile这个job也发生了错误，因为没有allow_failure: true，故而阻塞 下一个job无法进行） 和在本地运行golangci-lint是一样的，只是pipeline将这个操作自动化了~ 将 .gitlab-ci.yml文件 中的golangci-lint run -v修改为golangci-lint run -v -D errcheck,staticcheck，然后再进行提交,可以发现lint这个job成功通过 但compile这个job依然失败 看原因是go的镜像没有找到，故而无法进行编译。 将 image: hub-mirror.c.163.com/library/golang:latest修改为image: golang:latest （即从hub.docker.com去pull go的镜像） 提交后，自动触发pipeline，但compile阶段依然失败 这是因为在根目录没有.go文件，所以build失败。在本地执行，同样会如此： 修改- go build -race -o $OUTPUT_NAME为 12- cd cmd/- go build -race -o $OUTPUT_NAME 再次进行提交 (main.go在cmd文件下) 编译成功，但在将构建出的二进制文件作为作业产物导出时，发生错误，原因是没有这个文件 golint阶段也完全可以通过- golangci-lint run --timeout 3m --issues-exit-code 0 --out-format code-climate | tee gl-code-quality-report.json | jq -r &#39;.[] | &quot;\\(.location.path):\\(.location.lines.begin) \\(.description)&quot;&#39;将lint的结果作为作业产物生成并下载 这是因为go build出来的文件在cmd目录下，而当前默认在根目录下 将 123artifacts: paths: - $OUTPUT_NAME 修改为 123artifacts: paths: - cmd/$OUTPUT_NAME 再次提交，触发pipeline后，compile阶段生成的产物也正常找到并可以导出 至此，一个完整的Gitlab CI Pipeline就执行结束 关于代码的ut覆盖率和测试报告，值得在此基础上，新起一篇博文进行记述 更多可参考： GitLab Continuous Integration (CI) GitLab CI/CD B站视频-Gitlab CI 的基本使用 B站视频-GitLab CI 流水线构建优化 关于github上的持续集成，可参考 阮一峰-持续集成服务 Travis CI 教程","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go静态代码检查工具GolangCI-Lint","date":"2016-01-07T13:00:05.000Z","path":"2016/01/07/Go静态代码检查工具GolangCI-Lint/","text":"在计算机科学中，lint 是一种工具程序的名称，它用来标记源代码中，某些可疑的、不具结构性（可能造成 bug）的段落。它是一种静态程序分析工具，最早适用于 C 语言，在 UNIX 平台上开发出来。后来它成为通用术语，可用于描述在任何一种计算机程序语言中，用来标记源代码中有疑义段落的工具。 其中golangci/golangci-lint是Go生态中Lint的佼佼者 安装 Mac上可通过brew install golangci/tap/golangci-lint快速安装 或 GO111MODULE=on go get -u github.com/golangci/golangci-lint/cmd/golangci-lint@v1.16.0 可使用golangci-lint --version查看版本 可通过golangci-lint help linters查看其支持的所有linters 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107golangci-lint help lintersEnabled by default linters:（默认生效的 linters）deadcode: Finds unused code [fast: false, auto-fix: false]errcheck: Errcheck is a program for checking for unchecked errors in go programs. These unchecked errors can be critical bugs in some cases [fast: false, auto-fix: false]gosimple (megacheck): Linter for Go source code that specializes in simplifying a code [fast: false, auto-fix: false]govet (vet, vetshadow): Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string [fast: false, auto-fix: false]ineffassign: Detects when assignments to existing variables are not used [fast: true, auto-fix: false]staticcheck (megacheck): Staticcheck is a go vet on steroids, applying a ton of static analysis checks [fast: false, auto-fix: false]structcheck: Finds unused struct fields [fast: false, auto-fix: false]typecheck: Like the front-end of a Go compiler, parses and type-checks Go code [fast: false, auto-fix: false]unused (megacheck): Checks Go code for unused constants, variables, functions and types [fast: false, auto-fix: false]varcheck: Finds unused global variables and constants [fast: false, auto-fix: false]Disabled by default linters:（默认不生效的 linters）asciicheck: Simple linter to check that your code does not contain non-ASCII identifiers [fast: true, auto-fix: false]bidichk: Checks for dangerous unicode character sequences [fast: true, auto-fix: false]bodyclose: checks whether HTTP response body is closed successfully [fast: false, auto-fix: false]contextcheck: check the function whether use a non-inherited context [fast: false, auto-fix: false]cyclop: checks function and package cyclomatic complexity [fast: false, auto-fix: false]depguard: Go linter that checks if package imports are in a list of acceptable packages [fast: false, auto-fix: false]dogsled: Checks assignments with too many blank identifiers (e.g. x, _, _, _, := f()) [fast: true, auto-fix: false]dupl: Tool for code clone detection [fast: true, auto-fix: false]durationcheck: check for two durations multiplied together [fast: false, auto-fix: false]errname: Checks that sentinel errors are prefixed with the `Err` and error types are suffixed with the `Error`. [fast: false, auto-fix: false]errorlint: errorlint is a linter for that can be used to find code that will cause problems with the error wrapping scheme introduced in Go 1.13. [fast: false, auto-fix: false]exhaustive: check exhaustiveness of enum switch statements [fast: false, auto-fix: false]exhaustivestruct: Checks if all struct's fields are initialized [fast: false, auto-fix: false]exportloopref: checks for pointers to enclosing loop variables [fast: false, auto-fix: false]forbidigo: Forbids identifiers [fast: true, auto-fix: false]forcetypeassert: finds forced type assertions [fast: true, auto-fix: false]funlen: Tool for detection of long functions [fast: true, auto-fix: false]gci: Gci control golang package import order and make it always deterministic. [fast: true, auto-fix: true]gochecknoglobals: check that no global variables exist [fast: true, auto-fix: false]gochecknoinits: Checks that no init functions are present in Go code [fast: true, auto-fix: false]gocognit: Computes and checks the cognitive complexity of functions [fast: true, auto-fix: false]goconst: Finds repeated strings that could be replaced by a constant [fast: true, auto-fix: false]gocritic: Provides diagnostics that check for bugs, performance and style issues. [fast: false, auto-fix: false]gocyclo: Computes and checks the cyclomatic complexity of functions [fast: true, auto-fix: false]godot: Check if comments end in a period [fast: true, auto-fix: true]godox: Tool for detection of FIXME, TODO and other comment keywords [fast: true, auto-fix: false]goerr113: Golang linter to check the errors handling expressions [fast: false, auto-fix: false]gofmt: Gofmt checks whether code was gofmt-ed. By default this tool runs with -s option to check for code simplification [fast: true, auto-fix: true]gofumpt: Gofumpt checks whether code was gofumpt-ed. [fast: true, auto-fix: true]goheader: Checks is file header matches to pattern [fast: true, auto-fix: false]goimports: In addition to fixing imports, goimports also formats your code in the same style as gofmt. [fast: true, auto-fix: true]golint: Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes [fast: false, auto-fix: false]gomnd: An analyzer to detect magic numbers. [fast: true, auto-fix: false]gomoddirectives: Manage the use of 'replace', 'retract', and 'excludes' directives in go.mod. [fast: true, auto-fix: false]gomodguard: Allow and block list linter for direct Go module dependencies. This is different from depguard where there are different block types for example version constraints and module recommendations. [fast: true, auto-fix: false]goprintffuncname: Checks that printf-like functions are named with `f` at the end [fast: true, auto-fix: false]gosec (gas): Inspects source code for security problems [fast: false, auto-fix: false]ifshort: Checks that your code uses short syntax for if-statements whenever possible [fast: true, auto-fix: false]importas: Enforces consistent import aliases [fast: false, auto-fix: false]interfacer: Linter that suggests narrower interface types [fast: false, auto-fix: false]ireturn: Accept Interfaces, Return Concrete Types [fast: false, auto-fix: false]lll: Reports long lines [fast: true, auto-fix: false]makezero: Finds slice declarations with non-zero initial length [fast: false, auto-fix: false]maligned: Tool to detect Go structs that would take less memory if their fields were sorted [fast: false, auto-fix: false]misspell: Finds commonly misspelled English words in comments [fast: true, auto-fix: true]nakedret: Finds naked returns in functions greater than a specified function length [fast: true, auto-fix: false]nestif: Reports deeply nested if statements [fast: true, auto-fix: false]nilerr: Finds the code that returns nil even if it checks that the error is not nil. [fast: false, auto-fix: false]nilnil: Checks that there is no simultaneous return of `nil` error and an invalid value. [fast: false, auto-fix: false]nlreturn: nlreturn checks for a new line before return and branch statements to increase code clarity [fast: true, auto-fix: false]noctx: noctx finds sending http request without context.Context [fast: false, auto-fix: false]nolintlint: Reports ill-formed or insufficient nolint directives [fast: true, auto-fix: false]paralleltest: paralleltest detects missing usage of t.Parallel() method in your Go test [fast: true, auto-fix: false]prealloc: Finds slice declarations that could potentially be preallocated [fast: true, auto-fix: false]predeclared: find code that shadows one of Go's predeclared identifiers [fast: true, auto-fix: false]promlinter: Check Prometheus metrics naming via promlint [fast: true, auto-fix: false]revive: Fast, configurable, extensible, flexible, and beautiful linter for Go. Drop-in replacement of golint. [fast: false, auto-fix: false]rowserrcheck: checks whether Err of rows is checked successfully [fast: false, auto-fix: false]scopelint: Scopelint checks for unpinned variables in go programs [fast: true, auto-fix: false]sqlclosecheck: Checks that sql.Rows and sql.Stmt are closed. [fast: false, auto-fix: false]stylecheck: Stylecheck is a replacement for golint [fast: false, auto-fix: false]tagliatelle: Checks the struct tags. [fast: true, auto-fix: false]tenv: tenv is analyzer that detects using os.Setenv instead of t.Setenv since Go1.17 [fast: false, auto-fix: false]testpackage: linter that makes you use a separate _test package [fast: true, auto-fix: false]thelper: thelper detects golang test helpers without t.Helper() call and checks the consistency of test helpers [fast: false, auto-fix: false]tparallel: tparallel detects inappropriate usage of t.Parallel() method in your Go test codes [fast: false, auto-fix: false]unconvert: Remove unnecessary type conversions [fast: false, auto-fix: false]unparam: Reports unused function parameters [fast: false, auto-fix: false]varnamelen: checks that the length of a variable's name matches its scope [fast: false, auto-fix: false]wastedassign: wastedassign finds wasted assignment statements. [fast: false, auto-fix: false]whitespace: Tool for detection of leading and trailing whitespace [fast: true, auto-fix: true]wrapcheck: Checks that errors returned from external packages are wrapped [fast: false, auto-fix: false]wsl: Whitespace Linter - Forces you to use empty lines! [fast: true, auto-fix: false]Linters presets:（linters 分类）bugs: asciicheck, bidichk, bodyclose, contextcheck, durationcheck, errcheck, errorlint, exhaustive, exportloopref, gosec, govet, makezero, nilerr, noctx, rowserrcheck, scopelint, sqlclosecheck, staticcheck, typecheckcomment: godot, godox, misspellcomplexity: cyclop, funlen, gocognit, gocyclo, nestiferror: errcheck, errorlint, goerr113, wrapcheckformat: gci, gofmt, gofumpt, goimportsimport: depguard, gci, goimports, gomodguardmetalinter: gocritic, govet, revive, staticcheckmodule: depguard, gomoddirectives, gomodguardperformance: bodyclose, maligned, noctx, preallocsql: rowserrcheck, sqlclosecheckstyle: asciicheck, depguard, dogsled, dupl, errname, exhaustivestruct, forbidigo, forcetypeassert, gochecknoglobals, gochecknoinits, goconst, gocritic, godot, godox, goerr113, goheader, golint, gomnd, gomoddirectives, gomodguard, goprintffuncname, gosimple, ifshort, importas, interfacer, ireturn, lll, makezero, misspell, nakedret, nilnil, nlreturn, nolintlint, paralleltest, predeclared, promlinter, revive, stylecheck, tagliatelle, tenv, testpackage, thelper, tparallel, unconvert, varnamelen, wastedassign, whitespace, wrapcheck, wsltest: exhaustivestruct, paralleltest, testpackage, tparallelunused: deadcode, ineffassign, structcheck, unparam, unused, varcheck 可以传入参数 -E/--enable来使某个linter可用，也可通过-D/--disable参数来使某个linter不可用 如： 1golangci-lint run --disable-all -E errcheck 使用 检查当前目录下所有的文件 golangci-lint run 等同于 golangci-lint run ./… 可以指定某个目录和文件 golangci-lint run dir1 dir2/… dir3/file1.go 检查dir1和dir2目录下的代码 及dir3目录下的file1.go文件 更多棵参考Linters 常用Linter： deadcode 未使用且未导出的函数(比如：首字母小写且未被调用的方法) errcheck 返回的error未处理 structcheck 检测结构体中未使用的字段 unused 方法中方法名首字母小写(未导出)并且未使用的方法 gosimple 代码中有需要优化的地方 如：1. err = errors.New(fmt.Sprintf(“%s”, val)) 代码检查会直接推荐你使用fmt.Errorf(…)2. strChan := make(chan string,0) 代码检查会提示你直接使用 make(chan string)3. select中只有一个case 代码检查会提示你去掉select ineffassign：检测变量的赋值 示例： var index byte = 0 以上代码会提示 ineffectual assignment to index(无效的分配，因为index的默认值为0) govet：用于检测代码结构中可以的构造 示例：1. fmt.Errorf(“%s”, val) 有声明但没有使用2. loopclosure: loop variable xxx captured by func literal (govet) 某个方法中重复定义了相同的局部变量 typecheck gochecknoglobals: check that no global variables exist (检测是否有全局变量. 默认不开启) 可参考哈哈哈 以上都是利用该（二进制）工具在本地查验。使用gitlab的CI功能，每次有push/merge操作时自动触发lint查验，参见 点此查看更详细GolangCI-Lint 最佳实践 更多参考： golangci-lint 代码检查 Go静态代码检查工具GolangCI-Lint","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"gitlab-runner的安装与配置","date":"2016-01-06T13:35:09.000Z","path":"2016/01/06/gitlab-runner的安装与配置/","text":"官方文档：Install GitLab Runner Docker方式： 1234docker run -d --name gitlab-runner --restart always \\ -v /home/ubuntu/glab_runner:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 其中 /home/ubuntu/glab_runner为存放gitlab runner配置文件的位置 :为对应关系 进入容器docker exec -it e6ecd9372fcb bash, 并进行注册gitlab-runner register 依次按提示输入信息 (其中 Enter an executor: docker, docker+machine, kubernetes, custom, docker-ssh, parallels, shell, ssh, virtualbox, docker-ssh+machine: 选择docker) 此时在gitlab某项目的 设置-CI/CD-Runner,可以看到新增加的Runner，且description和tags和上面输入的一一对应 在项目中添加.gitlab-ci.yml,tags指定cui_test，则将可以用刚注册的Runner去跑.gitlab-ci.yml描述的任务 原生方式安装(以Ubuntu为例） 在 Ubuntu 上安装使用极狐GitLab Runner 激活： 123sudo gitlab-runner verifysudo gitlab-runner restart 查看配置文件： 删除某个runner： gitlab-runner verify --delete --name xxx 原生方式安装(以Mac为例） 下载并安装Gitlab-runner命令行(二进制文件) 123sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64sudo chmod +x /usr/local/bin/gitlab-runner 初始化gitlab-runner： 123cd ~gitlab-runner installgitlab-runner start … 目前看还不支持arm的机器 详细参考 GitLab-CI：从零开始的前端自动化部署 各种Executor各方面特点的比较：","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"自动化处理博客文章","date":"2016-01-06T11:47:34.000Z","path":"2016/01/06/自动化处理博客文章/","text":"在github新建了一个study-notes库，想要把博客文章整理推送上去。 hexo默认的*.md及对应的文件夹，全部在source/_post下面，在hexo g时生成html，并依据tags分门别类。 现在想直接依据tags，将文章及其对应的文件夹复制到git仓库相应的文件夹下。同一文章多个标签的话，放到多个文件夹中。且如果包含Todo标签，则不进行复制处理。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package mainimport ( \"errors\" \"fmt\" \"io\" \"io/ioutil\" \"os\" \"path/filepath\" \"regexp\" \"strings\")const ( GitPath = \"/Users/fliter/hub/study-notes/\")func main() &#123; basePath := \"/Users/fliter/blog/source/_posts/\" // 获取某目录下的所有文件; 也可以用 files, _ := filepath.Glob(\"*\") files, _ := ioutil.ReadDir(basePath) for _, f := range files &#123; if strings.Contains(f.Name(), \".md\") &#123; //fmt.Println(f.Name()) deal(basePath, f.Name()) &#125; &#125; fmt.Println(\"---完成拷贝---\")&#125;func deal(basePath, fileName string) &#123; filePath := basePath + fileName fmt.Println(filePath) // /Users/fliter/blog/source/_posts/空负安邦志-遂吟去国行.md // read the whole file at once b, err := ioutil.ReadFile(filePath) if err != nil &#123; panic(err) &#125; s := string(b) // fmt.Println(s) //全量内容 //s =` //--- //title: '空负安邦志,遂吟去国行' //date: 2018-11-26 19:57:04 //tags: [金庸,杂谈] //--- //` // 进行正则匹配 // go - 如何获得两个已知单词之间的字符串？ https://www.coder.work/article/212986 re := regexp.MustCompile(`tags: (.*)`) // 返回一个切片，第0个元素是全量的文本，之后是匹配到的具体内容 rs := re.FindStringSubmatch(s) //fmt.Println(\"rs:\", rs) if len(rs) == 0 &#123; return &#125; tags := re.FindStringSubmatch(s)[1] //fmt.Println(\"tags is:\", tags) var tagsSli []string if strings.Contains(tags, \"[\") &#123; tagsTmp := strings.TrimPrefix(tags, \"[\") tagsTrue := strings.TrimSuffix(tagsTmp, \"]\") fmt.Println(\"tagsTrue:\", tagsTrue) tagsSli = strings.Split(tagsTrue, \",\") &#125; else &#123; tagsSli = []string&#123;tags&#125; &#125; if InSlice(tagsSli, \"Todo\") &#123; return &#125; fmt.Println(\"tagsSli:\", tagsSli) for _, value := range tagsSli &#123; dstPath := GitPath + value + \"/\" initPath(dstPath) // 拷贝当前*.md及对应的文件夹到该目录 written, err := CopyFile(filePath, dstPath+fileName) if err != nil &#123; fmt.Println(\"dstPath+fileName:\", dstPath+fileName) fmt.Println(\"CopyFile err:\", err) continue &#125; _ = written //fmt.Println(\"written:\",written) srcDirPath := strings.TrimSuffix(filePath, \".md\") + \"/\" dstDirPath := dstPath + strings.TrimSuffix(fileName, \".md\") + \"/\" //fmt.Println(\"srcDirPath:\",srcDirPath) //fmt.Println(\"dstDirPath:\",dstDirPath) initPath(dstDirPath) errDir := CopyDir(srcDirPath, dstDirPath) if errDir != nil &#123; fmt.Println(\"CopyDir errDir:\", errDir) continue &#125; &#125; //os.Exit(111)&#125;// 复制文件夹 https://blog.csdn.net/youngwhz1/article/details/89706704func CopyDir(srcPath, desPath string) error &#123; //检查目录是否正确 if srcInfo, err := os.Stat(srcPath); err != nil &#123; return err &#125; else &#123; if !srcInfo.IsDir() &#123; return errors.New(\"源路径不是一个正确的目录！\") &#125; &#125; if desInfo, err := os.Stat(desPath); err != nil &#123; return err &#125; else &#123; if !desInfo.IsDir() &#123; return errors.New(\"目标路径不是一个正确的目录！\") &#125; &#125; if strings.TrimSpace(srcPath) == strings.TrimSpace(desPath) &#123; return errors.New(\"源路径与目标路径不能相同！\") &#125; err := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error &#123; if f == nil &#123; return err &#125; //复制目录是将源目录中的子目录复制到目标路径中，不包含源目录本身 if path == srcPath &#123; return nil &#125; //生成新路径 destNewPath := strings.Replace(path, srcPath, desPath, -1) if !f.IsDir() &#123; CopyFile(path, destNewPath) &#125; else &#123; if !FileIsExisted(destNewPath) &#123; return MakeDir(destNewPath) &#125; &#125; return nil &#125;) return err&#125;// 检查文件是否存在func FileIsExisted(filename string) bool &#123; existed := true if _, err := os.Stat(filename); os.IsNotExist(err) &#123; existed = false &#125; return existed&#125;//创建文件夹（如果文件夹不存在则创建）func MakeDir(dir string) error &#123; if !FileIsExisted(dir) &#123; if err := os.MkdirAll(dir, 0777); err != nil &#123; //os.ModePerm fmt.Println(\"MakeDir failed:\", err) return err &#125; &#125; return nil&#125;// 复制文件 https://blog.csdn.net/youngwhz1/article/details/89706704// 使用io.Copy方式func CopyFile(src, des string) (written int64, err error) &#123; srcFile, err := os.Open(src) if err != nil &#123; return 0, err &#125; defer srcFile.Close() //获取源文件的权限 fi, _ := srcFile.Stat() perm := fi.Mode() //desFile, err := os.Create(des) //无法复制源文件的所有权限 desFile, err := os.OpenFile(des, os.O_RDWR|os.O_CREATE|os.O_TRUNC, perm) //复制源文件的所有权限 if err != nil &#123; return 0, err &#125; defer desFile.Close() return io.Copy(desFile, srcFile)&#125;func initPath(path string) &#123; _, err := os.Stat(path) if err != nil &amp;&amp; errors.Is(err, os.ErrNotExist) &#123; // 创建多级目录 os.MkdirAll(path, os.ModePerm) &#125;&#125;func InSlice(sli []string, ele string) bool &#123; for _, v := range sli &#123; if v == ele &#123; return true &#125; &#125; return false&#125; 推送后效果如下：","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"阅江楼记","date":"2015-12-29T06:02:31.000Z","path":"2015/12/29/阅江楼记/","text":"明太祖朱元璋一统天下后，在南京狮子山的山顶修建阅江楼，亲自作了一篇《阅江楼记》，然后又令文臣每人作一篇。于是宋濂写下这篇《阅江楼记》。 宋濂 〔明代〕 金陵为帝王之州。自六朝迄于南唐，类皆偏据一方，无以应山川之王气。逮我皇帝，定鼎于兹，始足以当之。由是声教所暨，罔间朔南；存神穆清，与天同体。虽一豫一游，亦可为天下后世法。京城之西北有狮子山，自卢龙蜿蜒而来。长江如虹贯，蟠绕其下。上以其地雄胜，诏建楼于巅，与民同游观之乐。遂锡嘉名为“阅江”云。 登览之顷，万象森列，千载之秘，一旦轩露。岂非天造地设，以俟大一统之君，而开千万世之伟观者欤？当风日清美，法驾幸临，升其崇椒，凭阑遥瞩，必悠然而动遐思。见江汉之朝宗，诸侯之述职，城池之高深，关阨之严固，必曰：“此朕沐风栉雨、战胜攻取之所致也。”中夏之广，益思有以保之。见波涛之浩荡，风帆之上下，番舶接迹而来庭，蛮琛联肩而入贡，必曰：“此朕德绥威服，覃及外内之所及也。”四陲之远，益思所以柔之。见两岸之间、四郊之上，耕人有炙肤皲足之烦，农女有捋桑行馌之勤，必曰：“此朕拔诸水火、而登于衽席者也。”万方之民，益思有以安之。触类而思，不一而足。臣知斯楼之建，皇上所以发舒精神，因物兴感，无不寓其致治之思，奚此阅夫长江而已哉？彼临春、结绮，非弗华矣；齐云、落星，非不高矣。不过乐管弦之淫响，藏燕赵之艳姬。一旋踵间而感慨系之，臣不知其为何说也。 虽然，长江发源岷山，委蛇七千余里而始入海，白涌碧翻，六朝之时，往往倚之为天堑；今则南北一家，视为安流，无所事乎战争矣。然则，果谁之力欤？逢掖之士，有登斯楼而阅斯江者，当思帝德如天，荡荡难名，与神禹疏凿之功同一罔极。忠君报上之心，其有不油然而兴者耶？ 臣不敏，奉旨撰记，欲上推宵旰图治之切者，勒诸贞珉。他若留连光景之辞，皆略而不陈，惧亵也。","tags":[{"name":"奇文共赏","slug":"奇文共赏","permalink":"http://www.dashen.tech/tags/奇文共赏/"}]},{"title":"考研政治选择题","date":"2015-12-19T06:26:38.000Z","path":"2015/12/19/考研政治选择题/","text":"单选题16个,16分, 多选题17个,34分. 另有5个解答题,每个10分. 17个题超过一半是三选,其次是全选,最少的是双选 资源来自 考研政治选择题技巧全面总结 17,20,22,28全选概率为0. 即多选题的第1,4,6,12个不会全选 (第1个三选,第6个三选概率较高) 24,25,32,33两选概率为0. 可以简单记成2,3,4,5,不会两选(只是2和3为32和33),甚至全选概率更高 即第一个多选题不会是全选,最后两个多选题不会两选 18,19题全选概率也较低 多选要对11个,拿下22分 错在态度 两个选项 问法很宽泛,选项不明觉厉 资源来自 2020曲艺政治选择题技巧班第二讲","tags":[]},{"title":"逆矩阵的几种求法","date":"2015-12-13T07:12:29.000Z","path":"2015/12/13/逆矩阵的几种求法/","text":"初等变换法用的比较多 伴随矩阵法用的不算多","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"Hello World","date":"2015-12-06T23:49:57.000Z","path":"2015/12/07/Hello-World/","text":"我的个人技术网站www.dashen.tech正式上线了。今后，你可以在全世界任何一个角落，用任何一台可联网的设备进行访问。 此刻，我难掩内心的激动，不单单因为这个几乎不需要任何技术即可搭建完成的网站，而是因为互联网，因为这个时代。 1998年，在中学工作的爸爸，用一沓一面已经使用的穿孔纸，操作着双飞燕滚轮鼠标，将他用办公室那台浪潮电脑下载的《阿里巴巴与四十大盗》打印出来。此后的许多个午后，阳光透过老家阳台的玻璃打在脸庞，我躺在床上暖洋洋十分惬意。爸用他那并不算标准的普通话，开始给我讲阿里巴巴的故事。我不时提出不解与疑问，直至昏昏沉沉地睡去。今天，那沓已破旧不堪的故事集，仍完好压在我床榻之下，阿里巴巴的故事也一直深藏在心里。后来偶尔翻看，还能在页脚看到新浪字样。 我当然不会知道，几乎与此同时，在遥远的浙江，一个毫不懂技术的英语老师，持有了alibaba.com。十八罗汉的故事将在多年后为人所熟知，但在当时，这个坚信互联网将深刻改变商业的浙江人，还在别人的嘲笑中执拗地艰难前行。16年前，从新浪下载到的阿里巴巴的故事，成为互联网给我的第一份惊喜；16年后，另一个阿里巴巴不仅成为新浪的大股东，还以BAT三巨头的姿态深刻改变着人们衣食住行方方面面。对于一个现代人，他们提供的网络服务，已经如同水和电，深深嵌进每个人的生活。 1999年，幼儿园一个放假的周末，我随二大爷去他所在的城里小住，那里有一台小叔辗转带来的组装电脑。姐姐用一个叫“金山画王”的东西，几分钟内就画出了一只鲜艳漂亮的蝴蝶，让我惊讶并佩服不已。当我接过鼠标操纵笔和橡皮尝试作画，问的第一个问题是“姐姐，这块橡皮会用完吗？用完了要再从哪里买？” 我也是许多年后才知道，开发出金山画王的金山公司，有位年纪轻轻的IT劳模。在10多年前的90年代前后，初上大学的他在图书馆读到了一本《硅谷之火》 ，书中讲述的的故事让他心潮澎湃，绕着操场转了一圈又一圈。20年后，我切身领会到了当年他的激动。而这时他已抓住移动互联网风口，意欲实现当年夙愿。我的第一部智能手机，即拜其所赐。这个普通话和口才极差的工科男，不太会表露自己的内心情怀。但当那年我在中部一省份边陲的群山之中，看到当地居民拿着他新出的千元机，虽然依然不会用淘宝不会用来看新闻，但还是让我感慨不已。信息平等，是实现社会平等最起码的前提。 有人在20几年前已经深刻领会到这一点。在山西阳泉，一个自认技术不错的少年前去太原参加编程大赛，最后却惨败而回。当他路过省城的新华书店，疑惑一扫而光，里面有鳞次栉比的编程书籍，这和他家乡的资源形成强烈反差，自此，一颗种子就埋在了他心中，并在若干年后长成参天大树。“让每个人平等的提升自我”，这是我认为最直白却最震撼人心的品牌宣言。 2000年，还是用那台浪潮电脑，爸借来同事新买的30万像素的索尼数码相机作为摄像头，又从老家接来爷爷奶奶，在一个上午，不知如何操作居然看到了远在美国东海岸康涅狄格州的小叔。能看到屏幕上大洋彼岸亲人的一举一动，不要说对爷爷奶奶，这让我都感觉像是在梦中，在变魔术。后来我知道，这个让我认为是在变魔术的神奇东西，叫做“雅虎通”。 也是那一年，我在南北寺中学财务处外的那片草坪，扮演着洪七公和王欢扮演的东邪过招，玩的正欢。我回办公室去喝水，问在电脑旁的表哥在做什么。当我听到”在聊天”的回答后，他继续问我要不要也“注册”一个，并刻意补充“不要钱”。我说那好吧。我对他的问题“你想让昵称叫什么”又表示不解：“什么是昵称”？他说“小猫小狗都可以，叫小狗吧”。听到这个回答立马打消了我“注册”的想法，因为那时，我崇拜的是东邪北丐这样的英雄。匆匆喝过几口白水，又拿起打狗棒撒腿跑到草坪再战。后来，这个当时还叫做QICQ的东西，成为改变亿万中国人交流方式的工具。 2003年的非典是一场浩劫，但灾难的同时也在孕育着新生的力量。如同300多年的那场黑死病，60岁的黑格尔不幸而去，而23岁的英国剑桥大学三一学院学生伊萨克·牛顿，则迎来了自己的春天。 这一年，在杭州湖畔花园，一个叫淘宝的东西即将诞生。当年那个英语老师，已然小有名气，但在三剑客统治互联网江湖的时代，他仍然还只是配角。但这时，互联网纵深化发展的趋向已可见一斑，互联网的作用将不再只是看看新闻，玩玩游戏。 同样在这前后，出身苏北农村的吊丝青年刘强东，不得已结束在中关村的实体生意，开始新的尝试。这个毕业于中国人民大学社会学专业的前学霸，因对专业的失望，在大学期间自学了编程。 2004年，印尼苏门答腊海域发生地震并引发特大海啸，最终造成20余万人丧生。那是一个冬季的下午，我坐在邹平一中一间办公室的沙发上，看着当时的齐鲁晚报。“中国首富丁磊捐款1000万给海啸灾区”，这让我疑惑，丁磊是何方神圣？当我得知首富居然是互联网行业，不禁愕然，因为在我看来，看得见却摸不着的互联网，怎么会产生首富？首富不该是属于钢铁、汽车，乃至石油化工行业？后来，这个打出网聚人的力量的前首富，成为独树一帜的互联网门派之一。他辞掉家乡公务员南下广州的惊人之举，与在深圳那杯啤酒，在今天同样为人所津津乐道。当年那杯啤酒的另一位主角，正是我最崇拜的互联网英雄，我多年前拒绝注册的他的产品，在今天已然覆盖大半个中国。 这是时代机遇，也是个人选择。有几个大学老师会下海经商，有几个人大毕业生愿去中关村摆摊，有几个大学生会辞去家乡稳定工作南下闯荡？或者试想，那个长相英俊的阳泉青年如果真选择去唱戏，或当已在美帝过起舒适中产生活乐不思蜀，就不会有百度的出现。那个酷爱天文的潮汕青年选择去南京大学学地理，也许今天会是一位优秀的学者。那个已然位列成功人士的IT劳模，没有雄心壮志，不会选择置成功声誉于度外再次创业。 2004年后，我和网的关系已经无需再说。 它已经在我有意识或无意识间，不可逆转地一步步沁入我的生活。这一年，由两个斯坦福学生创办的搜索引擎在纳斯达克上市，并最终让被认为不可打败的微软头疼不已。同样这一年，又有一个哈佛大学学生辍学，开启了自己的传奇。… 此时此刻，在距我所在上海长宁不远的浙江乌镇， 一年一度的互联网大会正如期举行，包括国家最高领导人在内的政商领袖齐聚一堂，共商网事。而今，互联网再不是一个geek们之间炫技的工具，它也不单再是承载太多青年希望的创富工具，它让信息更透明，它让每个人都能发声，它将掀起一场影响深远的和平革命。 在我听完《阿里巴巴与四十大盗》的故事许多年后，《一千零一夜》的其他几个故事我隔了好几年才读到，对那个年纪的我诉说当时正在发生着的传奇，却会觉得是“天方夜谭”。几年后，我读完《辛伯达航海记》，被故事里辛伯达7次航海的奇遇痴迷不已，并认为比阿里巴巴和阿拉丁更让我神往。 500多年前，人类的大航海及与之俱来的地理大发现第一次从空间上让全球连为一体。而500年后的互联网革命，则被认为是继大航海后人类又一次深刻改变信息的传递与联系。 大航海是让每一个心有梦想的弄潮儿激动的，旅途的闻所未闻的奇花异草与所见所闻，更让人悸动难奈。作为一个从业者，我们所走的每一步都是前人未曾做过的，我们鲜有经验无章可循，这让我们担心，但更人激动。我们所走的每一步，也许都在创造着历史。 当我在高中第一次真正开始思考自己未来从事的工作，那时对数理痴迷不已的我毅然想要从事纯理科，我想做牛顿，做欧拉和高斯，做麦克斯韦。然而，当我对数学老师稍稍透露这个想法，他回答“如果早生几百年，也许很可能。但现在很难有那样的发现了。”这句他平淡说出的话于我不啻惊雷，我想了许多。而后西配楼卫生区经逢的事情发酵让我深陷痛不欲生的纠结，无暇或已无力再奢求再多想许多。2013年，我陪化学工程师的二大爷去一化工厂，厂长热情招待了我们。他问及我专业时我不疼不痒地说出，对方听到，也感慨地说了一句“还是让孩子学点这东西好（指化工），这玩意学无止境啊！” 说者无心听者有意，“这玩意学无止境”，这句话让我不再自欺欺人，我开始承认，我与生适合做一名工程师，即便当时，我已经是文理俱佳并以半geek自居的互联网爱好者。我对各家历史如数家珍，却对技术粗略知晓。 2013年6月，在又一个迷茫无措时刻，我决定做一些事情转移心中无法排解的万千块垒，那时我注册了一个域名，学了html，最后却因为学校的不支持而不了了之。 2015年，我处在5年来最兴奋最踏实最满意的一段时期，过往萦绕心间的羁绊，能解则解，不能释怀就先压在心底。我要发至内心感谢互联网，感谢**，感谢**。 在最后，我仍然想以那段著名的腾云杂志创刊词结尾。在我有关网络的多如牛毛的文章的结尾，我总是情不自禁想到它： 1988年3月，中山大学哲学系教授刘小枫写下哲理散文《我们这一代人的怕和爱》。与此同时，一项名为“中国计算机科技网”（CANET）的项目启动，希望将中国的大学和研究机构中的计算机与世界范围内的其他计算机网络相联。23年后的今天，我们借用这句话，雕琢出《腾云》这本刊物的宗旨：“面对未来，我们的怕与爱”。此时此刻，搜索引擎、电子商务、社交网站、移动互联网等基于网络的创新，让包括中国网民在内的全球20亿以上互联网用户的生活变得更加多姿多彩。面对人生和世界，我们“怕与爱”的基本情绪没有改变，但整体视角已经从过去和现在转投向了未来。这正是过去20多年间互联网在全世界崛起蔓延的深刻后果之一：爆炸的科技和信息对世界的祛魅使得“现在”越来越透明，“未来”却越来越混沌。所有关心世界如何运转的人，同样甚至更加关心那个激动人心却充满不确定性的未来。这也是我们策划《腾云》最初与最终的目的。这本读物是腾讯在茫茫人海中寻找思想伙伴，共同探索未来世界的持续努力之一。需要特别说明的是，《腾云》不承载任何传播腾讯企业资讯的使命，我们所关心的命题只有三：1，互联网的未来将走向何方？2，中国的未来将走向何方？3，人类社会的未来将走向何方？很明显，这样的思考远远超出了腾讯一家公司的视野和能力。所以，我们采行了一种特别的编辑策略：以文章的推荐者为核心，借助他们的远见卓识和宽广视野，将解读不确定未来的线索交付到读者手中。而这些推荐者，就是我们的“云中智库”。套用一句刘小枫在《我们这一代人的怕和爱》中所说的：只有品尝过怕和爱的生活的灵魂，才会懂得由怕和爱的生活本身用双手捧出的这颗灵魂。《腾云》所追求的不是对未来虚幻的想象，而是未来在当下的映照与投射，是我们对之充满了怕与爱的未来本身。 此刻，我万分荣幸成为互联网这艘大船上万千水手中的一员。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"高数大题汇总","date":"2015-12-05T08:17:56.000Z","path":"2015/12/05/高数大题汇总/","text":"&lt;2010.1&gt; 用泰勒公式,展开到三阶 -1/6x的四次方没有了,被吸收进o(x的三次方)里面去了 &lt;2015.16&gt; 这类题,记住公式一点不难,只需要基本的计算 此处也可以用华莱士公式即所谓的点火公式,大为减轻计算量 两个算出来,然后一等~ 旋转体的体积和表面积公式 &lt;2015.17&gt; 积分,确定f(x,y)的表达式, 算出来后,就比较常规了(二元函数极值存在的必要条件) &lt;2015.18&gt; 积分区域关于y轴对称 利用奇偶性,简化计算 常见的三种三角换元之一 &lt;2015.19&gt; &lt;2015.20&gt; 一道应用题 微分方程的物理应用现在出的不多了.几何应用考的较多 &lt;2015.21&gt; 现在二阶导&gt;0这个条件 还没有使用 拉格朗日中值定理 借助拉格朗日中值定理,构建不等式 &lt;2019.15&gt; &lt;2019.16&gt; 不定积分的计算 有理分式不定积分的计算 &lt;2019.17&gt; 微分方程 &amp; 求旋转体的体积 一阶非齐次线性微分方程,用求解共识即可 &lt;2019.18&gt; 二重积分的计算 &lt;2019.19&gt; &lt;2019.20&gt; 主要就是考计算..算偏导数 &lt;2019.21&gt; 法1: 法2:反证法: 法1: 法2: &lt;2020.15&gt; 斜渐近线 凑重要极限: 对于1的无穷型未定式,凑重要极限,或者取对数,就这两种办法 无穷-无穷 型未定式, 倒代换(令t=1/x),转换为0/0,然后洛必达 &lt;2020.16&gt; &lt;2020.17&gt; 基础题,最简单的一道大题了… 先求驻点. &lt;2020.18&gt; 写成x=g(y)的形式 三角换元 &lt;2020.19&gt; 二重积分,老朋友了~ 转换为极坐标来做 这个积分是分部积分法的一个典型应用 &lt;2020.20&gt; 证明题 零点定理: 罗尔定理: 柯西中值定理: &lt;2020.21&gt;","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"代码验证斯特林公式的准确性","date":"2015-11-29T03:20:30.000Z","path":"2015/11/29/代码验证斯特林公式的准确性/","text":"和华莱士公式千丝万缕","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"常见函数的图像","date":"2015-11-21T05:27:28.000Z","path":"2015/11/21/常见函数的图像/","text":"arcsinx cotx arctanx 反正切函数的图像如下: 即,对于tanx的图像,将x轴/y轴作为y轴/x轴,即是其反函数arctanx的图像~ arccotx 反余切函数的图像如下: 即,对于tanx的图像,将x轴/y轴作为y轴/x轴,即是其反函数arctanx的图像~ secx 正割函数的图像如下: cscx 余割函数的图像如下: 三角函数及其之间的关系","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"几种图形的标准方程","date":"2015-11-21T04:44:51.000Z","path":"2015/11/21/几种图形的标准方程/","text":"圆的标准方程(x-a)²+(y-b)²=r²三个参数a、b、r，即圆心坐标为(a，b)，只要求出a、b、r，这时圆的方程就被确定，因此确定圆方程，须三个独立条件，其中圆心坐标是圆的定位条件，半径是圆的定形条件。 所表示的曲线是以O(0，0)为圆心，以1单位长度为半径的圆；所表示的曲线是以O(0，0)为圆心，以r为半径的圆；所表示的曲线是以O(a，b)为圆心，以r为半径的圆。","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"间断点的类型","date":"2015-11-18T16:15:25.000Z","path":"2015/11/19/间断点的类型/","text":"间断点(point of discontinuity),在非连续函数y=f(x)中某点处xo处有中断现象 左右极限都存在的间断点称为第一类间断点,再近一步,如果左右极限都存在且相等的间断点,称为可去间断点; 左右极限都存在但不相等的间断点称为跳跃间断点 左右极限至少有一个不存在的间断点称为第二类间断点,若趋于x0正,或x0负时,f(x)趋于无穷,则称x0为f(x)的无穷间断点.","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"高数基础问题汇总","date":"2015-11-18T15:30:24.000Z","path":"2015/11/18/高数基础问题汇总/","text":"&lt;2010.1&gt; 无穷间断点,即趋于x0正,或x0负时,f(x)趋于无穷,则x0为f(x)的无穷间断点. B 在x=0处是跳跃间断点,即左右极限都存在但不相等 x=1是可去间断点 x=-1是无穷间断点 是间断点的一个前提,是函数在x0处不连续,故而09年题目D选项错误 微分方程的解的概念 C 反常积分的审敛,一般有两种做法: 当被积函数简单时,当成定积分来算,再取计算 当被积函数较复杂时,用反常积分审敛法 可作为结论记住 D B 了解隐函数偏导数的计算方法,则中规中矩比较简单.. D 高阶常系数线性齐次微分方程的通解 先写出特征方程 解出特征方程的根,根据根的情况写出微分方程的解 小蓝书第79页 求渐近线三步走: 该函数处处都有定义,所以没有铅直渐近线 当x趋于正/负无穷,函数极限趋于正/负无穷,所以也没有水平渐近线 渐近线数二经常经常考 不是求积分的 牛顿-莱布尼茨公式,而是求导数的莱布尼茨公式 15年的这个可用莱布尼茨公式, 16年的这个可用逐次求导~ 平面曲线的弧长公式 导数的应用 &lt;2011.1&gt; 等价无穷小量的定义 泰勒公式,展开到3 阶 C &lt;2011.2&gt; B 其实不用这么复杂,选择题 用特殊值法,设f(x)=x,一分钟搞定 &lt;2011.3&gt; 驻点即导数为0的点 &lt;2011.4&gt; 二阶常系数非齐次微分方程 考点1,怎样设特解 考点2, 线性微分方程解的叠加原理 考研一般都不太会只考一个考点,都会两个甚至更多合在一起考 &lt;2011.5&gt; 二元函数取极值的充分条件 A 不难 积分区间相同,被积函数不同–&gt;转化为被积函数的大小 lnx 单调递增,也就变成了比较sinx,cotx,cosx在(0,π/4)上的大小关系 很显然这个区间内,cosx&gt;sinx, 而cotx = cosx/sinx, 且该区间内0&lt;sinx&lt;1, 所以cotx&gt;cosx, B 太简单了 这个题稍微难一些~ 七种未定式 极限计算题,1的无穷次方类型 这种类型的未定式有两种做法: 取对数 凑重要极限 1的无穷次方型大题小题都非常爱出 可以不洛必达法则,而用等价无穷小替换 微分方程 一阶非齐次线性微分方程的求解~ 如果记住公式,也非常简单 利用定积分来求弧长 记住公式,又是送分题 secx=1/cosx, 它的积分看来还是得记住…不是特别好临场推导 曲线方程 由极坐标 给出 也不难 无界区间上的反常积分,热门考点 二重积分的计算 数二每年都考,要么大题,要么小题.2011还考过一道11分的大题.. 也就是说11年考了二重积分相关的考了15 通过配方,确定圆的圆心和半径 这种题一定要画图 与圆有关,不妨考虑极坐标系 y轴在极坐标系对应π/2 将二重积分写为二次积分 渐近线的定义及求法 在选择/填空中 出现频率很高 三步走: 沿着正无穷和负无穷方向的水平渐近线重合了,都是y=1 沿着同一个方向如果有了水平渐近线,就不会再有斜渐近线 C 算渐近线非常基础,应该要满分 导数的计算 123常数项是零次方项。任何除0以外的数的0次方都是1 。如3的0次方是1，-1的0次方也是1，0的0次方没有意义。注：-1⁰=-1，但是(-1)⁰=1。前者是用0减1求零次方，后者是对整个-1求零次方。 10！=1 其实特殊值法就可以,令n=1,可排除B,D n=2,可排除C 所以A 计算乘积形式的函数,在零点处的导数 概念题 难度系数0.283, 区分度0.99…考研中低于0.3的都被称为区分度不好的题目, 考的好的坏的做的都不好 可以特值啊 令an=1,有界;而sn显然无界,可以排除A,C 靠直觉盲猜就是B 定积分比较大小,有两种类型: 积分区间相同 被积函数相同 这道题是被积函数一样, 积分区间不同 其实不用这么麻烦.. 画图可知,I2&lt;I1&lt;I3 D 很简单啊… D 即区域D的面积的相反数 看成X型区域 更简单的做法: 割补之后, 就成了求这个矩形的面积的负值 基础的计算题,隐函数的导数计算..一定要保证计算速度和正确率 对方程两边关于x求导 因为让求二阶导在x=0处的值,所以继续求导 并不难 求极限,n项和式的极限,利用定积分来求 利用定积分的定义来求极限,非常常规的题型,经常考到 凑定积分的定义,再来算这个定积分 利用链式法则来计算偏导数,基础题 送分题 微分方程的求解题 先整理一下 把y作为自变量,x作为因变量 一阶微分方程有了一个初始条件后,其解是唯一的 题面比较新颖~y作为自变量,x作为因变量 基础题…曲率的计算公式,只要知道公式,题目没有任何难度 等价替换 C 极限的计算 求隐函数的导数,即对方程两端同时关于x求导 狄利克雷函数,处处不连续,自然也就处处不可导 平行考题,都是利用导数的定义来求极限~ 间断点 间断点的类型 x=π为f(x)的跳跃间断点, 但f(x)显然可积,故而F(x)是连续的,所以A,B全错了 如果f(x)有跳跃间断点,则F(x)在跳跃间断点处不可导 C 只要了解变限积分的性质,这道题非常容易做出来~ 补充: 反常积分 0的0次幂及负数次幂无意义 换元: D A 比较简单…送分题 二重积分 B 二期知道I4&lt;0, I1,I3=0 轮换对称性: 求极限 1的无穷次方型 未定式, 这种类型的处理办法有两个: 取对数,再求极限 凑重要极限 在此用凑重要极限的方法: 求最后这个极限时,不一定用泰勒公式,用洛必达一样很简单 法二: 定积分的几何应用,用来求平面图形的面积 其实不用关心图形长啥样 记住公式,会非常简单…记不住,就没法做了… 封闭曲线围成的图形面积~ 由参数方程确定的函数的求导 法线方程的计算 同一点处法线与切线相互垂直,即其斜率的乘积为-1 线性微分方程解的结构 带条件,确定C1,C2的值 利用解的结构,来求方程的解 平行考题 从15年开始,一年简单一年难..16年很难,17年简单,18年又难 无穷小量阶的比较…老朋友了 B 等价无穷小量替换 C 特殊值法:比如f(x)=x²,则g(x)计算可得为x 排除A,C 凹凸曲线的性质 D 极限运算, 在加减法里,是不能随便用等价无穷小量替换的! 但乘除是可以的 利用泰勒公式,展开到3阶. 或者用 洛必达法则(0/0型) 也可以一开始就洛必达,但计算量可能很大,可以试试 有界闭区域上连续函数的性质,以及取极值的结论 A 有理函数的反常积分,用配方法变形,用arctanx的导数=xxx 1 奇函数在x=0处的值为0,这一点是奇函数的隐藏条件! 知道这点就很简单了~ 隐函数全微分的计算,即偏导数的计算,基础题 方法1: 对方程两端分别对x,对y求偏导数,然后带进全微分即可~ 方法2: 隐函数存在定理,直接微分算全微分 用方法二: 这种题是送分题,一定要计算正确 阿基米德螺线 极坐标系与直角坐标系的转换. 切线的斜率 阿基米德螺线与对数螺线: 对数螺线在各种变化下可以保持形状不变~非常好的性质 鹦鹉螺就是对数螺线 雅各布.伯努利,非常喜欢对数螺线,要求墓碑上刻上,并且写一句话 “纵使改变,依然如我”, 但工匠不太懂或者偷懒,刻成了阿基米德螺线 伯努利双纽线,对数螺线,伯努利微分方程,伯努利概形,伯努利大数定律 约翰.伯努利自己发现的法则卖给了洛必达..他有个儿子叫丹尼尔.伯努利,这三个是伯努利家族最著名的 记住公式就是送分题 算这个极限时,要把x看作常量~ 1的无穷次方型,凑重要极限,或取对数 &lt;2015.5&gt; 还行,不难 &lt;2015.6&gt; 主要考察直角坐标系与极坐标系之间的转化,利用极坐标变换公式直接推导即可 在极坐标系下,x=cosθ, y=sinθ 不要忘记这个r 将二重积分,写成直角坐标系下的二次积分,或极坐标系下的二次积分,或者它们之间的相互转换,是数二中很喜欢的问题 比较简单 计算二元函数的全微分 &lt;2016.1&gt; 这一年数二平均分只有60分 无穷小量的比较 等价无穷小替换~ &lt;2016.2&gt; 连续,就要求左极限=右极限=这一点的函数值 &lt;2016.3&gt; 反常积分的敛散性 &lt;2016.4&gt; 驻点 即导数为0的点 &lt;2016.5&gt; 画图即可 A 不用这么正式 &lt;2016.6&gt; 非常简单的一道多元微分计算题 送分题 &lt;2016.9&gt; 渐近线的计算~ 分别求出k,b y=kx+b即斜渐近线方程 不难,斜渐近线经常考.送分题 &lt;2016.10&gt; 利用定积分的定义来求极限~ 和2012年的类似 分部积分法凑微分, 反对幂指三,所以把sinx放到后面 &lt;2016.11&gt; 不难 一阶非齐次方程的两个特解之差,为其对应其次方程的解.利用这点就可以求出p(x) 知道这一点就是送分题 &lt;2016.12&gt; 高阶导数的计算: 逐次求导,归纳 莱布尼兹公式 &lt;2016.13&gt; 导数的应用 复合函数求导(链式法则) &lt;2017.1&gt; 一个函数在某点连续的充要条件是它在该点左右都连续 A 使用了一个无穷小量替换无穷小量比阶,即 1-cosx~1/2x² 送分题 &lt;2017.2&gt; 又是送分题 画图一目了然~ y=x²-1即满足条件 B 凹曲线的性质,即任何弦都在其上方,由图易知 &lt;2017.3&gt; 数列极限的概念 举特例,设{Xn}为xxx A: 令{Xn}为(π+1/n),对于sinxn,收敛(在n-&gt;无穷时,等于特定值),但对于xn,n-&gt;无穷时,为π!=0 或者为nπ, 对于sinxn,n趋于无穷时sinxn=0,而当n趋于无穷时nπ也趋于无穷 B/C: 令Xn恒等于-1 &lt;2017.4&gt; 二阶常系数非齐次线性微分方程 可以直接设特解的只有两种形式: 解的叠加原理 &lt;2017.5&gt; 送分题 D &lt;2017.6&gt; 理解了含义,也是送分题 定积分的物理意义 &lt;2017.9&gt; 求斜渐近线~ 爱考 &lt;2017.10&gt; 基础题,由参数方程确定的函数求导 求由参数方程确定的二阶导, 这两步一定要记住: &lt;2017.11&gt; 基础题,反常积分的计算 分部积分法(反对幂指三)算积分, 洛必达法则 求极限 &lt;2017.12&gt; 求原函数 全微分 告诉了我们f(x,y)关于x的偏导数,关于y的偏导数 &lt;2017.13&gt; tanx/x的定积分非常不好求~ 交换积分次序~ 交换二次积分的积分次序,是个相对比较难的地方.什么时候交换呢?按给定的次序算,算不出来时~ 怎么换呢?先把原二次积分的积分区域先找到,然后改写,写成一个新的二次积分..需要准确写出边界的曲线 一般出二次积分的题,都是要考虑交换积分次序~ &lt;2018.1&gt; 又是较难的一年 极限中未知参数的确定 1的无穷次方型 未定式, 凑重要极限/或取对数再算 两个重要极限: 算极限时用到了e的x次方的泰勒公式,写到二阶即可 第一题就不好做 B &lt;2018.2&gt; 分段函数在分界点处 可不可导,根据导数的定义来判断 A:看上去分段,实际上可以写成一个统一的表达式,很显然xsinx在整个实轴上都是可导的.在0处自然也可导~ B: 左右导数都存在且相等. C: 偶函数,即为cosx D:等价无穷小替换1-cos狗 ~ 1/2狗² &lt;2018.3&gt; D 分段函数的连续性 &lt;2018.4&gt; 利用导数,来分析函数性质 D 做法较多,画图最简单 也可用排除法~ &lt;2018.5&gt; 比较定积分的大小~ 积分区间相同,被积函数不同 被积函数相同,积分区间不同 &lt;2018.6&gt; 二次积分的计算题~ &lt;2018.9&gt; 求极限 拉格朗日中值定理的结论, 夹逼准则 &lt;2018.10&gt; 曲线拐点及切线方程的计算~ 因为lnx的定义域需要是x&gt;0,故而舍掉x=-1 y=4x-3 &lt;2018.11&gt; 反常积分的计算题~ 被积函数为有理分式,且分母可以分解 不能先拆算计算, &lt;2018.12&gt; 由参数方程确定的曲线的曲率, 第n次出现了~ 星形线,2016年也出现过~ 这样就成了一道 隐函数求导的题目 &lt;2018.13&gt; 隐函数的偏导数的计算 对x求偏导 &lt;2019.1&gt; 直接看出答案 无穷小量比阶 C 不知道链接里的结论,就得用泰勒公式,展开到三阶.. &lt;2019.2&gt; 拐点,即二阶导数为0的点 现在只能排除C/D,还要利用是否该点两侧二阶导是否变号,来甄别A/B B &lt;2019.3&gt; 反常积分,判断敛散性 &lt;2019.4&gt; 二阶常系数线性微分方程的解 &lt;2019.5&gt; 二重积分的题 积分区域相同,被积函数不同. 可转化为比较被积函数的大小~ 当 0&lt;狗&lt;π/2时, 有 sin狗&lt;狗 1-cos狗 &lt; sin狗 或者画图~ &lt;2019.6&gt; 又需要用到泰勒公式(其实就数一明确考) 曲率相等,只能推出两个函数在该点的二阶导的绝对值相等..曲率只反映弯曲程度,不能反映凹凸性~ 即 由曲率相等,推不出二阶导相等~ &lt;2019.9&gt; 基础的极限计算题,1的无穷次方的型未定式,可以 凑重要极限, 先取对数,再来求极限 对数恒等式: &lt;2019.10&gt; 算切线方程的截距,要先知道切线方程,就要知道切线斜率,也就是要算一个由参数方程确定的函数的导数 摆线~知道形状对做题有所帮助 只需要求一阶导,很简单了… &lt;2019.11&gt; 基础题 多元复合函数 &lt;2019.12&gt; 曲线弧长的计算 弧长公式为: 根号下(1+tan²x) = secx &lt;2019.13&gt; 分部积分,或者交换积分次序~ 负号不能漏 &lt;2020.1&gt; 这年的随便看看,正常不会这么难 基础题,无穷小量比阶 无穷小量比阶 &lt;2020.2&gt; 间断点 间断点的类型 C &lt;2020.3&gt; 定积分的计算 变量代换 &lt;2020.4&gt; 高阶导数的计算~ 逐次求导,归纳 莱布尼茨公式(适用于乘积形式的函数) (还可以用高阶泰勒级数) 莱布尼茨公式: 这肯定不是最好的办法… 莱布尼茨公式的使用 &lt;2020.5&gt; 要逐个判断… 二重极限和累次极限… 聚点不用管 三种记法都可以~ &lt;2020.6&gt; 看到 导数&gt;函数,可以敏锐的想起 用e的2x次方 也可以正面硬刚,但这不该是选择题的解法.. &lt;2020.9&gt; 基本计算题,由参数方程确定的函数求导~ &lt;2020.10&gt; 基本计算题,交换积分次序~ 这几个都是交换次序的 &lt;2020.11&gt; 计算全微分. 也是基础题 &lt;2020.12&gt; 定积分的物理应用,考的不多,上次考是2011年(做功问题) 这次是压强问题 &lt;2020.13&gt; 微分方程与反常积分的综合应用 法一: 更简单一些的办法 法二: 更自然的做法","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"二叉树的五条性质","date":"2015-11-16T14:03:26.000Z","path":"2015/11/16/二叉树的五条性质/","text":"“二叉树中的度“是指树中最大的结点度，叶子结点是终端结点，是度为 0 的结点。 二叉树的度是指树中所有结点的度数的最大值。二叉树的度小于等于2，因为二叉树的定义要求二叉树中任意结点的度数（结点的分支数）小于等于2 ，并且两个子树有左右之分，顺序不可颠倒。 叶子结点就是度为0的结点，也就是没有子结点的结点叶子。如n0表示度为0的结点数，n1表示度为1的结点，n2表示度为2的结点数。在二叉树中：n0=n2+1；N=n0+n1+n2（N是总结点）。 叶子结点计算方法： 例：一棵树度为4，其中度为1，2，3，4的结点个数分别为4，2，1，1，则这棵树的叶子节点个数为多少？ 解：因为任一棵树中，结点总数=度数*该度数对应的结点数+1，所以： n0+4+2+1+1 = （0n0 + 14 + 22 + 31 + 4*1）+1 则：n0=8 其中：n0表示叶子结点。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"如何协助编译器生成高效代码","date":"2015-11-16T12:23:15.000Z","path":"2015/11/16/如何协助编译器生成高效代码/","text":"软件优化至关重要，软件优化一般有哪些方法？ 1）高级设计。选择适合的算法和数据结构。2）基本编码原则。避免限制优化的因素，这样编译器就能产生高效的代码。●消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率●消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。3）低级优化。结构化代码以利用硬件功能。●展开循环，降低开销，并且使进一步的优化成为可能。●通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。●用功能性的风格重写条件操作，使得编译采用条件数据传送。 https://blog.csdn.net/Longstar_L/article/details/109136262","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"一条指令的执行过程","date":"2015-11-16T12:08:39.000Z","path":"2015/11/16/一条指令的执行过程/","text":"流水线是怎样提高性能的，会遇到什么问题，解决方法是什么。 （1）指令执行基本分为取指，译码，执行，访存，写回，根据寄存器的特性可以不断的将一个时序过程分解成若干个子过程。 （2）多条指令重叠进行操作，每个过程都能有效的与其他子进程同时进行。这样可以提高处理器处理效率，争取在一个时钟周期中完成一条指令。 会遇到的问题：包括数据冒险和控制冒险。 处理数据冒险时： （1）使用暂停来避免冒险 ，也就是让指令停留在译码阶段，知道其源操作数的指令通过了写回阶段，具体做法是在执行阶段插入一个气泡。 （2）使用转发来避免数据冒险直接将结果值从流水线阶段传到更早点阶段 （3）加载和使用数据冒险 而处理控制冒险时，在执行阶段中，指令会改变条件码。我们在下一个周期往译码和处理阶段中插入气泡，并同时取出跳转指令后面的指令，这样就能取消（有时也称为指令排除）那两条预存错误的指令。 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;srcqid=4748329612927156777&amp;tn=50000022_hao_pg&amp;wd=%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%AD%A5%E9%AA%A4&amp;oq=%25E6%258C%2587%25E4%25BB%25A4%25E6%2589%25A7%25E8%25A1%258C%25E7%259A%2584%25E4%25B8%2589%25E4%25B8%25AA%25E6%25AD%25A5%25E9%25AA%25A4&amp;rsv_pq=f9a996740003e008&amp;rsv_t=8df1wRqQOxGTXZ6t%2BgYkqNr1lIoI6a0wYzwHULruwzq3PqafZUTOWaJgRN6CG59Eme%2FbowES&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=3&amp;rsv_sug1=3&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=t&amp;inputT=481&amp;rsv_sug4=978 https://blog.csdn.net/fuhanghang/article/details/83421254 https://www.cnblogs.com/fengliu-/p/9269387.html https://www.jianshu.com/p/85d6e4678fe9 https://blog.csdn.net/zxjoke/article/details/105435824 https://www.cnblogs.com/lfri/p/10053598.html https://cs.nju.edu.cn/swang/CompArchOrg_13F/slides/lecture25.pdf","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"考研数学二大纲","date":"2015-11-11T02:37:04.000Z","path":"2015/11/11/考研数学二大纲/","text":"考查内容相比数学一,数学三少很多,较好复习~ 高等数学 一、函数、极限、连续 考试内容 函数的概念及表示法、函数的有界性、单调性、周期性和奇偶性复合函数、反函数、分段函数和隐函数基本初等函数的性质及其图形初等函数函数关系的建立 数列极限与函数极限的定义及其性质函数的左极限与右极限无穷小量和无穷大量的概念及其关系无穷小量的性质及无穷小量的比较极限的四则运算极限存在的两个准则：单调有界准则和夹逼准则两个重要极限： 函数连续的概念函数间断点的类型初等函数的连续性闭区间上连续函数的性质 考试要求 1.理解函数的概念，掌握函数的表示法，并会建立应用问题的函数关系. 2.了解函数的有界性、单调性、周期性和奇偶性. 3.理解复合函数及分段函数的概念，了解反函数及隐函数的概念. 4.掌握基本初等函数的性质及其图形，了解初等函数的概念. 5.理解极限的概念，理解函数左极限与右极限的概念以及函数极限存在与左极限、右极限之间的关系. 6.掌握极限的性质及四则运算法则. 7.掌握极限存在的两个准则，并会利用它们求极限，掌握利用两个重要极限求极限的方法. 8.理解无穷小量、无穷大量的概念，掌握无穷小量的比较方法，会用等价无穷小量求极限. 9.理解函数连续性的概念(含左连续与右连续)，会判别函数间断点的类型. 10.了解连续函数的性质和初等函数的连续性，理解闭区间上连续函数的性质(有界性、最大值和最小值定理、介值定理)，并会应用这些性质. 二、一元函数微分学 考试内容 导数和微分的概念、导数的几何意义和物理意义、函数的可导性与连续性之间的关系、平面曲线的切线和法线、导数和微分的四则运算、基本初等函数的导数、复合函数、反函数、隐函数以及参数方程所确定的函数的微分法、高阶导数、一阶微分形式的不变性、微分中值定理洛必达(L’Hospital)法则、函数单调性的判别、函数的极值、函数图形的凹凸性、拐点及渐近线、函数图形的描绘、函数的最大值与最小值、弧微分、曲率的概念、曲率圆与曲率半径 考试要求 1.理解导数和微分的概念，理解导数与微分的关系，理解导数的几何意义，会求平面曲线的切线方程和法线方程，了解导数的物理意义，会用导数描述一些物理量，理解函数的可导性与连续性之间的关系. 2.掌握导数的四则运算法则和复合函数的求导法则，掌握基本初等函数的导数公式.了解微分的四则运算法则和一阶微分形式的不变性，会求函数的微分. 3.了解高阶导数的概念，会求简单函数的高阶导数. 4.会求分段函数的导数，会求隐函数和由参数方程所确定的函数以及反函数的导数. 5.理解并会用罗尔(Rolle)定理、拉格朗日(Lagrange)中值定理和泰勒(Taylor)定理，了解并会用柯西(Cauchy)中值定理. 6.掌握用洛必达法则求未定式极限的方法. 7.理解函数的极值概念，掌握用导数判断函数的单调性和求函数极值的方法，掌握函数最大值和最小值的求法及其应用. 了解曲率、曲率圆和曲率半径的概念，会计算曲率和曲率半径. 三、一元函数积分学 考试内容 原函数和不定积分的概念、不定积分的基本性质、基本积分公式、定积分的概念和基本性质、定积分中值定理、积分上限的函数及其导数、牛顿-莱布尼茨(Newton-Leibniz)公式、不定积分和定积分的换元积分法与分部积分法、有理函数、三角函数的有理式和简单无理函数的积分、反常(广义)积分、定积分的应用 考试要求 1.理解原函数的概念，理解不定积分和定积分的概念. 2.掌握不定积分的基本公式，掌握不定积分和定积分的性质及定积分中值定理，掌握换元积分法与分部积分法. 3.会求有理函数、三角函数有理式和简单无理函数的积分. 4.理解积分上限的函数，会求它的导数，掌握牛顿一莱布尼茨公式. 5.了解反常积分的概念，会计算反常积分. 6.掌握用定积分表达和计算一些几何量与物理量(平面图形的面积、平面曲线的弧长、旋转体的体积及侧面积、平行截面面积为已知的立体体积、功、引力、压力、质心、形心等)及函数的平均值. 四、多元函数微积分学 考试内容 多元函数的概念、二元函数的几何意义、二元函数的极限与连续的概念、有界闭区域上二元连续函数的性质、多元函数的偏导数和全微分、多元复合函数、隐函数的求导法、二阶偏导数、多元函数的极值和条件极值、最大值和最小值、二重积分的概念、基本性质和计算 考试要求 1.了解多元函数的概念，了解二元函数的几何意义. 2.了解二元函数的极限与连续的概念，了解有界闭区域上二元连续函数的性质.3.了解多元函数偏导数与全微分的概念，会求多元复合函数一阶、二阶偏导数，会求全微分，了解隐函数存在定理，会求多元隐函数的偏导数. 4.了解多元函数极值和条件极值的概念，掌握多元函数极值存在的必要条件，了解二元函数极值存在的充分条件，会求二元函数的极值，会用拉格朗日乘数法求条件极值，会求简单多元函数的最大值和最小值，并会解决一些简单的应用问题. 5.了解二重积分的概念与基本性质，掌握二重积分的计算方法(直角坐标、极坐标). 五、常微分方程 考试内容 常微分方程的基本概念、变量可分离的微分、齐次微分方程、一阶线性微分方程、可降阶的高阶微分方程、线性微分方程解的性质及解的结构定理、二阶常系数齐次线性微分方程、高于二阶的某些常系数齐次线性微分方程、简单的二阶常系数非齐次线性微分方程、微分方程的简单应用 考试要求 1.了解微分方程及其阶、解、通解、初始条件和特解等概念. 2.掌握变量可分离的微分方程及一阶线性微分方程的解法，会解齐次微分方程. 4.理解二阶线性微分方程解的性质及解的结构定理. 5.掌握二阶常系数齐次线性微分方程的解法，并会解某些高于二阶的常系数齐次线性微分方程. 6.会解自由项为多项式、指数函数、正弦函数、余弦函数以及它们的和与积的二阶常系数非齐次线性微分方程. 7.会用微分方程解决一些简单的应用问题. 线性代数 一、行列式 考试内容 行列式的概念和基本性质、行列式按行(列)展开定理 考试要求 1.了解行列式的概念，掌握行列式的性质. 2.会应用行列式的性质和行列式按行(列)展开定理计算行列式. 二、矩阵 考试内容 矩阵的概念、矩阵的线性运算、矩阵的乘法、方阵的幂、方阵乘积的行列式、矩阵的转置、逆矩阵的概念和性质、矩阵可逆的充分必要条件、伴随矩阵、矩阵的初等变换、初等矩阵、矩阵的秩、矩阵的等价、分块矩阵及其运算 考试要求 1.理解矩阵的概念，了解单位矩阵、数量矩阵、对角矩阵、三角矩阵、对称矩阵、反对称矩阵和正交矩阵以及它们的性质. 2.掌握矩阵的线性运算、乘法、转置以及它们的运算规律，了解方阵的幂与方阵乘积的行列式的性质. 3.理解逆矩阵的概念，掌握逆矩阵的性质以及矩阵可逆的充分必要条件.理解伴随矩阵的概念，会用伴随矩阵求逆矩阵. 4.了解矩阵初等变换的概念，了解初等矩阵的性质和矩阵等价的概念，理解矩阵的秩的概念，掌握用初等变换求矩阵的秩和逆矩阵的方法. 5.了解分块矩阵及其运算. 三、向量 考试内容 向量的概念、向量的线性组合和线性表示、向量组的线性相关与线性无关、向量组的极大线性无关组、等价向量组、向量组的秩、向量组的秩与矩阵的秩之间的关系、向量的内积、线性无关向量组的的正交规范化方法 考试要求 1.理解n维向量、向量的线性组合与线性表示的概念. 2.理解向量组线性相关、线性无关的概念，掌握向量组线性相关、线性无关的有关性质及判别法. 3.了解向量组的极大线性无关组和向量组的秩的概念，会求向量组的极大线性无关组及秩. 4.了解向量组等价的概念，了解矩阵的秩与其行(列)向量组的秩的关系. 5.了解内积的概念，掌握线性无关向量组正交规范化的施密特(Schmidt)方法. 四、线性方程组 考试内容 线性方程组的克拉默(Cramer)法则、齐次线性方程组有非零解的充分必要条件、非齐次线性方程组有解的充分必要条件、线性方程组解的性质和解的结构、齐次线性方程组的基础解系和通解、非齐次线性方程组的通解 考试要求 1.会用克拉默法则. 2.理解齐次线性方程组有非零解的充分必要条件及非齐次线性方程组有解的充分必要条件. 3.理解齐次线性方程组的基础解系及通解的概念，掌握齐次线性方程组基础解系和通解的求法. 4.理解非齐次线性方程组的解的结构及通解的概念. 5.会用初等行变换求解线性方程组 五、矩阵的特征值及特征向量 考试内容 矩阵的特征值和特征向量的概念，性质、相似矩阵的概念及性质、矩阵可相似对角化的充分必要条件、相似对角矩阵、实对称矩阵的特征值、特征向量及其相似对角矩阵 考试要求 1.理解矩阵的特征值和特征向量的概念及性质，会求矩阵特征值和特征向量. 2.理解相似矩阵的概念、性质及矩阵可相似对角化的充分必要条件，会将矩阵化为相似对角矩阵. 3.理解实对称矩阵的特征值和特征向量的性质. 六、二次型 考试内容 二次型及其矩阵表示、合同变换与合同矩阵、二次型的秩、惯性定理、二次型的标准形和规范形、用正交变换和配方法化二次型为标准形、二次型及其矩阵的正定性 考试要求 1.了解二次型的概念，会用矩阵形式表示二次型，了解合同变换与合同矩阵的概念. 2.了解二次型的秩的概念，了解二次型的标准形、规范形等概念，了解惯性定理，会用正交变换和配方法化二次型为标准形. 3.理解正定二次型、正定矩阵的概念，并掌握其判别法.","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"最小生成树算法","date":"2015-11-10T09:15:58.000Z","path":"2015/11/10/最小生成树算法/","text":"最小生成树(Minimum Spanning Tree,MST) 是图论中的内容, 是指一副 连通加权无向图 中一棵 权值最小 的生成树。最小生成树其实是最小权重生成树的简称 主要有两大算法,较容易理解的克鲁斯卡尔算法(Kruskal)和普里姆算法(Prim) 可参考最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示 Kruskal算法 Kruskal算法 Kruskal算法java版 Prim算法 Prim算法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"线代大题汇总","date":"2015-11-10T01:55:14.000Z","path":"2015/11/10/线代大题汇总/","text":"&lt;2016.22&gt; &lt;2016.23&gt; &lt;2017.22&gt; &lt;2017.23&gt; &lt;2018.22&gt; 难度系数为0.248,难分率不高… 需要考虑线性变换是否可逆~ &lt;2018.23&gt; &lt;2019.22&gt; &lt;2019.23&gt; &lt;2020.22&gt; &lt;2020.23&gt;","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"软件工程基础","date":"2015-11-08T17:02:39.000Z","path":"2015/11/09/软件工程基础/","text":"大纲如下: 复旦大学2021年硕士研究生招生考试自命题科目考试大纲 科目代码961 科目名称 软件工程专业基础综合 一、考试内容范围第一部分数据结构与算法 一、栈（Stack）、队列（Queue）和向量（Vector）内容：单链表,双向链表,环形链表,带哨兵节点的链表; 栈的基本概念和性质,栈ADT及其顺序,链接实现(爽哥注:即数组实现与链表实现);栈的应用;栈与递归; 队列的基本概念和性质,队列ADT及其顺序,链接实现;队列的应用; 向量基本概念和性质;向量ADT及其数组、链接实现; 二、树内容：树的基本概念和术语;树的前序,中序,后序,层次序遍历; 二叉树及其性质;普通树与二叉树的转换; 树的存储结构,标准形式;完全树(complete tree)的数组形式存储; 树的应用,Huffman树的定义与应用; 三、查找(search)内容：查找的基本概念; 对线性关系结构的查找,顺序查找,二分查找;Hash查找法,常见的Hash函数(直接定址法,随机数法),hash冲突的概念,解决冲突的方法(开散列方法/拉链法,闭散列方法/开址定址法),二次聚集现象; BST树定义,性质,ADT及其实现,BST树查找,插入,删除算法; 平衡树(AVL)的定义,性质,ADT及其实现,平衡树查找,插入算法,平衡因子的概念; 优先队列与堆,堆的定义,堆的生成,调整算法;范围查询; 四、排序内容：排序基本概念;插入排序,希尔排序,选择排序,快速排序,合并排序,基数排序等排序算法基本思想,算法代码及基本的时间复杂度分析 五、图内容：图的基本概念;图的存储结构,邻接矩阵,邻接表; 图的遍历,广度度优先遍历和深度优先遍历; 最小生成树基本概念,Prim算法,Kruskal算法; 最短路径问题,广度优先遍历算法,Dijkstra算法,Floyd算法;拓扑排序 第二部分软件工程 一、软件过程 软件过程的概念；经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）；过程评估与CMM/CMMI的基本概念；敏捷宣言与敏捷过程的特点。 二、软件需求 软件需求的概念；需求工程的基本过程；分层数据流模型；用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）；数据模型建模及其UML表达（类图）；行为模型建模及其UML表达（状态机图）。 三、软件设计与构造 软件体系结构及体系结构风格的概念；设计模式的概念；模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）；软件重构的概念；软件体系结构的UML建模（包图、类图、构件图、顺序图、部署图）；接口的概念；面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）；内聚与耦合的概念、常见的内聚和耦合类型。 四、软件测试 软件测试及测试用例的概念；单元测试、集成测试、确认测试、系统测试、回归测试的概念；调试的概念、调试与测试的关系；测试覆盖度的概念；白盒测试、黑盒测试的概念；代码圈复杂度的计算方法；白盒测试中的基本路径测试方法；黑盒测试中的等价类划分方法。 第三部分计算机系统基础 一、处理器体系结构内容：CPU中的时序电路、单周期处理器的设计、流水线处理器的基本原理、Data Hazard的处理、流水线设计中的其他问题 二、优化程序性能内容：优化程序性能、优化编译器的能力和局限性以及表示程序性能、特定体系结构或应用特性的性能优化、限制因素、确认和消除性能瓶颈 三、存储器结构及虚拟存储器内容：局部性、存储器层级结构、计算机高速缓存器原理、高速缓存对性能的影响、地址空间、虚拟存储器、虚拟内存的管理、翻译和映射、TLB、动态存储器分配和垃圾收集 四、链接、进程及并发编程内容：静态链接、目标文件、符号和符号表、重定位和加载、动态链接库、异常和进程、进程控制和信号、进程间的通信、进程间信号量的控制、信号量，各种并发编程模式，共享变量和线程同步，其他并行问题 五、系统级I/O和网络编程内容：I/O相关概念、文件及文件操作、共享文件、网络编程、客户端-服务器模型，套接字接口、HTTP请求，Web服务器 二、试卷结构试卷总分：150分 第一部分数据结构与算法（总分：60分）考试题型：问答、分析、编程 第二部分软件工程（总分：60分）考试题型：概念问答题、实践案例题 第三部分计算机系统基础（总分：30分）考试题型：问答、分析、编程 三、参考书目 作者书名 出版社 出版时间版次 备注MarkAllen Weiss数据结构与算法分析–Java语言描述（英文版·第3版）机械工业出版社2013年3月第三版 Roger Pressman软件工程：实践者的研究方法（英文版，第7版）机械工业出版社2010年10月第七版 RandalBryant;DavidO’Halloran深 入 理 解 计 算 机 系 统（英文版·第二版）机械工业出版社2011年1月第二版 以下内容参考自复旦大学961考纲解析 参考: 初试经验分享，961专业课126分！","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"线代基础问题汇总","date":"2015-11-08T09:58:50.000Z","path":"2015/11/08/线代基础问题汇总/","text":"&lt;2011.8&gt; 对矩阵A作初等行变换,等价于对矩阵左乘相应的初等矩阵 常见初等矩阵的逆 123第一种初等矩阵Tij的逆是自己Tij第二种初等矩阵Ti(m)的逆是Ti(1/m)第三种初等矩阵Tij(m)的逆是Tij(-m) D C 可以用特殊值法 &lt;2011.8&gt; A的秩与其伴随矩阵的秩之间的关系 D C 这个行列式的计算,可以装模作样算一算,因为选项有提示~ &lt;2012.7&gt; 线性相关 &lt;2012.8&gt; B 思路二:矩阵的相似对角化 可以使用两种方法来做 &lt;2012.14&gt; 注意求三阶行列式的两种办法: 直接计算——对角线法 任何一行或一列展开——代数余子式(这时候要注意正负符号,根据下标奇偶决定) &lt;2013.7&gt; 可逆,则满秩 &lt;2013.8&gt; 两矩阵相似,一定具有相同的特征多项式和特征值;但反之不一定成立. 但是 对于实对称矩阵,也可以推回去,完美 &lt;2013.14&gt; 还漏了一条,即 |A的转置| = |A| &lt;2014.7&gt; 比较简单,必须满分~ B D &lt;2014.8&gt; 向量组线性无关 , 一个向量组是线性无关的,其中一定不含零向量 充分性可考虑特例法,举反例 A 如果线性无关,至少里面不能存在0向量..存在0向量的一定线性相关 C 因为（α1-α2）+（α2-α3）+（α3-α1）=0，所以α1-α2，α2-α3，α3-α1线性相关 A此题应该可以特殊值法 &lt;2014.14&gt; 二次型的负惯性指数,是其标准型中的负系数的个数 标准型和规范型都是只含平方项的二次型标准型的系数可以为任意常数，而规范型的系数只专能为属-1，0，1同一实对称矩阵A化为的标准型可以有多个，但规范型是唯一的，标准型可以经过正交变换化为规范型（在规范型书写时，系数为1的平方项放在前面，系数为-1的平方项放在后面，系数为0的在最后，所以规范型唯一） 配方 正交变换法 当年这题考生普遍认为很难,难度系数0.22 其实不难啊 &lt;2015.7&gt; n元线性方程组Ax=b有无穷多解的充分必要条件为: r(A)=r(A,b) &lt; n A为三阶范德蒙德行列式,有较快的计算方法 其实很简单~ &lt;2015.8&gt; 方法1,利用初等行列变换 方法2,利用特征值 &lt;2015.14&gt; (实在不行就特殊值) 行列式=特征值之乘积 发现α也是B的特征向量 直接特殊值,简单粗暴~","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"向量组的秩","date":"2015-11-08T04:28:45.000Z","path":"2015/11/08/向量组的秩/","text":"向量组的秩 表示一个向量组的极大线性无关组所含向量的个数 由向量组的秩可以引出矩阵的秩的定义 而 矩阵的秩在线性代数中有着很大的应用，可以用于判断逆矩阵和线性方程组解的计算等方面。","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"华莱士公式","date":"2015-11-02T02:23:46.000Z","path":"2015/11/02/华莱士公式/","text":"比较高级,但记住在遇到相关问题时,可以极为大量简化计算~ 也称”点火公式”,”火箭发射公式”(源自张宇..) 宇哥讲“点火公式”（华里士公式） 推导 华莱士公式的证明","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"分部积分法","date":"2015-11-01T12:49:07.000Z","path":"2015/11/01/分部积分法/","text":"使用分部积分法前,一般要先 凑微分 按照 反对幂指三的次序,将这部分 置于前面作为u,剩下的部分作为v (越往右,越放在右边) 带你学分部积分 还有一种表格法,再算多项式积分时(即x乘以什么,或(x的三次方加x的平方)再乘以什么什么,必须带一个多项式,因为这样才能求导算到0), 非常直观,正式题目里不能用.. 分部积分～表格法简单又快捷 故而,有多项式的,用表格法; 没有多项式的,老老实实用分部积分 有时还要用到 换元积分法 研究生考试出大题的话,一般要 先凑积分,再分部积分,往往分部积分计算过程中,还需要用到换元积分 考研数学,第11题填空题,经常考这类问题.可能是反常积分~","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"矩阵的等价，合同和相似","date":"2015-11-01T11:35:52.000Z","path":"2015/11/01/矩阵的等价，合同和相似/","text":"矩阵之间就这三种关系 等价(又称为相抵) 矩阵合同问题","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"二重积分","date":"2015-11-01T10:10:12.000Z","path":"2015/11/01/二重积分/","text":"根据被积函数,选择是用直角坐标系,还是换 用极坐标系 极坐标下积分计算图形面积 分部积分法","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"七种未定式","date":"2015-11-01T06:10:13.000Z","path":"2015/11/01/七种未定式/","text":"七种未定式 对于后面三种类型: 两个重要极限及相关推导","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"斜渐近线","date":"2015-11-01T05:42:56.000Z","path":"2015/11/01/斜渐近线/","text":"一般斜渐近线最多有两条,即趋于正无穷时和负无穷时. 也可能没有","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"无穷小量比阶","date":"2015-11-01T04:02:43.000Z","path":"2015/11/01/无穷小量比阶/","text":"积分变限函数 先求导,将变限积分化为初等函数 一般还会配合使用 洛必达法则,即分子分母分别求导 等价无穷小替换: 两个等价无穷小的差,一定是一个更高阶的无穷小!","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"极值点、驻点和拐点","date":"2015-10-31T15:52:07.000Z","path":"2015/10/31/极值点、驻点和拐点/","text":"驻点、拐点与极值点精讲 驻点: 导数为0的点驻点（Stationary Point）又称为平稳点、稳定点或临界点（Critical Point） 极值点 (extreme point) 驻点和不可导点,称为函数的可疑极值点 驻点不一定都是极值点,如果倒数在此处两侧没有变号,则不会出现极值点(单调性没变) 极值点也不一定都是驻点 证明充分条件二 如下: 凹凸性与拐点在某点凹凸性相反,则该点即为拐点(inflection point) 如果f(x)二阶可导,且(x0,f(x0))为曲线f(x)的拐点,则必有x0处的二阶导数为-(定义如此) 某点处二阶导数不存在,但该点也有可能是其拐点(如正好在该点断开了,但两侧凹凸性变了)","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"判别极值的三个充分条件","date":"2015-10-31T15:25:49.000Z","path":"2015/10/31/判别极值的三个充分条件/","text":"属于一元函数微分学的几何应用 二阶导数的几何意义 如果一个函数f(x)在某个区间I上有f’’(x)（即二阶导数）&gt;0恒成立，那么在区间I上f(x)的图象上的任意两点连出的一条线段，这两点之间的函数图象都在该线段的下方，反之在该线段的上方。 ​​​​","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"多元函数的极值","date":"2015-10-31T09:11:35.000Z","path":"2015/10/31/多元函数的极值/","text":"无条件极值 求解步骤为: 对x求偏导,对y求偏导, 令它们为0,得出x,y的值; 算二阶导,并分别记为A,B,C (1)当B的平方-AC&lt;0,才有极值点:若A&gt;0,为极小值点;若A&lt;0,为极大值点;(2)当B的平方-AC&gt;0,不是极值点;(3)当B的平方-AC=0,可能是,也可能不是极值点 无条件极值 的套路如此.这类问题并不困难 条件极值 拉格朗日乘数法, 构造辅助函数 例: 将长为2m的铁丝分成三段,依次围成圆,正方形和正三角形,三个图形的面积之和是否存在最小值?若存在,求出最小值.","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"sql各关键字执行顺序","date":"2015-10-29T16:35:23.000Z","path":"2015/10/30/sql各关键字执行顺序/","text":"概述: 写的顺序： select … from… where…. group by… having… order by.. limit [offset,] (rows) 执行顺序： from… where…group by… having…. select … order by… limit 12345678910（8）SELECT（9）DISTINCT &lt;select_list&gt;（1）FROM &lt;left_table&gt;（3）&lt;join_type&gt; JOIN &lt;right_table&gt;（2）ON &lt;join_condition&gt;（4）WHERE &lt;where_condition&gt;（5）GROUP BY &lt;grout_by_list&gt;（6）WITH &#123;CUTE|ROLLUP&#125;（7）HAVING &lt;having_condition&gt;（10）ORDER BY &lt;order_by_list&gt;（11）LIMIT &lt;limit_number&gt; 每步关键字执行的结果都会形成一个虚表，编号大的关键字执行的动作都是在编号小的关键字执行结果所得的虚表上进行（或者说编号大的关键字处理的对象是编号小的关键执行过后得到的虚表），以此类推。 sql执行顺序 详解: 123456789101112(1)from (3) join (2) on (4) where (5)group by(开始使用select中的别名，后面的语句中都可以使用)(6) avg,sum.... (7)having (8) select (9) distinct (10) order by(11) limit 从这个顺序中不难发现，所有的 查询语句都是从from开始执行，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。 第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表） 第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级=’x’的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级=’x’ 因为它的过滤是最终的。 第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. 第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 第十二步：应用top选项。此时才返回结果给请求者即用户。 mysql的执行顺序详解: 一个完成的SELECT语句包含可选的几个子句, SELECT语句的定义如下： 1&lt;SELECT clause&gt; [&lt;FROM clause&gt;] [&lt;WHERE clause&gt;] [&lt;GROUP BY clause&gt;] [&lt;HAVING clause&gt;] [&lt;ORDER BY clause&gt;] [&lt;LIMIT clause&gt;] SELECT子句是必选的，其它子句如WHERE子句、GROUP BY子句等是可选的。 一个SELECT语句中，子句的顺序是固定的。例如GROUP BY子句不会位于WHERE子句的前面。 SELECT语句中子句的执行顺序与SELECT语句中子句的输入顺序是不一样的，所以并不是从SELECT子句开始执行的，而是按照下面的顺序执行： 开始-&gt;FROM子句-&gt;WHERE子句-&gt;GROUP BY子句-&gt;HAVING子句-&gt;ORDER BY子句-&gt;SELECT子句-&gt;LIMIT子句-&gt;最终结果 每个子句执行后都会产生一个中间结果，供接下来的子句使用，如果不存在某个子句，就跳过 对比了一下，mysql和sql执行顺序基本是一样的, 标准顺序的 SQL 语句为: select 考生姓名, max(总成绩) as max总成绩 from tb_Grade where 考生姓名 is not null group by 考生姓名 having max(总成绩) &gt; 600 order by max总成绩 在上面的示例中 SQL 语句的执行顺序如下: (1). 首先执行 FROM 子句, 从 tb_Grade 表组装数据源的数据 (2). 执行 WHERE 子句, 筛选 tb_Grade 表中所有数据不为 NULL 的数据 (3). 执行 GROUP BY 子句, 把 tb_Grade 表按 “学生姓名” 列进行分组(注：这一步开始才可以使用select中的别名，他返回的是一个游标，而不是一个表，所以在where中不可以使用select中的别名，而having却可以使用，感谢网友 zyt1369 提出这个问题) (4). 计算 max() 聚集函数, 按 “总成绩” 求出总成绩中最大的一些数值 (5). 执行 HAVING 子句, 筛选课程的总成绩大于 600 分的. (7). 执行 ORDER BY 子句, 把最后的结果按 “Max 成绩” 进行排序. 以上内容来自网络.","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"矩阵的乘法","date":"2015-10-29T02:07:18.000Z","path":"2015/10/29/矩阵的乘法/","text":"图片来自; 矩阵乘法理解 微软数学求解器（Microsoft Math Solver）","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"泰勒公式","date":"2015-10-27T17:39:29.000Z","path":"2015/10/28/泰勒公式/","text":"图片来自: 给我俩分钟，还你泰勒公式记忆一片天空 图片来自: 一个方法/八个泰勒公式/永久记忆 本质: 计算机无法对三角函数，对数函数，直接计算，而泰勒公式可以将所有的复杂函数转化为简单的加减乘除的近似运算，从而利用计算机进行计算，减少了人工计算的复杂度，进而在物理，化学，材料，航天等工程领域广泛应用 常见的泰勒公式及其记忆:","tags":[{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"好用的git reset命令","date":"2015-10-25T12:43:28.000Z","path":"2015/10/25/好用的git-reset命令/","text":"简介 可以将Git分为三个区域: 1、工作区（working directry）: 即项目目录 2、暂缓区（stage/index.也称暂存区,缓存区等） : 使用git add命令将文件从工作区加入暂存区,只有该区域的文件才可以被commit 3、(提交的)历史记录区（history/HEAD） : 指向最近一次commit Git的所有操作就是对这三个区域的状态（或内容）的操作。 git reset 有3个可选参数: –soft,–mixed(默认),–hard,三者用法如下: –hard 会清空工作目录和暂存区的改动,而 –soft则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。 如果不加参数，那么默认使用 –mixed 参数: 保留工作目录，并清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。 所以, 想要三个区域全部变为某次commit之后的状态,可以先git log, 获取那次commit的id,然后git reset --hard commitId 想将git add的文件从暂缓区移除, 使用git reset HEAD,git reset (--mixed) HEAD xxx文件,则是将某个文件从暂缓区移除 实际使用: 撤销本次的 git add git reset HEAD 撤销本次及上次的git add git reset HEAD^ 撤销最近一次git commit(提交历史区/暂存区/工作区全部移除) git reset –hard HEAD^ 撤销最近两次git commit(提交历史区/暂存区/工作区全部移除) 一定程度上, 使用HEAD^可以省去git log查看具体commitId的操作 参考 &amp;&amp; 值得一看git的reset和checkout的区别 Git Reset 三种模式 Git 三大区域的操作分析","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"app解包&重新签名","date":"2015-10-12T02:21:46.000Z","path":"2015/10/12/app解包-重新签名/","text":"https://www.google.com/search?q=%E8%A7%A3%E5%8C%85%E9%87%8D%E7%AD%BE%E5%90%8D&amp;newwindow=1&amp;biw=1920&amp;bih=1060&amp;sxsrf=AOaemvIAgawyKzCrFyEEKZ0p1WwSsqt9VA%3A1634005224481&amp;ei=6PBkYdP5HL-M4-EPkfimuAk&amp;ved=0ahUKEwjTjd3n58PzAhU_xjgGHRG8CZcQ4dUDCA4&amp;uact=5&amp;oq=%E8%A7%A3%E5%8C%85%E9%87%8D%E7%AD%BE%E5%90%8D&amp;gs_lcp=Cgdnd3Mtd2l6EAMyBwgjELADECdKBAhBGAFQ0G5Yo3NgkXZoAXAAeACAAYEEiAHPD5IBBTQtMi4ymAEAoAEByAEBwAEB&amp;sclient=gws-wiz","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"go:embed","date":"2015-10-08T08:39:12.000Z","path":"2015/10/08/go-embed/","text":"//go:embed 入门","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"git reflog命令","date":"2015-10-01T13:12:57.000Z","path":"2015/10/01/git-reflog命令/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"MySQL关闭查询缓存","date":"2015-09-29T13:59:33.000Z","path":"2015/09/29/MySQL关闭查询缓存/","text":"根据 局部性原理, MySQL Query Cache (QC) 会缓存select 查询( 默认开启),以减少下次查询需用的时间. 但如果对表进行 INSERT, UPDATE, DELETE, TRUNCATE, ALTER TABLE, DROP TABLE, DROP DATABASE 等操作, 则之前的缓存会失效且删除. 这样一定程度上也会影响数据库的性能, 故而对一些频繁变动的表, 开启缓存并不好; 另外在测试数据库性能时,也需要关闭QC,以避免其对测试结果的影响. QC 有较大的弊端,无胜于有, 故而在MySQL 8.0中,移除了查询缓存的相关功能: The query cache is deprecated as of MySQL 5.7.20, and is removed in MySQL 8.0. 现在缓存更多是做在应用逻辑层, 或使用一些NoSQL型数据库如Redis 8.0以下的查询缓存相关设置,可参考: MySQL关闭查询缓存（QC）的两种方法 select version(); 18.0.21 show variables like “%cache%” 更多可参考: MySQL查询缓存简介 MySQL 8.0: Retiring Support for the Query Cache 8.10.3.3 查询缓存配置 Mysql高级之查询缓存(Mysql8.0已废弃此功能)","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"rebase与merge异同与最佳使用场景","date":"2015-09-26T11:26:19.000Z","path":"2015/09/26/rebase与merge异同与最佳使用场景/","text":"使用 rebase 所有人就好像都在同一条直线上开发一样，git log --graph 看着很舒服; 而使用 merge 的log看起来就很乱，有各种分叉，当要合入的分支会特别多时，更是如此. 下游分支更新上游分支内容的时候使用 rebase；上游分支合并下游分支内容的时候使用 merge； 实战篇 参见: git:亲测体验rebase与merge 参考: 从一个问题认识git rebase和git merge 逃不掉的merge和rebase 深入浅出Git——merge和rebase","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"常见路由协议","date":"2015-09-19T12:27:50.000Z","path":"2015/09/19/常见路由协议/","text":"目前常用路由协议的AD优先级为： 直连路由&gt; 静态路由 &gt; EBGP &gt; EIGRP &gt; OSPF &gt; ISIS &gt; RIP &gt; IBGP IGRP、EIGRP是思科设计的内部网关协议，RIP和OSPF是通用的内部网关协议 BGP机房和普通的IDC机房其实机柜和用电等成本基本上是一样的，贵的原因在于带宽，BGP是揉合了各大主流线路带宽(一般是电信+联通+移动)可以满足不同运营商的用户的访问体验；而传统IDC一般都是单线路带宽，例如电信IDC，电信的用户访问体验就很好，联通和移动访问就要差一些 更多阅读： 常见的路由协议(RIP、OSPF、ISIS、BGP 23 张图详解路由协议：计算机网络的核心技术 既然已经有了BGP为什么还需要OSPF与RIP这一类IGP？ BGP: 一个更像应用程序的路由协议 由 Facebook 事故引发的 BGP 工具探索","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"快捷键汇总","date":"2015-09-18T14:47:23.000Z","path":"2015/09/18/快捷键汇总/","text":"Chrome中: 复制出一个和当前页面完全一样的新Tab: 有好多种办法,不需要安装扩展就可实现的是: Ctrl+L,选中当前地址,再Option+Enter 打开控制台: option＋command＋i mac系统使用chrome浏览器快捷键总结 安装Vimium插件后: 1234567891011121314151617向下/上/左/右移动 j/k/h/l向下/上跳动 d/u回到顶/尾部 gg/G窗口打开模式 本窗口/新窗口 f/F查找历史记录+书签 o/O关闭/恢复标签 x/X查找书签 b/B（当前/新窗口打开）选择左/右标签 J/K搜索剪贴板关键字 在当前/新窗口 p/P跳转到当前url上一级/最高级 gu/gU创建/查看标签页 t/T将焦点聚集在第一个输入框 gi (2gi就是第二个输入框)刷新 r新标签中打开多个链接 &lt;a-f&gt; 即：alt+f开/关静音 &lt;a-m&gt;即：alt+m固定标签栏 &lt;a-p&gt;即 alt+p上一个标签 ^ vimium完全教程，各类技巧大全 chrome 获取剪贴板内容_Chrome插件Vimium使用教程 JetBrains中: 竖直选中: option+shift VSCode中: 复制上一行: option+shift+↑","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"写sql时的一些tips","date":"2015-09-14T12:10:52.000Z","path":"2015/09/14/写sql时的一些tips/","text":"分页查询问题 user表 有300多万行记录,现在想要获取从 第300万起之后的50行,如果直接 1select * from `user` limit 3000000,50 需用时近4s 而改用如下写法: 1select * from `user` where id &gt;= (SELECT id FROM `user` WHERE id LIMIT 3000000,1) LIMIT 50 用时1s 这是许多年前,小菜鸟 爽哥第一次出去面试,遇到的一个还算比较有质量的问题 limit与offset limit x, y 表示跳过前x条记录,读取其后的y条数据,等效于 limit y offset x left join之后记录数 是变多还是变少? left join就是以当前from的这张表为主表,右表对其进行关联;right join是当前from的这张表为辅表,对右表进行关联 两张表关联,如果关联的字段是一对一,不可能出现记录变多的情况;如果关联字段是一对多, left join后一定会变多. 以left join为例，如果左表（即主表）和右表为一对多，则关联得到的新表的记录数一定多于左表即主表；如果是多对一，则得到的新表的记录数与左表即主表记录数相同（仅指初步关联后的，尚且不带where条件的原始新表） 另:join等同于inner join,mysql中没有full join sql解冻必看 数据库大神之路 group by一个字段和多个字段,哪个得到的记录数多? group by a字段, 即以a字段为纲,把那些和a字段相同的行记录 合为一行; group by a,b字段, 是以(a,b)为纲,把那些和(a,b)相同的行记录 合为一行; 参见上图,当年研究的明明白白. 举例加深印象: 有一张姓名和户籍表,共10000行记录. 因为有重名现象存在,执行group by name,即把姓名相同的人合为一行, 所以得到的结果,肯定小于等于10000,也许只有7000; 而如果是多个字段, 如group by name,province,则是把姓名和省份都相同的合为一行,相当于条件更苛刻了(比如有两个张三,一个山东,一个广西,那这两条无法合为一行了),能合为一行的数量变少,故而得到的记录数比1这种条件会多,会大于等于7000,小于等于10000. 峥嵘岁月 借助count(1), 可将按某个字段group by后的分组的数量, 由高到低进行排序 如有 一张订单表如下, 现想获取每个用户的下单数量,并按由高到低排序 1select user_id as \"用户\",count(1) as \"下单次数\" from ali_order group by user_id order by count(1) desc 含有group by子句的sql, select 后面可以出现各种聚合函数(如count,sum,max,min,avg等); 如果select后出现了表中的某个字段,只能是group by后面的字段,其他字段会报错 以下内容供参考: 主键(或唯一索引键/唯一的联合索引键)重复相关 参见 有则更新,无则插入 带条件的update语句 有这样一个场景, 用户参加活动,可以获得抽奖机会.可以多次参与活动获得抽奖机会,但总数量不能超过设定的一个值(如为33,该值运营可能会调整). 用户A参加活动,获得了一些抽奖机会. 之后该用户又参加活动,又获取了一些抽奖机会(如为20),现需要更新其抽奖机会字段. 在不获取其现有抽奖机会的前提下,可以一条update语句实现更新,且不会超过总数 123update 表 set drawCnt = case when (drawCnt + 20 &gt; 33) then 33 else drawCnt + 20 endwhere uid = xxxxx 一些不讲求性能的场景可以这样写. 但大多数情况下,在项目中应避免复杂sql union和union all 用于两张或多张表之间的(竖直)连接. union all只是简单的拼在一起,如果两张表数据没啥重复,用union all性能更好 union在此基础上,还会进行排序,去重等操作; 只要几张表字段数一致且数据类型一致即可,不需要名字也一样, 后面的表会用第一张表的字段名 有如下三张表: 如果执行 123456789select * from a union all select * from bunion all select * from c 结果如下: 而如果用union,则 可见在使用union进行多表连接时,对于同一张表中 完全相同的字段(如表b中的典韦),不会进行去重, 对于不同表中 值 完全相同的字段,则会进行去重(如表b和表c中的赵云,最后只保留了表b中的记录). 根据时间段分组 按小时分组,统计每个小时段内的数据 1234567891011SELECT count(123), date_format(ctime,'%Y-%m-%d %H') as timeFROM t1 WHERE xxx = 3 GROUP BY time ORDER BY count(123) DESC 参考: MYSQL按时间段(按小时分组)分组查询当天小时内数据 有用的时间计算 计算两个日期之间相隔的天数 SELECT DATEDIFF(&quot;2021-06-09&quot;,&quot;2020-08-11&quot;) AS &quot;进站时长&quot; 计算某个日期 过一些天后 的日期 SELECT DATE_ADD(&quot;2020-08-11&quot;,INTERVAL 1000 day) AS &quot;进站1000天&quot;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"好用的git stash命令","date":"2015-09-03T13:09:10.000Z","path":"2015/09/03/好用的git-stash命令/","text":"1234567stash 英[stæʃ] 美[stæʃ]v. 存放; 贮藏; 隐藏;n. 一批贮藏物;[例句]She has a fortune stashed away in various bank accounts.她有一大笔钱存在几个不同的银行账户下。 当多人协作,在同一分支上进行开发. 同事push了我需要用到的新代码,我本地有未提交的(如还是半成品无法通过编译)的代码,直接git pull会失败,此时可用git stash进行”暂存” 1. git stash save “save message” : 执行存储时，添加备注，方便查找，只用 git stash 也可以，但查找时不方便识别。 2. git stash list ： 列表查看所有的”stash” 3. git stash show ： 显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加 stash@{$num}，如第二个 git stash show stash@{1} 4. git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show stash@{$num} -p ，如第二个：git stash show stash@{1} -p 5. git stash apply : 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} 6. git stash pop ： 恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，如应用并删除第二个：git stash pop stash@{1} 7. git stash drop stash@{$num} ： 丢弃stash@{$num}存储，从列表中删除这个存储 8. git stash clear ： 删除所有缓存的stash 参考: git stash 用法总结和注意点","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Charles使用不完全指南","date":"2015-09-03T10:08:49.000Z","path":"2015/09/03/Charles使用不完全指南/","text":"1. 安装证书 Help-&gt;SSL Proxying 依次 Install Charles Root Certificate Charles Root Certificate in iOS Simulators 在钥匙串中改为 始终信任 2. 是否设置为本机代理 勾选macOS Proxy,则Charles将被设置为系统代理,可以抓取到本机的各种网络请求 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而Charles是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或直接将代理服务器设置成 127.0.0.1:8888 亦可达到相同效果。 但其实大多数情况下,查看Web端的接口,都直接使用浏览器的控制台. 使用Charles抓包手机上的请求. 为防止在抓包时收到本机网络的干扰, 一般不要勾选. 3. 抓取手机数据 如下: 然后: 手机和电脑连接同一Wifi 获取本机的ip地址 在手机上选择对应的Wifi-&gt;HTTP代理-&gt;手动,服务器写电脑的ip,端口填8888 设置好后,Charles会弹出手机请求连接的确认,点击Allow,手机和电脑就建立了连接 4. 抓取手机上的Https请求 1.需要安装证书,模拟中间人攻击 在第一步中, Install Charles Root Certificate,已经安装了Charles的CA证书,而后在手机连接电脑代理情况下,按照弹窗提示,手机浏览器访问chls.pro/ssl,进行手机端证书下载 2.手机安装证书这一步常出问题,以iPhone为例,在设置中搜索证书,进行信任设置 3.回到Charles,进行SSL Proxy设置: 点击Add,在Host中填*,即抓所有的https的包(也可以填写指定ip或域名,只抓取该Host下的https请求), Port填写443. 这是我曾经抓取过的部分https请求: 5. 高阶功能 使用Mapping,修改手机app实际访问的接口地址 参见: charles修改访问的地址 大神之路 (!!!好好好大神之路)charles神奇技能 哈哈哈哈 这是我曾经修改的部分https请求: 哈哈哈哈 参考: charles使用笔记","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"有则更新,无则插入","date":"2015-08-29T11:59:13.000Z","path":"2015/08/29/有则更新-无则插入/","text":"1234567891011121314151617181920212223SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for a-- ----------------------------DROP TABLE IF EXISTS `a`;CREATE TABLE `a` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT '', `book` varchar(255) DEFAULT NULL, `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of a-- ----------------------------BEGIN;INSERT INTO `a` VALUES (1, '宋江', '&lt;水浒传&gt;', '2010-06-10 15:15:05');INSERT INTO `a` VALUES (2, '卢俊义', '&lt;水浒传&gt;', '2012-05-19 10:59:35');INSERT INTO `a` VALUES (3, '吴用', '&lt;水浒传&gt;', '2018-12-06 19:59:53');COMMIT; 有则更新，无则插入 12insert into t1 (字段1,字段2,字段3) values (值1,值2,值3) on duplicate key update 字段2=values(字段2) 存在重复主键(或唯一索引/联合索引)则更新，不存在则插入。 即 如果在更新某条数据时, 发现要更新的某个(或联合索引下的多个)字段,已经和现有数据的对应字段重复,且该字段需要唯一,则只更新 on duplicate key update后的字段为本条sql想要更新的value.; 否则就正常insert插入. 如: 1234INSERT INTO a ( id, `name`, book, create_time )VALUES ( 1, '晁盖', '四大名著之一', '2020-10-10 21:15:05' ) on duplicate key update book = values(book); 此时不会报 1062 - Duplicate entry ‘1’ for key ‘PRIMARY’, Time: 0.036000s, 而可以成功更新update后的book字段: 如果想更新多个字段,则可用逗号分隔, 1234INSERT INTO a ( id, `name`, book, create_time )VALUES ( 1, '晁盖', '古典小说', '2020-10-10 21:15:05' ) on duplicate key update book = values(book),`name` = values(`name`) 该方法更常用于 某张表的几个字段建了一个联合索引, 如 成绩表的学生姓名和学科两个字段,合在一起必须唯一. 现在又拿到一批成绩单,可以用这种方式.当”姓名-学科”已存在时,只更新成绩字段;否则正常写入一条新纪录. 查看某张表的索引信息show index from t1 有则替换 1REPLACE INTO a(id,`name`,book) VALUES(2,\"玉麒麟\",\"施耐庵作品\") 使用Replace插入一条记录时, 如果不存在重复的唯一键, 则Replace和Insert功能相同; 如有重复的唯一键, Replace会使用新记录的值来替换原来的记录值; 即REPLACE将Delete和Insert合二为一,形成一个原子操作;这样就可以不必考虑在同时使用Delete和Insert时添加事务等复杂操作. 在使用Replace时, 表中必须有唯一索引, 且这个索引所在的字段不能允许空值,否则Replace就和Insert完全一样; 执行Replace后, 系统返回的是受影响的行数: 如果返回1, 说明在表中没有重复的记录(即相当于insert); 如果返回2, 说明有一条重复记录, 实际会先调用Delete删除这条记录,然后再记录用Insert来插入这条记录,故而受影响的行数为2. 有则忽略 1insert ignore into a(id,`name`,book) values(3,\"智多星\",\"农民起义小说\") 在insert后面增加ignore后,存在冲突 唯一键 时,将会忽略本次更新,直接不会进行写入. 参考: insert…on duplicate key update语法详解 mysql使用笔记：有则更新，无则插入","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"崖山凭唁","date":"2015-08-23T15:32:54.000Z","path":"2015/08/23/崖山凭吊/","text":"目的地，是42公里外的一处古战场遗迹。古代上规模的大战，几乎都发生于长江以北，在这样一个偏远的南隅一角，不会有什么大规模的决战。确实，与长平/官渡/赤壁/肥水之战比，它的规模实在太小太小（真正军人只有几万）。然而，它对整个汉民族的意义和影响，却非其上任何一场战役可比。 长平之战赵国40万生力损失殆尽，秦统天下，只剩时间问题。官渡之战，河南的曹操战胜河北的袁绍，一统黄河流域。赤壁之战，另两方是自称兵圣后裔的江东孙氏，和自称大汉皇叔的刘备集团。孰胜孰败，不过是汉人群体换了个临时头目，归根结底，只是汉民族内部矛盾。 孙刘曹操操劳终生，螳螂背后有黄雀，到头却不过是为司马家族做嫁衣。秦皇汉武时即有的北方异族边患，因为长城，因为李牧和李广们，终不教其过阴山。西晋王朝的八王之乱，终于给了窥伺几百年却终不得进的胡人绝好机会。 虽传统王权所在的北方陷落，但王谢们这样的北方大族举家南迁，终究还是在江南拉扯起半壁江山，为汉人保留了一脉纯净的文化血脉。 与赤壁大战稍有不同的是肥水之战，这两场同样发生于长江上的对垒，都堪称那个时代整个地球上人类最大规模的械斗。肥水之战的一方，是志得意满的异族精英苻坚。如此战东晋败，则汉人失去纯净文化血脉，要提早近1000年。 然而然而，风声鹤唳草木皆兵，八公山下的胜利，让拥兵百万投鞭断流的异族英雄狼狈而逃。千年来，中原和江南的汉人，打跑了匈奴，同化了突厥契丹，却终究败给了13世纪举世无匹的蒙古铁骑。 崖山战后，南宋流亡朝廷灭亡，汉人的天下在历史上第一次完全沦陷于外族。有人说“崖山之后无中国，明亡之后无华夏”。（确切地说不该是明亡之后，是李自成的大顺朝灭亡之后）。以今天56个民族同属中华大家庭的角度看，自然是有些言之过甚。但以我自身，一个孔孟邹鲁之地生养的新时期汉族读书人，却只得不情愿又无可奈何地接受。 据由破窗理论推论，第一次失去纯洁被侵占后，第二次第三次的抗争意义，也就没那么大了。因此，虽然同样有叛徒内奸，但与同样属灭国级大战的山海关战役比，我没看到吴三桂这样的特大号汉奸，而看到了汉人知识分子的抗争，看到了威武不屈的文天祥和陆秀夫： “天地有正气，杂然赋流形。下则为河岳，上则为日星。于人曰浩然，沛乎塞苍冥。皇路当清夷，含和吐明庭。时穷节乃见，一一垂丹青。在齐太史简，在晋董狐笔。在秦张良椎，在汉苏武节。为严将军头，为嵇侍中血。为张睢阳齿，为颜常山舌。或为辽东帽，清操厉冰雪。或为出师表，鬼神泣壮烈。或为渡江楫，慷慨吞胡羯。或为击贼笏，逆竖头破裂。是气所磅礴，凛烈万古存。当其贯日月，生死安足论。地维赖以立，天柱赖以尊。三纲实系命，道义为之根。嗟予遘阳九，隶也实不力。楚囚缨其冠，传车送穷北。鼎镬甘如饴，求之不可得。阴房阗鬼火，春院閟天黑。牛骥同一皂，鸡栖凤凰食。一朝蒙雾露，分作沟中瘠。如此再寒暑，百沴自辟易。嗟哉沮洳场，为我安乐国。岂有他缪巧，阴阳不能贼。顾此耿耿在，仰视浮云白。悠悠我心悲，苍天曷有极。哲人日已远，典刑在夙昔。风檐展书读，古道照颜色。”700多年前这场让小小的官冲村和偌大的神州同样翻山倒海的海战，在736年后，已然难觅当年踪迹。潮平两岸阔，风静縠纹平。旧事江河远去，10万具浮尸，无数的断桅残杆，都随滚滚而来的江水，消逝于历史的浩瀚天空，连一个让我找到断剑锈戟的机会都没有。中国多战场遗迹，此地偏居偏僻南中国的偏僻处，山遥路远，凭吊之人不似其他古迹那般频多。然而，比之刘禹锡杜牧王安石苏轼等人吟诵的石头城，乌江亭，赤壁，此战此地的意义，有过而绝无不及。 先人已去700余年，尸骨不存。700年后，先生在天有灵，请收下这个北方齐鲁故地辗转而来的后辈读书人，对本民族英雄无比的尊敬与无尽的景仰。 “我死后，害怕洪水滔天恶评如潮”","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"毓秀中山","date":"2015-08-18T04:40:49.000Z","path":"2015/08/18/毓秀中山/","text":"目的地，是30公里外的中山先生旧居，来中山必去的景点。中山是中国唯一一个以人名命名的地级市，这个面积并不大的珠江西侧的秀美小城处处烙刻着国父的印记。其实，中山近代还出了一位名动上海滩的名伶，民国四大美女之一。但无奈性格如同林妹妹，因陷于无端的绯闻名誉的侵害，年纪轻轻即想不开服药香消玉殒，让人无尽叹惋。再观如今娱乐圈，唯余呵呵 以广州为中心，珠江为轴，东侧是东莞，西侧对应中山，东侧再是深圳，西侧对应同为经济特区的珠海，东侧最外是特区香港，西侧最外是特区澳门。澳门面积实在太小太小，对内地经济拉动作用有限，一定程度使珠海经济体量不及深圳1/5，中山约为东莞1/2。故而经济重心该在广州以东. 骑行中途避暑休憩/在蓝天白云碧水椰林下，开启了新一天的长途奔袭。把100块的自行车蹬得飞快，呼呼生风，真个是除去铃铛不响，其他地儿都响。行至半途，看到著名的105国道即京珠高速就在眼前，这条2700公里长的国家级干道，从北京发出，经津冀鲁豫鄂赣终止于广东珠海。想起11年踩在天安门广场南面的中国公路零里程点留照一张，今番已快到由其发出的一条长长线段的终点，四年过去，感慨莫名。 躲在街巷小摊桌旁，吃着豆腐花和哈密瓜，来往车流人群如梭，远方蓝天白云一尘不染。我突然感觉像在做梦，像一个年少时躺在奶奶家爷爷的竹质躺椅上, 做过的一个有关好多年后遥遥无期的梦。 中国收音机博物馆。对上一代人而言，收音机俨然就是今天的智能手机。在那么个资讯不发达的年代，有这样一个了解世界的窗口，有这样一个神奇的 能接收看不到摸不着信号的神器，实在是比现在拥有近乎人手一部的智能手机要炫酷和有意义得多。我清楚记得&lt;大侦探福尔摩斯&gt;第一部结尾，罗伯特·唐尼对Watson说“华生，这 才是未来。”目光凝视，如炬炯炯。 孙文西路步行街沿街走廊下，数半仙摆摊掐指，点化来往路人。被其一拦下，说算一卦，想恰逢乞巧问卦姻缘吧。无奈此前银行取款不成，全身只剩一块两毛，早餐犹未解决。说明财力，让他量力而行。瞎眼半仙也是无语，不想多算，侧脸遥指西山寺，口中念叨有缘人在寺中。。沿街而行，至西山寺，缘石阶上，虽居闹市，却烟雾缭绕古木遮天。到寺中转悠一圈，在风扇下悠闲看着墙壁橱窗内一个个陌生头像，是逝者的家人为其在寺中所买的“神位”，如报纸边角豆腐块大小，满满一墙。我极速回忆，看得哪部古代破案的悬疑片，就是根据庙中的神位信息找到线索一举破案。 早在远古文明伊始前，那时的先人面对这个世界，有太多的疑惑。月亮星辰的起落，江河的洪汛，疾病与死亡…那时候没有万有引力的概念，不会想到看不见的微生物。于是，无论东方还是西方，都一样产生了神，产生了宗教。漫长的等待，无数代人平凡着地出生与死去后，有了文明之光，有了欧几里得和阿基米德，有了开普勒和伽利略，有了改变所有人世界观的牛顿…后来，人们登上了月球，消灭了天花和鼠疫。然而，我们熟知的远不只是汪洋大海的一片贝壳，但时至今日，仍有许多不解或不能解之惑。对自然，对人生，对纷繁复杂的社会，对尘世三千剪不断的愁丝… “任何事情解释到最后，都只剩数学和宗教”. 抛下这些如对夜空中浩淼星辰的追寻，此行是为找半仙算中的有缘人。微风吹拂，夹杂善男信女们花一块钱从寺旁所买劣质香火的刺鼻气味，我快速看下四遭，除了跪拜在地上念念有词的大妈，就是前来烧香拜佛的超龄剩女。长叹一声，这不要钱的卦，就是不准啊。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"2的n次方对照表","date":"2015-08-12T09:02:47.000Z","path":"2015/08/12/2的n次方对照表/","text":"2的n次方对照表2的0次方： 12的1次方： 22的2次方： 42的3次方： 82的4次方： 162的5次方： 322的6次方： 642的7次方： 1282的8次方： 2562的9次方： 5122的10次方：10242的11次方：20482的12次方：40962的13次方：81922的14次方：163842的15次方：327682的16次方：655362的17次方：1310722的18次方：2621442的19次方：5242882的20次方：10485762的21次方：20971522的22次方：41943042的23次方：83886082的24次方：167772162的25次方：335544322的26次方：671088642的27次方：1342177282的28次方：2684354562的29次方：5368709122的30次方：10737418242的31次方：21474836482的32次方：42949672962的33次方：85899345922的34次方：171798691842的35次方：343597383682的36次方：687194767362的37次方：1374389534722的38次方：2748779069442的39次方：5497558138882的40次方：10995116277762的41次方：21990232555522的42次方：43980465111042的43次方：87960930222082的44次方：175921860444162的45次方：351843720888322的46次方：703687441776642的47次方：1407374883553282的48次方：2814749767106562的49次方：5629499534213122的50次方：11258999068426242的51次方：22517998136852482的52次方：45035996273704962的53次方：90071992547409922的54次方：180143985094819842的55次方：360287970189639682的56次方：720575940379279362的57次方：1441151880758558722的58次方：2882303761517117442的59次方：5764607523034234882的60次方：11529215046068469762的61次方：23058430092136939522的62次方：46116860184273879042的63次方：92233720368547758082的64次方：18446744073709551616 另:unsigned 为“无符号”,即只能为非负数 mysql中,几种整型的区别: tinyint占1 个字节的存储空间。 如果是 unsigned, 范围是从 0 到 255 即2^8 -1。 如果区分符号可正可负, 则能表征从 -2^7 (-128) 到 2^7 - 1 (127)之间的值。 smallint占2 个字节的存储空间。 如果是 unsigned, 范围是从 0 到 65535 即2^16 -1。 如果区分符号可正可负, 则能表征从 -2^15 (-32768) 到 2^15 - 1 (32767) 之间的值。 mediumint占3 个字节的存储空间。 如果是 unsigned, 范围是从 0 到 16777215 即2^24 -1。 如果区分符号可正可负, 则能表征从 -2^23 (-8388608) 到 2^23 - 1 (8388607) 之间的值。 int占4 个字节的存储空间。 如果是 unsigned, 范围是从 0 到 4294967295 即2^32 -1。 如果区分符号可正可负, 则能表征从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 之间的值。 bigint占8 个字节的存储空间。 如果是 unsigned, 范围是从 0 到 2的64次方：18446744073709551615 即2^32 -1 。 如果区分符号可正可负, 则能表征从 -2^63 (-9,223,372,036,854,775,808) 到 2^63 - 1 (9,223,372,036,854,775,807) 之间的值。 参考: MYSQL中TINYINT、SMALLINT、MEDIUMINT,INT 和BIGINT 的区别 mysql中tinyint、smallint、int、bigint的区别","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"婺州缅怀","date":"2015-08-01T15:31:46.000Z","path":"2015/08/01/婺州缅怀/","text":"金华，又名婺州，其下义乌，永康，东阳，兰溪，武义等县市，皆有名气。 金华江，别称婺江，由义乌江（东阳江在义乌段的称谓）和武义江在市区汇合而成。如同二水三分的武汉三镇，两江也将金华城区一分为三。 通济桥，两江交汇后的婺江上第一座桥，将分居南北两岸的八一南路与八一北路连为一体。 通济桥高悬，离水面数10米。8年前的初冬，一名温州籍23岁女子，“因到金华后未找到男友，而一气之下跳江”。 8年前的那一天，一名28岁的青年军官，驻金华某部机要科副连职中尉参谋孟祥斌，陪前来探望的妻儿幼女恰从此走过。 本素昧平生，却在那一刻，被永远地改变。彼时彼刻，桥上的行人过客，只道有人落水，只知千钧一发危如累卵。 出于军人本职，28岁男子纵身跳下刺骨江中，轻生者得救，救人者身亡。而这一切，都被桥面上前来探望的妻女目睹。这样的场景，太过于残酷。 那刻，与久未谋面的丈夫千里相聚不过几天却又阴阳永隔。其妻也要轻生跳江随夫而去的冲动，像玄慈以身明法后的叶二娘，更像胡一刀死后的胡夫人。 不到3个月，即阖家欢庆的春节，举国同欢之下，鲜有人知道，这个春节，对孤女寡母是何辛酸。 2008年年初，孟祥斌入选感动中国获奖人物，透过屏幕，他的义举为多人所知。那时，我是一名初三学生，对英雄的敬仰，沸腾的满腔热血，一如今日。 “史册，尘封记忆；旧事，江河远去。凭吊，不过竹泪一滴”。 8年后，孟的女儿已有十一二岁，不会再相信他只是“睡着了”。8年，在偌大的中国，偌大的人间，有更多类似于此或更甚于此的悲情剧发生。身处缤乱纷杂的信息爆炸时代，行色匆匆，健忘的人大概多忘却甚或从来未曾记住。 对于普通人，2007.11.30这一天不论发生什么，都只是漫长3万多天并不起眼的一瞬，无论这天发生什么惊天伟岸的壮举，事不关己，也确实并不需刻意记怀。 8年后的今天，一个对于军人极其特殊的日子里，我恰在金华，来到通济桥头，桥上车水马龙，江心绿洲黄宾虹公园亭台内，依稀可见游园者纳凉。烈日炎炎，江水也失去生气，几乎断流。车鸣声伴随蝉叫，构成了这个夏日午后再寻常不过的场景。8年前那个严寒凛冽日子里发生的事情，大概只能清楚留存于死者妻女的脑海，一遍又一遍地循环放映。 我站在柳条下，极目西望。青山虽遮，绿水自流，婺江与衢江在兰溪汇成兰江，北至梅城汇新安江后称为富春江，继续北上到富阳以下即钱塘江。一条千年前挖凿的京杭运河，南北联通了赤县神州海河黄河淮河长江钱塘江五大水系。沿运河北上，过苏州，镇江，扬州，徐州，聊城，即到山东北大门德州，也正是孟的故乡。 天地悠悠，江流滚滚。山川异域，风月同天。我信步走到桥头，追思往事，昔人已去，鱼沉雁杳。孟的事迹不会为人永远记住，孟氏遗孀遗女的境况，虽未曾看到却不难想见。而我能做的，也只是对我尊敬的这位老乡，缅怀以示未曾忘记罢了。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 于2015/8/1","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"清月照郭","date":"2015-07-31T13:53:38.000Z","path":"2015/07/31/清月照郭/","text":"90公里，22分钟，从上海法租界到嘉兴南湖。 夜绕南湖，清辉照郭；塘水沦涟，与月上下。桥畔灯影，明灭林外；桥头钓客，噤声如蝇。此时独行，杂人静默。晚风拂柳，光落荷叶。万籁俱寂，唯见蝉鸣。唯此一人，爽说爽啊 江南大厦—戴梦得为老城中心，秀洲区政府对面的江南摩尔，则被认为新区的中心。但亲身骑行，可以负责任地说，这两处中心皆是名大于实，其实索然寡味，孤处皇坟山水间一洲的希尔顿酒店周遭，却是仅次于南湖公园的又一大好地方，风景极佳。","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"原码、反码、补码与位运算","date":"2015-07-25T11:04:22.000Z","path":"2015/07/25/原码、反码、补码与位运算/","text":"原码、反码、补码 计算机中都是以 补码 的形式存储数据!!! 机器只能识别0和1, 原码、反码、补码都只是二进制的某种表现形式~ 最高位为1,说明为负值 最末位为1,说明为奇数(常用来判断奇偶数) 参考自: 原码、反码和补码的相关知识点 位运算 位运算符 主要是对位的操作,故而其 操作类型为整型 直接在位(bit)上进行操作,效率和性能都非常好.. 在以前内存和处理能力（CPU）都是非常昂贵的，于是直接在位上编程就成为了处理信息的首选方式（在有些情况下也是唯一的方式）。如今，直接对位进行操作在底层系统、图像处理和密码学等领域还是至关重要的。 C#中的位运算符: 位取反,或称位异或,在C#中用~符号,而在Go中用&amp;^ 参考自: 位运算符 『GCTT 出品』Go 中的位运算 &amp; 操作符 逻辑规则: 元素均为1,结果才为1 是一个很好的将整数的指定位清零的方式 高效判断一个数字是奇数还是偶数 将数字n和值 1 使用 &amp; 做 AND 运算 : 如果结果为 1,那说明数字n是一个奇数; 反之为偶数 | 操作符 逻辑规则: 任一元素为1,结果就为1 即只有元素皆为0,结果才为0 将一个整数中的指定位置修改为 1 使用位作为配置信息 调用 procstr(“HELLO PEOPLE!”, LOWER|REV|CAP) 将会把字符串转换成小写，反转并将每个单词的首字母转换成大写。当 conf 上的第 2、3、4 位为 1 时（conf 等于 14）将会执行上述操作。在内部我们使用 if 语句来取出这些位并且根据相应的配置操作字符串。 ^ 操作符 逻辑规则: 当两数不同时,结果为1;两数相同时,结果为0 可以使用 XOR 来切换指定位上的值 使用 ^ 作为位非操作 &amp;^ 运算符 &amp;^ 运算符叫做 AND NOT。它是一个 使用 AND 后，再使用 NOT 操作的简写 逻辑规则: 123 如果第二个操作符返回 1。那么该位将会被清 0。 移位操作及其应用 更多参考: 通过位运算理解原码、反码和补码 原码、反码、补码与位运算 位运算的常见操作和题目 阮一峰-关于2的补码 读源码必备 | 万字长文！位运算面试看这篇就够了！","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"神奇的git cherry-pick命令","date":"2015-07-21T13:12:05.000Z","path":"2015/07/21/神奇的git-cherry-pick命令/","text":"git cherry-pick可以理解为”挑拣”提交，它会获取X分支的某次提交，并作为一个新的提交引入到Y分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用git cherry-pick了。 从master分支切出一个新分支dev_cui,两个分支各自向前. dev_cui分支上进行了三次提交,分别为commit1,commit2,commit3, 第一次提交: 第二次提交: 第三次提交: 现在我想把dev_cui分支的第二次提交commit2合并到master上: 三次提交的commit id为: commit1 :9dfaaab44715d1cc27bbbab638863e5076cb5a5ecommit2 :298b7346dc77387e20ac892ff5ec548813f714a3commit3 :cb0e1872c60286cf243aec01a064a4a75193a28a 切换到master分支,执行 git cherry-pick 298b7346dc77387e20ac892ff5ec548813f714a3 因为master分支没有改动,故而将dev_cui分支的某次提交合入master不会发生冲突,这是最简单的情况. 当master也发生了修改,且修改的文件,和这次要合入的commit改动的是同一个时,就会出现冲突,情况要复杂一些.","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"MySQL的四种索引类型","date":"2015-07-20T14:34:07.000Z","path":"2015/07/20/MySQL的四种索引类型/","text":"b-treehashfull-textr-tree(用的非常少) 参考: mysql中的索引类型有哪些，可以从哪些角度来看？ MySQL 索引优化 btree hash rtree (部分内容已经不准确) 备份地址","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"夜路黄石","date":"2015-06-26T15:29:57.000Z","path":"2015/06/26/夜行黄石路/","text":"&emsp;&emsp;本搭乘从 成都东 开来的D2235由武汉至黄石，但到站等待时，才被告知因四川某段水灾，列车取消…且无法改签合适车票，只得退掉重买。最后所坐的D5951，晚点约2小时，更要命的是到黄石北站而不是我下张车票的出发地黄石站。 &emsp;&emsp;车到之时已晚上11点有余，移动电源电量早已耗尽，又无安卓/WP充电线而无法及时补充。待我从车站旁的便利店给手机充电半响出来之时（这趟动车少有的座位下居然没电源），月明星疏，人迹寥寥，只有三五的士，开来询问去处。报价不菲，当下挥手道不用不用。我原心想，为G/D新修的北站地处荒僻处，老车站应在城区闹市，沿途漫走，定然灯光璀璨，沿路商铺宾馆当鳞次栉比。经武功山一役，鞋子踢石涉水已然报废，上山之时为千方百计减轻重量，又潇洒把鞋垫取出，连通雨伞一并扔了，再兼连日疾走，脚上早已吃不消。但想虽有12KM就权当夜游，支撑不住就就近找地休息。 &emsp;&emsp;然而万万没想到，黄石这个地级市的车站命名竟如此奇葩….黄石站已然在其荒僻的辖区与治下的大冶交界之处，莫说沿途繁华，算是”城乡结合部”，都是对这五个字的蔑视：少有住家，两侧多山林草地，灯光黯黯，不闻人声。只有偶然身后闷雷般车鸣阵阵，接着是一队趁月黑风高绕城而去的超载卡车，告知我不是太空的孤独旅客。 &emsp;&emsp;这次意料之外的事儿，使我无意中踏入了初中/高中都曾学过的大冶市地界（两地在争此站的归属）。至此，此次中部环行，竟然无心栽柳把当年著名的汉冶萍走了一圈。盛宣怀的十几项第一，又亲身去过或经历了一项。他在山东创造性地用以工代赈的方法疏浚的小清河，正是流经我县的重要水系之一（这比罗斯福新政修胡佛水坝，这项同样是“以工代赈”的工程早了Ｎ些年）；他创办于1895年和1896年的北洋大学和南洋公学，即今南开七里台和上海徐家汇，都亲身去过。人能如盛宣怀一生，生意成绩至此，夫复何求。 &emsp;&emsp;若在平时，导航说步行需一小时，我通常按半小时计划，因自知步履远快于常速。而这时，抛去背包中所带的一部词典和一本书，平板，移动电源这些此刻俨然好像有几十斤重的东西不说，单单就脚上的水泡和这双有不如无的敝履，也决定这次要结结实实走上三小时，每走一步，脚上水泡和鞋摩擦，痛意袭来，尤其鞋底极薄，踩到路边花生粒大小的石块，即不禁张口伸舌大叫一声。将最后的一卷卫生纸伴同身旁草片树叶放于鞋内，算作鞋垫，略有裨益。 &emsp;&emsp;这孤独的三小时却似万年！为节约宝贵电量我又不能把音量调到最大让“小苹果”和“民族风”一路相随。身乏体累，这样的行走太过索然无味，痛意袭来或简直就是煎熬。前不挨村后不靠店，秦琼当锏杨志卖刀，彼时我第一想法就是，在空旷无人的公路高歌《国际歌》罢！这不正是许多仁人志士临刑前的最后一句？然而，然而，我个连小学阅读课本上《中国少年先锋队队歌》都还依稀记得的优秀少先队员，居然除去那句“英特纳雄耐尔就一定要实现”，其他一句都想不起来… &emsp;&emsp;作为一个即将开赴大城市，或许将被同化千人一面失去特色的五线小城市半文艺青年，此刻，我还是别有风范的。黄石所辖的西塞山区，正是在古代诗词尤其唐诗中著名的西塞山所在地。“西塞山前白鹭飞，桃花流水鳜鱼肥。青箬笠，绿蓑衣，斜风细雨不须归。钓台渔父褐为裘，两两三三舴艋舟。能纵棹，惯乘流，长江白浪不曾忧。”这首诗，有一种超然物外恬静自得之感，天地悠悠，万物灵动，任你风来雨去，我自安然物外，道家＜逍遥游＞和柳宗元＜江雪＞的意象，好似融在一起如胶似漆。我甚至觉得，300年后，九死一生的苏轼在黄石北面的黄冈，谱就著名的＜定风波＞和＜前赤壁赋＞时，定然受到了前辈这首小诗的影响。 &emsp;&emsp;西塞山最有名的诗词当属高中所学的＜西塞山怀古＞。诗中前四句，概括了明代小说＜三国演义＞最后一回司马灭孙吴的著名一役，也是小说最后那首总结诗“石头城下无波涛”的出处。 &emsp;&emsp;“人世几回伤往事，山形依旧枕寒流。今逢四海为家日，故垒萧萧芦荻秋。”（必须要承认，我一直以为西塞山应该是东起镇江西到南京这一块的一座江岸小山）。 这后四句有极强的代入感，因为它不光可以从刘禹锡嘴中说出，由当世的你我任何一人说出也完全合情合理。同样生缝四海为家日，面对1800年前那个群星璀璨时代的旧迹，也许同样会唏嘘感慨，只是语言水平所限表达不出来罢！ &emsp;&emsp;这条大江，见证了三家归晋，也同样见证了天下三分。安葬小乔和鲁肃的岳阳，此行路过的赤壁，华容道所在的监利（这里面有”门道”），旧时的柴桑今日的九江，皆是时间大江冲刷，留在岸边的当时遗迹。 &emsp;&emsp;怀古之忧思并没有如滔滔大江滚滚不绝。低头看着孤零零的影子，我惊然想起：出来已有半月，这月三国杀的人物形象和皮肤包是领不到了。儿童节那天白菜价入手的曹冲，也还一次没有用过，和荀彧和华佗的逆天配合只是听人说过自己未曾玩过，等回来一定买瓶汽水，开黑好好玩几局… &emsp;&emsp;其时明月在天，清风吹叶。抬头望去，目所能及，一条宽阔公路径直向前不见归处，两侧路灯金黄闪耀消失远方。正是：雄关漫道在前，而今迈步走起。走起…","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"武功论道","date":"2015-06-17T15:20:01.000Z","path":"2015/06/17/武功论道/","text":"2015年6月中旬，在结束东莞-广州-深圳-厦门的东南环行，稍事休息后，开启了另一程同样难忘堪为经典的中部环行。第一站即是湘赣边界的”赣西明珠”萍乡。 在中国，尤是在中西部，省会城市一般都被本省其他地级市包围，其以无与伦比的经济、政治地位，对周边城市具有极强辐射作用。然而，长沙是少数几个处在两省交界处的省城(另外几个是南京,杭州,哈尔滨)。它像一轮巨大发动机，不光带动株潭，也如磁石不可避免影响了赣西小城萍乡。所以，这座距南昌远而离长沙近的”边城”湘味十足，这从诸多领域影响了这座”江南煤都”。 若不是近年爆出的萍乡芦溪籍大师王林，大多外省人对这座面积不大也不算发达的城市恐毫无印象，而实际上，无论古时还是近代，萍乡都有值得一说的履历：据考其名源于孔子，萍乡有仅次曲阜的全国第二大孔庙；这里是著名的汉冶萍之“萍”，为“汉阳造”提供源源能量。也因煤矿而生的工人阶级，革命时期，刘少奇在此领导安源路矿工人大罢工，毛在此策划秋收起义，揭开中国革命新篇章。此外，这里还是少年先锋队和红领巾的诞生地，殷殷血火，可见一斑。 除此，萍乡还具有江西海拔最高点。最高点所在的山名武功山，即旅游宣传片的的“云中草原”。 江西多名山，庐山，三清山，龙虎山，井冈山…相形之下，武功山名气不大。而此次环行，便是让我再次印证”偏向行人少去处,无限风光在险峰”。 车至萍乡站，其实，这里已处建成区不大的小城北端，而新修的高铁站，叫萍乡北站，却是不知已偏到了哪里…2元一班的1路公交车联通萍乡站与城南汽车站，火车站对面，是一个同样破旧有年代感的规模不大的汽车站。早前查询得知，从此处坐车即可到芦溪县的武功山。 晚上逛了足足一晚，在此略去不表。第二天清早，坐一辆中巴，启程前去。一段很长行程之后，司机说到了景区。我下车却疑惑，这好似荒郊野外，丝毫没见到有任何商业化存在——有了诸多景区尤其同省高度商业化的庐山之先例，先入为主，我当这里也一定是熙熙攘攘满是人声，漫山都是随处可购的商品和商店。这里的清冷让我惊讶。 不是人挤人的景点，却给户外爱好者留得了一方实在堪称天堂的圣地净土。初入景区，即是青葱一片，流水潺潺。我把随身背的行囊放在一旁，把特意挑选的2块钱一根的翠玉竹杖放在其上。双手捧一泓清流，冰凉彻骨，扑在脸上，顿觉神清气爽。 这台阶绵延云雾之中不知归处，群山孤寂，鲜有人至，除去脚步，唯有鸟鸣。 这从高山深处而来的溪流激荡冲进潭中，溅起浪花朵朵，如飞花碎玉，晶莹多芒。近处细看，这白花如微雨似的纷纷落下，如一树梨花簌簌飘荡。想起少时自读课本朱自清所描绘的梅雨潭。 站在高处回看，来路尚清晰。此时山雨未至，云雾尚小，故还可一览无余。 台阶两侧的片片竹枝，笔直修长，青翠欲滴，凌霜傲雨，清丽俊逸。身在竹簧深处，这般的环境，此般的清幽，难免不让人想起王维&lt;竹里馆&gt;，以及笑傲江湖上令狐冲结实任盈盈的洛阳东郊竹林。 宋祖英演唱的插曲&lt;天作之合&gt;，余音不绝的绝妙旋律，超脱物外的歌词，不自觉回放耳边： 莽莽苍苍兮 群山巍峨 日月光照兮 纷纭错落 丝竹共振兮 执节者歌 行云流水兮 用心无多 求大道以弭兵兮 凌万物而超脱 觅知音固难得兮 唯天地与作合 求大道以弭兵兮 凌万物而超脱 觅知音固难得兮 唯天地与作合 远行无轻担，虽只寥寥物品，但路途一远却似千斤。为减少重量把占份量的零食全部吃掉，脉动喝掉，一路舍弃了雨伞，甚至把鞋垫也扔了。然而上山虽累，但路就在脚下，目标明确，只消埋头，无需思索。 沿着铺设好的阶梯拾级而上，路上 能偶遇三五原路下来的旅人，或相视一笑擦肩而过，或暂时驻足交流几句。大多时候，我还是戴着耳机，听的节目恰恰是金庸武侠。当讲到&lt;射雕&gt;郭黄初遇洪七公一幕，所做“君子好逑”和所舞“逍遥游”，正一步步踩在青石梯上，山涧的山水匆匆一路流下，烟雾氤氲缭绕笼罩，当真是如其名有诗的意境。 这时我想，一支竹杖在手，芒鞋在脚，鸡腿在背，独在群山中，云深不知处，心意超然，洒脱不羁，不恰恰是书中神龙见首不见尾的叫花子头吗？( ´◔ ‸◔’) 此亭名为“息心”，在干道之上，云雾之间。此处海拔之高已接近峰顶，空气中弥漫着水汽。丝丝笼罩到露出的胳膊，头发和眼镜上。此前几天5小时骑行厦门岛，胳膊被曝晒。此番浸润在水汽中，痛感稍轻。 行了约莫4个小时，终于快到山顶“金顶”，此处也正是江西海拔最高处。越往高处，树越来越少最后只剩草甸，一边高齐，一望无际，这正是“云中草原”得名所在。不难料想，待至来年帐篷节，漂浮的云朵下，一朵朵七彩鲜花盛开在碧油油的草甸上，将是何美不胜收。 山顶是几处道观，武功山并不胜在人文景观，而在相当原生态原汁原味的自然风光。故而几处人文景观并不出名，也并无太多看点。 此时已是细雨绵绵，淅沥不绝。山顶更是笼罩在一片雾气之中，能见度不足10米。我披上雨衣，盖过背包手机，雨并不算大，在山顶徘徊闲逛。有三个年纪不算大的青年，也在山顶一隅蹲坐交谈。与其闲聊几句，知道他们是西面盛产爆竹的湖南醴陵人（萍乡原本也盛产爆竹，但当地政府扶植不力未成产业），原本是去钓鱼，一时兴起即来了武功山，脚上穿的还是拖鞋。 待不片刻，雾气暂消，山顶终可一览无遗。然而却无值得一陈之景，与山腰茂密的草甸比，这里更显稀疏。 这时我开始面临一个问题：是原封不动地原路返回，还是按前方依稀可见的小径而找新路下山？ 走新路的难度甚至风险不难预见，略作思索，决意另辟新路。这正是这次行程不同以往精彩所在。 山路崎岖，如上山那般的石阶是不会再有了。放眼看去，是紧贴山腰的一条小路，蜿蜒向前消失于雾气之中。 雨也越下越大，那层单薄的雨衣，渐渐不足以支撑。无奈躲在道途中一块大石头下。我孤自伫立，目光凝滞。雨哗哗下着，偶尔有斜刺而来的雨点冲向脸庞，模糊了镜片，浸润了露在外面的一切。 一袭蓝色料雨衣，一支翠绿玉竹杖，这里是远离闹市人群弥漫在雾气风雨中的群山，蓝色薄膜飘飘舞动，我扶着竹杖，望这方圆百里的雨落群山，听雨簌簌划来打在青草上，土地上，石头上。人的渺小，如同大山万千棵草和树，人的不同，在于能超脱这一切。这一刻，这情境，我又情不自禁觉得，像如洒脱的令狐冲，身负上等武功，人在深山，一履芒鞋，酒乐萧笙，别无羁绊。 雨天行险路，山道湿滑陡峭，嶙峋狭窄，不得不格外小心。而更是问题的，是临到岔道口时的踌躇纠结。 初行之时，道路比较明确，然而走着走着，却要分好多路。从山脚到山顶来时只用4小时，而寻路下山，足足用了7个小时。一来下山探寻的新路路程更远，另则也是道路崎岖险峻，更兼身陷歧路迷途，走了半天才恍然发觉有误。或有的已感觉前方无路，走过“险滩”，路却又明确躺在眼前。 渐渐的成片草甸减少，树木逐渐增多。之前山间的石头路，也成了树木从中树叶、泥土、石块堆积混合而成的小路，隐藏于林间，多不见天日。 跋山涉水，过独木桥，是的，这就是驴友们的天堂。这条小路是未经修砌的山路，漫漫长途，除去隔三差五的驴友团和山下很远处偶尔上山的居民，鲜有人来。 如此周而复始走了四五个小时，仍不见公路和人家，心中稍稍有些焦急之感。此时其实已临近山脚，虽看不到稻田民居，但抬头看，却知道已走了大半路程。但无奈就是找不到路，或者一直走下去迟迟不见海拔下降。我渐渐能偶尔看到废弃的民居，山间放养的半野的耕牛，不禁欣喜。当听到潺潺水声，看到一道水渠，更觉得曙光在前。我看到了一头耕牛在沿着水渠缓缓而行，我跟在他身后，心想跟着它总归会找到人家。但这时却也担心：渠内水势滔滔，哗哗而下，正与这耕牛行进方向相反。待到足足跟了这黑牛10多分钟后，发觉不对，怏怏掉头，随着顺势而下的水流，缓步下山。 大概五六点钟，来到了山脚，有十几座房屋，虽然破败，但总让我欣喜异常。我看到还有新挂的彩旗，门前还有三五啄食的鸡群。但挨个敲门查看，这里并没有人居住。后来得知，这里原本有人居住，后因交通不便全部搬到了山下，于是这里就叫做无人村，离山下有人住的地方还有很长段距离。 在一间土屋前，窗子已倾颓只剩一半，屋内黑黝黝却不易看清，这时我甚至想，如果今晚无法下去，就在此停宿一晚，这将更符合侠士的生活。停留片刻，我做出如下决策：继续往前走到7点，如果仍前不挨村后不着店，就折返来此，在破败的屋中停宿。 这时已徒步跋涉山间10个小时，不觉有些劳累，拿出上饶鸡腿，这被雨淋得半湿的鸡腿拿在手里别有感觉，在此情景格外有味道。 这是有标志性意义的一刻。我在山路与柏油路相交的地方，留下了这张照片。这时的时间是6：56。后来询问得知，武功山仅止这群山中的特定一座。我下山的地方，已不属武功山而叫九龙山，而我应该还足足翻越了之间的铁蹄峰。其实除去人工修葺的台阶道观，自然风光他们并无什么差异。我11小时的终点，其实是是驴友们徒步上山的起点，而他们的终点则是我的起点是——景区门口。 我走过碧润的梯田，遇到一位耕种而归的老大爷，这也是时隔数小时，我再次与人交流。听我简述遭遇并询问何处有落脚宾馆，他带我来其家中。原来老大爷年轻的的儿子儿媳正经营一家户外旅店，刚刚起步。 值得一说的是，由于对武功山开发程度的高估，随身没有带太多现金，老板也不用支付宝，更别提微信支付。搜集书包，现金刚刚够，虽然旅店价格并不算高，这样我遭遇从未料想过的情况，我确实对这个扑面而来的互联网时代高估得过头。看我为难，知我窘境这家旅店的老板爽快地说“我们也在外面过，知道出门在外，谁都不易，没事，我们不要你钱”。 听到这般古道热肠的话语，却更让我心中一沉。因为一般说出这番话的都是我，而过后往往不见哪怕是滴水涓埃的回音，或当我需要他或可是举手之劳的帮助时，结果往往失望。将心比心，他们中的很多一定是有心相报却无机会。角色转换，当我处在被帮助的一方，如以后还能明确有机会回报，那我此刻自是毫无迟疑地接受他们的好意，然而，我担心这回报会遥遥无期，这会成为我一直记挂的一笔沉甸甸的人情债。何况此前与他们素昧平生，此番萍水相逢，得遇此古道热肠，更是让我唏嘘不已。 店主邀我和他们一家愉快地进行了晚餐。桌上碗碟琳琳，吃完一位活泼的小男孩也和他漂亮文静的妹妹一起游戏着，还有一位尚处襁褓中的婴儿，他还不能参与到哥哥姐姐的活动中来。我在南方上学四年，临到毕业，终于在这里，有幸参加了一次异乡人原汁原味的家庭晚餐。 餐后交谈甚久，这是增长见闻，扩展未曾见未所知，或未曾想到的，这样的聊天是有益双方的。我荣幸认识了他们，更希望他们一家事业有成，老者健康，儿女成长。他们是最朴实的好人，这社会，我们，不该让好人吃亏。 晨起临走，我把所需的钱放在未曾拆封的一些饼干糕点中，将这个袋子送给了两位可爱的小朋友。与店主一家带着不舍点头告别，但行路匆匆，时代的步履太快太快，容不得我在此做如我心愿的太长久的停留。 我印象深刻的，是从群山而来的溪涧欢快地一路相随。还有头顶的片片白云。回头远望，不禁想到了那句“我从云中来”，用在这正是恰如其分。 近山如画墙，远山如帚长。我从云中来，回头白茫茫。惜去乃尔觉，常时自相忘。相忘岂不佳，遣此怀春伤。飘洒从何来，衣巾湿微凉。初疑风雨集，冉冉游尘黄。无归亦自可，信美非吾乡。登舟望东云，犹向帆端翔。 就在这样的环境下，我穿着破烂不堪的鞋子，且行且看。2小时左右，走到了麻田乡。这里虽然不繁华，但有小小的市集，有通往萍乡市区安源的大坝，更重要的，是这里有全乡唯一的ATM机。从此取出足量现金，去不多的几家商店疯狂扫货。在镇上小走，随后上车，挥手作别这块充满原生态纯洁的地方，挥别这段注定已是经典的旅行。 这是在车上透过车窗拍摄的江南水乡。我戴着耳机，听着的还是孔庆东讲的金庸武侠。车渐入繁华地，从城南车站坐1路公交到火车站附近曾住过的宾馆。休憩一晚，第二天清早，我又踏上了前往长沙，继而岳阳，咸宁赤壁，武汉，黄石，庐山，共青城的旅途。长沙的岳麓山橘子洲，以及那家1月后登上新闻并有幸参与其全程命名的无人书店；岳阳为老乡范仲淹而去的岳阳楼，以及楼区的小乔墓、鲁肃墓，还有正式以丐帮帮主身份前去视察丐帮总部——洞庭一隅的君山岛（正是“武功山论道，君山岛视察”）；夜绕赤壁城；重来大武汉；夜行黄石路；共青城瞻仰耀邦，做环卫大爷的三轮车一路向西去鄱阳之滨的北岸公园…….作为此次中部环形的一部分，这些都让我印象深刻。但这次环行的第一站，萍乡武功山，却注定与之不同——这里不单有我的美好回忆，还有我虽只有一面之交的朋友。有些人相交多年曾有共事，却依旧不谙其心不知其人；有的人萍水相逢虽只一面，却知其人却把评价和记忆默默留在心中。 有必要为此做一个广告，这家旅店，名叫永顺户外接待站。这是离驴友徒步的起点九龙山最近的一家。店主的人品信誉，想必也无需多说。 时隔数月，回想起当时情景，仍历历在目。这些所见之景和所想之事，超出我语言所能表达的范围。最后也只好在以最能恰如其分表述万一的《天作之合》作结： 求大道以弭兵兮 凌万物而超脱 觅知音固难得兮 唯天地与作合 求大道以弭兵兮 凌万物而超脱 觅知音固难得兮 唯天地与作合","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"使用Golang编写一个web接口,并进行并发调用","date":"2015-06-07T10:46:34.000Z","path":"2015/06/07/使用Golang编写一个web接口-并进行并发调用/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package mainimport ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"os\" \"strings\")func main() &#123; http.HandleFunc(\"/\", printPwd) //设置访问的路由 err := http.ListenAndServe(\":80\", nil) //设置监听的端口 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125;func printPwd(w http.ResponseWriter, r *http.Request) &#123; argsAll := os.Args log.Println(\"argsAll: \", argsAll) argsUseful := os.Args[1:] log.Println(\"argsUseful: \", argsUseful) path := \"\" if len(argsUseful) &gt; 0 &amp;&amp; ( argsUseful[0] == \"-root\" || argsUseful[0] == \"root\") &#123; path = \"/\" &#125; else &#123; err := r.ParseForm() //解析参数，默认是不会解析的 if err != nil &#123; panic(err) &#125; fmt.Println(r.Form) //这些信息是输出到服务器端的打印信息 fmt.Println(\"路径值为:\", r.URL.Path) allPath := r.URL.Path //fmt.Println(\"scheme\", r.URL.Scheme) //fmt.Println(r.Form[\"url_long\"]) //for k, v := range r.Form &#123; // fmt.Println(\"key:\", k) // fmt.Println(\"val:\", strings.Join(v, \"\")) //&#125; pathSli := strings.Split(allPath, \"path=\") pathSli = strings.Split(pathSli[1], \"&amp;\") path = pathSli[0] &#125; fmt.Println(\"值为:\", path) //fmt.Fprintf(w, \"Hello Wrold!\") //这个写入到w的是输出到客户端的 dirList, err := ioutil.ReadDir(path) if err != nil &#123; fmt.Fprintf(w, \"读取目录出错\") //这个写入到w的是输出到客户端的 return &#125; var fileInfos []FileInfo var item FileInfo //fmt.Println(dirList) for _, v := range dirList &#123; item.Name = v.Name() item.IsDir = v.IsDir() item.Size = v.Size() fileInfos = append(fileInfos, item) &#125; var rs Data rs.Path = path rs.Dirs = fileInfos rsJson, _ := json.Marshal(rs) fmt.Println( string(rsJson)) //这个写入到w的是输出到客户端的 fmt.Fprintf(w, string(rsJson)) //这个写入到w的是输出到客户端的&#125;type Data struct &#123; Path string `json:\"path\"` Dirs []FileInfo `json:\"dirs\"`&#125;type FileInfo struct &#123; Name string `json:\"name\"` // base name of the file IsDir bool `json:\"is_dir\"` // abbreviation for Mode().IsDir() Size int64 `json:\"size\"` // length in bytes for regular files; system-dependent for others&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package mainimport ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" \"strings\")func main() &#123; http.HandleFunc(\"/\", getDirInfo) //设置访问的路由 err := http.ListenAndServe(\":8001\", nil) //设置监听的端口 if err != nil &#123; log.Fatal(\"ListenAndServe: \", err) &#125;&#125;func getDirInfo(w http.ResponseWriter, r *http.Request) &#123; fmt.Println(\"路径值为:\", r.URL.Path) allPath := r.URL.Path pathSli := strings.Split(allPath, \"path=\") pathSli = strings.Split(pathSli[1], \"&amp;\") path := pathSli[0] fmt.Println(\"值为:\", path) path = \"/usr/local/openresty&amp;page=1\" //生成要访问的url url := \"http://127.0.0.1:80/path=\" + path fmt.Println(\"url为:\",url) //提交请求 response,_ := http.Get(url) if response.StatusCode != 200 &#123; fmt.Fprintf(w,\"请求接口出错\") return &#125; defer response.Body.Close() body,_ := ioutil.ReadAll(response.Body) //rs := string(body) s := Data2&#123;&#125; err := json.Unmarshal(body,&amp;s) if err != nil &#123; fmt.Fprintf(w,\"json转换失败\") return &#125; fmt.Println(s) var rs RsData rs.Path = path ch := make(chan int,5) for __,val := range s.Dirs &#123; rs.TotalSize = rs.TotalSize + val.Size if val.IsDir == true &#123; rs.DirCount = rs.DirCount + 1 go func(channel chan int ,dirName string,path string) &#123; path = path + \"/\" +dirName url := \"http://127.0.0.1:80/path=\" + path response,_ := http.Get(url) if response.StatusCode != 200 &#123; fmt.Fprintf(w,\"请求接口出错\") return &#125; defer response.Body.Close() body,_ := ioutil.ReadAll(response.Body) err := json.Unmarshal(body,&amp;s) if err != nil &#123; fmt.Fprintf(w,\"json转换失败\") return &#125; for _, item := range s.Dirs &#123; if item.IsDir &#123; ch &lt;- 1 &#125;else&#123; ch &lt;- 2 &#125; &#125; &#125;(ch,val.Name,path) result := &lt;-ch if result == 1 &#123; rs.DirCount++ &#125; else &#123; rs.FileCount++ &#125; &#125; else &#123; rs.FileCount++ &#125; &#125; rsJson, _ := json.Marshal(rs) fmt.Fprintf(w, string(rsJson)) //这个写入到w的是输出到客户端的&#125;type Data2 struct &#123; Path string `json:\"path\"` Dirs []FileInfo2 `json:\"dirs\"`&#125;type FileInfo2 struct &#123; Name string `json:\"name\"` // base name of the file IsDir bool `json:\"is_dir\"` // abbreviation for Mode().IsDir() Size int64 `json:\"size\"` // length in bytes for regular files; system-dependent for others&#125;type RsData struct &#123; Path string `json:\"path\"` DirCount int64 `json:\"dirCount\"` FileCount int64 `json:\"fileCount\"` TotalSize int64 `json:\"totalSize\"`&#125; 感觉问题2的解法存有问题,可以fix以及promote 麻雀虽小,却涉及到: golang实现简单的http web服务 接受并解析命令行参数 字符串处理 结构体转json并返回 获取某路径下的文件信息(包含文件夹等,Linux一切皆文件) 以及: 发送http请求 将请求其他接口获得的json转为结构体 使用有缓存的channel进行并发控制 递归调用","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"MySQL异常错误码","date":"2015-05-11T05:10:39.000Z","path":"2015/05/11/MySQL异常错误码/","text":"Server抛给Client错误的 消息信息/错误值/SQLSTATE值 均列在源码share/messages_to_clients.txt文件中。“%d”和“%s”分别代表编号和字符串，显示时，它们将被消息值取代。 由于MySQL源码更新较频繁,以下内容可能缺失或有变更,虽然概率较小. 最新参考: mysql-server/blob/8.0/share/messages_to_clients.txt · 错误：1000 SQLSTATE: HY000 (ER_HASHCHK) 消息：hashchk · 错误：1001 SQLSTATE: HY000 (ER_NISAMCHK) 消息：isamchk · 错误：1002 SQLSTATE: HY000 (ER_NO) 消息：NO · 错误：1003 SQLSTATE: HY000 (ER_YES) 消息：YES · 错误：1004 SQLSTATE: HY000 (ER_CANT_CREATE_FILE) 消息：无法创建文件’%s’ (errno: %d) · 错误：1005 SQLSTATE: HY000 (ER_CANT_CREATE_TABLE) 消息：无法创建表’%s’ (errno: %d) · 错误：1006 SQLSTATE: HY000 (ER_CANT_CREATE_DB) 消息：无法创建数据库’%s’ (errno: %d) · 错误：1007 SQLSTATE: HY000 (ER_DB_CREATE_EXISTS) 消息：无法创建数据库’%s’，数据库已存在。 · 错误：1008 SQLSTATE: HY000 (ER_DB_DROP_EXISTS) 消息：无法撤销数据库’%s’，数据库不存在。 · 错误：1009 SQLSTATE: HY000 (ER_DB_DROP_DELETE) 消息：撤销数据库时出错（无法删除’%s’，errno: %d） · 错误：1010 SQLSTATE: HY000 (ER_DB_DROP_RMDIR) 消息：撤销数据库时出错（can’t rmdir ‘%s’, errno: %d） · 错误：1011 SQLSTATE: HY000 (ER_CANT_DELETE_FILE) 消息：删除’%s’时出错 (errno: %d) · 错误：1012 SQLSTATE: HY000 (ER_CANT_FIND_SYSTEM_REC) 消息：无法读取系统表中的记录。 · 错误：1013 SQLSTATE: HY000 (ER_CANT_GET_STAT) 消息：无法获取’%s’的状态(errno: %d) · 错误：1014 SQLSTATE: HY000 (ER_CANT_GET_WD) 消息：无法获得工作目录(errno: %d) · 错误：1015 SQLSTATE: HY000 (ER_CANT_LOCK) 消息：无法锁定文件(errno: %d) · 错误：1016 SQLSTATE: HY000 (ER_CANT_OPEN_FILE) 消息：无法打开文件：’%s’ (errno: %d) · 错误：1017 SQLSTATE: HY000 (ER_FILE_NOT_FOUND) 消息：无法找到文件： ‘%s’ (errno: %d) · 错误：1018 SQLSTATE: HY000 (ER_CANT_READ_DIR) 消息：无法读取’%s’的目录 (errno: %d) · 错误：1019 SQLSTATE: HY000 (ER_CANT_SET_WD) 消息：无法为’%s’更改目录 (errno: %d) · 错误：1020 SQLSTATE: HY000 (ER_CHECKREAD) 消息：自上次读取以来表’%s’中的记录已改变。 · 错误：1021 SQLSTATE: HY000 (ER_DISK_FULL) 消息：磁盘满(%s)；等待某人释放一些空间… · 错误：1022 SQLSTATE: 23000 (ER_DUP_KEY) 消息：无法写入；复制表’%s’的 键。 · 错误：1023 SQLSTATE: HY000 (ER_ERROR_ON_CLOSE) 消息：关闭’%s’时出错 (errno: %d) · 错误：1024 SQLSTATE: HY000 (ER_ERROR_ON_READ) 消息：读取文件’%s’时出错 (errno: %d) · 错误：1025 SQLSTATE: HY000 (ER_ERROR_ON_RENAME) 消息：将’%s’重命名为’%s’时出错 (errno: %d) · 错误：1026 SQLSTATE: HY000 (ER_ERROR_ON_WRITE) 消息：写入文件’%s’时出错 (errno: %d) · 错误：1027 SQLSTATE: HY000 (ER_FILE_USED) 消息：’%s’已锁定，拒绝更改。 · 错误：1028 SQLSTATE: HY000 (ER_FILSORT_ABORT) 消息：分类失败 · 错误：1029 SQLSTATE: HY000 (ER_FORM_NOT_FOUND) 消息：对于’%s’，视图’%s’不存在。 · 错误：1030 SQLSTATE: HY000 (ER_GET_ERRNO) 消息：从存储引擎中获得错误%d。 · 错误：1031 SQLSTATE: HY000 (ER_ILLEGAL_HA) 消息：关于’%s’的表存储引擎不含该选项。 · 错误：1032 SQLSTATE: HY000 (ER_KEY_NOT_FOUND) 消息：无法在’%s’中找到记录。 · 错误：1033 SQLSTATE: HY000 (ER_NOT_FORM_FILE) 消息：文件中的不正确信息：’%s’ · 错误：1034 SQLSTATE: HY000 (ER_NOT_KEYFILE) 消息：对于表’%s’， 键文件不正确，请尝试修复。 · 错误：1035 SQLSTATE: HY000 (ER_OLD_KEYFILE) 消息：旧的键文件，对于表’%s’，请修复之！ · 错误：1036 SQLSTATE: HY000 (ER_OPEN_AS_READONLY) 消息：表’%s’是只读的。 · 错误：1037 SQLSTATE: HY001 (ER_OUTOFMEMORY) 消息：内存溢出，重启服务器并再次尝试（需要%d字节）。 · 错误：1038 SQLSTATE: HY001 (ER_OUT_OF_SORTMEMORY) 消息：分类内存溢出，增加服务器的分类缓冲区大小。 · 错误：1039 SQLSTATE: HY000 (ER_UNEXPECTED_EOF) 消息：读取文件’%s’时出现意外EOF (errno: %d) · 错误：1040 SQLSTATE: 08004 (ER_CON_COUNT_ERROR) 消息：连接过多。 · 错误：1041 SQLSTATE: HY000 (ER_OUT_OF_RESOURCES) 消息：内存溢出，请检查是否mysqld或其他进程使用了所有可用内存，如不然，或许应使用’ulimit’允许mysqld使用更多内存，或增加交换空间的大小。 · 错误：1042 SQLSTATE: 08S01 (ER_BAD_HOST_ERROR) 消息：无法获得该地址给出的主机名。 · 错误：1043 SQLSTATE: 08S01 (ER_HANDSHAKE_ERROR) 消息：不良握手 · 错误：1044 SQLSTATE: 42000 (ER_DBACCESS_DENIED_ERROR) 消息：拒绝用户‘%s‘@’%s’访问数据库’%s’。 · 错误：1045 SQLSTATE: 28000 (ER_ACCESS_DENIED_ERROR) 消息：拒绝用户‘%s‘@’%s’的访问（使用密码：%s） · 错误：1046 SQLSTATE: 3D000 (ER_NO_DB_ERROR) 消息：未选择数据库。 · 错误：1047 SQLSTATE: 08S01 (ER_UNKNOWN_COM_ERROR) 消息：未知命令。 · 错误：1048 SQLSTATE: 23000 (ER_BAD_NULL_ERROR) 消息：列’%s’不能为空。 · 错误：1049 SQLSTATE: 42000 (ER_BAD_DB_ERROR) 消息：未知数据库’%s’。 · 错误：1050 SQLSTATE: 42S01 (ER_TABLE_EXISTS_ERROR) 消息：表’%s’已存在。 · 错误：1051 SQLSTATE: 42S02 (ER_BAD_TABLE_ERROR) 消息：未知表’%s’。 · 错误：1052 SQLSTATE: 23000 (ER_NON_UNIQ_ERROR) 消息：%s中的列’%s’不明确。 · 错误：1053 SQLSTATE: 08S01 (ER_SERVER_SHUTDOWN) 消息：在操作过程中服务器关闭。 · 错误：1054 SQLSTATE: 42S22 (ER_BAD_FIELD_ERROR) 消息：’%s’中的未知列’%s’。 · 错误：1055 SQLSTATE: 42000 (ER_WRONG_FIELD_WITH_GROUP) 消息：’%s’不在GROUP BY中。 · 错误：1056 SQLSTATE: 42000 (ER_WRONG_GROUP_FIELD) 消息：无法在’%s’上创建组。 · 错误：1057 SQLSTATE: 42000 (ER_WRONG_SUM_SELECT) 消息：语句中有sum函数和相同语句中的列。 · 错误：1058 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT) 消息：列计数不匹配值计数。 · 错误：1059 SQLSTATE: 42000 (ER_TOO_LONG_IDENT) 消息：ID名称’%s’过长。 · 错误：1060 SQLSTATE: 42S21 (ER_DUP_FIELDNAME) 消息：重复列名’%s’。 · 错误：1061 SQLSTATE: 42000 (ER_DUP_KEYNAME) 消息：重复键名称’%s’。 · 错误：1062 SQLSTATE: 23000 (ER_DUP_ENTRY) 消息：键%d的重复条目’%s’。 · 错误：1063 SQLSTATE: 42000 (ER_WRONG_FIELD_SPEC) 消息：对于列’%s’，列分类符不正确。 · 错误：1064 SQLSTATE: 42000 (ER_PARSE_ERROR) 消息：在行%d上，%s靠近’%s’。 · 错误：1065 SQLSTATE: 42000 (ER_EMPTY_QUERY) 消息：查询为空。 · 错误：1066 SQLSTATE: 42000 (ER_NONUNIQ_TABLE) 消息：非唯一的表/别名：’%s’ · 错误：1067 SQLSTATE: 42000 (ER_INVALID_DEFAULT) 消息：关于’%s’的无效默认值。 · 错误：1068 SQLSTATE: 42000 (ER_MULTIPLE_PRI_KEY) 消息：定义了多个主键。 · 错误：1069 SQLSTATE: 42000 (ER_TOO_MANY_KEYS) 消息：指定了过多键：允许的最大键数是%d。 · 错误：1070 SQLSTATE: 42000 (ER_TOO_MANY_KEY_PARTS) 消息：指定了过多键部分：允许的最大键部分是%d。 · 错误：1071 SQLSTATE: 42000 (ER_TOO_LONG_KEY) 消息：指定的键过长，最大键长度是%d字节。 · 错误：1072 SQLSTATE: 42000 (ER_KEY_COLUMN_DOES_NOT_EXITS) 消息：键列’%s’在表中不存在。 · 错误：1073 SQLSTATE: 42000 (ER_BLOB_USED_AS_KEY) 消息：BLOB列’%s’不能与已使用的表类型用在 键说明中。 · 错误：1074 SQLSTATE: 42000 (ER_TOO_BIG_FIELDLENGTH) 消息：对于列’%s’，列长度过大 (max = %d)，请使用BLOB或TEXT取而代之。 · 错误：1075 SQLSTATE: 42000 (ER_WRONG_AUTO_KEY) 消息：不正确的表定义，只能有1个auto列，而且必须将其定义为 键。 · 错误：1076 SQLSTATE: HY000 (ER_READY) 消息：%s，连接就绪。版本：’%s’，套接字：’%s’，端口：%d · 错误：1077 SQLSTATE: HY000 (ER_NORMAL_SHUTDOWN) 消息：%s，正常关闭。 · 错误：1078 SQLSTATE: HY000 (ER_GOT_SIGNAL) 消息：%s，获得信号%d。放弃！ · 错误：1079 SQLSTATE: HY000 (ER_SHUTDOWN_COMPLETE) 消息：%s，关闭完成 · 错误：1080 SQLSTATE: 08S01 (ER_FORCING_CLOSE) 消息：%s，强制关闭线程%ld，用户：’%s’ · 错误：1081 SQLSTATE: 08S01 (ER_IPSOCK_ERROR) 消息：无法创建IP套接字 · 错误：1082 SQLSTATE: 42S12 (ER_NO_SUCH_INDEX) 消息：表’%s’中没有与CREATE INDEX中索引类似的索引，重新创建表。 · 错误：1083 SQLSTATE: 42000 (ER_WRONG_FIELD_TERMINATORS) 消息：字段分隔符参量不是预期的，请参考手册。 · 错误：1084 SQLSTATE: 42000 (ER_BLOBS_AND_NO_TERMINATED) 消息：不能与BLOB一起使用固定行长度，请使用’fields terminated by’。 · 错误：1085 SQLSTATE: HY000 (ER_TEXTFILE_NOT_READABLE) 消息：文件’%s’必须在数据库目录下，或能被所有人读取。 · 错误：1086 SQLSTATE: HY000 (ER_FILE_EXISTS_ERROR) 消息：文件’%s’已存在。 · 错误：1087 SQLSTATE: HY000 (ER_LOAD_INFO) 消息：记录，%ld；已删除，%ld；已跳过，%ld；警告，%ld · 错误：1088 SQLSTATE: HY000 (ER_ALTER_INFO) 消息：记录，%ld；重复，%ld · 错误：1089 SQLSTATE: HY000 (ER_WRONG_SUB_KEY) 消息：不正确的子部分键，使用的键部分不是字符串，所用的长度长于键部分，或存储引擎不支持唯一子键。 · 错误：1090 SQLSTATE: 42000 (ER_CANT_REMOVE_ALL_FIELDS) 消息：不能用ALTER TABLE删除所有列，请使用DROP TABLE取而代之。 · 错误：1091 SQLSTATE: 42000 (ER_CANT_DROP_FIELD_OR_KEY) 消息：不能撤销’%s’，请检查列/键是否存在。 · 错误：1092 SQLSTATE: HY000 (ER_INSERT_INFO) 消息：记录，%ld；复制，%ld；告警，%ld · 错误：1093 SQLSTATE: HY000 (ER_UPDATE_TABLE_USED) 消息：不能在FROM子句中制定要更新的目标表’%s’。 · 错误：1094 SQLSTATE: HY000 (ER_NO_SUCH_THREAD) 消息：未知线程ID：%lu · 错误：1095 SQLSTATE: HY000 (ER_KILL_DENIED_ERROR) 消息：你不是线程%lu的所有者。 · 错误：1096 SQLSTATE: HY000 (ER_NO_TABLES_USED) 消息：未使用任何表。 · 错误：1097 SQLSTATE: HY000 (ER_TOO_BIG_SET) 消息：列%s和SET的字符串过多。 · 错误：1098 SQLSTATE: HY000 (ER_NO_UNIQUE_LOGFILE) 消息：不能生成唯一的日志文件名%s.(1-999) · 错误：1099 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED_FOR_WRITE) 消息：表’%s’已用READ锁定，不能更新。 · 错误：1100 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED) 消息：未使用LOCK TABLES锁定表’%s’。 · 错误：1101 SQLSTATE: 42000 (ER_BLOB_CANT_HAVE_DEFAULT) 消息：BLOB/TEXT列’%s’不能有默认值。 · 错误：1102 SQLSTATE: 42000 (ER_WRONG_DB_NAME) 消息：不正确的数据库名’%s’。 · 错误：1103 SQLSTATE: 42000 (ER_WRONG_TABLE_NAME) 消息：不正确的表名’%s’。 · 错误：1104 SQLSTATE: 42000 (ER_TOO_BIG_SELECT) 消息：SELECT将检查超过MAX_JOIN_SIZE的行，如果SELECT正常，请检查WHERE，并使用SET SQL_BIG_SELECTS=1或SET SQL_MAX_JOIN_SIZE=#。 · 错误：1105 SQLSTATE: HY000 (ER_UNKNOWN_ERROR) 消息：未知错误。 · 错误：1106 SQLSTATE: 42000 (ER_UNKNOWN_PROCEDURE) 消息：未知过程’%s’ · 错误：1107 SQLSTATE: 42000 (ER_WRONG_PARAMCOUNT_TO_PROCEDURE) 消息：对于过程’%s’，参数计数不正确 · 错误：1108 SQLSTATE: HY000 (ER_WRONG_PARAMETERS_TO_PROCEDURE) 消息：对于过程’%s’，参数不正确 · 错误：1109 SQLSTATE: 42S02 (ER_UNKNOWN_TABLE) 消息：%s中的未知表%s · 错误：1110 SQLSTATE: 42000 (ER_FIELD_SPECIFIED_TWICE) 消息：列’%s’被指定了两次。 · 错误：1111 SQLSTATE: HY000 (ER_INVALID_GROUP_FUNC_USE) 消息：无效的分组函数使用 · 错误：1112 SQLSTATE: 42000 (ER_UNSUPPORTED_EXTENSION) 消息：表’%s’使用了该MySQL版本中不存在的扩展。 · 错误：1113 SQLSTATE: 42000 (ER_TABLE_MUST_HAVE_COLUMNS) 消息：1个表至少要有1列。 · 错误：1114 SQLSTATE: HY000 (ER_RECORD_FILE_FULL) 消息：表’%s’已满。 · 错误：1115 SQLSTATE: 42000 (ER_UNKNOWN_CHARACTER_SET) 消息：未知字符集’%s’。 · 错误：1116 SQLSTATE: HY000 (ER_TOO_MANY_TABLES) 消息：表过多，MySQL在1个联合操作中只能使用%d个表。 · 错误：1117 SQLSTATE: HY000 (ER_TOO_MANY_FIELDS) 消息：列过多。 · 错误：1118 SQLSTATE: 42000 (ER_TOO_BIG_ROWSIZE) 消息：行的大小过大。对于所使用的表类型，不包括BLOB，最大行大小为%ld。必须将某些列更改为TEXT或BLOB。 · 错误：1119 SQLSTATE: HY000 (ER_STACK_OVERRUN) 消息：线程堆栈溢出，已使用，%ld堆栈的%ld。如果需要，请使用’mysqld -O thread_stack=#’指定较大的堆栈。 · 错误：1120 SQLSTATE: 42000 (ER_WRONG_OUTER_JOIN) 消息：在OUTER JOIN中发现交叉关联，请检查ON条件。 · 错误：1121 SQLSTATE: 42000 (ER_NULL_COLUMN_IN_INDEX) 消息：列’%s’与UNIQUE或INDEX一起使用，但未定义为NOT NULL。 · 错误：1122 SQLSTATE: HY000 (ER_CANT_FIND_UDF) 消息：无法加载函数’%s’。 · 错误：1123 SQLSTATE: HY000 (ER_CANT_INITIALIZE_UDF) 消息：无法初始化函数’%s’; %s · 错误：1124 SQLSTATE: HY000 (ER_UDF_NO_PATHS) 消息：对于共享库，不允许任何路径。 · 错误：1125 SQLSTATE: HY000 (ER_UDF_EXISTS) 消息：函数’%s’已存在。 · 错误：1126 SQLSTATE: HY000 (ER_CANT_OPEN_LIBRARY) 消息：不能打开共享库’%s’ (errno: %d %s) · 错误：1127 SQLSTATE: HY000 (ER_CANT_FIND_DL_ENTRY) 消息：不能发现库中的符号’%s’。 · 错误：1128 SQLSTATE: HY000 (ER_FUNCTION_NOT_DEFINED) 消息：函数’%s’未定义。 · 错误：1129 SQLSTATE: HY000 (ER_HOST_IS_BLOCKED) 消息：由于存在很多连接错误，主机’%s’被屏蔽，请用’mysqladmin flush-hosts’解除屏蔽。 · 错误：1130 SQLSTATE: HY000 (ER_HOST_NOT_PRIVILEGED) 消息：不允许将主机’%s’连接到该MySQL服务器。 · 错误：1131 SQLSTATE: 42000 (ER_PASSWORD_ANONYMOUS_USER) 消息：你正在已匿名用户身份使用MySQL，不允许匿名用户更改密码。 · 错误：1132 SQLSTATE: 42000 (ER_PASSWORD_NOT_ALLOWED) 消息：必须有更新mysql数据库中表的权限才能更改密码。 · 错误：1133 SQLSTATE: 42000 (ER_PASSWORD_NO_MATCH) 消息：无法在用户表中找到匹配行。 · 错误：1134 SQLSTATE: HY000 (ER_UPDATE_INFO) 消息：行匹配，%ld；已更改，%ld；警告，%ld · 错误：1135 SQLSTATE: HY000 (ER_CANT_CREATE_THREAD) 消息：无法创建新线程(errno %d)，如果未出现内存溢出，请参阅手册以了解可能的与操作系统有关的缺陷。 · 错误：1136 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT_ON_ROW) 消息：列计数不匹配行%ld上的值计数。 · 错误：1137 SQLSTATE: HY000 (ER_CANT_REOPEN_TABLE) 消息：无法再次打开表’%s’。 · 错误：1138 SQLSTATE: 22004 (ER_INVALID_USE_OF_NULL) 消息：NULL值使用无效。 · 错误：1139 SQLSTATE: 42000 (ER_REGEXP_ERROR) 消息：获得来自regexp的错误’%s’。 · 错误：1140 SQLSTATE: 42000 (ER_MIX_OF_GROUP_FUNC_AND_FIELDS) 消息：如果没有GROUP BY子句，GROUP列 (MIN(),MAX(),COUNT(),…)与非GROUP列的混合不合法。 · 错误：1141 SQLSTATE: 42000 (ER_NONEXISTING_GRANT) 消息：没有为主机’%s’上的用户’%s’定义这类授权。 · 错误：1142 SQLSTATE: 42000 (ER_TABLEACCESS_DENIED_ERROR) 消息：拒绝用户‘%s‘@’%s’在表’%s’上使用%s命令。 · 错误：1143 SQLSTATE: 42000 (ER_COLUMNACCESS_DENIED_ERROR) 消息：拒绝用户‘%s‘@’%s’在表’%s’的’%s’上使用%s命令。 · 错误：1144 SQLSTATE: 42000 (ER_ILLEGAL_GRANT_FOR_TABLE) 消息：非法GRANT/REVOKE命令，请参阅手册以了解可使用那种权限。 · 错误：1145 SQLSTATE: 42000 (ER_GRANT_WRONG_HOST_OR_USER) 消息：GRANT的主机或用户参量过长。 · 错误：1146 SQLSTATE: 42S02 (ER_NO_SUCH_TABLE) 消息：表’%s.%s’不存在。 · 错误：1147 SQLSTATE: 42000 (ER_NONEXISTING_TABLE_GRANT) 消息：在表’%s’上没有为主机’%s’上的用户’%s’定义的这类授权。 · 错误：1148 SQLSTATE: 42000 (ER_NOT_ALLOWED_COMMAND) 消息：所使用的命令在该MySQL版本中不允许。 · 错误：1149 SQLSTATE: 42000 (ER_SYNTAX_ERROR) 消息：存在SQL语法错误，请参阅与你的MySQL版本对应的手册，以了解正确的语法。 · 错误：1150 SQLSTATE: HY000 (ER_DELAYED_CANT_CHANGE_LOCK) 消息：对于表%s，延迟的插入线程不能获得请求的锁定。 · 错误：1151 SQLSTATE: HY000 (ER_TOO_MANY_DELAYED_THREADS) 消息：使用的延迟线程过多。 · 错误：1152 SQLSTATE: 08S01 (ER_ABORTING_CONNECTION) 消息：与数据库’%s’和用户’%s’的连接%ld失败 (%s) · 错误：1153 SQLSTATE: 08S01 (ER_NET_PACKET_TOO_LARGE) 消息：获得信息包大于’max_allowed_packet’字节。 · 错误：1154 SQLSTATE: 08S01 (ER_NET_READ_ERROR_FROM_PIPE) 消息：获得来自连接管道的读错误。 · 错误：1155 SQLSTATE: 08S01 (ER_NET_FCNTL_ERROR) 消息：获得来自fcntl()的错误。 · 错误：1156 SQLSTATE: 08S01 (ER_NET_PACKETS_OUT_OF_ORDER) 消息：获得信息包无序。 · 错误：1157 SQLSTATE: 08S01 (ER_NET_UNCOMPRESS_ERROR) 消息：无法解压缩通信信息包。 · 错误：1158 SQLSTATE: 08S01 (ER_NET_READ_ERROR) 消息：读取通信信息包时出错。 · 错误：1159 SQLSTATE: 08S01 (ER_NET_READ_INTERRUPTED) 消息：读取通信信息包时出现超时。 · 错误：1160 SQLSTATE: 08S01 (ER_NET_ERROR_ON_WRITE) 消息：写入通信信息包时出错。 · 错误：1161 SQLSTATE: 08S01 (ER_NET_WRITE_INTERRUPTED) 消息：写入通信信息包时出现超时。 · 错误：1162 SQLSTATE: 42000 (ER_TOO_LONG_STRING) 消息：结果字符串长于’max_allowed_packet’字节。 · 错误：1163 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_BLOB) 消息：所使用的表类型不支持BLOB/TEXT列。 · 错误：1164 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_AUTO_INCREMENT) 消息：所使用的表类型不支持AUTO_INCREMENT列。 · 错误：1165 SQLSTATE: HY000 (ER_DELAYED_INSERT_TABLE_LOCKED) 消息：由于用LOCK TABLES锁定了表，INSERT DELAYED不能与表’%s’一起使用。 · 错误：1166 SQLSTATE: 42000 (ER_WRONG_COLUMN_NAME) 消息：不正确的列名’%s’。 · 错误：1167 SQLSTATE: 42000 (ER_WRONG_KEY_COLUMN) 消息：所使用的存储引擎不能为列’%s’编制索引。 · 错误：1168 SQLSTATE: HY000 (ER_WRONG_MRG_TABLE) 消息：MERGE表中的所有表未同等定义。 · 错误：1169 SQLSTATE: 23000 (ER_DUP_UNIQUE) 消息：由于唯一性限制，不能写入到表’%s’。 · 错误：1170 SQLSTATE: 42000 (ER_BLOB_KEY_WITHOUT_LENGTH) 消息：在未指定键长度的键说明中使用了BLOB/TEXT列’%s’。 · 错误：1171 SQLSTATE: 42000 (ER_PRIMARY_CANT_HAVE_NULL) 消息：PRIMARY KEY的所有部分必须是NOT NULL，如果需要为NULL的关键字，请使用UNIQUE取而代之。 · 错误：1172 SQLSTATE: 42000 (ER_TOO_MANY_ROWS) 消息：结果有1个以上的行组成。 · 错误：1173 SQLSTATE: 42000 (ER_REQUIRES_PRIMARY_KEY) 消息：该表类型要求主键。 · 错误：1174 SQLSTATE: HY000 (ER_NO_RAID_COMPILED) 消息：该MySQL版本是未使用RAID支持而编译的。 · 错误：1175 SQLSTATE: HY000 (ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE) 消息：你正在使用安全更新模式，而且试图在不使用WHERE的情况下更新使用了KEY列的表。 · 错误：1176 SQLSTATE: HY000 (ER_KEY_DOES_NOT_EXITS) 消息：在表’%s’中，键’%s’不存在。 · 错误：1177 SQLSTATE: 42000 (ER_CHECK_NO_SUCH_TABLE) 消息：无法打开表。 · 错误：1178 SQLSTATE: 42000 (ER_CHECK_NOT_IMPLEMENTED) 消息：用于表的引擎不支持%s。 · 错误：1179 SQLSTATE: 25000 (ER_CANT_DO_THIS_DURING_AN_TRANSACTION) 消息：不允许在事务中执行该命令。 · 错误：1180 SQLSTATE: HY000 (ER_ERROR_DURING_COMMIT) 消息：在COMMIT期间出现错误%d。 · 错误：1181 SQLSTATE: HY000 (ER_ERROR_DURING_ROLLBACK) 消息：在ROLLBACK期间出现错误%d。 · 错误：1182 SQLSTATE: HY000 (ER_ERROR_DURING_FLUSH_LOGS) 消息：在FLUSH_LOGS期间出现错误%d。 · 错误：1183 SQLSTATE: HY000 (ER_ERROR_DURING_CHECKPOINT) 消息：在CHECKPOINT期间出现错误%d。 · 错误：1184 SQLSTATE: 08S01 (ER_NEW_ABORTING_CONNECTION) 消息：与数据库’%s’、用户’%s’和主机’%s’的连接%ld失败 (%s)。 · 错误：1185 SQLSTATE: HY000 (ER_DUMP_NOT_IMPLEMENTED) 消息：针对表的存储引擎不支持二进制表转储。 · 错误：1186 SQLSTATE: HY000 (ER_FLUSH_MASTER_BINLOG_CLOSED) 消息：Binlog已关闭，不能RESET MASTER。 · 错误：1187 SQLSTATE: HY000 (ER_INDEX_REBUILD) 消息：重新创建转储表’%s’的索引失败。 · 错误：1188 SQLSTATE: HY000 (ER_MASTER) 消息：来自主连接’%s’的错误。 · 错误：1189 SQLSTATE: 08S01 (ER_MASTER_NET_READ) 消息：读取主连接时出现网络错误。 · 错误：1190 SQLSTATE: 08S01 (ER_MASTER_NET_WRITE) 消息：写入主连接时出现网络错误。 · 错误：1191 SQLSTATE: HY000 (ER_FT_MATCHING_KEY_NOT_FOUND) 消息：无法找到与列列表匹配的FULLTEXT索引。 · 错误：1192 SQLSTATE: HY000 (ER_LOCK_OR_ACTIVE_TRANSACTION) 消息：由于存在活动的锁定表或活动的事务，不能执行给定的命令。 · 错误：1193 SQLSTATE: HY000 (ER_UNKNOWN_SYSTEM_VARIABLE) 消息：未知的系统变量’%s’。 · 错误：1194 SQLSTATE: HY000 (ER_CRASHED_ON_USAGE) 消息：表’%s’被标记为崩溃，应予以修复。 · 错误：1195 SQLSTATE: HY000 (ER_CRASHED_ON_REPAIR) 消息：表’%s’被标记为崩溃，而且上次修复失败（自动？） · 错误：1196 SQLSTATE: HY000 (ER_WARNING_NOT_COMPLETE_ROLLBACK) 消息：不能回滚某些非事务性已变动表。 · 错误：1197 SQLSTATE: HY000 (ER_TRANS_CACHE_FULL) 消息：多语句事务要求更多的’max_binlog_cache_size’存储字节，增大mysqld变量，并再次尝试。 · 错误：1198 SQLSTATE: HY000 (ER_SLAVE_MUST_STOP) 消息：运行从实例时不能执行该操作，请首先运行STOP SLAVE。 · 错误：1199 SQLSTATE: HY000 (ER_SLAVE_NOT_RUNNING) 消息：该操作需要运行的从实例，请配置SLAVE并执行START SLAVE。 · 错误：1200 SQLSTATE: HY000 (ER_BAD_SLAVE) 消息：服务器未配置为从服务器，请更正config文件，或使用CHANGE MASTER TO。 · 错误：1201 SQLSTATE: HY000 (ER_MASTER_INFO) 消息：无法初始化主服务器信息结构，在MySQL错误日志中可找到更多错误消息。 · 错误：1202 SQLSTATE: HY000 (ER_SLAVE_THREAD) 消息：无法创建从线程，请检查系统资源。 · 错误：1203 SQLSTATE: 42000 (ER_TOO_MANY_USER_CONNECTIONS) 消息：用户%s已有了超过’max_user_connections’的活动连接。 · 错误：1204 SQLSTATE: HY000 (ER_SET_CONSTANTS_ONLY) 消息：或许仅应与SET一起使用常量表达式。 · 错误：1205 SQLSTATE: HY000 (ER_LOCK_WAIT_TIMEOUT) 消息：超过了锁定等待超时，请尝试重新启动事务。 · 错误：1206 SQLSTATE: HY000 (ER_LOCK_TABLE_FULL) 消息：总的锁定数超出了锁定表的大小。 · 错误：1207 SQLSTATE: 25000 (ER_READ_ONLY_TRANSACTION) 消息：在READ UNCOMMITTED事务期间，无法获得更新锁定。 · 错误：1208 SQLSTATE: HY000 (ER_DROP_DB_WITH_READ_LOCK) 消息：当线程保持为全局读锁定时，不允许DROP DATABASE。 · 错误：1209 SQLSTATE: HY000 (ER_CREATE_DB_WITH_READ_LOCK) 消息：当线程保持为全局读锁定时，不允许CREATE DATABASE。 · 错误：1210 SQLSTATE: HY000 (ER_WRONG_ARGUMENTS) 消息：为%s提供的参量不正确。 · 错误：1211 SQLSTATE: 42000 (ER_NO_PERMISSION_TO_CREATE_USER) 消息：不允许‘%s‘@’%s’创建新用户。 · 错误：1212 SQLSTATE: HY000 (ER_UNION_TABLES_IN_DIFFERENT_DIR) 消息：不正确的表定义，所有的MERGE表必须位于相同的数据库中。 · 错误：1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK) 消息：试图获取锁定时发现死锁，请尝试重新启动事务。 · 错误：1214 SQLSTATE: HY000 (ER_TABLE_CANT_HANDLE_FT) 消息：所使用的表类型不支持FULLTEXT索引。 · 错误：1215 SQLSTATE: HY000 (ER_CANNOT_ADD_FOREIGN) 消息：无法添加外键约束。 · 错误：1216 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW) 消息：无法添加或更新子行，外键约束失败。 · 错误：1217 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED) 消息：无法删除或更新父行，外键约束失败。 · 错误：1218 SQLSTATE: 08S01 (ER_CONNECT_TO_MASTER) 消息：连接至主服务器%s时出错。 · 错误：1219 SQLSTATE: HY000 (ER_QUERY_ON_MASTER) 消息：在主服务器%s上执行查询时出错。 · 错误：1220 SQLSTATE: HY000 (ER_ERROR_WHEN_EXECUTING_COMMAND) 消息：执行命令%s: %s时出错。 · 错误：1221 SQLSTATE: HY000 (ER_WRONG_USAGE) 消息：%s和%s的用法不正确。 · 错误：1222 SQLSTATE: 21000 (ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT) 消息：所使用的SELECT语句有不同的列数。 · 错误：1223 SQLSTATE: HY000 (ER_CANT_UPDATE_WITH_READLOCK) 消息：由于存在冲突的读锁定，无法执行查询。 · 错误：1224 SQLSTATE: HY000 (ER_MIXING_NOT_ALLOWED) 消息：禁止混合事务性表和非事务性表。 · 错误：1225 SQLSTATE: HY000 (ER_DUP_ARGUMENT) 消息：在语句中使用了两次选项’%s’。 · 错误：1226 SQLSTATE: 42000 (ER_USER_LIMIT_REACHED) 消息：用户’%s’超出了’%s’资源（当前值：%ld）。 · 错误：1227 SQLSTATE: 42000 (ER_SPECIFIC_ACCESS_DENIED_ERROR) 消息：拒绝访问，需要%s权限才能执行该操作。 · 错误：1228 SQLSTATE: HY000 (ER_LOCAL_VARIABLE) 消息：变量’%s’是1种SESSION变量，不能与SET GLOBAL一起使用。 · 错误：1229 SQLSTATE: HY000 (ER_GLOBAL_VARIABLE) 消息：变量’%s’是1种GLOBAL变量，应使用SET GLOBAL来设置它。 · 错误：1230 SQLSTATE: 42000 (ER_NO_DEFAULT) 消息：变量’%s’没有默认值。 · 错误：1231 SQLSTATE: 42000 (ER_WRONG_VALUE_FOR_VAR) 消息：变量’%s’不能设置为值’%s’。 · 错误：1232 SQLSTATE: 42000 (ER_WRONG_TYPE_FOR_VAR) 消息：变量’%s’的参量类型不正确。 · 错误：1233 SQLSTATE: HY000 (ER_VAR_CANT_BE_READ) 消息：变量’%s’只能被设置，不能被读取。 · 错误：1234 SQLSTATE: 42000 (ER_CANT_USE_OPTION_HERE) 消息：不正确的’%s’用法/位置。 · 错误：1235 SQLSTATE: 42000 (ER_NOT_SUPPORTED_YET) 消息：该MySQL版本尚不支持’%s’。 · 错误：1236 SQLSTATE: HY000 (ER_MASTER_FATAL_ERROR_READING_BINLOG) 消息：从二进制日志读取数据时，获得来自主服务器的致命错误%d: ‘%s’。 · 错误：1237 SQLSTATE: HY000 (ER_SLAVE_IGNORED_TABLE) 消息：由于“replicate-*-table”规则，从SQL线程忽略了查询。。 · 错误：1238 SQLSTATE: HY000 (ER_INCORRECT_GLOBAL_LOCAL_VAR) 消息：变量’%s’是一种%s变量。 · 错误：1239 SQLSTATE: 42000 (ER_WRONG_FK_DEF) 消息：对于 ‘%s’: %s， 外键定义不正确。 · 错误：1240 SQLSTATE: HY000 (ER_KEY_REF_DO_NOT_MATCH_TABLE_REF) 消息：键引用和表引用不匹配。 · 错误：1241 SQLSTATE: 21000 (ER_OPERAND_COLUMNS) 消息：操作数应包含%d列。 · 错误：1242 SQLSTATE: 21000 (ER_SUBQUERY_NO_1_ROW) 消息：子查询返回1行以上。 · 错误：1243 SQLSTATE: HY000 (ER_UNKNOWN_STMT_HANDLER) 消息：指定给%s的未知预处理语句句柄。 · 错误：1244 SQLSTATE: HY000 (ER_CORRUPT_HELP_DB) 消息：帮助数据库崩溃或不存在。 · 错误：1245 SQLSTATE: HY000 (ER_CYCLIC_REFERENCE) 消息：对子查询的循环引用。 · 错误：1246 SQLSTATE: HY000 (ER_AUTO_CONVERT) 消息：将列’%s’从%s转换为%s。 · 错误：1247 SQLSTATE: 42S22 (ER_ILLEGAL_REFERENCE) 消息：引用’%s’不被支持 (%s)。 · 错误：1248 SQLSTATE: 42000 (ER_DERIVED_MUST_HAVE_ALIAS) 消息：所有的导出表必须有自己的别名。 · 错误：1249 SQLSTATE: 01000 (ER_SELECT_REDUCED) 消息：在优化期间简化了选择%u。 · 错误：1250 SQLSTATE: 42000 (ER_TABLENAME_NOT_ALLOWED_HERE) 消息：来自某一SELECT的表’%s’不能在%s中使用。 · 错误：1251 SQLSTATE: 08004 (ER_NOT_SUPPORTED_AUTH_MODE) 消息：客户端不支持服务器请求的鉴定协议，请考虑升级MySQL客户端。 · 错误：1252 SQLSTATE: 42000 (ER_SPATIAL_CANT_HAVE_NULL) 消息：SPATIAL索引的所有部分必须是NOT NULL。 · 错误：1253 SQLSTATE: 42000 (ER_COLLATION_CHARSET_MISMATCH) 消息：对于CHARACTER SET ‘%s’，COLLATION ‘%s’无效。 · 错误：1254 SQLSTATE: HY000 (ER_SLAVE_WAS_RUNNING) 消息：从服务器正在运行。 · 错误：1255 SQLSTATE: HY000 (ER_SLAVE_WAS_NOT_RUNNING) 消息：从服务器已停止。 · 错误：1256 SQLSTATE: HY000 (ER_TOO_BIG_FOR_UNCOMPRESS) 消息：解压的数据过大，最大大小为%d（也可能是，解压数据的长度已损坏）。 · 错误：1257 SQLSTATE: HY000 (ER_ZLIB_Z_MEM_ERROR) 消息：ZLIB，无足够内存。 · 错误：1258 SQLSTATE: HY000 (ER_ZLIB_Z_BUF_ERROR) 消息：ZLIB，输出缓冲区内无足够空间（也可能是，解压数据的长度已损坏）。 · 错误：1259 SQLSTATE: HY000 (ER_ZLIB_Z_DATA_ERROR) 消息：ZLIB，输入数据已损坏。 · 错误：1260 SQLSTATE: HY000 (ER_CUT_VALUE_GROUP_CONCAT) 消息：%d行被GROUP_CONCAT()截去。 · 错误：1261 SQLSTATE: 01000 (ER_WARN_TOO_FEW_RECORDS) 消息：行%ld不包含所有列的数据。 · 错误：1262 SQLSTATE: 01000 (ER_WARN_TOO_MANY_RECORDS) 消息：行%ld被解短，它包含的数据大于输入列中的数据。 · 错误：1263 SQLSTATE: 22004 (ER_WARN_NULL_TO_NOTNULL) 消息：列被设为默认值，在行%ld上将NULL提供给了NOT NULL列。 · 错误：1264 SQLSTATE: 22003 (ER_WARN_DATA_OUT_OF_RANGE) 消息：为行%ld上的列’%s’调整超出范围的值。 · 错误：1265 SQLSTATE: 01000 (WARN_DATA_TRUNCATED) 消息：为行%ld上的列’%s’截短数据。 · 错误：1266 SQLSTATE: HY000 (ER_WARN_USING_OTHER_HANDLER) 消息：为表%s使用存储引擎%s。 · 错误：1267 SQLSTATE: HY000 (ER_CANT_AGGREGATE_2COLLATIONS) 消息：对于操作’%s’，非法混合了校对(%s,%s)和(%s,%s)。 · 错误：1268 SQLSTATE: HY000 (ER_DROP_USER) 消息：无法撤销1个或多个请求的用户。 · 错误：1269 SQLSTATE: HY000 (ER_REVOKE_GRANTS) 消息：无法撤销所有权限，为1个或多个请求的用户授权。 · 错误：1270 SQLSTATE: HY000 (ER_CANT_AGGREGATE_3COLLATIONS) 消息：对于操作’%s’，非法混合了校对(%s,%s)、(%s,%s)和(%s,%s)。 · 错误：1271 SQLSTATE: HY000 (ER_CANT_AGGREGATE_NCOLLATIONS) 消息：对于操作’%s’，非法混合了校对。 · 错误：1272 SQLSTATE: HY000 (ER_VARIABLE_IS_NOT_STRUCT) 消息：变量’%s’不是变量组分（不能用作XXXX.variable_name）。 · 错误：1273 SQLSTATE: HY000 (ER_UNKNOWN_COLLATION) 消息：未知校对’%s’。 · 错误：1274 SQLSTATE: HY000 (ER_SLAVE_IGNORED_SSL_PARAMS) 消息：由于该MySQL从服务器是在不支持SSL的情况下编译的，CHANGE MASTER中的SSL参数被忽略，随后，如果启动了具备SSL功能的MySQL，可使用这些参数。 · 错误：1275 SQLSTATE: HY000 (ER_SERVER_IS_IN_SECURE_AUTH_MODE) 消息：服务器正运行在“–secure-auth”模式下，但‘%s‘@’%s’有1个采用旧格式的密码，请将密码更改为新格式。 · 错误：1276 SQLSTATE: HY000 (ER_WARN_FIELD_RESOLVED) 消息：SELECT #%d的字段或引用’%s%s%s%s%s’是在SELECT #%d中确定的。 · 错误：1277 SQLSTATE: HY000 (ER_BAD_SLAVE_UNTIL_COND) 消息：对于START SLAVE UNTIL，不正确的参数或参数组合。 · 错误：1278 SQLSTATE: HY000 (ER_MISSING_SKIP_SLAVE) 消息：与START SLAVE UNTIL一起执行按步复制时，建议使用“–skip-slave-start”，否则，如果发生未预料的从服务器mysqld重启，间出现问题。 · 错误：1279 SQLSTATE: HY000 (ER_UNTIL_COND_IGNORED) 消息：SQL线程未启动，因而UNTIL选项被忽略。 · 错误：1280 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_INDEX) 消息：不正确的索引名’%s’。 · 错误：1281 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_CATALOG) 消息：不正确的目录名’%s’。 · 错误：1282 SQLSTATE: HY000 (ER_WARN_QC_RESIZE) 消息：查询高速缓冲设置大小%lu时失败，新的查询高速缓冲的大小是%lu。 · 错误：1283 SQLSTATE: HY000 (ER_BAD_FT_COLUMN) 消息：列’%s’不能是FULLTEXT索引的一部分。 · 错误：1284 SQLSTATE: HY000 (ER_UNKNOWN_KEY_CACHE) 消息：未知的键高速缓冲’%s’。 · 错误：1285 SQLSTATE: HY000 (ER_WARN_HOSTNAME_WONT_WORK) 消息：MySQL是在“–skip-name-resolve”模式下启动的，必须在不使用该开关的情况下重启它，以便该授权能起作用。 · 错误：1286 SQLSTATE: 42000 (ER_UNKNOWN_STORAGE_ENGINE) 消息：未知的表引擎’%s’。 · 错误：1287 SQLSTATE: HY000 (ER_WARN_DEPRECATED_SYNTAX) 消息：’%s’已过时，请使用’%s’取而代之。 · 错误：1288 SQLSTATE: HY000 (ER_NON_UPDATABLE_TABLE) 消息：%s的目标表%s不可更新。 · 错误：1289 SQLSTATE: HY000 (ER_FEATURE_DISABLED) 消息：’%s’特性已被禁止，要想使其工作，需要用’%s’创建MySQL。 · 错误：1290 SQLSTATE: HY000 (ER_OPTION_PREVENTS_STATEMENT) 消息：MySQL正使用%s选项运行，因此不能执行该语句。 · 错误：1291 SQLSTATE: HY000 (ER_DUPLICATED_VALUE_IN_TYPE) 消息：列’%s’在%s中有重复值’%s’。 · 错误：1292 SQLSTATE: 22007 (ER_TRUNCATED_WRONG_VALUE) 消息：截短了不正确的%s值: ‘%s’ · 错误：1293 SQLSTATE: HY000 (ER_TOO_MUCH_AUTO_TIMESTAMP_COLS) 消息：不正确的表定义，在DEFAULT或ON UPDATE子句中，对于CURRENT_TIMESTAMP，只能有一个TIMESTAMP列。 · 错误：1294 SQLSTATE: HY000 (ER_INVALID_ON_UPDATE) 消息：对于’%s’列，ON UPDATE子句无效。 · 错误：1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS) 消息：在预处理语句协议中，尚不支持该命令。 · 错误：1296 SQLSTATE: HY000 (ER_GET_ERRMSG) 消息：从%s获得错误%d ‘%s’。 · 错误：1297 SQLSTATE: HY000 (ER_GET_TEMPORARY_ERRMSG) 消息：从%s获得临时错误%d ‘%s’。 · 错误：1298 SQLSTATE: HY000 (ER_UNKNOWN_TIME_ZONE) 消息：未知或不正确的时区: ‘%s’ · 错误：1299 SQLSTATE: HY000 (ER_WARN_INVALID_TIMESTAMP) 消息：在行%ld的列’%s’中存在无效的TIMESTAMP值。 · 错误：1300 SQLSTATE: HY000 (ER_INVALID_CHARACTER_STRING) 消息：无效的%s字符串: ‘%s’ · 错误：1301 SQLSTATE: HY000 (ER_WARN_ALLOWED_PACKET_OVERFLOWED) 消息：%s()的结果大于max_allowed_packet (%ld)，已截短 · 错误：1302 SQLSTATE: HY000 (ER_CONFLICTING_DECLARATIONS) 消息：冲突声明：’%s%s’和’%s%s’ · 错误：1303 SQLSTATE: 2F003 (ER_SP_NO_RECURSIVE_CREATE) 消息：不能从另一个存储子程序中创建%s。 · 错误：1304 SQLSTATE: 42000 (ER_SP_ALREADY_EXISTS) 消息：%s %s已存在。 · 错误：1305 SQLSTATE: 42000 (ER_SP_DOES_NOT_EXIST) 消息：%s %s不存在。 · 错误：1306 SQLSTATE: HY000 (ER_SP_DROP_FAILED) 消息：DROP %s %s失败 · 错误：1307 SQLSTATE: HY000 (ER_SP_STORE_FAILED) 消息：CREATE %s %s失败。 · 错误：1308 SQLSTATE: 42000 (ER_SP_LILABEL_MISMATCH) 消息：%s无匹配标签: %s · 错误：1309 SQLSTATE: 42000 (ER_SP_LABEL_REDEFINE) 消息：重新定义标签%s · 错误：1310 SQLSTATE: 42000 (ER_SP_LABEL_MISMATCH) 消息：末端标签%s无匹配项 · 错误：1311 SQLSTATE: 01000 (ER_SP_UNINIT_VAR) 消息：正在引用未初始化的变量%s。 · 错误：1312 SQLSTATE: 0A000 (ER_SP_BADSELECT) 消息：PROCEDURE %s不能在给定场景下返回结果集。 · 错误：1313 SQLSTATE: 42000 (ER_SP_BADRETURN) 消息：仅在FUNCTION中允许RETURN。 · 错误：1314 SQLSTATE: 0A000 (ER_SP_BADSTATEMENT) 消息：在存储程序中不允许%s。 · 错误：1315 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_IGNORED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE被忽略。 · 错误：1316 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_TRANSLATED) 消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE已被截短为SET SQL_LOG_BIN。 · 错误：1317 SQLSTATE: 70100 (ER_QUERY_INTERRUPTED) 消息：查询执行被中断。 · 错误：1318 SQLSTATE: 42000 (ER_SP_WRONG_NO_OF_ARGS) 消息：对于%s %s，参量数目不正确，预期为%u，但却是%u。 · 错误：1319 SQLSTATE: 42000 (ER_SP_COND_MISMATCH) 消息：未定义的CONDITION: %s · 错误：1320 SQLSTATE: 42000 (ER_SP_NORETURN) 消息：在FUNCTION %s中未发现RETURN。 · 错误：1321 SQLSTATE: 2F005 (ER_SP_NORETURNEND) 消息：FUNCTION %s结束时缺少RETURN。 · 错误：1322 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_QUERY) 消息：光标语句必须是SELECT。 · 错误：1323 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_SELECT) 消息：光标SELECT不得有INTO。 · 错误：1324 SQLSTATE: 42000 (ER_SP_CURSOR_MISMATCH) 消息：未定义的CURSOR: %s · 错误：1325 SQLSTATE: 24000 (ER_SP_CURSOR_ALREADY_OPEN) 消息：光标已打开 · 错误：1326 SQLSTATE: 24000 (ER_SP_CURSOR_NOT_OPEN) 消息：光标未打开 · 错误：1327 SQLSTATE: 42000 (ER_SP_UNDECLARED_VAR) 消息：未声明的变量：%s · 错误：1328 SQLSTATE: HY000 (ER_SP_WRONG_NO_OF_FETCH_ARGS) 消息：不正确的FETCH变量数目。 · 错误：1329 SQLSTATE: 02000 (ER_SP_FETCH_NO_DATA) 消息：FETCH无数据。 · 错误：1330 SQLSTATE: 42000 (ER_SP_DUP_PARAM) 消息：重复参数: %s · 错误：1331 SQLSTATE: 42000 (ER_SP_DUP_VAR) 消息：重复变量: %s · 错误：1332 SQLSTATE: 42000 (ER_SP_DUP_COND) 消息：重复条件: %s · 错误：1333 SQLSTATE: 42000 (ER_SP_DUP_CURS) 消息：重复光标: %s · 错误：1334 SQLSTATE: HY000 (ER_SP_CANT_ALTER) 消息：ALTER %s %s失败。 · 错误：1335 SQLSTATE: 0A000 (ER_SP_SUBSELECT_NYI) 消息：不支持Subselect值。 · 错误：1336 SQLSTATE: 0A000 (ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许%s。 · 错误：1337 SQLSTATE: 42000 (ER_SP_VARCOND_AFTER_CURSHNDLR) 消息：光标或句柄声明后面的变量或条件声明。 · 错误：1338 SQLSTATE: 42000 (ER_SP_CURSOR_AFTER_HANDLER) 消息：句柄声明后面的光标声明。 · 错误：1339 SQLSTATE: 20000 (ER_SP_CASE_NOT_FOUND) 消息：对于CASE语句，未发现Case。 · 错误：1340 SQLSTATE: HY000 (ER_FPARSER_TOO_BIG_FILE) 消息：配置文件’%s’过大。 · 错误：1341 SQLSTATE: HY000 (ER_FPARSER_BAD_HEADER) 消息：文件’%s’中存在残缺的文件类型标题。 · 错误：1342 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_COMMENT) 消息：解析’%s’时，文件意外结束。 · 错误：1343 SQLSTATE: HY000 (ER_FPARSER_ERROR_IN_PARAMETER) 消息：解析参数’%s’时出错（行：’%s’）。 · 错误：1344 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER) 消息：跳过未知参数’%s’时，文件意外结束。 · 错误：1345 SQLSTATE: HY000 (ER_VIEW_NO_EXPLAIN) 消息：EXPLAIN/SHOW无法发出，缺少对基本表的权限。 · 错误：1346 SQLSTATE: HY000 (ER_FRM_UNKNOWN_TYPE) 消息：文件’%s’在其题头中有未知的类型’%s’。 · 错误：1347 SQLSTATE: HY000 (ER_WRONG_OBJECT) 消息：’%s.%s’不是%s。 · 错误：1348 SQLSTATE: HY000 (ER_NONUPDATEABLE_COLUMN) 消息：列’%s’不可更新。 · 错误：1349 SQLSTATE: HY000 (ER_VIEW_SELECT_DERIVED) 消息：视图的SELECT在FROM子句中包含子查询。 · 错误：1350 SQLSTATE: HY000 (ER_VIEW_SELECT_CLAUSE) 消息：视图的SELECT包含’%s’子句。 · 错误：1351 SQLSTATE: HY000 (ER_VIEW_SELECT_VARIABLE) 消息：视图的SELECT包含1个变量或参数。 · 错误：1352 SQLSTATE: HY000 (ER_VIEW_SELECT_TMPTABLE) 消息：视图的SELECT引用了临时表’%s’。 · 错误：1353 SQLSTATE: HY000 (ER_VIEW_WRONG_LIST) 消息：视图的SELECT和视图的字段列表有不同的列计数。 · 错误：1354 SQLSTATE: HY000 (ER_WARN_VIEW_MERGE) 消息：此时，不能在这里使用视图合并算法（假定未定义算法）。 · 错误：1355 SQLSTATE: HY000 (ER_WARN_VIEW_WITHOUT_KEY) 消息：正在更新的视图没有其基本表的完整键。 · 错误：1356 SQLSTATE: HY000 (ER_VIEW_INVALID) 消息：视图’%s.%s’引用了无效的表、列、或函数，或视图的定义程序／调用程序缺少使用它们的权限。 · 错误：1357 SQLSTATE: HY000 (ER_SP_NO_DROP_SP) 消息：无法从另一个存储子程序中撤销或更改%s。 · 错误：1358 SQLSTATE: HY000 (ER_SP_GOTO_IN_HNDLR) 消息：在存储子程序句柄中不允许GOTO。 · 错误：1359 SQLSTATE: HY000 (ER_TRG_ALREADY_EXISTS) 消息：触发程序已存在。 · 错误：1360 SQLSTATE: HY000 (ER_TRG_DOES_NOT_EXIST) 消息：触发程序不存在。 · 错误：1361 SQLSTATE: HY000 (ER_TRG_ON_VIEW_OR_TEMP_TABLE) 消息：触发程序的’%s’是视图或临时表。 · 错误：1362 SQLSTATE: HY000 (ER_TRG_CANT_CHANGE_ROW) 消息：在%strigger中，不允许更新%s行。 · 错误：1363 SQLSTATE: HY000 (ER_TRG_NO_SUCH_ROW_IN_TRG) 消息：在%s触发程序中没有%s行。 · 错误：1364 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_FIELD) 消息：字段’%s’没有默认值。 · 错误：1365 SQLSTATE: 22012 (ER_DIVISION_BY_ZERO) 消息：被0除。 · 错误：1366 SQLSTATE: HY000 (ER_TRUNCATED_WRONG_VALUE_FOR_FIELD) 消息：不正确的%s值，’%s’，对于行%ld 上的列’%s’。 · 错误：1367 SQLSTATE: 22007 (ER_ILLEGAL_VALUE_FOR_TYPE) 消息：解析过程中发现非法%s ‘%s’值。 · 错误：1368 SQLSTATE: HY000 (ER_VIEW_NONUPD_CHECK) 消息：不可更新视图’%s.%s’上的CHECK OPTION。 · 错误：1369 SQLSTATE: HY000 (ER_VIEW_CHECK_FAILED) 消息：CHECK OPTION失败，’%s.%s’ · 错误：1370 SQLSTATE: 42000 (ER_PROCACCESS_DENIED_ERROR) 消息：对于子程序’%s’，拒绝用户‘%s‘@’%s’使用%s命令。 · 错误：1371 SQLSTATE: HY000 (ER_RELAY_LOG_FAIL) 消息：清除旧中继日志失败，%s · 错误：1372 SQLSTATE: HY000 (ER_PASSWD_LENGTH) 消息：密码混编应是%d位的十六进制数。 · 错误：1373 SQLSTATE: HY000 (ER_UNKNOWN_TARGET_BINLOG) 消息：在binlog索引中未发现目标日志。 · 错误：1374 SQLSTATE: HY000 (ER_IO_ERR_LOG_INDEX_READ) 消息：读取日志索引文件时出现I/O错误。 · 错误：1375 SQLSTATE: HY000 (ER_BINLOG_PURGE_PROHIBITED) 消息：服务器配置不允许binlog清除。 · 错误：1376 SQLSTATE: HY000 (ER_FSEEK_FAIL) 消息：fseek()失败。 · 错误：1377 SQLSTATE: HY000 (ER_BINLOG_PURGE_FATAL_ERR) 消息：在日志清除过程中出现致命错误。 · 错误：1378 SQLSTATE: HY000 (ER_LOG_IN_USE) 消息：可清除的日志正在使用，不能清除。 · 错误：1379 SQLSTATE: HY000 (ER_LOG_PURGE_UNKNOWN_ERR) 消息：在日志清除过程中出现未知错误。 · 错误：1380 SQLSTATE: HY000 (ER_RELAY_LOG_INIT) 消息：初始化中继日志位置失败，%s · 错误：1381 SQLSTATE: HY000 (ER_NO_BINARY_LOGGING) 消息：未使用二进制日志功能。 · 错误：1382 SQLSTATE: HY000 (ER_RESERVED_SYNTAX) 消息：’%s’语法保留给MySQL服务器内部使用。 · 错误：1383 SQLSTATE: HY000 (ER_WSAS_FAILED) 消息：WSAStartup失败。 · 错误：1384 SQLSTATE: HY000 (ER_DIFF_GROUPS_PROC) 消息：尚不能用不同的组处理过程。 · 错误：1385 SQLSTATE: HY000 (ER_NO_GROUP_FOR_PROC) 消息：对于该过程，SELECT必须有1个组。 · 错误：1386 SQLSTATE: HY000 (ER_ORDER_WITH_PROC) 消息：不能与该过程一起使用ORDER子句。 · 错误：1387 SQLSTATE: HY000 (ER_LOGGING_PROHIBIT_CHANGING_OF) 消息：二进制日志功能和复制功能禁止更改全局服务器%s。 · 错误：1388 SQLSTATE: HY000 (ER_NO_FILE_MAPPING) 消息：无法映射文件: %s, errno: %d · 错误：1389 SQLSTATE: HY000 (ER_WRONG_MAGIC) 消息：%s中有错 · 错误：1390 SQLSTATE: HY000 (ER_PS_MANY_PARAM) 消息：预处理语句包含过多的占位符。 · 错误：1391 SQLSTATE: HY000 (ER_KEY_PART_0) 消息：键部分’%s’的长度不能为0。 · 错误：1392 SQLSTATE: HY000 (ER_VIEW_CHECKSUM) 消息：视图文本校验和失败。 · 错误：1393 SQLSTATE: HY000 (ER_VIEW_MULTIUPDATE) 消息：无法通过联合视图’%s.%s’更改1个以上的基本表。 · 错误：1394 SQLSTATE: HY000 (ER_VIEW_NO_INSERT_FIELD_LIST) 消息：不能在没有字段列表的情况下插入联合视图’%s.%s’。 · 错误：1395 SQLSTATE: HY000 (ER_VIEW_DELETE_MERGE_VIEW) 消息：不能从联合视图’%s.%s’中删除。 · 错误：1396 SQLSTATE: HY000 (ER_CANNOT_USER) 消息：对于%s的操作%s失败。 · 错误：1397 SQLSTATE: XAE04 (ER_XAER_NOTA) 消息：XAER_NOTA: 未知XID · 错误：1398 SQLSTATE: XAE05 (ER_XAER_INVAL) 消息：XAER_INVAL: 无效参量（或不支持的命令） · 错误：1399 SQLSTATE: XAE07 (ER_XAER_RMFAIL) 消息：XAER_RMFAIL: 当全局事务处于%s状态时，不能执行命令。 · 错误：1400 SQLSTATE: XAE09 (ER_XAER_OUTSIDE) 消息：XAER_OUTSIDE: 某些工作是在全局事务外完成的。 · 错误：1401 SQLSTATE: XAE03 (ER_XAER_RMERR) 消息：XAER_RMERR: 在事务分支中出现致命错误，请检查数据一致性。 · 错误：1402 SQLSTATE: XA100 (ER_XA_RBROLLBACK) 消息：XA_RBROLLBACK: 回滚了事务分支。 · 错误：1403 SQLSTATE: 42000 (ER_NONEXISTING_PROC_GRANT) 消息：在子程序’%s’上没有为主机’%s’上的用户’%s’定义的这类授权。 · 错误：1404 SQLSTATE: HY000 (ER_PROC_AUTO_GRANT_FAIL) 消息：无法授予EXECUTE和ALTER ROUTINE权限。 · 错误：1405 SQLSTATE: HY000 (ER_PROC_AUTO_REVOKE_FAIL) 消息：无法撤销已放弃子程序上的所有权限。 · 错误：1406 SQLSTATE: 22001 (ER_DATA_TOO_LONG) 消息：对于行%ld上的列’%s’来说，数据过长。 · 错误：1407 SQLSTATE: 42000 (ER_SP_BAD_SQLSTATE) 消息：不良SQLSTATE: ‘%s’ · 错误：1408 SQLSTATE: HY000 (ER_STARTUP) 消息：%s，连接就绪；版本，’%s’；套接字，’%s’；端口，%d %s · 错误：1409 SQLSTATE: HY000 (ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR) 消息：不能从具有固定大小行的文件中将值加载到变量。 · 错误：1410 SQLSTATE: 42000 (ER_CANT_CREATE_USER_WITH_GRANT) 消息：不允许用GRANT创建用户。 · 错误：1411 SQLSTATE: HY000 (ER_WRONG_VALUE_FOR_TYPE) 消息：不正确的%s值，’%s’，对于函数%s · 错误：1412 SQLSTATE: HY000 (ER_TABLE_DEF_CHANGED) 消息：表定义已更改，请再次尝试事务。 · 错误：1413 SQLSTATE: 42000 (ER_SP_DUP_HANDLER) 消息：在相同块中声明了重复句柄。 · 错误：1414 SQLSTATE: 42000 (ER_SP_NOT_VAR_ARG) 消息：子程序%s的OUT或INOUT参量不是变量。 · 错误：1415 SQLSTATE: 0A000 (ER_SP_NO_RETSET) 消息：不允许从%s返回结果集。 · 错误：1416 SQLSTATE: 22003 (ER_CANT_CREATE_GEOMETRY_OBJECT) 消息：不能从发送给GEOMETRY字段的数据中获取几何对象。 · 错误：1417 SQLSTATE: HY000 (ER_FAILED_ROUTINE_BREAK_BINLOG) 消息：1个子程序失败，在其声明没有NO SQL或READS SQL DATA，而且二进制日志功能已启用，如果更新了非事务性表，二进制日志将丢失其变化信息。 · 错误：1418 SQLSTATE: HY000 (ER_BINLOG_UNSAFE_ROUTINE) 消息：在该子程序的在其声明没有DETERMINISTIC、NO SQL或READS SQL DATA，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变量）。 · 错误：1419 SQLSTATE: HY000 (ER_BINLOG_CREATE_ROUTINE_NEED_SUPER) 消息：你没有SUPER权限，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变量）。 · 错误：1420 SQLSTATE: HY000 (ER_EXEC_STMT_WITH_OPEN_CURSOR) 消息：不能执行该预处理语句，该预处理语句有与之相关的打开光标。请复位语句并再次执行。 · 错误：1421 SQLSTATE: HY000 (ER_STMT_HAS_NO_OPEN_CURSOR) 消息：语句(%lu)没有打开的光标。 · 错误：1422 SQLSTATE: HY000 (ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG) 消息：在存储函数或触发程序中，不允许显式或隐式提交。 · 错误：1423 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_VIEW_FIELD) 消息：视图’%s.%s’基本表的字段没有默认值。 · 错误：1424 SQLSTATE: HY000 (ER_SP_NO_RECURSION) 消息：不允许递归存储子程序。 · 错误：1425 SQLSTATE: 42000 (ER_TOO_BIG_SCALE) 消息：为列’%s’指定了过大的标度%d。最大为%d。 · 错误：1426 SQLSTATE: 42000 (ER_TOO_BIG_PRECISION) 消息：为列’%s’指定了过高的精度%d。最大为%d。 · 错误：1427 SQLSTATE: 42000 (ER_M_BIGGER_THAN_D) 消息：对于float(M,D)、double(M,D)或decimal(M,D)，M必须&gt;= D (列’%s’)。 · 错误：1428 SQLSTATE: HY000 (ER_WRONG_LOCK_OF_SYSTEM_TABLE) 消息：不能将系统’%s.%s’表的写锁定与其他表结合起来。 · 错误：1429 SQLSTATE: HY000 (ER_CONNECT_TO_FOREIGN_DATA_SOURCE) 消息：无法连接到外部数据源，数据库’%s’！ · 错误：1430 SQLSTATE: HY000 (ER_QUERY_ON_FOREIGN_DATA_SOURCE) 消息：处理作用在外部数据源上的查询时出现问题。数据源错误：’%s’ · 错误：1431 SQLSTATE: HY000 (ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST) 消息：你试图引用的外部数据源不存在。数据源错误：’%s’ · 错误：1432 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE) 消息：无法创建联合表。数据源连接字符串’%s’格式不正确。 · 错误：1433 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID) 消息：数据源连接字符串’%s’格式不正确。 · 错误：1434 SQLSTATE: HY000 (ER_CANT_CREATE_FEDERATED_TABLE) 消息：无法创建联合表。外部数据源错误：’%s’ · 错误：1435 SQLSTATE: HY000 (ER_TRG_IN_WRONG_SCHEMA) 消息：触发程序位于错误的方案中。 · 错误：1436 SQLSTATE: HY000 (ER_STACK_OVERRUN_NEED_MORE) 消息：线程堆栈溢出，%ld字节堆栈用了%ld字节，并需要%ld字节。请使用’mysqld -O thread_stack=#’指定更大的堆栈。 · 错误：1437 SQLSTATE: 42000 (ER_TOO_LONG_BODY) 消息：’%s’的子程序主体过长。 · 错误：1438 SQLSTATE: HY000 (ER_WARN_CANT_DROP_DEFAULT_KEYCACHE) 消息：无法撤销默认的keycache。 · 错误：1439 SQLSTATE: 42000 (ER_TOO_BIG_DISPLAYWIDTH) 消息：对于列’%s’，显示宽度超出范围(max = %d) · 错误：1440 SQLSTATE: XAE08 (ER_XAER_DUPID) 消息：XAER_DUPID: XID已存在 · 错误：1441 SQLSTATE: 22008 (ER_DATETIME_FUNCTION_OVERFLOW) 消息：日期时间函数，%s字段溢出。 · 错误：1442 SQLSTATE: HY000 (ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG) 消息：由于它已被调用了该存储函数／触发程序的语句使用，不能在存储函数／触发程序中更新表’%s’。 · 错误：1443 SQLSTATE: HY000 (ER_VIEW_PREVENT_UPDATE) 消息：表’%s’的定义不允许在表’%s上执行操作%s。 · 错误：1444 SQLSTATE: HY000 (ER_PS_NO_RECURSION) 消息：预处理语句包含引用了相同语句的存储子程序调用。不允许以这类递归方式执行预处理语句。 · 错误：1445 SQLSTATE: HY000 (ER_SP_CANT_SET_AUTOCOMMIT) 消息：不允许从存储函数或触发程序设置autocommit。 · 错误：1446 SQLSTATE: HY000 (ER_NO_VIEW_USER) 消息：视图定义人不完全合格。 · 错误：1447 SQLSTATE: HY000 (ER_VIEW_FRM_NO_USER) 消息：视图%s.%s没有定义人信息（旧的表格式）。当前用户将被当作定义人。请重新创建视图！ · 错误：1448 SQLSTATE: HY000 (ER_VIEW_OTHER_USER) 消息：需要SUPER权限才能创建具有%s@%s定义器的视图。 · 错误：1449 SQLSTATE: HY000 (ER_NO_SUCH_USER) 消息：没有注册的%s@%s。 · 错误：1450 SQLSTATE: HY000 (ER_FORBID_SCHEMA_CHANGE) 消息：不允许将方案从’%s’变为’%s’。 · 错误：1451 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED_2) 消息：不能删除或更新父行，外键约束失败(%s)。 · 错误：1452 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW_2) 消息：不能添加或更新子行，外键约束失败(%s)。 · 错误：1453 SQLSTATE: 42000 (ER_SP_BAD_VAR_SHADOW) 消息：必须用...引用变量，或重新命名变量。 · 错误：1454 SQLSTATE: HY000 (ER_PARTITION_REQUIRES_VALUES_ERROR) 消息：对于每个分区，%s PARTITIONING需要VALUES %s的定义。 · 错误：1455 SQLSTATE: HY000 (ER_PARTITION_WRONG_VALUES_ERROR) 消息：在分区定义中，只有%s PARTITIONING能使用VALUES %s。 · 错误：1456 SQLSTATE: HY000 (ER_PARTITION_MAXVALUE_ERROR) 消息：MAXVALUE只能在最后1个分区定义中使用。 · 错误：1457 SQLSTATE: HY000 (ER_PARTITION_SUBPARTITION_ERROR) 消息：子分区只能是哈希分区，并按键分区。 · 错误：1458 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_PART_ERROR) 消息：定义了错误的分区数，与前面的设置不匹配。 · 错误：1459 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_SUBPART_ERROR) 消息：定义了错误的子分区数，与前面的设置不匹配。 · 错误：1460 SQLSTATE: HY000 (ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR) 消息：在分区（子分区）函数中不允许使用常量／随机表达式。 · 错误：1461 SQLSTATE: HY000 (ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR) 消息：RANGE/LIST VALUES中的表达式必须是常量。 · 错误：1462 SQLSTATE: HY000 (ER_FIELD_NOT_FOUND_PART_ERROR) 消息：在表中未发现分区函数字段列表中的字段。 · 错误：1463 SQLSTATE: HY000 (ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR) 消息：仅在KEY分区中允许使用字段列表。 · 错误：1464 SQLSTATE: HY000 (ER_INCONSISTENT_PARTITION_INFO_ERROR) 消息：frm文件中的分区信息与能够写入到frm文件中的不一致。 · 错误：1465 SQLSTATE: HY000 (ER_PARTITION_FUNC_NOT_ALLOWED_ERROR) 消息：%s函数返回了错误类型。 · 错误：1466 SQLSTATE: HY000 (ER_PARTITIONS_MUST_BE_DEFINED_ERROR) 消息：对于%s分区，必须定义每个分区。 · 错误：1467 SQLSTATE: HY000 (ER_RANGE_NOT_INCREASING_ERROR) 消息：对于各分区，VALUES LESS THAN值必须严格增大。 · 错误：1468 SQLSTATE: HY000 (ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR) 消息：VALUES值必须与分区函数具有相同的类型。 · 错误：1469 SQLSTATE: HY000 (ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR) 消息：Multiple definition of same constant in list partitioning · 错误：1470 SQLSTATE: HY000 (ER_PARTITION_ENTRY_ERROR) 消息：在查询中，不能独立使用分区功能。 · 错误：1471 SQLSTATE: HY000 (ER_MIX_HANDLER_ERROR) 消息：在该MySQL版本中，不允许分区中的句柄组合。 · 错误：1472 SQLSTATE: HY000 (ER_PARTITION_NOT_DEFINED_ERROR) 消息：对于分区引擎，有必要定义所有的%s。 · 错误：1473 SQLSTATE: HY000 (ER_TOO_MANY_PARTITIONS_ERROR) 消息：定义了过多分区。 · 错误：1474 SQLSTATE: HY000 (ER_SUBPARTITION_ERROR) 消息：对于子分区，仅能将RANGE/LIST分区与HASH/KEY分区混合起来。 · 错误：1475 SQLSTATE: HY000 (ER_CANT_CREATE_HANDLER_FILE) 消息：无法创建特定的句柄文件。 · 错误：1476 SQLSTATE: HY000 (ER_BLOB_FIELD_IN_PART_FUNC_ERROR) 消息：在分区函数中，不允许使用BLOB字段。 · 错误：1477 SQLSTATE: HY000 (ER_CHAR_SET_IN_PART_FIELD_ERROR) 消息：如果为分区函数选择了二进制校对，才允许使用VARCHAR。 · 错误：1478 SQLSTATE: HY000 (ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF) 消息：在分区函数中，%s需要包含所有文件。 · 错误：1479 SQLSTATE: HY000 (ER_NO_PARTS_ERROR) 消息：%s的数目= 0不是允许的值。 · 错误：1480 SQLSTATE: HY000 (ER_PARTITION_MGMT_ON_NONPARTITIONED) 消息：无法在非分区表上进行分区管理。 · 错误：1481 SQLSTATE: HY000 (ER_DROP_PARTITION_NON_EXISTENT) 消息：分区列表中的错误出现变化。 · 错误：1482 SQLSTATE: HY000 (ER_DROP_LAST_PARTITION) 消息：不能删除所有分区，请使用DROP TABLE取而代之。 · 错误：1483 SQLSTATE: HY000 (ER_COALESCE_ONLY_ON_HASH_PARTITION) 消息：COALESCE PARTITION仅能在HASH/KEY分区上使用。 · 错误：1484 SQLSTATE: HY000 (ER_ONLY_ON_RANGE_LIST_PARTITION) 消息：%s PARTITION仅能在RANGE/LIST分区上使用。 · 错误：1485 SQLSTATE: HY000 (ER_ADD_PARTITION_SUBPART_ERROR) 消息：试图用错误的子分区数增加分区。 · 错误：1486 SQLSTATE: HY000 (ER_ADD_PARTITION_NO_NEW_PARTITION) 消息：必须至少添加1个分区。 · 错误：1487 SQLSTATE: HY000 (ER_COALESCE_PARTITION_NO_PARTITION) 消息：必须至少合并1个分区。 · 错误：1488 SQLSTATE: HY000 (ER_REORG_PARTITION_NOT_EXIST) 消息：重组的分区数超过了已有的分区数。 · 错误：1489 SQLSTATE: HY000 (ER_SAME_NAME_PARTITION) 消息：在表中，所有分区必须有唯一的名称。 · 错误：1490 SQLSTATE: HY000 (ER_CONSECUTIVE_REORG_PARTITIONS) 消息：重组分区集合时，它们必须连续。 · 错误：1491 SQLSTATE: HY000 (ER_REORG_OUTSIDE_RANGE) 消息：新分区的范围超过了已重组分区的范围。 · 错误：1492 SQLSTATE: HY000 (ER_DROP_PARTITION_FAILURE) 消息：在该版本的句柄中，不支持撤销分区。 · 错误：1493 SQLSTATE: HY000 (ER_DROP_PARTITION_WHEN_FK_DEFINED) 消息：在表上定义了外键约束时，不能舍弃分区。 · 错误：1494 SQLSTATE: HY000 (ER_PLUGIN_IS_NOT_LOADED) 消息：未加载插件’%s’ B.2. 客户端错误代码和消息客户端错误信息来自下述源文件： · 圆括号中的错误值和符号与include/errmsg.h MySQL源文件中的定义对应。 · 消息值与libmysql/errmsg.c文件中列出的错误消息对应。%d和%s分别代表数值和字符串，显示时，它们将被消息值取代。 由于更新很频繁，这些文件中可能包含这里未列出的额外错误消息。 · 错误：2000 (CR_UNKNOWN_ERROR) 消息：未知MySQL错误。 · 错误：2001 (CR_SOCKET_CREATE_ERROR) 消息：不能创建UNIX套接字(%d) · 错误：2002 (CR_CONNECTION_ERROR) 消息：不能通过套接字’%s’ (%d)连接到本地MySQL服务器。 · 错误：2003 (CR_CONN_HOST_ERROR) 消息：不能连接到’%s’ (%d)上的MySQL服务器。 · 错误：2004 (CR_IPSOCK_ERROR) 消息：不能创建TCP/IP套接字(%d) · 错误：2005 (CR_UNKNOWN_HOST) 消息：未知的MySQL服务器主机’%s’ (%d) · 错误：2006 (CR_SERVER_GONE_ERROR) 消息：MySQL服务器不可用。 · 错误：2007 (CR_VERSION_ERROR) 消息：协议不匹配，服务器版本= %d，客户端版本= %d · 错误：2008 (CR_OUT_OF_MEMORY) 消息：MySQL客户端内存溢出。 · 错误：2009 (CR_WRONG_HOST_INFO) 消息：错误的主机信息 · 错误：2010 (CR_LOCALHOST_CONNECTION) 消息：通过UNIX套接字连接的本地主机。 · 错误：2011 (CR_TCP_CONNECTION) 消息：%s，通过TCP/IP · 错误：2012 (CR_SERVER_HANDSHAKE_ERR) 消息：服务器握手过程中出错。 · 错误：2013 (CR_SERVER_LOST) 消息：查询过程中丢失了与MySQL服务器的连接。 · 错误：2014 (CR_COMMANDS_OUT_OF_SYNC) 消息：命令不同步，你现在不能运行该命令。 · 错误：2015 (CR_NAMEDPIPE_CONNECTION) 消息：命名管道，%s · 错误：2016 (CR_NAMEDPIPEWAIT_ERROR) 消息：无法等待命名管道，主机，%s；管道，%s (%lu) · 错误：2017 (CR_NAMEDPIPEOPEN_ERROR) 消息：无法打开命名管道，主机，%s；管道，%s (%lu) · 错误：2018 (CR_NAMEDPIPESETSTATE_ERROR) 消息：无法设置命名管道的状态，主机，%s；管道，%s (%lu) · 错误：2019 (CR_CANT_READ_CHARSET) 消息：无法初始化字符集%s (路径：%s) · 错误：2020 (CR_NET_PACKET_TOO_LARGE) 消息：获得的信息包大于’max_allowed_packet’字节。 · 错误：2021 (CR_EMBEDDED_CONNECTION) 消息：嵌入式服务器。 · 错误：2022 (CR_PROBE_SLAVE_STATUS) 消息：SHOW SLAVE STATUS出错： · 错误：2023 (CR_PROBE_SLAVE_HOSTS) 消息：SHOW SLAVE HOSTS出错： · 错误：2024 (CR_PROBE_SLAVE_CONNECT) 消息：连接到从服务器时出错： · 错误：2025 (CR_PROBE_MASTER_CONNECT) 消息：连接到主服务器时出错： · 错误：2026 (CR_SSL_CONNECTION_ERROR) 消息：SSL连接错误 · 错误：2027 (CR_MALFORMED_PACKET) 消息：残缺信息包。 · 错误：2028 (CR_WRONG_LICENSE) 消息：该客户端库仅授权给具有’%s’许可的MySQL服务器使用。 · 错误：2029 (CR_NULL_POINTER) 消息：空指针的无效使用。 · 错误：2030 (CR_NO_PREPARE_STMT) 消息：语句未准备好。 · 错误：2031 (CR_PARAMS_NOT_BOUND) 消息：没有为预处理语句中的参数提供数据。 · 错误：2032 (CR_DATA_TRUNCATED) 消息：数据截短。 · 错误：2033 (CR_NO_PARAMETERS_EXISTS) 消息：语句中不存在任何参数。 · 错误：2034 (CR_INVALID_PARAMETER_NO) 消息：无效的参数编号。 · 错误：2035 (CR_INVALID_BUFFER_USE) 消息：不能为非字符串／非二进制数据类型发送长数据（参数：%d）。 · 错误：2036 (CR_UNSUPPORTED_PARAM_TYPE) 消息：正使用不支持的缓冲区类型， %d （参数：%d） · 错误：2037 (CR_SHARED_MEMORY_CONNECTION) 消息：共享内存，%s · 错误：2038 (CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR) 消息：不能打开共享内存，客户端不能创建请求事件(%lu) · 错误：2039 (CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR) 消息：不能打开共享内存，未收到服务器的应答事件(%lu) · 错误：2040 (CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR) 消息：不能打开共享内存，服务器不能分配文件映射(%lu) · 错误：2041 (CR_SHARED_MEMORY_CONNECT_MAP_ERROR) 消息：不能打开共享内存，服务器不能获得文件映射的指针(%lu) · 错误：2042 (CR_SHARED_MEMORY_FILE_MAP_ERROR) 消息：不能打开共享内存，客户端不能分配文件映射(%lu) · 错误：2043 (CR_SHARED_MEMORY_MAP_ERROR) 消息：不能打开共享内存，客户端不能获得文件映射的指针(%lu) · 错误：2044 (CR_SHARED_MEMORY_EVENT_ERROR) 消息：不能打开共享内存，客户端不能创建%s事件(%lu) · 错误：2045 (CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR) 消息：不能打开共享内存，无来自服务器的应答 (%lu) · 错误：2046 (CR_SHARED_MEMORY_CONNECT_SET_ERROR) 消息：不能打开共享内存，不能将请求事件发送到服务器(%lu) · 错误：2047 (CR_CONN_UNKNOW_PROTOCOL) 消息：错误或未知协议 · 错误：2048 (CR_INVALID_CONN_HANDLE) 消息：无效的连接句柄 · 错误：2049 (CR_SECURE_AUTH) 消息：拒绝使用旧鉴定协议（早于4.1.1）的连接（开启了客户端’secure_auth’选项）。 · 错误：2050 (CR_FETCH_CANCELED) 消息：行检索被mysql_stmt_close()调用取消。 · 错误：2051 (CR_NO_DATA) 消息：在未事先获取行的情况下试图读取列。 · 错误：2052 (CR_NO_STMT_METADATA) 消息：预处理语句不含元数据。 · 错误：2053 (CR_NO_RESULT_SET) 消息：在没有与语句相关的结果集时试图读取行。 · 错误：2054 (CR_NOT_IMPLEMENTED) 消息：该特性尚未实施。 分类: dateBase","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"善用佳软","date":"2015-04-22T06:13:09.000Z","path":"2015/04/22/善用佳软/","text":"毕业在即，整理四年旧物，足迹，笔记。除去曾嗜用一时的轻笔记，云笔记，彩云笔记，麦库记事，仅目前最常用的为知，有道，印象加在一起，就超过10000条笔记----换言之，四年里平均每天创建十条笔记。大致翻看，占比最多的是经济学尤其与地理历史人文结合在一起的区域经济，这大概就是即便对方是领域内的巨擘耆宿，也不惧与其坐而论道，面不赤红心不乱跳。除去初生牛犊不怕虎的莽劲，还有脑中并不太逊色于ta的数据作为支撑。 在过去没有互联网和搜索引擎的时代，做学问遇到显学问题，多要不耐其烦投身卷帙浩繁的书卷，费时费力。而今，已经早不是能学与不能学，而是想学与不想学的时代。在相当多的领域，一个有兴趣的孩子通过善用网络所获取的知识和掌握的技能，绝不会逊色最知名教授课上兴趣索然的学生。这一点，在以后会更为清晰明了。 此刻你我正经逢的互联网时代，被人称为是自500年前地理大发现后又一次世界范围的”connect”。作为勉强的第一代“互联网原住民”，除去阅历尚浅的年少轻狂，也确乎存在迥然于父辈这般大小时的一些特质，只不过，它被一句代际之间无论现在还是以后都必然的“生活水平提高”所覆盖，背后正默默发生正悄悄改变固有生活方式，只发仞于一代或几代的变革，却被忽略----当00后这群原汁原味的原住民长大我这个年纪，或如听过长尾理论，无事耐下性子看完索然寡味的&lt;世界是平的&gt;，&lt;未来是湿的&gt;，以及可堪经典的&lt;失控&gt;，对以上这段有些绕口的话所表达的意思，也许会多些认同。 早在大学之初对国内BAT三巨头有过这样的比较：它们的主业，即搜索引擎，电子商务还是即时通讯，哪一个对人的改变大一些？是改变人获取信息方式的“百度一下你就知道”，还是让商业地产不寒而栗快递业方兴未艾的电子商务，或者让运营商暴利锐减的即时通讯？相信多数人的答案会是和其原配夫人一般形影不离的淘宝和qq，极少是缺少用户黏性如同情人的百度。及至后来开始在自己感兴趣的几个并不高深的“显学”领域开疆拓土，对我而言答案坚定地变成了搜索引擎。 后来周鸿祎磨剑8年，携so.com欲雪旧恨，在so.com上线的前几天，有句首页金句让我深深赞同，“如果我们能妥善地利用搜索，则实在是已经改变了世界”。 当然，无论是上万条的笔记或是上T的资料，单单而言还只是一个数字，还只是纯浪费时间并无价值。我确无翻看旧时笔记的习惯，但翻看几篇，那天发生何事，多历历浮于脑中，更莫说已浏览过一遍的笔记资料。这个带给我无尽烦恼的特质，终于在这里有了小小的让人稍觉欣慰之处。","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"leetcode-面试题-09 用两个栈实现队列","date":"2015-03-31T16:00:09.000Z","path":"2015/04/01/leetcode-面试题-09-用两个栈实现队列/","text":"面试题09. 用两个栈实现队列 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-面试题-06 从尾到头打印链表","date":"2015-03-31T16:00:06.000Z","path":"2015/04/01/leetcode-面试题-06-从尾到头打印链表/","text":"面试题06. 从尾到头打印链表 难度: 简单 12345678910111213141516171819202122/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reversePrint(head *ListNode) []int &#123; res := make([]int,0) if head == nil &#123; return res &#125; temp := reversePrint(head.Next) res = append(res,temp...) res = append(res,head.Val) return res&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"数组及字符串相关算法汇总","date":"2015-03-26T15:50:03.000Z","path":"2015/03/26/数组及字符串相关算法汇总/","text":"数组字符串那些经典算法：最大子序列和，最长递增子序列，最长公共子串，最长公共子序列，字符串编辑距离，最长不重复子串，最长回文子串","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"操作系统相关入门","date":"2015-03-26T15:31:53.000Z","path":"2015/03/26/操作系统相关入门/","text":"找工作笔试面试那些事儿(13)—操作系统常考知识点总结","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"}]},{"title":"微软笔试题汇总","date":"2015-03-26T07:09:50.000Z","path":"2015/03/26/微软笔试题汇总/","text":"微软笔试题汇总分类解析","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"动态规划(DP)问题摘录","date":"2015-03-23T13:48:46.000Z","path":"2015/03/23/动态规划-DP-问题摘录/","text":"动态规划及面试，学完这一篇，你就入门了：Dynamic Programming, 动态规划，经典题目 闫氏DP分析法，从此再也不怕DP问题！ 哪本《数据结构与算法》最好？","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"二分查找","date":"2015-03-23T11:01:35.000Z","path":"2015/03/23/二分查找/","text":"1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\")func main() &#123; var lookingFor int = 6 var sortedArray []int = []int&#123;1, 3, 4, 6, 7, 9, 10, 11, 13&#125; index := binarySearch(sortedArray, lookingFor) fmt.Println(\"the array\", sortedArray) fmt.Println(\"the lookingFor\", lookingFor) if index &gt;= 0 &#123; fmt.Println(\"Find the index:\", index) &#125; else &#123; fmt.Println(\"Not Find the Data!\") &#125;&#125;func binarySearch(sortedArray []int, lookingFor int) int &#123; var low int = 0 var high int = len(sortedArray) - 1 for low &lt;= high &#123; var mid int = low + (high-low)/2 var midValue int = sortedArray[mid] if midValue == lookingFor &#123; return mid &#125; else if midValue &gt; lookingFor &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return -1&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"快速排序","date":"2015-03-22T13:03:50.000Z","path":"2015/03/22/快速排序/","text":"排序算法：快速排序【图解+代码】 动画详解排序算法之快速排序 Quick Sort 快速排序和二分查找法总结 使用 Go 实现快速排序 和CSP理论的提出者系自一人,即大名鼎鼎的托尼·霍尔（Tony Hoare）爵士 天神荟萃 sort.Sort的实现: 当待排序元素≤12时，使用希尔排序；当阈值为0时，使用堆排序。否则使用快速排序。在确定其分区点时，有一个三值取中的逻辑（元素数量不大于40时进行一次，大于40时进行三次）。根据注释的Tukey’s Ninther，了解到这是取中值的一个算法… “最优雅和高效的算法之一”, 使用golang,短止20行 算法思想是 分而治之和递归调用 通过选取一个pivot，将一个数组划分为两个子数组。 1.从数组中选择一个元素作为pivot 2.重新排列数组，小于pivot的在pivot的左边，大于pivot的在其右边。 3.递归地对划分后的左右两部分重复上述步骤。 排序算法汇总 确实如果不考虑 枢轴点(pivot)的选取,而定死以最后一个(或第一个)元素作为pivot,那快速排序的代码实现,确实并不复杂. 而在工业实现中,这个枢轴点的选取,一般会采用三值取中(当元素数较少)甚至九值取中(当元素数较多)… “取中”涉及到复杂的数学原理,面试时对方的渣渣水平,不足予论.只要写出定死枢轴值是最后一个元素的就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"math/rand\" \"sort\" \"time\")func partition(a []int, lo, hi int) int &#123; pivot := a[hi] // 关键一步,可以一眼看出选定的枢轴点是第一个元素还是最后一个元素,hi显然选取了最后一个元素 i := lo - 1 for j := lo; j &lt; hi; j++ &#123; if a[j] &lt; pivot &#123; i++ a[j], a[i] = a[i], a[j] &#125; &#125; a[i+1], a[hi] = a[hi], a[i+1] return i + 1&#125;func quickSort(a []int, lo, hi int) &#123; if lo &gt;= hi &#123; return &#125; p := partition(a, lo, hi) quickSort(a, lo, p-1) quickSort(a, p+1, hi)&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) testData1 := make([]int, 0, 100000000) times := 100000000 for i := 0; i &lt; times; i++ &#123; val := rand.Intn(20000000) testData1 = append(testData1, val) &#125; start := time.Now() quickSort(testData1, 0, len(testData1)-1) fmt.Println(\"single goroutine: \", time.Now().Sub(start)) if !sort.IntsAreSorted(testData1) &#123; fmt.Println(\"wrong quick_sort implementation\") &#125;&#125; 添加部分注释如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( \"fmt\" \"time\")func partition(a []int, lo, hi int) int &#123; pivot := a[hi] fmt.Println(\"未处理前的数组为:\", a) fmt.Println(\"pivot:\", pivot) fmt.Println(\"当前数组长度为:\", hi+1) fmt.Println(\"lo:\", lo) fmt.Println(\"hi:\", hi) fmt.Println(\"进行循环:\\n\\n\") i := lo - 1 for j := lo; j &lt; hi; j++ &#123; fmt.Println(\"****循环开始****\") fmt.Println(\"j is:\", j) if a[j] &lt; pivot &#123; i++ fmt.Println(\"i is:\", i) a[j], a[i] = a[i], a[j] fmt.Println(\"now a is:\", a) &#125; fmt.Println(\"-----循环结束----\") &#125; a[i+1], a[hi] = a[hi], a[i+1] fmt.Println(\"last a is:\", a) time.Sleep(1e9) return i + 1&#125;func quickSort(a []int, lo, hi int) &#123; if lo &gt;= hi &#123; return &#125; p := partition(a, lo, hi) fmt.Println(\"\\n\\n获取到当前p为:\", p) fmt.Println(\"开始递归:\\n\\n\\n\") quickSort(a, lo, p-1) fmt.Println(\"进行后半部分的排序\") quickSort(a, p+1, hi)&#125;func main() &#123; var list []int list = []int&#123;3, 7, 2, 3, 8, 0, 1, 9, 6, 5&#125; quickSort(list, 0, len(list)-1) fmt.Println(list)&#125; 返回值为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170j is: 0i is: 0now a is: [3 7 2 3 8 0 1 9 6 5]-----循环结束----****循环开始****j is: 1-----循环结束----****循环开始****j is: 2i is: 1now a is: [3 2 7 3 8 0 1 9 6 5]-----循环结束----****循环开始****j is: 3i is: 2now a is: [3 2 3 7 8 0 1 9 6 5]-----循环结束----****循环开始****j is: 4-----循环结束----****循环开始****j is: 5i is: 3now a is: [3 2 3 0 8 7 1 9 6 5]-----循环结束----****循环开始****j is: 6i is: 4now a is: [3 2 3 0 1 7 8 9 6 5]-----循环结束----****循环开始****j is: 7-----循环结束----****循环开始****j is: 8-----循环结束----last a is: [3 2 3 0 1 5 8 9 6 7]获取到当前p为: 5开始递归:未处理前的数组为: [3 2 3 0 1 5 8 9 6 7]pivot: 1当前数组长度为: 5lo: 0hi: 4进行循环:****循环开始****j is: 0-----循环结束----****循环开始****j is: 1-----循环结束----****循环开始****j is: 2-----循环结束----****循环开始****j is: 3i is: 0now a is: [0 2 3 3 1 5 8 9 6 7]-----循环结束----last a is: [0 1 3 3 2 5 8 9 6 7]获取到当前p为: 1开始递归:进行后半部分的排序未处理前的数组为: [0 1 3 3 2 5 8 9 6 7]pivot: 2当前数组长度为: 5lo: 2hi: 4进行循环:****循环开始****j is: 2-----循环结束----****循环开始****j is: 3-----循环结束----last a is: [0 1 2 3 3 5 8 9 6 7]获取到当前p为: 2开始递归:进行后半部分的排序未处理前的数组为: [0 1 2 3 3 5 8 9 6 7]pivot: 3当前数组长度为: 5lo: 3hi: 4进行循环:****循环开始****j is: 3-----循环结束----last a is: [0 1 2 3 3 5 8 9 6 7]获取到当前p为: 3开始递归:进行后半部分的排序进行后半部分的排序未处理前的数组为: [0 1 2 3 3 5 8 9 6 7]pivot: 7当前数组长度为: 10lo: 6hi: 9进行循环:****循环开始****j is: 6-----循环结束----****循环开始****j is: 7-----循环结束----****循环开始****j is: 8i is: 6now a is: [0 1 2 3 3 5 6 9 8 7]-----循环结束----last a is: [0 1 2 3 3 5 6 7 8 9]获取到当前p为: 7开始递归:进行后半部分的排序未处理前的数组为: [0 1 2 3 3 5 6 7 8 9]pivot: 9当前数组长度为: 10lo: 8hi: 9进行循环:****循环开始****j is: 8i is: 8now a is: [0 1 2 3 3 5 6 7 8 9]-----循环结束----last a is: [0 1 2 3 3 5 6 7 8 9]获取到当前p为: 9开始递归:进行后半部分的排序[0 1 2 3 3 5 6 7 8 9] 牛刀小用: leetcode-75. 颜色分类","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"算法通关40讲","date":"2015-03-01T07:09:23.000Z","path":"2015/03/01/算法通关40讲/","text":"参考: 算法面试40讲相关讲义 01丨合格程序员的第一步：算法与数据结构 区块链的数据结构: 链表+默克尔树 02丨如何事半功倍地学习算法与数据结构 一万小时定律 优先队列也就是堆 LRU Cache也是一种数据结构 03丨如何计算算法的复杂度 递归,不得不提斐波那契数列,其递归写法的时间复杂度是? O(2的n次方) 代码简洁,但执行次数过多,不是最优的. 主定律公司.. 以下常见的时间复杂度记住即可: 二分查找: O(logn) 二叉树的遍历(前/中/后): O(n) ? 快速排序/归并排序: O(nlogn) 04丨如何通过LeetCode来进行算法题目练习 05丨理论讲解：数组&amp;链表 数组: 在内存中连续;查询为O(1),插入/删除操作为O(n),因为要挪动后面的内容 链表: 查询O(n), 插入/删除O(1) 06丨面试题：反转一个单链表&amp;判断链表是否有环 链表的题目就是有时比较无聊,思考难度不大,但代码实现有些复杂..需要多练,且部分代码要记下来 07丨理论讲解：堆栈&amp;队列 中文博大精深… Stack可以叫”栈”,也可以叫”堆栈”, 但不能叫”堆”,堆特指’Heap’这种数据结构 既可以用数组实现,也可以用链表实现…但面试时一般都不会去问实现 阮一峰-Stack的三种含义 Big-O Cheat Sheet 08丨面试题：判断括号字符串是否有效 leetcode-20 有效的括号 09丨面试题：用队列实现栈&amp;用栈实现队列 leetcode-232 用栈实现队列 leetcode-225 用队列实现栈 10丨理论讲解：优先队列 11丨面试题：返回数据流中的第K大元素 12丨面试题：返回滑动窗口中的最大值 13丨理论讲解：哈希表 14丨面试题：有效的字母异位词 15丨面试题：两数之和 16丨面试题：三数之和 17丨理论讲解：树&amp;二叉树&amp;二叉搜索树 18丨面试题：验证二叉搜索树 19丨面试题：二叉树&amp;二叉搜索树的最近公共祖先 20丨理论讲解：二叉树遍历","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-1339 分裂二叉树的最大乘积","date":"2015-02-28T16:22:19.000Z","path":"2015/03/01/leetcode-1339-分裂二叉树的最大乘积/","text":"复旦大学2021年软件工程专业研究生考试,出了这道题(第4题),20分 1339. 分裂二叉树的最大乘积 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-1226 哲学家进餐","date":"2015-02-28T16:20:26.000Z","path":"2015/03/01/leetcode-1226-哲学家进餐/","text":"1226. 哲学家进餐 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-912 排序数组","date":"2015-02-28T16:15:12.000Z","path":"2015/03/01/leetcode-912-排序数组/","text":"912. 排序数组 难度: 中等 非常简单,排序,且没有要求时间复杂度,可以有10+种写法… 祭出快速排序 123456789101112131415161718192021222324252627282930func sortArray(nums []int) []int &#123; quicksort(nums,0,len(nums)-1) return nums&#125;func quicksort(nums []int, lo,hi int) &#123; if lo &gt;= hi &#123; return &#125; p := partition(nums,lo,hi) quicksort(nums,lo,p-1) quicksort(nums,p+1,hi)&#125;func partition(nums []int,lo,hi int) int &#123; pivot := nums[hi] i := lo-1 for j:=lo;j&lt;hi;j++ &#123; //一进循环就是一个判断,不满足直接下一次循环 if nums[j] &lt; pivot &#123; //满足的条件是当前元素的值要小于枢轴值 i++ nums[i],nums[j] = nums[j],nums[i] &#125; &#125; //注意,这个swap是在循环之外! nums[i+1],nums[hi] = nums[hi],nums[i+1] return i+1&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-887 鸡蛋掉落","date":"2015-02-28T16:14:47.000Z","path":"2015/03/01/leetcode-887-鸡蛋掉落/","text":"887. 鸡蛋掉落 难度: 困难 参考: 复工复产找工作？先来看看这道面试题：双蛋问题 从第12分钟开始 递归和动态规划的关系 看动画轻松理解「递归」与「动态规划」 在递归、分治策略、动态规划以及贪心算法之间的关系一文中提到, 斐波那契数列,如果用”纯递归解法”, 因为时间复杂度为指数,超过40就计算量就会非常大,但用”动态规划”则可以优化时间复杂度为O(n) 但凡DP，一定有递推关系，否则递推关系都没有就更别说什么子问题重复计算了。 动态规划用于解决 子问题有重复求解 的情况，既可以用递归实现，也可以用迭代实现(for循环的形式)； 理论上讲，任何递归写法的程序都可以改为for循环实现。 首先，”递归” 不是一种算法，而是一种编程写法。 递归是实现手段,动态规划则是解决问题的思想 动态规划本质是不是就是递归算法，再加上记忆功能呢？ 递归和动态规划 理解递归与动态规划–从 Fibonacci 函数的四种实现聊起","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-877 石子游戏","date":"2015-02-28T16:14:37.000Z","path":"2015/03/01/leetcode-877-石子游戏/","text":"877. 石子游戏 难度: 中等 用一行代码解决leetcode中等题","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-785 判断二分图","date":"2015-02-28T16:13:05.000Z","path":"2015/03/01/leetcode-785-判断二分图/","text":"&amp;此题为使用 图 问题的典型 &amp; 785. 判断二分图 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-772 基本计算器III","date":"2015-02-28T16:12:52.000Z","path":"2015/03/01/leetcode-772-基本计算器III/","text":"&amp;此题为 高频面试题-基本计算器 类型的典型 &amp; 772. 基本计算器III 难度: 困难 升级一下:支持减法 借助两个stack 将减号看做是加”负数” 继续升级:支持乘法和除法 需要考虑符号的优先级 最开始堆栈为空 继续升级:支持小括号","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-739 每日温度","date":"2015-02-28T16:12:19.000Z","path":"2015/03/01/leetcode-739-每日温度/","text":"&amp;此题为使用 栈/ Stack 求解的典型&amp; 739. 每日温度 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-704 二分查找","date":"2015-02-28T16:11:44.000Z","path":"2015/03/01/leetcode-704-二分查找/","text":"参见: 二分查找 90%以上的程序员无法正确无误地写出二分查找代码。—- Jon Bentley [Programming Pearls] 704. 二分查找 难度: 简单 12345678910111213141516func binarySearch(nums []int, target int) int &#123; low := 0 high := len(nums) - 1 for low &lt;= high &#123; middle := low + (high-low)/2 midValue := nums[middle] if midValue == target &#123; return middle &#125; else if midValue &gt; target &#123; high = middle - 1 &#125; else &#123; low = middle + 1 &#125; &#125; return -1&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-606 根据二叉树创建字符串","date":"2015-02-28T16:11:06.000Z","path":"2015/03/01/leetcode-606-根据二叉树创建字符串/","text":"606. 根据二叉树创建字符串 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-654 最大二叉树","date":"2015-02-28T16:10:54.000Z","path":"2015/03/01/leetcode-654-最大二叉树/","text":"654. 最大二叉树 难度: 中等 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-617 合并二叉树","date":"2015-02-28T16:10:17.000Z","path":"2015/03/01/leetcode-617-合并二叉树/","text":"617. 合并二叉树 难度: 简单 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-516 最长回文子序列","date":"2015-02-28T16:08:36.000Z","path":"2015/03/01/leetcode-516-最长回文子序列/","text":"&amp;此题为”动态规划-区间规划”类型的典型题目 &amp; 516. 最长回文子序列 难度: 中等 也可以用线性规划来解决","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-509 斐波那契数","date":"2015-02-28T16:08:29.000Z","path":"2015/03/01/leetcode-509-斐波那契数/","text":"509. 斐波那契数 难度: 简单 递归写法: 123456789func fib(N int) int &#123; if N &lt;= 1 &#123; return N &#125; return fib(N-1) + fib(N-2)&#125; 写法简洁,但效率却很低,会出现大量重复计算…(解决重复计算,优先考虑到的办法就是动态规划) 即约为 $\\frac{1}{\\sqrt{5} }\\cdot [ (1.618)^n + (0.618)^n$] 一般都认为这种写法的时间复杂度为: $O(2^n)$ : 求解F(n),必须先计算F(n-1)和F(n-2),计算F(n-1)和F(n-2)，又必须先计算F(n-3)和F(n-4)…. 以此类推，直至必须先计算F(1)和F(0),然后逆推得到F(n-1)和F(n-2)的结果，从而得到F(n). 可见过程中要计算很多重复的值(且没有将这些过程中的值存储起来复用)，在时间上造成了很大浪费，算法的时间复杂度随着N的增大呈现指数增长，时间的复杂度为$O(2^n)$ 非递归写法: 12345678910func fib(N int) int &#123; a,b := 0,1 //这其实就是f(0)和f(1) for i := 0; i &lt; N; i++ &#123; a, b = b, a+b //每次循环,依次变为1,1 / 1,2 / 2,3 / 3,5 / 5,8... &#125; return a&#125; 时间复杂度为: $O(n)$ 从 $n&gt;2$ 开始，用F(n-1)和F(n-2)两个数相加求出结果，避免大量重复计算，其的效率比递归算法快得多，算法的时间复杂度与n成正比，即算法的时间复杂度为 $O(n)$ 动态规划解法: 时间复杂度为 $O(n)$ 参见: 动态规划套路详解 面试题10- I. 斐波那契数列（动态规划，清晰图解） 矩阵相乘法: 根据上面的递归公式, 可以得到 计算f(n)就简化为计算${矩阵}^{n-2}$，而计算${矩阵}^{n-2}$，又可以进行分解，即计算$${矩阵}^{\\frac{n-2}{2}}$$的平方，逐步分解下去. 由于折半计算矩阵次方，因而时间复杂度为$O(\\log_2n)$ 1234567891011121314151617181920212223242526272829303132333435func fib(N int) int &#123; if N == 0 || N == 1 &#123; return N &#125; // first 是第0个和第1个元素 first := [][2]int&#123;[2]int&#123;0, 1&#125;, [2]int&#123;0, 0&#125;&#125; // temp为系数 temp := [][2]int&#123;[2]int&#123;0, 1&#125;, [2]int&#123;1, 1&#125;&#125; res := matrix22_pow(temp, N - 1) return matrix22_mul(first, res)[0][1]&#125;func matrix22_pow(x [][2]int, n int) [][2]int &#123; r := x res := [][2]int&#123;[2]int&#123;1, 0&#125;, [2]int&#123;0, 1&#125;&#125; for n != 0 &#123; if n &amp; 1 == 1 &#123; // 最低二进制位为1 res = matrix22_mul(res, r) &#125; // 2维矩阵相乘 r = matrix22_mul(r, r) n &gt;&gt;= 1 &#125; return res&#125;func matrix22_mul(x, y [][2]int) [][2]int &#123; temp := make([][2]int, 2) temp[0][0] = x[0][0] * y[0][0] + x[0][1] * y[0][1] temp[0][1] = x[0][0] * y[0][1] + x[0][1] * y[1][1] temp[1][0] = x[1][0] * y[0][0] + x[1][1] * y[0][1] temp[1][1] = x[1][0] * y[1][0] + x[1][1] * y[1][1] return temp&#125; 达到同样目的,时间复杂度可以是 $O(2^n)$,也可以是 $O(\\log_2n)$.可见算法选取是有多么重要,性能可能千差万别 更多参考: 斐波那契数列三种解法及时间复杂度分析 斐波那契数的时间复杂度、空间复杂度详解 斐波那契数列的三种时间复杂度 6种解法解决斐波那契数列","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"leetcode-454 四数相加II","date":"2015-02-28T16:07:34.000Z","path":"2015/03/01/leetcode-454-四数相加II/","text":"454. 四数相加II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-451 根据字符出现频率排序","date":"2015-02-28T16:07:31.000Z","path":"2015/03/01/leetcode-451-根据字符出现频率排序/","text":"451. 根据字符出现频率排序 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-447 回旋镖的数量","date":"2015-02-28T16:07:27.000Z","path":"2015/03/01/leetcode-447-回旋镖的数量/","text":"447. 回旋镖的数量 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-445 两数相加II","date":"2015-02-28T16:07:25.000Z","path":"2015/03/01/leetcode-445-两数相加II/","text":"445. 两数相加 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-438 找到字符串中所有字母异位词","date":"2015-02-28T16:07:18.000Z","path":"2015/03/01/leetcode-438-找到字符串中所有字母异位词/","text":"438. 找到字符串中所有字母异位词 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-435 无重叠区间","date":"2015-02-28T16:07:15.000Z","path":"2015/03/01/leetcode-435-无重叠区间/","text":"&amp;此题为 高频试题-合并区间 类型的典型题目 &amp; 435. 无重叠区间 难度: 中等 方法1:暴力法 因为n(2的n-1次方)远大于nlog(n),故而排序的时间复杂度就可以忽略不计了 方法2:暴力法2 方法3:贪婪法1 方法4:贪婪法2 按照结束时间排序","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-417 太平洋大西洋水流问题","date":"2015-02-28T16:06:51.000Z","path":"2015/03/01/leetcode-417-太平洋大西洋水流问题/","text":"&amp;此题为 难题-接雨水II 类型的典型 &amp; 417. 太平洋大西洋水流问题 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-407 接雨水II","date":"2015-02-28T16:06:47.000Z","path":"2015/03/01/leetcode-407-接雨水II/","text":"&amp;此题为 难题-接雨水II 类型的典型 &amp; 407. 接雨水 II 难度: 困难 从里面向外寻找, 对于每一个点,都要不断地往外去寻找超过自己,又最矮的柱子 时间复杂度为O(n的立方) 采用农村包围城市的做法,从外面往里面寻找 从最外面最矮的那个开始,慢慢向里面计算(做BFS,即广度优先算法) 为什么不先选择最高的那个呢?因为决定接雨水的高度,是由最矮的那个决定的~ 怎样可以快速知道,接下来哪个高度最矮呢? 可以借用有限队列提高速度 代码如下: 复杂度分析: leetcode-417 太平洋大西洋水流问题","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-355 设计推特","date":"2015-02-28T16:05:55.000Z","path":"2015/03/01/leetcode-355-设计推特/","text":"355. 设计推特 难度: 中等 已有的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243type Twitter struct &#123;&#125;/** Initialize your data structure here. */func Constructor() Twitter &#123;&#125;/** Compose a new tweet. */func (this *Twitter) PostTweet(userId int, tweetId int) &#123;&#125;/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */func (this *Twitter) GetNewsFeed(userId int) []int &#123;&#125;/** Follower follows a followee. If the operation is invalid, it should be a no-op. */func (this *Twitter) Follow(followerId int, followeeId int) &#123;&#125;/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */func (this *Twitter) Unfollow(followerId int, followeeId int) &#123;&#125;/** * Your Twitter object will be instantiated and called as such: * obj := Constructor(); * obj.PostTweet(userId,tweetId); * param_2 := obj.GetNewsFeed(userId); * obj.Follow(followerId,followeeId); * obj.Unfollow(followerId,followeeId); */ 参考: LeetCode 第355题 Design Twitter","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-354 套信封问题","date":"2015-02-28T16:05:54.000Z","path":"2015/03/01/leetcode-354-套信封问题/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-350 两个数组的交集II","date":"2015-02-28T16:05:50.000Z","path":"2015/03/01/leetcode-350-两个数组的交集II/","text":"350. 两个数组的交集II 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-349 两个数组的交集","date":"2015-02-28T16:05:49.000Z","path":"2015/03/01/leetcode-349-两个数组的交集/","text":"349. 两个数组的交集 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-347 前K个高频元素","date":"2015-02-28T16:05:47.000Z","path":"2015/03/01/leetcode-347-前K个高频元素/","text":"&amp;此题为使用 优先队列/ Priority Queue 求解的典型&amp; 347. 前 K 个高频元素 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-345 反转字符串中的元音字母","date":"2015-02-28T16:05:45.000Z","path":"2015/03/01/leetcode-345-反转字符串中的元音字母/","text":"345. 反转字符串中的元音字母 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-344 反转字符串","date":"2015-02-28T16:05:44.000Z","path":"2015/03/01/leetcode-344-反转字符串/","text":"344. 反转字符串 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-341 扁平化嵌套列表迭代器","date":"2015-02-28T16:05:41.000Z","path":"2015/03/01/leetcode-341-扁平化嵌套列表迭代器/","text":"341. 扁平化嵌套列表迭代器 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-340 至多包含K个不同字符的最长子串","date":"2015-02-28T16:05:40.000Z","path":"2015/03/01/leetcode-340-至多包含K个不同字符的最长子串/","text":"&amp;此题为 难题-至多包含K个不同字符的最长子串 类型的典型 &amp; 340. 至多包含K个不同字符的最长子串 难度: 困难 暴力法: 使用两个快慢指针,外加一个哈希表 代码实现:","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-336 回文对","date":"2015-02-28T16:05:36.000Z","path":"2015/03/01/leetcode-336-回文对/","text":"&amp;此题为 难题-回文对 类型的典型 &amp; 336. 回文对 难度: 困难 回文: 正读和反读都一样的字符串 暴力法: 复习一下Trie: 代码实现: 主体函数比较简单: 如何处理查找: 复杂度分析:","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-328 奇偶链表","date":"2015-02-28T16:05:28.000Z","path":"2015/03/01/leetcode-328-奇偶链表/","text":"328. 奇偶链表 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-315 计算右侧小于当前元素的个数","date":"2015-02-28T16:05:15.000Z","path":"2015/03/01/leetcode-315-计算右侧小于当前元素的个数/","text":"&amp;此题为使用 线段树 / Segment 数据结构进行求解的典型 &amp; 785. 判断二分图 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-308 二维区域和检索-可变","date":"2015-02-28T16:05:08.000Z","path":"2015/03/01/leetcode-308-二维区域和检索-可变/","text":"&amp;此题为使用 树状数组 / Binary Indexed Tree 数据结构进行求解的典型 &amp; [308. 二维区域和检索 - 可变 () 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-300 最长上升子序列","date":"2015-02-28T16:05:00.000Z","path":"2015/03/01/leetcode-300-最长上升子序列/","text":"&amp;此题为 动态规划 类型的典型题目 &amp; 300. 最长上升子序列 难度: 中等 暴力法: 状态转移方程式,即一个递推公式 已经证明了有最优子结构,那有重复子问题吗? 时间复杂度分析: 递归的写法需要耗费非常多的重复计算..避免重叠计算---一种办法就是”记忆化”,把算好的保存起来 记忆化总是发生在递归之后 时间复杂度分析: 对于这种将问题规模不断减少的做法,称为自顶向下的方法 时间复杂度分析: 动态规划解题难点: 应当采用什么样的数据结构,来保存什么样的计算结果? 如何利用保存下来的计算结果,推导出状态转移方程.","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-290 单词规律","date":"2015-02-28T16:04:50.000Z","path":"2015/03/01/leetcode-290-单词规律/","text":"290. 单词规律 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-283 移动零","date":"2015-02-28T16:04:43.000Z","path":"2015/03/01/leetcode-283-移动零/","text":"283. 移动零 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-160 相交链表","date":"2015-02-28T16:04:40.000Z","path":"2015/03/01/leetcode-160-相交链表/","text":"160. 相交链表 难度: 简单 https://www.cnblogs.com/yxh-amysear/p/9608796.html http://c.biancheng.net/view/8250.html https://zhuanlan.zhihu.com/p/83138917","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-279 完全平方数","date":"2015-02-28T16:04:39.000Z","path":"2015/03/01/leetcode-279-完全平方数/","text":"279. 完全平方数 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-269 火星字典","date":"2015-02-28T16:04:29.000Z","path":"2015/03/01/leetcode-269-火星字典/","text":"&amp;此题为 高频面试题-火星字典 类型的典型 &amp; 269. 火星字典 难度: 困难 拓扑排序,将每个字母看作是图里的顶点,它们之间的关系,是连接顶点与顶点的边,且是有向边,是一个有向图..最后对这个有向图进行拓扑排序 根据输入构建一个有向图 对这个有向图进行排序 第三课用广度优先算法(Breadth First Search, BFS)实现了拓扑排序,在此用深度优先算法(Depth First Search,DFS)来实现 掌握好拓扑排序的两种写法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-257 二叉树的所有路径","date":"2015-02-28T16:04:17.000Z","path":"2015/03/01/leetcode-257-二叉树的所有路径/","text":"257. 二叉树的所有路径 难度: 简单 考察递归, 此题为 Google 的面试题之一 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func binaryTreePaths(root *TreeNode) []string &#123; var res []string if root == nil &#123; return res &#125; if root.Left == nil &amp;&amp; root.Right == nil &#123; return []string&#123;strconv.Itoa(root.Val)&#125; &#125; tmpLeft := binaryTreePaths(root.Left) for i := 0; i &lt; len(tmpLeft); i++ &#123; res = append(res, strconv.Itoa(root.Val)+\"-&gt;\"+tmpLeft[i]) &#125; tmpRight := binaryTreePaths(root.Right) for i := 0; i &lt; len(tmpRight); i++ &#123; res = append(res, strconv.Itoa(root.Val)+\"-&gt;\"+tmpRight[i]) &#125; return res&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-253 会议室II","date":"2015-02-28T16:04:13.000Z","path":"2015/03/01/leetcode-253-会议室II/","text":"&amp;此题为 贪婪算法 类型的典型题目 &amp; 253. 会议室II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-250 统计同值子树","date":"2015-02-28T16:04:10.000Z","path":"2015/03/01/leetcode-250-统计同值子树/","text":"&amp;此题为使用 二叉树的后序遍历 求解的典型 &amp; 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-247 中心对称数II","date":"2015-02-28T16:04:07.000Z","path":"2015/03/01/leetcode-247-中心对称数II/","text":"&amp;此题为使用 递归 进行求解的典型 &amp; 247. 中心对称数II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-242 有效的字母异位词","date":"2015-02-28T16:04:02.000Z","path":"2015/03/01/leetcode-242-有效的字母异位词/","text":"&amp;此题为使用 数组,字符串 /Array&amp;String 求解的典型&amp; 242. 有效的字母异位词 难度: 简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( \"fmt\")func main() &#123; s := \"anagram\" t := \"nagaram\" rs := isAnagram(s, t) fmt.Println(rs)&#125;func isAnagram(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; //各维护一个map,字母为key,出现次数为value,各循环一遍; //然后进行比较 m1 := make(map[rune]int) //rune即int32 m2 := make(map[int32]int) for _, item := range s &#123; //ok判别式 if _, ok := m1[item]; ok &#123; m1[item]++ &#125; else &#123; m1[item] = 1 &#125; //fmt.Println(reflect.TypeOf(item)) //fmt.Println(m1) &#125; for _, item := range t &#123; //ok判别式 if _, ok := m2[item]; ok &#123; m2[item]++ &#125; else &#123; m2[item] = 1 &#125; &#125; //fmt.Println(m2) //判断m1和m2是否一致 //两个map之间没法没接用\"==\"比较,\"==\"只能用来判断map是否为nil //可以使用reflect.DeepEqual来\"深度比较\"两个map是否\"相同\" if len(m1) != len(m2) &#123; return false &#125; for k := range m1 &#123; if m1[k] != m2[k] &#123; return false &#125; &#125; return true&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-239 滑动窗口最大值","date":"2015-02-28T16:03:59.000Z","path":"2015/03/01/leetcode-239-滑动窗口最大值/","text":"&amp;此题为使用 双端队列/ Deque 求解的典型&amp; 239. 滑动窗口最大值 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-237 删除链表中的节点","date":"2015-02-28T16:03:57.000Z","path":"2015/03/01/leetcode-237-删除链表中的节点/","text":"237. 删除链表中的节点 难度: 简单 123456789101112131415/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteNode(node *ListNode) &#123; if node == nil &#123; return &#125; node.Val = node.Next.Val node.Next = node.Next.Next&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-234 回文链表","date":"2015-02-28T16:03:54.000Z","path":"2015/03/01/leetcode-234-回文链表/","text":"234. 回文链表 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-232 用栈实现队列","date":"2015-02-28T16:03:52.000Z","path":"2015/03/01/leetcode-232-用栈实现队列/","text":"姊妹篇: leetcode-225 用队列实现栈 232. 用栈实现队列 难度: 简单 类似”负负得正”.. 所以要用两个Stack,比如一个叫input,一个叫output, 入input,出和查看元素从output. 只要有pop(移除)和peek(看)操作,就 已经有部分实现好的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243type MyQueue struct &#123;&#125;/** Initialize your data structure here. */func Constructor() MyQueue &#123;&#125;/** Push element x to the back of queue. */func (this *MyQueue) Push(x int) &#123;&#125;/** Removes the element from in front of queue and returns that element. */func (this *MyQueue) Pop() int &#123;&#125;/** Get the front element. */func (this *MyQueue) Peek() int &#123;&#125;/** Returns whether the queue is empty. */func (this *MyQueue) Empty() bool &#123;&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ Push:入队列 Pop: 出队列 Peek: 查看队列的最后一个元素 完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475type MyQueue struct &#123; Stack1, Stack2 *stack&#125;// Constructor Initialize your data structure here.func Constructor() MyQueue &#123; return MyQueue&#123; Stack1: newStack(), Stack2: newStack(), &#125;&#125;// Push element x to the back of queue.func (queue *MyQueue) Push(x int) &#123; queue.Stack1.push(x)&#125;// Pop Removes the element from in front of queue and returns that element.func (queue *MyQueue) Pop() int &#123; if queue.Stack2.isEmpty() &#123; //优化: 栈a中留一个元素供pop,可以少一次操作 for queue.Stack1.len() &gt; 1 &#123; queue.Stack2.push(queue.Stack1.pop()) &#125; return queue.Stack1.pop() &#125; return queue.Stack2.pop()&#125;// Peek Get the front element.func (queue *MyQueue) Peek() int &#123; res := queue.Pop() //队列为空 if res != -1 &#123; queue.Stack2.push(res) &#125; return res&#125;// Empty Returns whether the queue is empty.func (queue *MyQueue) Empty() bool &#123; return queue.Stack1.isEmpty() &amp;&amp; queue.Stack2.isEmpty()&#125;// stack defines Stack1 stacktype stack struct &#123; nums []int&#125;// newStack creates a empty stackfunc newStack() *stack &#123; return &amp;stack&#123; nums: []int&#123;&#125;, &#125;&#125;func (s *stack) push(n int) &#123; s.nums = append(s.nums, n)&#125;func (s *stack) pop() int &#123; if s.isEmpty() &#123; return -1 &#125; res := s.nums[len(s.nums)-1] s.nums = s.nums[:len(s.nums)-1] return res&#125;func (s *stack) len() int &#123; return len(s.nums)&#125;func (s *stack) isEmpty() bool &#123; return s.len() == 0&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"leetcode-230 二叉搜索树中第K小的元素","date":"2015-02-28T16:03:50.000Z","path":"2015/03/01/leetcode-230-二叉搜索树中第K小的元素/","text":"&amp;此题为使用 二叉树的中序遍历 求解的典型 &amp; 230. 二叉搜索树中第K小的元素 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-226 翻转二叉树","date":"2015-02-28T16:03:46.000Z","path":"2015/03/01/leetcode-226-翻转二叉树/","text":"面国内某厂,享受了和Homebrew作者一样的待遇 .ﾟヽ(｡◕‿◕｡)ﾉﾟ.:｡+ﾟ &amp;和反转链表一样,翻转二叉树,可能是面试中最常考察的两个算法题… &amp; 226. 翻转二叉树 难度: 简单 所给代码中已经定义好了一个二叉树 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; //左右节点进行交换 // temp := root.Right // root.Right = root.Left // root.Left = temp //可以直接更换,无需引入中间变量 root.Left,root.Right = root.Right,root.Left //进行递归,反转子节点和右节点 root.Left = invertTree(root.Left) root.Right = invertTree(root.Right) return root&#125; 图示讲解 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"leetcode-225 用队列实现栈","date":"2015-02-28T16:03:45.000Z","path":"2015/03/01/leetcode-225-用队列实现栈/","text":"姊妹篇: leetcode-232 用栈实现队列 225. 用队列实现栈 难度: 简单 已经有部分实现好的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243type MyStack struct &#123;&#125;/** Initialize your data structure here. */func Constructor() MyStack &#123;&#125;/** Push element x onto stack. */func (this *MyStack) Push(x int) &#123;&#125;/** Removes the element on top of the stack and returns that element. */func (this *MyStack) Pop() int &#123;&#125;/** Get the top element. */func (this *MyStack) Top() int &#123;&#125;/** Returns whether the stack is empty. */func (this *MyStack) Empty() bool &#123;&#125;/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 完整代码: 12","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"leetcode-222 完全二叉树的节点个数","date":"2015-02-28T16:03:42.000Z","path":"2015/03/01/leetcode-222-完全二叉树的节点个数/","text":"222. 完全二叉树的节点个数 难度: 中等 完全二叉树的节点数，你真的会算吗？","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-220 存在重复元素III","date":"2015-02-28T16:03:40.000Z","path":"2015/03/01/leetcode-220-存在重复元素III/","text":"220. 存在重复元素III 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-219 存在重复元素II","date":"2015-02-28T16:03:39.000Z","path":"2015/03/01/leetcode-219-存在重复元素II/","text":"219. 存在重复元素II 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-217 存在重复元素","date":"2015-02-28T16:03:37.000Z","path":"2015/03/01/leetcode-217-存在重复元素/","text":"217. 存在重复元素 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-215 数组中的第K个最大元素","date":"2015-02-28T16:03:35.000Z","path":"2015/03/01/leetcode-215-数组中的第K个最大元素/","text":"姊妹问题: 面试题 17.14. 最小K个数 &amp;此题为使用 快速排序 进行求解的典型 &amp; 因为第K个,正好对应快排枢纽值pivot右侧的元素 但因为此题没有时间/空间复杂度要求,可以用任何排序. 也可以使用堆排序中堆化部分的代码,只选出前K个最大元素. 形式上最简单的就是先不管,排好序,(如果是从大到小排)然后再取第K个,即为第K大的元素 在此使用堆排序 215. 数组中的第K个最大元素 难度: 中等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func findKthLargest(nums []int, k int) int &#123; heapSort(nums) return nums[len(nums)-k]&#125;type Heap struct &#123; arr []int // 用来存储堆的数据 size int // 用来标识堆的大小&#125;func createHeap(arr []int) (h Heap) &#123; h.arr = arr h.size = len(arr) //非常标志性的特点,i-- for i := h.size / 2; i &gt;= 0; i-- &#123; adjustHeap(h, i) &#125; return&#125;func adjustHeap(h Heap, parentNode int) &#123; leftNode := parentNode*2 + 1 rightNode := parentNode*2 + 2 maxNode := parentNode if leftNode &lt; h.size &amp;&amp; h.arr[maxNode] &lt; h.arr[leftNode] &#123; maxNode = leftNode &#125; if rightNode &lt; h.size &amp;&amp; h.arr[maxNode] &lt; h.arr[rightNode] &#123; maxNode = rightNode &#125; if maxNode != parentNode &#123; h.arr[maxNode], h.arr[parentNode] = h.arr[parentNode], h.arr[maxNode] adjustHeap(h, maxNode) &#125;&#125;func heapSort(arr []int) &#123; h := createHeap(arr) for h.size &gt; 0 &#123; // 将最大的数值调整到堆的末尾 h.arr[0], h.arr[h.size-1] = h.arr[h.size-1], h.arr[0] // 减少堆的长度 h.size-- // 由于堆顶元素改变了，而且堆的大小改变了，需要重新调整堆，维持堆的性质 adjustHeap(h, 0) &#125;&#125; 如果时间复杂度要求是O(N),可参考: Top K 问题 找出一个数组里面前K个最大数","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-212 单词搜索II","date":"2015-02-28T16:03:32.000Z","path":"2015/03/01/leetcode-212-单词搜索II/","text":"&amp;此题为使用 单词树/Trie 求解的典型 &amp; 212. 单词搜索 II 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-209 长度最小的子数组","date":"2015-02-28T16:03:29.000Z","path":"2015/03/01/leetcode-209-长度最小的子数组/","text":"209. 长度最小的子数组 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-208 实现Trie(前缀树)","date":"2015-02-28T16:03:28.000Z","path":"2015/03/01/leetcode-208-实现Trie-前缀树/","text":"208. 实现 Trie (前缀树) 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"leetcode-206 反转链表","date":"2015-02-28T16:03:26.000Z","path":"2015/03/01/leetcode-206-反转链表/","text":"&amp;也许是面试中最常考察的算法题… &amp; 206. 反转链表 难度: 简单 所给代码中已经定义好了一个单链表 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseList(head *ListNode) *ListNode &#123; if head == nil &#123; return head &#125; var prev *ListNode var curt *ListNode = head for curt != nil &#123; //var temp *ListNode = curt.Next //暂存下一个节点 //指针反转 //curt.Next = prev //往下走一步 // prev = curt //curt = temp //三者交换value..可以不引入temp中间变量;但结合下图,还是用之前引入temp变量的写法更好理解 curt.Next,prev,curt = prev,curt,curt.Next &#125; return prev&#125; 图片来自:大圣算法 升级款: leetcode-92 反转链表II","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Interview","slug":"Interview","permalink":"http://www.dashen.tech/tags/Interview/"}]},{"title":"leetcode-205 同构字符串","date":"2015-02-28T16:03:25.000Z","path":"2015/03/01/leetcode-205-同构字符串/","text":"205. 同构字符串 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-203 移除链表元素","date":"2015-02-28T16:03:23.000Z","path":"2015/03/01/leetcode-203-移除链表元素/","text":"203. 移除链表元素 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-202 快乐数","date":"2015-02-28T16:03:22.000Z","path":"2015/03/01/leetcode-202-快乐数/","text":"202. 快乐数 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-199 二叉树的右视图","date":"2015-02-28T16:03:19.000Z","path":"2015/03/01/leetcode-199-二叉树的右视图/","text":"199. 二叉树的右视图 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-198 打家劫舍","date":"2015-02-28T16:03:18.000Z","path":"2015/03/01/leetcode-198-打家劫舍/","text":"&amp;此题为 动态规划 类型的典型题目 &amp; 198. 打家劫舍 难度: 简单 “0-1思想”","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-172 阶乘后的零","date":"2015-02-28T16:02:52.000Z","path":"2015/03/01/leetcode-172-阶乘后的零/","text":"172. 阶乘后的零 难度: 简单 题目与 面试题 16.05. 阶乘尾数 完全一致 1234567func trailingZeroes(n int) int &#123; if n/5 == 0 &#123; return 0 &#125; return n/5 + trailingZeroes(n/5)&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-169 主要元素","date":"2015-02-28T16:02:49.000Z","path":"2015/03/01/leetcode-169-主要元素/","text":"169. Majority Element 中文版: 主要元素 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 常规做法12345678910111213141516171819202122func majorityElement(nums []int) int &#123; m := make(map[int]int) for _, v := range nums &#123; if _, ok := m[v]; ok &#123; m[v] = m[v] + 1 &#125; else &#123; m[v] = 1 &#125; if len(nums) &lt; 2*m[v] &#123; return v &#125; &#125; return 0&#125; 时间复杂度为O(n), 引入了一个map,空间复杂度为O(n) 进阶做法 你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？ 12","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-150 逆波兰表达式求值","date":"2015-02-28T16:02:30.000Z","path":"2015/03/01/leetcode-150-逆波兰表达式求值/","text":"150. 逆波兰表达式求值 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-149 直线上最多的点数","date":"2015-02-28T16:02:29.000Z","path":"2015/03/01/leetcode-149-直线上最多的点数/","text":"149. 直线上最多的点数 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-148 排序链表","date":"2015-02-28T16:02:28.000Z","path":"2015/03/01/leetcode-148-排序链表/","text":"148. 排序链表 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-147 对链表进行插入排序","date":"2015-02-28T16:02:27.000Z","path":"2015/03/01/leetcode-147-对链表进行插入排序/","text":"&amp;此题为使用 插入排序 进行求解的典型 &amp; 147. 对链表进行插入排序 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-146 LRU缓存机制","date":"2015-02-28T16:02:26.000Z","path":"2015/03/01/leetcode-146-LRU缓存机制/","text":"146. LRU缓存机制 难度: 中等 12","tags":[]},{"title":"leetcode-145 二叉树的后序遍历","date":"2015-02-28T16:02:25.000Z","path":"2015/03/01/leetcode-145-二叉树的后序遍历/","text":"姊妹篇: leetcode-94 二叉树的中序遍历 leetcode-144 二叉树的前序遍历 后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。遍历路径为 ＞ 为何”Postorder Traversal”缩写为LRD? LRD其实是指遍历的顺序: L为left R为right D为根节点,因为root与right首字母相同,为免歧义,用D代指根节点(Data),有的地方也用N来代指(Node) 相应的,前序遍历(Preorder Traversal ,DLR)和中序遍历(Inorder Traversal ,LDR)如下: 前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。遍历路径为 ＜ 中序遍历（LDR），是二叉树遍历的一种，也叫做中根遍历、中序周游，可记做左根右。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。遍历路径为 ∧ 所谓的”前/中/后”,是指访问到根节点的次序 145. 二叉树的后序遍历 难度: 困难 递归写法: 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func postorderTraversal(root *TreeNode) []int &#123; var res []int = make([]int,0) if root == nil &#123; return res &#125; //递归一定要写好终止条件 temp := postorderTraversal(root.Left) res = append(res,temp...) temp = postorderTraversal(root.Right) res = append(res,temp...) res = append(res,root.Val) return res&#125; 时间复杂度/空间复杂度均为O(n)","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-144 二叉树的前序遍历","date":"2015-02-28T16:02:24.000Z","path":"2015/03/01/leetcode-144-二叉树的前序遍历/","text":"姊妹篇: leetcode-94 二叉树的中序遍历 leetcode-145 二叉树的后序遍历 144. 二叉树的前序遍历 难度: 中等 递归解法: 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123; var res []int = make([]int, 0) if root == nil &#123; return res &#125; res = append(res,root.Val) //递归调用,遍历左节点;temp用来承接返回的值 temp := preorderTraversal(root.Left) res = append(res,temp...) //遍历右节点 temp = preorderTraversal(root.Right) res = append(res,temp...) return res&#125; 迭代解法: 参考","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-143 重排链表","date":"2015-02-28T16:02:23.000Z","path":"2015/03/01/leetcode-143-重排链表/","text":"143. 重排链表 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-141 环形链表","date":"2015-02-28T16:02:21.000Z","path":"2015/03/01/leetcode-141-环形链表/","text":"141. 环形链表 难度: 简单 (经典的)快慢指针法: 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func hasCycle(head *ListNode) bool &#123; if head == nil &#123; return false &#125; slow := head fast := head for fast != nil &amp;&amp; fast.Next != nil &#123; //之所以还要加fast != nil的判断(且必须在前),是为了短路,防止报错,见后面的代码 slow = slow.Next fast = fast.Next.Next if slow == fast &#123; return true &#125; &#125; return false&#125; 为何还要加fast != nil的判断且必须在前面? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport \"github.com/davecgh/go-spew/spew\"func main() &#123; l0 := &amp;ListNode&#123;&#125; l0.Val = 100 l1 := &amp;ListNode&#123;&#125; l1.Val = 207 l0.Next = l1 spew.Println(l0) spew.Println(\"--------------\") hasCycle(l0)&#125;// * Definition for singly-linked list.type ListNode struct &#123; Val int Next *ListNode&#125;func hasCycle(head *ListNode) bool &#123; if head == nil &#123; return false &#125; slow := head fast := head for fast.Next != nil &#123; spew.Println(\"此时慢指针的下一个节点是:\", slow.Next) spew.Println(\"此时快指针的下一个节点是:\", fast.Next) slow = slow.Next fast = fast.Next.Next spew.Println(\"此时慢指针的下一个节点是:\", slow.Next) spew.Println(\"此时快指针的下一个节点是:\", fast.Next) //cs := fast.Next.Next.Next.Next.Next.Next //在不打印,不判别时,不会报错,可以一直写下去 //spew.Println(cs) if slow == fast &#123; return true &#125; &#125; return false&#125; 输出为: 1234567891011121314&lt;*&gt;&#123;100 &lt;*&gt;&#123;207 &lt;nil&gt;&#125;&#125;--------------此时慢指针的下一个节点是: &lt;*&gt;&#123;207 &lt;nil&gt;&#125;此时快指针的下一个节点是: &lt;*&gt;&#123;207 &lt;nil&gt;&#125;此时慢指针的下一个节点是: &lt;nil&gt;panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x8 pc=0x10be51e]goroutine 1 [running]:main.hasCycle(0xc0000102d0, 0x1) /Users/shuangcui/go/src/leetcode/141.go:49 +0x1aemain.main() /Users/shuangcui/go/src/leetcode/141.go:21 +0xfbexit status 2 如上代码中,传入一个有两个元素的链表. 因为 快指针fast 不是顺次遍历,而是跳跃,如果不加fast != nil的条件,且不放在判别式的前面, 就会出现如上报错,即在判定(或打印)下下个指针时,会出现越界而报错. 第一次遍历后,各变量指针的指向: 如果不加fast != nil的条件,且不放在判别式的前面,那fast.Next越界而发生panic","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-129 求根到叶子节点数字之和","date":"2015-02-28T16:02:09.000Z","path":"2015/03/01/leetcode-129-求根到叶子节点数字之和/","text":"129. 求根到叶子节点数字之和 难度: 中等 12","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-127 单词接龙","date":"2015-02-28T16:02:07.000Z","path":"2015/03/01/leetcode-127-单词接龙/","text":"127. 单词接龙 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-126 单词接龙II","date":"2015-02-28T16:02:06.000Z","path":"2015/03/01/leetcode-126-单词接龙II/","text":"126. 单词接龙II 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-125 验证回文串","date":"2015-02-28T16:02:05.000Z","path":"2015/03/01/leetcode-125-验证回文串/","text":"125. 验证回文串 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-112 路径总和","date":"2015-02-28T16:01:52.000Z","path":"2015/03/01/leetcode-112-路径总和/","text":"112. 路径总和 难度: 简单 递归求解即可 123456789101112131415161718192021/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func hasPathSum(root *TreeNode, targetSum int) bool &#123; if root == nil &#123; return false &#125; if root.Left == nil &amp;&amp; root.Right == nil &#123; return targetSum == root.Val &#125; return hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-111 二叉树的最小深度","date":"2015-02-28T16:01:51.000Z","path":"2015/03/01/leetcode-111-二叉树的最小深度/","text":"姊妹篇: leetcode-104 二叉树的最大深度 111. 二叉树的最小深度 难度: 简单 递归求出根节点到叶子节点的深度，输出最小值即可 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; if root.Left == nil &#123; return minDepth(root.Right) + 1 &#125; if root.Right == nil &#123; return minDepth(root.Left) + 1 &#125; //之所以定义left和right,为了防止下面return时还有再次计算 left := minDepth(root.Left) right := minDepth(root.Right) if left &gt; right &#123; return right + 1 &#125; else &#123; return left + 1 &#125; 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-110 平衡二叉树","date":"2015-02-28T16:01:50.000Z","path":"2015/03/01/leetcode-110-平衡二叉树/","text":"平衡二叉树（Balanced Binary Tree)具有以下性质： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 110. 平衡二叉树 难度: 简单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport \"fmt\"type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func main() &#123; root := TreeNode&#123; Val: 3, Left: &amp;TreeNode&#123;Val: 9&#125;, Right: &amp;TreeNode&#123;Val: 20, Left: &amp;TreeNode&#123;Val: 15&#125;, Right: &amp;TreeNode&#123;Val: 7&#125;&#125;, &#125; rs := isBalanced(&amp;root) fmt.Println(rs)&#125;func isBalanced(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; fmt.Println(111) if isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &amp;&amp; height(root.Left)-height(root.Right) &lt;= 1 &amp;&amp; height(root.Left)-height(root.Right) &gt;= -1 &#123; return true &#125; else &#123; return false &#125;&#125;func height(root *TreeNode) int &#123; var h int if root == nil &#123; return h &#125; fmt.Println(\"左右为:\", height(root.Left), height(root.Right)) if height(root.Left) &gt;= height(root.Right) &#123; return height(root.Left) + 1 &#125; else &#123; return height(root.Right) + 1 &#125;&#125; Go Math中很多常用方法的返回值都是float..比如取绝对值,取最大值 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-107  二叉树的层次遍历II","date":"2015-02-28T16:01:47.000Z","path":"2015/03/01/leetcode-107-二叉树的层次遍历II/","text":"姊妹篇: 102. 二叉树的层序遍历 107. 二叉树的层次遍历II 难度: 简单 递归写法: 123456789101112131415161718192021222324252627282930313233343536373839//Definition for a binary tree node.type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;var res [][]intfunc levelOrderBottom(root *TreeNode) [][]int &#123; res = [][]int&#123;&#125; bfs(root, 0) reverse(res) return res&#125;func bfs(root *TreeNode, level int) &#123; if root != nil &#123; if len(res) == level &#123; res = append(res, []int&#123;&#125;) &#125; res[level] = append(res[level], root.Val) bfs(root.Left, level+1) bfs(root.Right, level+1) &#125;&#125;func reverse(res [][]int) [][]int &#123; long := len(res) - 1 i := 0 for long &gt; i &#123; res[long], res[i] = res[i], res[long] long-- i++ &#125; return res&#125; 相比于102. 二叉树的层序遍历,只是在输出前,多了一个反转的操作","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-106 从中序与后序遍历序列构造二叉树","date":"2015-02-28T16:01:46.000Z","path":"2015/03/01/leetcode-106-从中序与后序遍历序列构造二叉树/","text":"106. 从中序与后序遍历序列构造二叉树 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-105 从前序与中序遍历序列构造二叉树","date":"2015-02-28T16:01:45.000Z","path":"2015/03/01/leetcode-105-从前序与中序遍历序列构造二叉树/","text":"105. 从前序与中序遍历序列构造二叉树 难度: 中等 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123; var root *TreeNode if len(preorder) &lt; 1 || len(inorder) &lt; 1&#123; return root &#125; left := find(inorder,preorder[0]) if left &lt; 0&#123; return root &#125; root = &amp;TreeNode&#123; Val:preorder[0], Left:buildTree(preorder[1:left+1],inorder[0:left]), Right:buildTree(preorder[left+1:],inorder[left+1:]), &#125; return root&#125;func find(inorder []int,target int) int &#123; for i := 0; i &lt; len(inorder);i++ &#123; if target == inorder[i] &#123; return i &#125; &#125; return -1&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-104 二叉树的最大深度","date":"2015-02-28T16:01:44.000Z","path":"2015/03/01/leetcode-104-二叉树的最大深度/","text":"姊妹篇: leetcode-111 二叉树的最小深度 104. 二叉树的最大深度 难度: 简单 递归求出根节点到叶子节点的深度，输出其中最大值即可 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123; var res int if root == nil &#123; return res &#125; left := maxDepth(root.Left) right := maxDepth(root.Right) if left &gt; right &#123; return left + 1 //根节点也算一层 &#125; else &#123; return right + 1 &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-103  二叉树的锯齿形层次遍历","date":"2015-02-28T16:01:43.000Z","path":"2015/03/01/leetcode-103-二叉树的锯齿形层次遍历/","text":"103. 二叉树的锯齿形层次遍历 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-102 二叉树的层序遍历","date":"2015-02-28T16:01:42.000Z","path":"2015/03/01/leetcode-102-二叉树的层序遍历/","text":"姊妹篇: 107. 二叉树的层次遍历 II 102. 二叉树的层序遍历 难度: 中等 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS(Breadth First Search)，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。 递归写法: 12345678910111213141516171819202122232425262728//Definition for a binary tree node.type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;var res [][]intfunc levelOrder(root *TreeNode) [][]int &#123; res = [][]int&#123;&#125; bfs(root, 0) return res&#125;func bfs(root *TreeNode, level int) &#123; if root != nil &#123; if len(res) == level &#123; res = append(res, []int&#123;&#125;) &#125; res[level] = append(res[level], root.Val) bfs(root.Left, level+1) bfs(root.Right, level+1) &#125;&#125; 参考: 二叉树的层序遍历 golang","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-101 对称二叉树","date":"2015-02-28T16:01:41.000Z","path":"2015/03/01/leetcode-101-对称二叉树/","text":"101. 对称二叉树 难度: 简单 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; return isSameNode(root.Left,root.Right) &#125;func isSameNode(left *TreeNode,right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil &#123; return true &#125; if left == nil || right == nil &#123; return false &#125; if left.Val != right.Val &#123; return false &#125; return isSameNode(left.Left,right.Right) &amp;&amp; isSameNode(left.Right,right.Left)&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-100 相同的树","date":"2015-02-28T16:01:40.000Z","path":"2015/03/01/leetcode-100-相同的树/","text":"100. 相同的树 难度: 简单 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p == nil &amp;&amp; q == nil &#123; return true &#125; //已经判断过了两个二叉树全为nil,并已经返回; //所以此处但凡满足条件,即只要有一个是nil,另一个一定不会是nil if p == nil || q == nil &#123; return false &#125; if p.Val != q.Val &#123; return false &#125; return isSameTree(p.Left,q.Left) &amp;&amp; isSameTree(p.Right,q.Right)&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-96 不同的二叉搜索树","date":"2015-02-28T16:01:36.000Z","path":"2015/03/01/leetcode-96-不同的二叉搜索树/","text":"96. 不同的二叉搜索树 难度: 中等 参考 卡特兰数 12345678910111213141516171819package mainimport \"fmt\"func main() &#123; for i := 0; i &lt;= 40; i++ &#123; fmt.Printf(\"第%d个卡特兰数为:%d\\n\", i, numTrees(i)) &#125;&#125;func numTrees(n int) int &#123; rs := 1 for i := 0; i &lt; n; i++ &#123; rs = rs * 2 * (2*i + 1) / (i + 2) &#125; return rs&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041第0个卡特兰数为:1第1个卡特兰数为:1第2个卡特兰数为:2第3个卡特兰数为:5第4个卡特兰数为:14第5个卡特兰数为:42第6个卡特兰数为:132第7个卡特兰数为:429第8个卡特兰数为:1430第9个卡特兰数为:4862第10个卡特兰数为:16796第11个卡特兰数为:58786第12个卡特兰数为:208012第13个卡特兰数为:742900第14个卡特兰数为:2674440第15个卡特兰数为:9694845第16个卡特兰数为:35357670第17个卡特兰数为:129644790第18个卡特兰数为:477638700第19个卡特兰数为:1767263190第20个卡特兰数为:6564120420第21个卡特兰数为:24466267020第22个卡特兰数为:91482563640第23个卡特兰数为:343059613650第24个卡特兰数为:1289904147324第25个卡特兰数为:4861946401452第26个卡特兰数为:18367353072152第27个卡特兰数为:69533550916004第28个卡特兰数为:263747951750360第29个卡特兰数为:1002242216651368第30个卡特兰数为:3814986502092304第31个卡特兰数为:14544636039226909第32个卡特兰数为:55534064877048198第33个卡特兰数为:212336130412243110第34个卡特兰数为:-241155619205100756第35个卡特兰数为:100389241586533302第36个卡特兰数为:-113283020768157371第37个卡特兰数为:50195343198909880第38个卡特兰数为:193059012303499538第39个卡特兰数为:-179060006317004359第40个卡特兰数为:209805052422741817 第33位之后就发生了int64的溢出,之后的都不对了 最初使用了 $$f \\left(n \\right) = \\frac{1}{n+1} \\frac{(2n)!}{n!\\cdot n!} = \\frac{(2n)!}{(n+1)!\\cdot n!} $$ 代码如下: 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\")func main() &#123; for i := 0; i &lt;= 40; i++ &#123; fmt.Println(numTrees1(i)) &#125;&#125;func numTrees1(n int) int &#123; a := getFactorial(2 * n) b := getFactorial(n) fmt.Println(a) return a / ((n + 1) * b * b)&#125;// 返回x的阶乘func getFactorial(x int) int &#123; rs := 1 for i := 1; i &lt;= x; i++ &#123; rs *= i &#125; return rs&#125; factorial adj. 因子的，阶乘的 n. [数] 阶乘 ​​​​ 但是,阶乘也是一个”爆炸型增长”, 44!=2658271574788448768043625811014615890319638528000000000, 远远超出了int64的最大范围 使用了Go官方提供的 math/big包,但效果并不好 Golang大整数计算示例-阶乘 最后,用以为性能会很差的递归方式,用递推关系式 $$f \\left(0 \\right) = 1, f \\left(n+1 \\right) = \\frac{2(2n+1)}{n+2} \\cdot f \\left(n \\right) $$ beat了100%的用户.. 另外,也可以使用动态规划方法来求解","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-95 不同的二叉搜索树II","date":"2015-02-28T16:01:35.000Z","path":"2015/03/01/leetcode-95-不同的二叉搜索树II/","text":"95. 不同的二叉搜索树II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-94 二叉树的中序遍历","date":"2015-02-28T16:01:34.000Z","path":"2015/03/01/leetcode-94-二叉树的中序遍历/","text":"姊妹篇: leetcode-144 二叉树的前序遍历 leetcode-145 二叉树的后序遍历 94. 二叉树的中序遍历 难度: 中等 二叉树的前序、中序、后序三种遍历方式,所谓的”前中后”,指的是对根节点的遍历顺序. 可参考或点击查看此篇 即对于中序排序,对每个节点始终按照”左中右”的规则进行遍历; 根据访问结点操作发生位置命名：① NLR：前序遍历(PreorderTraversal亦称（先序遍历））——访问结点的操作发生在遍历其左右子树之前。② LNR：中序遍历(InorderTraversal)——访问结点的操作发生在遍历其左右子树之中（间）。③ LRN：后序遍历(PostorderTraversal)——访问结点的操作发生在遍历其左右子树之后。注意：由于被访问的结点必是某子树的根，所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为根、根的左子树和根的右子树。NLR、LNR和LRN分别又称为先根遍历、中根遍历和后根遍历。 对于任意一个编号为n的节点，如果它有子节点，它的左子节点编号为2n,右节点的编号为2n+1。（这条性质很重要，决定了二叉树可以用数组来表示） 二叉树的顺序存储,力荐 迭代解法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport \"fmt\"//Definition for a binary tree node.type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func main() &#123; var a = TreeNode&#123;&#125; rs := inorderTraversal(&amp;a) fmt.Println(rs)&#125;func inorderTraversal(root *TreeNode) []int &#123; //声明返回 var result []int //判断根 if root == nil &#123; return result &#125; //寻找左--放入栈 var stack []*TreeNode //放入根 stack = append(stack, root) //准备工作寻找左--并放入栈 p := root.Left for p != nil &#123; //压入栈 stack = append(stack, p) //继续左 p = p.Left &#125; //开始填充结果 for len(stack) != 0 &#123; //栈顶出栈 topNode := stack[len(stack)-1] stack = stack[:len(stack)-1] //写入当前 result = append(result, topNode.Val) //判断当前的右 if topNode.Right == nil &#123; continue &#125; //当前右入栈 stack = append(stack, topNode.Right) //获取当前的右的左 p := topNode.Right.Left for p != nil &#123; //压入栈 stack = append(stack, p) //继续左 p = p.Left &#125; &#125; //返回结果 return result&#125; 递归解法: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func inorderTraversal(root *TreeNode) []int &#123; res := make([]int,0) if root == nil &#123; return res &#125; temp := inorderTraversal(root.Left) res = append(res,temp...) res = append(res,root.Val) temp = inorderTraversal(root.Right) res = append(res,temp...) return res&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-92 反转链表II","date":"2015-02-28T16:01:32.000Z","path":"2015/03/01/leetcode-92-反转链表II/","text":"基础款: leetcode-206 反转链表 92. 反转链表 II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-91 解码方法","date":"2015-02-28T16:01:31.000Z","path":"2015/03/01/leetcode-91-解码方法/","text":"&amp;此题为使用 递归 进行求解的典型 &amp; 91. 解码方法 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-88 合并两个有序数组","date":"2015-02-28T16:01:28.000Z","path":"2015/03/01/leetcode-88-合并两个有序数组/","text":"每天一道leetcode88-合并两个有序数组","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-86 分隔链表","date":"2015-02-28T16:01:26.000Z","path":"2015/03/01/leetcode-86-分隔链表/","text":"86. 分隔链表 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-84 柱状图中最大的矩形","date":"2015-02-28T16:01:24.000Z","path":"2015/03/01/leetcode-84-柱状图中最大的矩形/","text":"&amp;此题为 难题-柱状图中最大的矩形 类型的典型 &amp; 84. 柱状图中最大的矩形 难度: 困难 暴力法: 时间复杂度为O(n的平方); 当遇到一个下降的高度时,就可以开始计算 遇到一个上升的高度,不着急计算 复杂度分析:","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-83 删除排序链表中的重复元素","date":"2015-02-28T16:01:23.000Z","path":"2015/03/01/leetcode-83-删除排序链表中的重复元素/","text":"83. 删除排序链表中的重复元素 难度: 中等 三道题套路解决递归问题 如链接失效,可点击","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-82 删除排序链表中的重复元素II","date":"2015-02-28T16:01:22.000Z","path":"2015/03/01/leetcode-82-删除排序链表中的重复元素II/","text":"82. 删除排序链表中的重复元素II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-80 删除排序数组中的重复项II","date":"2015-02-28T16:01:20.000Z","path":"2015/03/01/leetcode-80-删除排序数组中的重复项II/","text":"80. 删除排序数组中的重复项II 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-76 最小覆盖子串","date":"2015-02-28T16:01:16.000Z","path":"2015/03/01/leetcode-76-最小覆盖子串/","text":"76. 最小覆盖子串 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-75 颜色分类","date":"2015-02-28T16:01:15.000Z","path":"2015/03/01/leetcode-75-颜色分类/","text":"75. 颜色分类 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-71 简化路径","date":"2015-02-28T16:01:11.000Z","path":"2015/03/01/leetcode-71-简化路径/","text":"71. 简化路径 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-69 x的平方根","date":"2015-02-28T16:01:09.000Z","path":"2015/03/01/leetcode-69-x的平方根/","text":"https://leetcode-cn.com/problems/sqrtx/","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-62 不同路径","date":"2015-02-28T16:01:02.000Z","path":"2015/03/01/leetcode-62-不同路径/","text":"&amp;此题为 动态规划 类型的典型题目 &amp; 62. 不同路径 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-61 旋转链表","date":"2015-02-28T16:01:01.000Z","path":"2015/03/01/leetcode-61-旋转链表/","text":"61. 旋转链表 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-56 合并区间","date":"2015-02-28T16:00:56.000Z","path":"2015/03/01/leetcode-56-合并区间/","text":"&amp;此题为 高频试题-合并区间 类型的典型题目 &amp; 56. 合并区间 难度: 中等 贪婪算法 时间复杂度和空间复杂度","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-52 N皇后II","date":"2015-02-28T16:00:52.000Z","path":"2015/03/01/leetcode-52-N皇后II/","text":"&amp;此题为使用 回溯 进行求解的典型 &amp; 52. N皇后II 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-49 字母异位词分组","date":"2015-02-28T16:00:49.000Z","path":"2015/03/01/leetcode-49-字母异位词分组/","text":"49. 字母异位词分组 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-44 通配符匹配","date":"2015-02-28T16:00:44.000Z","path":"2015/03/01/leetcode-44-通配符匹配/","text":"&amp;此题为 难题-正则表达式匹配 类型的典型 &amp; 44. 通配符匹配 难度: 困难","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-42 接雨水","date":"2015-02-28T16:00:42.000Z","path":"2015/03/01/leetcode-42-接雨水/","text":"最朴素的一种解法,使用动态规划~ 维护一个一维的dp数组，这个DP算法需要遍历两遍数组，第一遍遍历dp[i]中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值A[i]相比，如果大于当前值，则将差值存入结果 直接贴代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func trap(height []int) int &#123; rs := 0 mx := 0 n := len(height) dp := make([]int,n) for i := 0; i &lt; n; i++ &#123; dp[i] = mx mx = max(mx,height[i]) &#125; mx = 0 for i := n-1; i &gt;= 0; i-- &#123; dp[i] = min(dp[i],mx) mx = max(mx,height[i]) if dp[i] - height[i] &gt; 0 &#123; rs += dp[i] - height[i] &#125; &#125; return rs&#125;// golang max intfunc max(first int, args... int) int &#123; for _ , v := range args&#123; if first &lt; v &#123; first = v &#125; &#125; return first&#125;// golang min intfunc min(first int, args... int) int &#123; for _ , v := range args&#123; if first &gt; v &#123; first = v &#125; &#125; return first&#125; 运行结果: 总结:显然,这还不是最优解法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-39 组合总和","date":"2015-02-28T16:00:39.000Z","path":"2015/03/01/leetcode-39-组合总和/","text":"&amp;此题为使用 回溯 进行求解的典型 &amp; 39. 组合总和 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-34 在排序数组中查找元素的第一个和最后一个位置","date":"2015-02-28T16:00:34.000Z","path":"2015/03/01/leetcode-34-在排序数组中查找元素的第一个和最后一个位置/","text":"&amp;此题为 二分搜索-找确定的边界 类型的典型题目 &amp; 34. 在排序数组中查找元素的第一个和最后一个位置 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-33 搜索旋转排序数组","date":"2015-02-28T16:00:33.000Z","path":"2015/03/01/leetcode-33-搜索旋转排序数组/","text":"&amp;此题为”二分搜索-找模糊的边界”类型的典型题目 &amp; 33. 搜索旋转排序数组 难度: 中等 所谓旋转数组,即从某个位置开始,左边或右边是排好序的","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-28 实现strStr()","date":"2015-02-28T16:00:28.000Z","path":"2015/03/01/leetcode-28-实现strStr/","text":"&amp;此题为 难题-实现strStr() 类型的典型 &amp; 28. 实现 strStr() 难度: 简单 暴力法:比较简单 KMP算法 两个疑惑: KMP中重要的数据结构: LPS 为什么不需要比较前面的位置? 反证法可以证明: 没有必要! 当我们知道两个绿色的方块,就是最大的公共前缀和后缀时,就可以放心地进行跳跃操作,而不需要担心我们会担心完全匹配的情况发生.因为完美匹配不可能在跳跃的空间内发生 如何求出needle字符串的最长公共前缀和后缀数组? 暴力法: O(n的平方) 更高效的做法: O(n) 实例: needle = ADCADB LPS = 000000 复杂度分析: KMP的代码十分精妙~","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-27 移除元素","date":"2015-02-28T16:00:27.000Z","path":"2015/03/01/leetcode-27-移除元素/","text":"27. 移除元素 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-26 删除排序数组中的重复项","date":"2015-02-28T16:00:26.000Z","path":"2015/03/01/leetcode-26-删除排序数组中的重复项/","text":"26. 删除排序数组中的重复项 难度: 简单","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-25 K个一组翻转链表","date":"2015-02-28T16:00:25.000Z","path":"2015/03/01/leetcode-25-K个一组翻转链表/","text":"&amp;此题为使用 链表/ Linked List 求解的典型 &amp; 25. K 个一组翻转链表 难度: 困难 考察: 对链表翻转算法的熟悉程度 对递归算法的理解程度","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"leetcode-24 两两交换链表中的节点","date":"2015-02-28T16:00:24.000Z","path":"2015/03/01/leetcode-24-两两交换链表中的节点/","text":"24. 两两交换链表中的节点 难度: 中等 和链表反转类似，都有三个指针，分别指向前后和当前节点。不同点是两两交换后，移动节点步长为２ 此题还可使用递归思路来求解 视频讲解: [LeetCode] 24. 两两交换链表中的节点(Swap Nodes in Pairs) 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; prev, cur := head, head head = cur.Next for ; cur != nil &amp;&amp; cur.Next != nil; cur = cur.Next &#123; next := cur.Next if prev != nil &#123; prev.Next = next &#125; cur.Next, next.Next, prev = next.Next, cur, cur &#125; return head&#125; 三道题套路解决递归问题","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-23 合并K个排序链表","date":"2015-02-28T16:00:23.000Z","path":"2015/03/01/leetcode-23-合并K个排序链表/","text":"&amp;此题为 高频面试题 的典型 &amp; 23. 合并K个排序链表 难度: 困难 解法1:暴力法用一个数组保存所有链表中的数,然后进行排序,从头到尾将数组遍历,生成一个排好序的链表; 假设每个链表的平均长度为n,则整体的时间复杂度为O(nk * log(nk)) 解法2:最小堆 一直维护这个大小为k的最小堆 解法3:分治法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-22 括号生成","date":"2015-02-28T16:00:22.000Z","path":"2015/03/01/leetcode-22-括号生成/","text":"&amp;此题为使用 栈/ Stack 求解的典型&amp; 22. 括号生成 难度: 中等 利用一个栈,不断地往里面压左括号,一旦遇到一个右括号,就把栈顶的左括号弹出来,表示这是一个合法的组合..直到最后,判断栈里还有无左括号剩余","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-21 合并两个有序链表","date":"2015-02-28T16:00:21.000Z","path":"2015/03/01/leetcode-21-合并两个有序链表/","text":"&amp;此题为使用 链表/ Linked List 求解的典型&amp; 21. 合并两个有序链表 难度: 简单 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; var dummy *ListNode = &amp;ListNode&#123;&#125; var curr *ListNode = dummy for l1 != nil &amp;&amp; l2 != nil &#123; if l1.Val &lt; l2.Val &#123; curr.Next = &amp;ListNode&#123;Val:l1.Val&#125; l1 = l1.Next &#125; else &#123; curr.Next = &amp;ListNode&#123;Val:l2.Val&#125; l2 = l2.Next &#125; curr = curr.Next &#125; if l1 != nil &#123; curr.Next = l1 &#125; if l2 != nil &#123; curr.Next = l2 &#125; return dummy.Next&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-20 有效的括号","date":"2015-02-28T16:00:20.000Z","path":"2015/03/01/leetcode-20-有效的括号/","text":"&amp; 属于经典面试题…用的也是经典的数据结构,即用栈 &amp; 20. 有效的括号 难度: 简单 时间复杂度为O(n)","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-19 删除链表的倒数第N个节点","date":"2015-02-28T16:00:19.000Z","path":"2015/03/01/leetcode-19-删除链表的倒数第N个节点/","text":"19. 删除链表的倒数第N个节点 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-16 最接近的三数之和","date":"2015-02-28T16:00:16.000Z","path":"2015/03/01/leetcode-16-最接近的三数之和/","text":"16. 最接近的三数之和 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-15 三数之和","date":"2015-02-28T16:00:15.000Z","path":"2015/03/01/leetcode-15-三数之和/","text":"15. 三数之和 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-11 盛最多水的容器","date":"2015-02-28T16:00:11.000Z","path":"2015/03/01/leetcode-11-盛最多水的容器/","text":"11. 盛最多水的容器 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-10 正则表达式匹配","date":"2015-02-28T16:00:10.000Z","path":"2015/03/01/leetcode-10-正则表达式匹配/","text":"&amp;此题为 难题-正则表达式匹配 类型的典型 &amp; 10. 正则表达式匹配 难度: 困难 经常使用正则匹配,但很少思考其背后如何实现… 在此只需要实现正则表达式里的两个小功能 递归解法1:从前往后递归调用: 递归解法2:从后往前递归调用: 一道思路相似的题目: leetcode-44 通配符匹配","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-7 整数反转","date":"2015-02-28T16:00:07.000Z","path":"2015/03/01/leetcode-7-整数反转/","text":"7. 整数反转 难度: 简单 方法一: 转为字符串,将字符串反转后再转为整型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func reverse(x int) int &#123; if x == 0 || x &lt; -2147483648 || x &gt; 2147483647 &#123; return 0 &#125; if x &gt; 0 &#123; rs := dealPostiveData(x) if rs &lt; -2147483648 || rs &gt; 2147483647 &#123; return 0 &#125; else &#123; return rs &#125; &#125; else &#123; numPostive := x * -1 rsPostive := dealPostiveData(numPostive) rs := rsPostive * -1 if rs &lt; -2147483648 || rs &gt; 2147483647 &#123; return 0 &#125; else &#123; return rs &#125; &#125;&#125;func dealPostiveData(num int) (int) &#123; var sli []string numStr := strconv.Itoa(num) for _, v := range numStr &#123; sli = append(sli, string(v)) &#125; long := len(sli) var sli2 []string for k := range sli &#123; sli2 = append(sli2, sli[long-k-1]) &#125; rsStr := \"\" for _, val := range sli2 &#123; rsStr += val &#125; rs, _ := strconv.Atoi(rsStr) return rs&#125; 方法二: 除10取余","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-4 寻找两个有序数组的中位数","date":"2015-02-28T16:00:04.000Z","path":"2015/03/01/leetcode-4-寻找两个有序数组的中位数/","text":"思路分析:第一感觉,先对两个数组排序,再判断得出其中位数的值,好像并不困难. 但说了时间复杂度需要为 O(log(m + n)),那第一步排序,几种常见的排序算法就要被滤掉. 常见算法的时间复杂度参考 可参考","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-3 最大字符子串","date":"2015-02-28T16:00:03.000Z","path":"2015/03/01/leetcode-3-最大字符子串/","text":"Longest Common SubString, 又称为”LCS”问题 123456789101112131415161718192021222324252627func lengthOfLongestSubstring(s string) int &#123; start := 0 end := 0 repeatCount := 0 slen := len(s) m := make(map[byte]byte) for end &lt; slen &#123; tmp := s[end] if _,ok := m[tmp];!ok &#123; m[tmp] = tmp end++ repeatCount = int(math.Max(float64(repeatCount),float64(end-start))) &#125; else &#123; delete(m,s[start]) start++ &#125; &#125; return repeatCount &#125; 参考,所谓容器,即一个map 更多参考: 图解LeetCode第 3 号问题：无重复字符的最长子串 无重复字符的最长子串 最长公共子序列和最长公共子串 动态规划求解最长公共子序列 笔试面试算法经典–最长公共子串（Longest Common SubString）","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-2 两数相加","date":"2015-02-28T16:00:02.000Z","path":"2015/03/01/leetcode-2-两数相加/","text":"那本[GPAI]1.3节内容(第29页),如何计算两个单链表所代表的数之和 2. 两(个单链表所代表的)数相加 难度: 中等 方法一: 整数相加法分别遍历两个链表,求出两个链表所代表的整数的值,而后将两个整数相加,最后将和用链表形式表示出来; 这种方法优点是计算简单,但当链表所代表的整数非常大(超出了int64的范围),就无法使用该法了. 方法二: 链表相加法","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"leetcode-1 两数之和","date":"2015-02-28T16:00:01.000Z","path":"2015/03/01/leetcode-1-两数之和/","text":"难度: 中等 最朴素的一种解法,两次循环~时间复杂度为O(n的平方) 直接贴代码: 12345678910111213func twoSum(nums []int, target int) []int &#123; rs := make([]int,0) for i,v := range nums &#123; for i2,v2 := range nums&#123; if v + v2 == target &amp;&amp; i != i2 &#123; rs = append(rs,i,i2) return rs &#125; &#125; &#125; return rs&#125; 进一步优化时间复杂度,用空间换时间两次一维循环,时间复杂度为O(n) 12345678910111213141516171819202122func twoSum(nums []int, target int) []int &#123; hash := make(map[int]int) for k, v := range nums &#123; hash[v] = k &#125; for k, v := range nums &#123; tmp := target - v if _, ok := hash[tmp]; ok &#123; if hash[tmp] == k &#123; continue//\"你不能重复利用这个数组中同样的元素\",防止如目标值为6,数组为[3,2,4]这种情况下[0,0]也符合条件 &#125; return []int&#123;k, hash[tmp]&#125; &#125; &#125; return nil&#125; 还可以继续优化为一次一维循环,时间复杂度为O(n) 12345678910111213141516func twoSum(nums []int, target int) []int &#123; hash := make(map[int]int) for k,v := range nums &#123; if j,ok := hash[target-v];ok &#123; return []int&#123;k,j&#125; &#125; hash[v] = k &#125; return nil&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"算法初步III","date":"2015-01-31T16:00:02.000Z","path":"2015/02/01/算法初步III/","text":"8.剖析大厂算法面试真题-高频题精讲(一) 3.无重复字符的最长子串leetcode-3 最大字符子串 Longest Common SubString, 又称为”LCS”问题 暴力法: 子序列和子串: 子序列不需要连续 暴力法的时间复杂度: 线性法: 复杂度分析: 优化的线性法: 4.寻找两个有序数组的中位数leetcode-4 寻找两个有序数组的中位数 暴力法: 切分法: 时间复杂度: 扩展一: 如果给定的两个数组都是没有经过排序处理的,应该如何找出中位数呢? 先合并排序,再找出中位数. 有无更好的方法呢? 扩展二: 对于分布式的大数据处理,应考虑两方面的限制: 每台服务器进行算法计算的复杂度限制,包括时间和空间复杂度 空间复杂度: 假设存储的都是32位整型,即4个字节,那么10亿个数需占用40亿字节,大约40GB 而快速排序的空间复杂度为log(n),那大约30次堆栈压入 服务器与服务器之间进行通信时的网络带宽限制 经典的快速选择算法 leetcode-23 合并K个排序链表 8.剖析大厂算法面试真题-高频题精讲(二) 合并区间+无重叠区间 火星字典 基本计算器 56.合并区间 leetcode-56 合并区间 435.无重叠区间 leetcode-435 无重叠区间 力扣上还有很多关于区间的问题 269.火星字典 leetcode-269 火星字典 772.基本计算器III leetcode-772 基本计算器III 10.剖析大厂算法面试真题-难题精讲(一) 正则表达式匹配 柱状图中的最大矩形 实现strStr() 10.正则表达式匹配 leetcode-10 正则表达式匹配 leetcode-44 通配符匹配 84.柱状图中最大的矩形 leetcode-84 柱状图中最大的矩形 28.实现strStr() leetcode-28 实现strStr() 11.剖析大厂算法面试真题-难题精讲(二) 回文对 至多包含K个不同字符的最长子串 接雨水II 336.回文对 leetcode-336 回文对 340.至多包含K个不同字符的最长子串 leetcode-340 至多包含K个不同字符的最长子串 407.接雨水II leetcode-407 接雨水II leetcode-417 太平洋大西洋水流问题 12.冲刺 刷题 简历 面试经验 刷题/Leetcode 这点上Golang差好多,能直接用的只有slice,map这聊聊几个… 最关键的不是量的问题,而是质的问题 白板面试注意事项: 刷过的题目忘了怎么办? 简历/Resume 面试经验/Interview","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"算法初步II","date":"2015-01-31T16:00:01.000Z","path":"2015/02/01/算法初步II/","text":"3.面试中常用的算法 - 排序 冒泡排序/Bubble Sort冒泡排序 是一种稳定的排序算法 插入排序/Insertion Sort与冒泡排序的区别: 在冒泡排序中,经过每一轮的排序处理后,数组后端的数是排好序的; 在插入排序中,经过每一轮的排序处理后,数组前端的数都是排好序的 算法思想: 不断地将尚未排好序的数插入到已经排好序的部分. 时间复杂度和冒牌排序一样,也是O(n的平方), 也是一种稳定的排序算法 leetcode-147 对链表进行插入排序 归并排序/Merge Sort 归并排序的核心思想是分治,把一个复杂问题拆分成若干个子问题来求解. 把数组从中间划分成两个子数组; 一直递归地把子数组划分成更小的子数组,直到子数组里面只有一个元素; 依次按照递归的返回顺序,不断地合并排好序的子数组,知道最后把整个数组的顺序排好 也是稳定的排序算法; 对两个有序的数组进行合并的操作,面试中常问…. 快速排序/Quick Sort 也采用了分治的思想 类似全班排高矮,找一个中中不溜的(即基准值),让所有人和ta比较.然后依次分组,再再每个组里再找一个中不溜的,继续下去… 快速排序是直接在原数组里进行各种操作,当子数组被分割出来时,原数组里的排序也改变了; 然后在子数组里继续找基准值,继续划分一直比下去,直到子数组元素个数为1(递归) 最差情况下,和冒泡排序一样 leetcode-215 数组中的第K个最大元素 拓扑排序/Topological Sort 拓扑是研究图论中,顶点和顶点连线之间的关系 一个有向无环图,可以有一个或多个拓扑排序的序列 一般会用广度/深度优先算法来构建 时间复杂度为O(n) 4. 面试中常用的算法–递归,回溯分析和处理问题的能力 递归/Recursion二叉树的很多性质,在定义上就满足递归. 可以使一个看似复杂的问题变得简洁和易于理解 经典案例: 汉诺塔(又称河内塔) 算法思想: leetcode-91 解码方法 递归思想是自顶向下; 动态规划思想是自底向上 leetcode-247 中心对称数II 两种方法,来解决递归算法的时间复杂度分析: 迭代法: 公式法: 计算递归函数复杂度最方便的工具, 只需牢记3种可能出现的情况,以及处理它们的公式即可. 回溯/Backtracking 回溯算法是一种试探算法, 可以避免我们走弯路 leetcode-39 组合总和 leetcode-52 N皇后II 回溯,实际上是用递归实现的.因此在分析回溯的时间复杂度时,其实就是在对递归函数进行分析. 递归和回溯,可以说是算法面试中,最重要的算法考察点之一,很多其他算法都有它们的影子,例如: 二叉树的定义和遍历, 归并排序,快速排序, 动态规划(实际是对递归的优化) 二分搜索(也可以利用递归去实现) 5.深度优先与广度优先算法 在整个算法知识点中占比非常大; 应用最多的地方是对图进行遍历(树也是图的一种) 深度优先搜索算法/DFS 深度优先搜索是一种在开发爬虫早期使用较多的方法。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。在一个HTML文件中，当一个超链被选择后，被链接的HTML文件将执行深度优先搜索，即在搜索其余的超链结果之前必须先完整地搜索单独的一条链。深度优先搜索沿着HTML文件上的超链走到不能再深入为止，然后返回到某一个HTML文件，再继续选择该HTML文件中的其他超链。当不再有其他超链可选择时，说明搜索已经结束。 深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次. 和走迷宫一样,尽量往深处走. 一般用来解决连通性的问题 深度优先遍历必须依赖栈(Stack)这个数据结构 选择一个起始点,不停地压入和弹出.. 例题: 递归实现: 非递归实现: 复杂度分析: 如何利用DFS寻找最短路径? 广度优先搜索算法/BFS 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 BFS，其英文全称是Breadth First Search 一般用来解决最短路径的问题 广度优先遍历需要借用的数据结构是队列(Queue) 选择一个起始顶点: 队列为空,说明所有的点都被标记过了,结束搜索 复杂度分析: 扩展:从A走到B最多允许打通3堵墙,求最短路径的步数: 面试时,都可以从最暴力的办法开始想,然后一步步优化. 6.动态规划/Dynamic Programming 大事化小,小事化了 leetcode-300 最长上升子序列 子序列和子数组不同,不需要元素是连续的 leetcode-198 打家劫舍 leetcode-62 不同路径 常见问题: 线性规划/Linear Programming(最为简单) 求dp[i]的办法,主要有两种: “0-1思想” leetcode-198 打家劫舍 leetcode-62 不同路径 当前值依赖于前面所有计算好的值 区间规划/Interval Programming leetcode-516 最长回文子序列 约束规划/Constraint Programming NP完全问题: NP即非决定性多项式/Non-deterministic Polynomial 无法在多项式的时间内解答…(即时间复杂度为指数级,阶乘级等,这对计算机来说是接收不了的) 时间复杂度 并不是程序解决问题需要花费的具体时间,而是程序运行时间随着问题规模扩大,增长得有多快…如果是O(1),即无论规模多大,时间都是固定的;如果是O(n),即随着规模线性增加 “0-1背包问题”的时间复杂度,是一个非多项式级别的… 7.二分搜索算法与贪婪算法 二分搜索/Binary Search 也称为”折半搜索”,”对数搜索”,前提必须是排好序的 优点和缺点: 递归写法与非递归写法: 递归写法: 时间复杂度分析: 非递归写法: 二分搜索的核心: 确定搜索的范围和区间 取中间的数判断是否满足条件 如果不满足条件,判定应该往哪个半边继续进行搜索 &lt;编程珠玑&gt;中写道:只有10%的程序员能正确写出二分搜索的代码. 面试题好多都是经典二分搜索的变形: 找确定的边界 34. 在排序数组中查找元素的第一个和最后一个位置 递归的写法: 找模糊的边界 所谓模糊的边界,即边界的值不等于目标的值,而是大于或小于目标的值. 当不满足条件,而middle的数等于target时怎么办? leetcode-33 搜索旋转排序数组 不定长边界 代码实现: 贪婪/Greedy 贪婪是一种在每一步都采取在当前状态下最好或最优的选择,从而希望导致结果是最好或最优的算法 贪婪算法的反例:0-1背包问题 leetcode-253 会议室II 面试中 贪婪算法 考察不多. 二分搜索算法是重中之重,看似简单,但想写对并不容易","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"算法初步","date":"2015-01-31T16:00:00.000Z","path":"2015/02/01/算法初步/","text":"0.算法功底决定Offer质量 算法能力能够准确判别一个程序员的技术功底是否扎实 算法能力是发掘程序员学习能力与成长潜力的关键手段 算法能力能够协助判断程序员分析并解决突发问题的能力 算法能力是设计一个高性能系统的必备基础 1.掌握实用的数据结构数据结构是算法的基石,算法是否足够优秀,往往取决于使用的数据结构是否恰到好处 1.1 常用数据结构和技巧/Common Data Structure 数组,字符串/Array&amp;String 翻转字符串: 用两个指针,最开始分别指向首尾,相互交换..而后向中央靠拢,直到相遇为止 leetcode-242 有效的字母异位词 链表/Linked List 优点:123灵活地分配内存空间能在O(1)时间内删除或者添加元素 缺点: 1查询元素需要O(n)时间,即需要从头开始遍历 相比于数组,链表可以不需要开辟一段连续的内存空间,但同时不能通过下标进行查询.如果需要经常查询和遍历的场景,不是太合适优先考虑链表 而如果数据的元素个数不确定,而且频繁需要写操作,链表较合适. 而元素个数确定,删除/插入操作并不多,则数组更为适合 解题技巧: 利用快慢指针(有时甚至需要用到三个指针), 如链表的翻转, 寻找第K个元素, 寻找链表中中间位置的元素, 判断链表是否有环等 构建一个虚假的链表头,一般用需要返回一个新的链表的题目中 如 两个已排好序的链表,进行整合排序 将链表的奇偶数按原定顺序分离,生成前半部分为奇数,后半部分为偶数的链表 如果不用一个虚假的链表头,那么在创建新链表的第一个元素时,都需要判断链表的头指针是否为空,即需要多写一条if else语句. 比较简洁的写法是创建一个新的链表头,直接往其后面添加元素即可.最后返回这个空的链表头的下一个节点 如何训练该技巧: 在纸上或者白板上画出节点之间的相互关系. 画出修改的方法. 凭空想象非常困难 leetcode-21 合并两个有序链表 leetcode-25 K个一组翻转链表 数组和链表为物理数据结构,下面的是逻辑数据结构,其实现都是基于数组或链表 栈/Stack leetcode中等偏上题目经常用到的数据结构 后进先出(LIFO) 所有操作,都是在栈顶部完成的, 如何实现: 可以用一个单链表来实现栈这种逻辑数据结构 何时用到栈: 只关心最近一次的操作,且在操作完成后,需向前查找更前一次的操作 leetcode-22 括号生成 (利用一个栈,不断地往里面压左括号,一旦遇到一个右括号,就把栈顶的左括号弹出来,表示这是一个合法的组合..直到最后,判断栈里还有无左括号剩余) leetcode-739 每日温度 (最直观的做法,就是针对每个温度值,向后进行一次搜索,找到比当前温度更高的值,O(n的平方)…这种办法做了许多重复的对比) (利用一个堆栈stack,从头扫描T,如果当天的温度比堆栈顶端那一天的温度还要高,那就知道结果了..O(n) ) 队列/Queue 先进先出(FIFO) 只允许在队尾查看和添加数据,在队头查看和删除数据. 如何实现队列: 用一个双链表,其头指针(front)允许在队头查看和删除数据,尾指针(rear)允许在队尾查看和删除数据 何时用到队列: 需要按照一定得顺序处理数据,而数据在不断的变化… 广度优先搜索,是运用队列最多的地方 双端队列/Deque 队列的头尾两端,能在O(1)的时间内进行数据的查看,添加和删除 如何实现双端队列: 用一个双链表 何时用到双端队列: 实现一个长度动态变化的窗口或者连续区间,而动态窗口这种数据结构,在许多题目里都用应用 leetcode-239 滑动窗口最大值 拿到一道题目时,先想想最直观的做法,然后考虑对其进行优化 暴力解法: O(n*k) 优化解法: 可以用一个双端队列来表述这个窗口,双端队列保存当前窗口中最大的那个数的下标,双标队列新的头,总是当前窗口中最大的那个数..同时,有了这个下标,可以很快的知道新的窗口是否已经不再包含原来那个最大的数,如果不再包含,就把原来那个旧的最大的数从双端队列的头部删除..不管窗口的长度k多长,因为数组里的每个数,都分别被压入和弹出双端队列一次,所以可以优化到O(n)的时间复杂度 会频繁进行两个操作: 将新的数据加到窗口的尾部, 将旧的数据从窗口头部删除 双端队列可以使如上量操作在O(1)内完成 树/Tree 树的共性: 结构直观 通过树问题 来考察递归算法掌握的熟练程度, 即一棵树要满足某种性质,往往要求每个节点都满足. 例如在定义一颗二叉搜索树时,每个节点也都必须是一棵二叉搜索树…故而树的问题和对递归的考察紧密相连 常考的树的形状有: 普通二叉树 平衡二叉树 完全二叉树 二叉搜索树 四叉树 多叉树 特殊的树:(不需花费太多精力) 红黑树 自平衡二叉搜索树 对于树的考察,无非就是树的遍历和序列化 遍历 前序遍历(Preorder Traversal) 先访问根节点,然后左子树,再右子树; 主要用于在树里进行搜索,以及创建一棵新的树 中序遍历(Inorder Traversal) 主要用于 二叉搜索树,因为二叉搜索树的特点就是左孩子小于根节点,根节点小于右节点 后序遍历(Postorder Traversal) leetcode-250 统计同值子树 对某个节点进行分析时,需要用到左子树和右子树的信息,即所需要的信息,是从树的底部不断向上进行..好比修剪一棵树的叶子,方法是从外面将叶子不断修剪掉 掌握好这三种遍历的递归写法和非递归写法,及分析它们的时间复杂度和空间复杂度… 掌握好树,说明对递归有很好的认识,可以帮助学习图论; 二叉搜索树尤其是热门考点(中序遍历尤其爱考,因为节点被遍历到的顺序,是按照数值大小的顺序排列好的–仅仅针对BST,普通二叉树并不满足).. 如: leetcode-230 二叉搜索树中第K小的元素 中序遍历一遍,访问到第K个元素时,返回结果即可; 还可以问求解第K大的元素,对这个二叉搜索树进行反向的中序遍历 2 (相对)高级的数据结构 Advanced Data Structure解决一些中等难度以上的题目 优秀的算法往往取决于你采用的数据结构 其实现比常用数据结构要复杂很多,在处理一些复杂问题的过程中,多拥有一把利器.掌握好其性质和所适用的场合,在分析问题时回归本质,很多问题即可迎刃而解 优先队列/Priority Queue 与普通队列的区别: 保证每次取出的元素是队列中优先级最高的 优先级别可自定义 最常用的场景: 从一堆杂乱无章的数据中,按照一定的顺序(或优先级)筛选(部分或全部)数据 如找出一个数组前K大的数,最直接的办法是排序,然后依次输出前K大的数..依据快速排序,时间复杂度为O(nlogn)..而如果借用优先队列,就可以将时间复杂度优化至O(K+nlogK),当数据量n很大,而K相对较小时,可以大为降低时间复杂度.. 其本质在于,要找出前K大的数,并不需要对所有的数进行排序 优先队列的本质,是一个二叉堆结构,堆在英文里叫做Binary Heap, 是利用一个数组结构来实现的完全二叉树; 换句话说,优先队列的本质是一个数组,数组里的每个元素,既有可能是其他元素的父节点,也有可能是其他元素的子节点,而且每个父节点只能有两个子节点. 最基本的操作就是两个: 向上筛选 (sift up / bubble up) 由于二叉堆是一棵完全二叉树,且堆的大小为K,从下面往上爬,就需要O(logK)的时间, 向下筛选 (sift down / bubble down) 由于二叉堆是一棵完全二叉树,且堆的大小为K,从上面往下,也是需要O(logK)的时间 另一个重要的时间复杂度: 优先队列的初始化 初始化一个大小为n的堆,时间复杂度为O(n). 不需要推导 leetcode-347 前K个高频元素 看到”前k个”这样的字眼,就应该很自然地想到用优先队列. 优先级别如何选定呢?可以由出现的次数来决定.. 统计词频的最佳数据结构,是哈希表 图/Graph 图是所有数据结构中,知识点最丰富的一个: 阶,度(又分出度和入度) 树,森林,环 有向图,无向图,完全有向图,完全无向图 连通图,连通分量 图的存储和表达方式: 邻接矩阵,邻接链表 围绕图的算法,也是各式各样: 图的遍历: 深度优先,广度优先 环的检测: 有向图,无向图 拓扑排序 最短路径算法: Dijkstra,Bellman-Ford,Floyd Warshall 连通性相关算法: Kosaraju,Tarjan,求解孤岛的数量,判断是否为树,图的着色,旅行商问题(Traveling Salesman Problem),TSP)等 不需要对每一个都一一掌握,需要有的放矢 必须熟练掌握的: 图的存储和表达方式: 邻接矩阵,邻接链表 图的遍历: 深度优先,广度优先 二部图的检测(,又称二分图,Bipartite),树的检测,环的检测(包括有向图和无向图) 拓扑排序 联合-查找算法(Union-Find) 最短路径: Dijkstra,Bellman-Ford(能区分不同,知道在不同场景该用哪个即可) “二部图的检测(Bipartite),树的检测,环的检测(包括有向图和无向图)”,”拓扑排序”,都是基于图的遍历,尤其是深度优先遍历.遍历可以在邻接矩阵或邻接链表上进行 leetcode-785 判断二分图 前缀树(字典树)/Trie 被广泛地应用于字典查找中 什么是字典查找? 例如: 给定一系列构成字典的字符串,要求在字典当中找出所有以”ABC”开头的字符串 方法一:暴力搜索法 假设要匹配的开头长度为m,则该方法时间复杂度为O(m*n) 方法二: 前缀树 时间复杂度O(x),x标识字典里单词最长的那个单词的字符个数. 在大多数情况下,字典里的单词个数n,是远远大于x的 前缀树的经典应用: 搜索框输入搜索文字,会罗列以搜索词开头的相关搜索 汉语拼音输入法的联想输出(输入内容为”cuis”) 重要性质: 每个节点至少包含两个基本属性: children: 数组或集合,罗列出每个分支当中包含的所有字符 isEnd: 布尔值,表示该节点是否为某字符串的结尾 前缀树的根节点是空的.即只利用到了这个节点的children属性, 除了根节点,其他所有节点都可能是单词的结尾,叶子节点一定都是单词的结尾 最基本操作: 创建 遍历一遍输入的字符串,对每个字符串的字符进行遍历. 从前缀树的根节点开始,将每个字符加入到节点的children字符集当中 如果字符集已经包含了这个字符,跳过 如果当前字符是字符串的最后一个,则把当前节点的isEnd标记为真 前缀树真正强大之处在于,每个节点还能用来保存额外的信息, 如用来记录拥有相同前缀的所有字符串,这样当用户输出某个前缀时,就能在O(1)的时间内给出全部推荐字符串 搜索 (创建完成后,搜索实际非常简单了) 从前缀树的根节点出发,逐个匹配输入的前缀字符 如果遇到了,继续往下一层搜索, 如果没遇到,立即返回 leetcode-212 单词搜索II 使用深度优先算法(想象成走迷宫) 线段树/Segment Tree 由来: 什么是线段树: 线段树的实现,在书写起来有些繁琐,需要不断练习,才能加深印象.. leetcode-315 计算右侧小于当前元素的个数 树状数组(Fenwick树, 二叉索引树)/Fenwick Tree,Binary Indexed Tree 树状数组又称芬威克树,二叉索引树，概念上是树状，实际上是使用数组实现的，表现为一种隐式数据结构 由来: 因为只需要求解前K个元素的总和,不需要是任何一个区间,而树状数组的实现比线段树更容易 参考: 树状数组 重要的基本特征: leetcode-308 二维区域和检索-可变 总结: 优先队列: 经常考察,但其实现比较繁琐.许多编程语言都有其实现,届时直接”拿来主义”使用即可…(但还是建议自己实现一个优先队列) 图:大数据问题常常都得使用图论 前缀树: 一般出现在面试的难题中,往往需要自己实现一棵前缀树 线段树和树状数组: 应用场合比较明确","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"约瑟夫环问题","date":"2014-12-31T16:01:02.000Z","path":"2015/01/01/约瑟夫环问题/","text":"剑指 Offer 62. 圆圈中最后剩下的数字 难度: 简单 约瑟夫问题/约瑟夫斯置换 真正的俄罗斯轮盘赌 递归写法: 123456789func lastRemaining(n int, m int) int &#123; if n == 1 &#123; return 0 &#125; else &#123; return (lastRemaining(n-1,m) +m) %n &#125;&#125; 非递归写法: 123456789101112131415161718192021222324252627282930313233343536func lastRemaining(n int, m int) int &#123; var ( find int //find=1找到下一个猴子让它出去 count int //count计数是否数到m num int //当num到达N-1时，只剩一只猴子 flag = []int&#123;&#125; //flag[i],该猴子已经出去了 rs int // 最终结果 ) for i := 0; i &lt; n; i++ &#123; flag = append(flag, 0) &#125; i := 0 //找下一只要出去的猴子从i开始找 for num != n-1 &#123; find = 0 count = 0 for ; find == 0; i++ &#123; t := i % n if flag[t] == 0 &#123; count += 1 &#125; if count == m &#123; num++ find = 1 flag[t] = 1 &#125; &#125; &#125; for i = 0; i &lt; n; i++ &#123; if flag[i] == 0 &#123; rs = i &#125; &#125; return rs&#125; 这种写法反而耗费的时间更长 地产商都来抢饭啦..","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"剑指 Offer 07. 重建二叉树","date":"2014-12-31T16:00:07.000Z","path":"2015/01/01/剑指-Offer-07-重建二叉树/","text":"剑指 Offer 07. 重建二叉树 难度: 中等 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123; if len(preorder) == 0 &#123; return nil &#125; root := &amp;TreeNode&#123;preorder[0], nil, nil&#125; i := 0 for ; i &lt; len(inorder); i++ &#123; if inorder[i] == preorder[0] &#123; break &#125; &#125; root.Left = buildTree(preorder[1:len(inorder[:i])+1], inorder[:i]) root.Right = buildTree(preorder[len(inorder[:i])+1:], inorder[i+1:]) return root&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Go内存详解","date":"2014-04-01T15:52:01.000Z","path":"2014/04/01/Go内存详解/","text":"C++ 堆区，栈区，数据段，bss段，代码区（详解） 1.内存分区 代码经过预处理,编译,汇编,链接4步后,生成一个可执行程序.(编译原理中的必学内容) 三大平台都有size命令,用来查看一个程序的信息 text:表示代码区的大小.程序编译完之后,代码区的大小是固定的. data &amp; objc(Windows中为bss): 程序中用到的数据内容 dec &amp; hex:十进制大小和十六进制大小 在程序还没有运行之前,即还没有加载到内存前,其内部已经分好了三段信息,分别为:代码区(text),(初始化)数据区(data),和未初始化数据区(bss). 有时也会把data和bss合称为静态区或全局区 1.1 代码区(text) 存放CPU执行的机器指令. 通常代码区是可共享的,即另外的执行程序可以调用它,使其可共享的目的是: 对于频繁被执行的程序,只需要在内存中有一份代码即可. 代码区通常是只读的,使其只读的原因是防止程序意外地修改了它的指令. 另外,代码区还规划了局部变量的相关信息. 1.2 全局初始化数据区/静态数据区(data) 该区包含了在程序中明确被初始化的全局变量,已经初始化的静态变量(包括全局静态变量和局部静态变量),以及常量数据(如字符串常量等) 1.3 未初始化数据区(bss) Go中bss为0,因为Go语言所有的数据,默认都是初始化的,如定义了一个字符串,其默认为””,因此是在data区域. 而对于C语言,如声明了一个int a,是存在bss区域,而不是data区域---如果程序中有用到该变量,而又没有初始化,可能会导致错误的产生.. Go这一点与C不同,摒弃了放在bss区,而是放在了data区. text区,data区和bss区,栈区(stack),堆区(heap),合称内存四区 1.4 栈区(stack) 栈区大小是有限制的,大小为1M, 超过1M大小,就要放到堆区.. 栈区大小限制可以扩展,Windows中最大可扩展为10M, Linux中最大可扩展为16M 1.5 堆区(heap) 堆区的大小和内存条的大小有关.一般堆区最大值不会超过内存大小的一半 Go用new()创建一块空间,不需要管释放..因为有垃圾回收机制,去自动释放 在Go中,对栈区和堆区集中管理,给用户即程序员暴露了一个虚拟的内存区域. 在32位系统上,这个地址一般以0xc0420开头 栈区是从高地址向低地址进行数据的存储 代码区和数据区是所有程序共享的吗? 代码区是的,数据区是独有的,B程序获取不到A的数据区(但可用通过一些手段/第三方软件,如Cheat Engine软件,可以用来修改其他程序的内存地址,如修改一些游戏里面参数的值) 2.Go Runtime内存分配 即在内存四区的基础上加了一层 可参考: TCMalloc原理 2.1 基本策略 Go启动后,内存消耗量会比较大,因为会申请一大块内存 每次从操作系统申请一大块内存,以减少系统调用(并不一定是”大块连续内存”) 将内存切分成小块,构成双向链表 为对象分配内存时,只需从大小合适的链表中提取一个小块即可 回收对象内存时,将该小块内存重新归还到原链表,以便复用(而不是归还给操作系统,这样能减少系统调用) 如果闲置内存太多,将尝试归还部分内存给操作系统,降低整体开销 Go的内存操作模型---高端面试常问… 为什么用链表而不用数组? 因为申请的空间,并不是一个连续的空间 2.2 内存管理单元 _PageShift为上移或左移的意思 _PageSize为页大小 将1左移13,即1后面加上13个0,这个二进制值即是8KB arean区域 bitmap区域 spans区域 bitmap即 位图 用4个bit(位)来标住对象包含的指针和GC信息 垃圾回收时,先在bitmap中查找相关信息 2.3 内存管理组件 内存分配由内存分配器完成,分配器由三种组件构成: cache: 每个运行期工作线程都会绑定一个cache,用于无锁object的分配 central: 为所有的cache提供切分好的后辈span资源 heap: 管理闲置span,需要时向操作系统申请内存 2.3.1 cache 通过mcache,去管理mspan span存的是页的信息,一页有8KB. //runtime/sizeclasses.go12345678910const ( _MaxSmallSize = 32768 smallSizeDiv = 8 smallSizeMax = 1024 largeSizeDiv = 128 _NumSizeClasses = 67 _PageShift = 13)var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125; 一个”页”分成了67个块内容,加起来正好是8KB大小. 而bitmap标识页里面的这些个块,到底有没使用 2.3.2 central //runtime/mcentral.go 2.3.3 heap 三个层次,层层递进 //runtime/mheap.go 三者关系 mheap负责管理申请堆区空间 sizeclass,译作”规格” 最接近数据块的是mcache,其每一个对象都绑定着相关信息,想使用时找mcentral,去找到一个对应规格的mspan. 由mheap去分配 2.4 分配流程 (一层层逐级向上找) 计算待分配对象的规格(size_class) 从cache_alloc数组中找到规格相同的span 从span.manualFreeList链表主提取可用的object 如果span.manualFreeList为空,从central获取新的span 如果central.nonempty为空,从heap.free/freelarge获取,并切分成object链表 如果heap没有大小合适的span,向操作系统申请新的内存 2.5 释放流程 将标记为可回收的object交还给所属的span.freelist(在bitmap里面有标记) 该span被放回central,可以提供cache重新获取 如果span已全部回收object,将其交还给heap,以便重新分切复用 定期扫描heap里闲置的span,释放其占用的内存 注: 以上流程不包括大对象,它直接从heap分配和释放 2.6 总结 Go语言的内存分配非常复杂,一个原则就是能复用的一定要复用 Go在程序启动时,会向操作系统申请一大块内存,之后自行管理 Go内存管理的基本单元是mspan,它由若干个页组成,每种mspan可以分配特定大小的object mcache,mcentral,mheap是go内存管理的三大组件,层层递进. mcache管理线程在本地缓存的mspan; mcentral管理全局的mspan供所有线程使用; mheap管理Go的所有动态分配内存. 一般小对象通过mspan分配内存; 大对象则直接由mheap分配内存 3. Go GC 垃圾回收 Go的垃圾回收也是并行的 参考: 带你领略Go源码的魅力 | Go内存原理详解 2021补充参考： 可视化Go内存管理 图解Go运行时调度器 已将Tony Bai大佬博客添加友链 ^_^ Go memory allocator","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang利用组合实现继承,和php或java面向对象的继承有何不同","date":"2014-03-01T15:54:15.000Z","path":"2014/03/01/golang利用组合实现继承-和php或java面向对象的继承有何不同/","text":"对于golang Go语言不支持继承,但支持组合.面向对象语言继承中的部分功能,可以使用组合来近似实现. 组合由结构体嵌套结构体来实现. 假设有两个结构体--- 作家author(“父类”)和作品work(“子类”),两结构体字段如下: 1234567891011121314type author struct &#123; name string //作者名 nationality string //国籍 gender string age int work //匿名(或者称为内嵌)字段，即该字段没有显式的名字。仅指明字段的类型，此时该类型就是字段的名字。切片类型在嵌套结构体时不能匿名,但结构体类型在嵌套结构体时可以匿名&#125;type work struct &#123; name string //作品名 category string //作品类型 completedYear int //完笔年份&#125; author结构体的字段有name, nationality, gender, age, 同时嵌套一个匿名结构体work。该字段表明author结构体是由work结构体组合而成。则现在结构体author可以访问work结构体的所有成员和方法。声明一个work类型的变量w,再声明一个author类型的变量a;123456789101112131415161718192021222324var w workw.name = \"战争与和平\"w.category = \"masterpiece\"w.completedYear = 1869//等同于 //w := work&#123;// name:\"战争与和平\",// category:\"masterpiece\",// completedYear:1869,//&#125;var a authora.name = \"托尔斯泰\"a.nationality = \"俄国\"a.gender = \"男\"a.age = 82a.work = wfmt.Printf(\"作者名为:%s,作品名为:%s\", a.name, a.work.name)fmt.Println(\"\\n\")fmt.Println(a.category)fmt.Println(a.work.category)一旦一个结构体嵌套另外一个结构体，Go访问嵌套结构体成员时，就好像是在访问自己结构体成员。也就是说a.work.category可以用a.category来代替。 但当两个结构体都有一个相同字段时,如此处的name,则访问”子结构体”work中的name属性,需要a.work.category,中间的.work不能省却; 上述代码输出: 1234作者名为:战争与和平,作品名为:战争与和平masterpiecemasterpiece 结构体的同名成员(字段)在嵌套时如此,那同名的方法呢? 见如下代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport \"fmt\"type author struct &#123; name string //作者名 nationality string //国籍 gender string age int work //匿名(或者称为内嵌)字段，即该字段没有显式的名字。仅指明字段的类型，此时该类型就是字段的名字。切片类型在嵌套结构体时不能匿名,但结构体类型在嵌套结构体时可以匿名&#125;type work struct &#123; name string //作品名 category string //作品类型 completedYear int //完笔年份&#125;func (aa author) printSomething() &#123; fmt.Println(\"我是作家\")&#125;func (ww work) printSomething() &#123; fmt.Println(\"我是著作\")&#125;func (ww work) tellYouSomething() &#123; fmt.Println(\"作者将“战争”与“和平”的两种生活、两条线索交叉描写，构成一部百科全书式的壮阔史诗。\")&#125;func main() &#123; var w work w.name = \"战争与和平\" w.category = \"masterpiece\" w.completedYear = 1869 //等同于 //w := work&#123; // name:\"战争与和平\", // category:\"masterpiece\", // completedYear:1869, //&#125; var a author a.name = \"托尔斯泰\" a.nationality = \"俄国\" a.gender = \"男\" a.age = 82 a.work = w a.printSomething() a.work.printSomething() a.tellYouSomething() a.work.tellYouSomething()&#125; 输出为:1234我是作家我是著作作者将“战争”与“和平”的两种生活、两条线索交叉描写，构成一部百科全书式的壮阔史诗。作者将“战争”与“和平”的两种生活、两条线索交叉描写，构成一部百科全书式的壮阔史诗。 可见对方法同样如此. 另注: golang中的方法和函数与其他编程语言中的同名概念有所不同.官方定义是方法是包含了接收者的函数; Golang 不是一个纯粹的面向对象的编程语言，它不支持类。因此通过在一个类型上建立方法来实现与 class 相似的行为。同名方法可以定义在不同的类型上，但是 Golang 不允许同名函数。假设有两个结构体 Square 和 Circle。在 Square 和 Circle 上定义同名的方法是合法的。 更多可点击,尤其是其中”值接收者和指针接收者”值得一看 参考 : Golang 入门 : 结构体(struct) Golang教程第27节–组合取代继承 golang 组合 继承 对于php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class author &#123; var $name = \"托尔斯泰\" ; var $nationality = \"俄国\"; var $gender = \"男\"; var $age = 82; public function printSomething($one,$two)&#123; echo \"我是作家\\n\"; var_dump($one); var_dump($two); &#125; public function father()&#123; echo \"我是父类中的方法\\n\"; &#125;&#125;class work extends author &#123; var $name = \"战争与和平\"; var $category = \"masterpiece\"; var $completedYear = 1869; public function printSomething($one,$two)&#123; echo \"我是著作\\n\"; var_dump($one); return \"666\"; &#125; public function children()&#123; echo \"我是子类中的方法\\n\"; &#125;&#125;$cs = new work();$cs-&gt;father();$cs-&gt;children();$cs-&gt;printSomething(\"shuang\",\"hahaha\");echo $cs-&gt;name;echo PHP_EOL; 输出结果为: 12345我是父类中的方法我是子类中的方法我是著作string(6) &quot;shuang&quot;战争与和平 总结 对方法的调用: $this-&gt;方法名();如果子类中有该方法则调用的是子类中的方法，若没有则是调用父类中的; 在子类内部,使用parent::则始终调用的是父类中的方法。 对变量的调用： $this-&gt;变量名；如果子类中有该变量则调用的是子类中的，若没有则调用的是父类中的 思考:如上代码中,如何在只实例化子类而不实例化父类的前提下,也不修改和侵入子类代码的情况下,实现调用父类中的(被子类重写的)printSomething()方法? 另注:自PHP5.3之后,子类重写(override)父类方法时(即在子类中重新定义一个和父类中某方法同名的新方法),子类中这个新方法的形参和父类的形参个数必须一致(因为php是弱类型语言,所以对类型是否一致不要求),对返回值无要求; (如上面代码中,如果class work中的printSomething方法只有一个参数即printSomething($one),则在运行时会报错: Warning: Declaration of work::printSomething($one) should be compatible with author::printSomething($one, $two) in /Users/xxxx/xxx/xxx.php on line xx) 对于静态方法,情况类似 参考: php面向对象的重写与重载 PHP类方法重写原则 php子类中如何调用父类中的变量和方法 php继承父类，子类和父类中都有同名方法，实例化子类，在父类中调用这个方法，调用的是子类的","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"重写(Override)与重载(Overload)","date":"2014-02-28T16:01:03.000Z","path":"2014/03/01/重写-Override-与重载-Overload/","text":"其实叫覆盖与重载更好一些,能够分得更为明晰","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Java","slug":"Java","permalink":"http://www.dashen.tech/tags/Java/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang internal代码包","date":"2014-02-28T16:00:01.000Z","path":"2014/03/01/golang-internal代码包/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang实现多态","date":"2014-02-28T16:00:00.000Z","path":"2014/03/01/golang实现多态/","text":"系列文章： golang利用组合实现继承,和php或java面向对象的继承有何不同 Golang类型断言 golang之interface入门 interface,鸭子类型与泛型 golang中「实现」OOP 封装、继承和多态 面向对象的三个基本特征 继承,多态,封装,是面向对象的三大特性. 封装 Encapsulation 指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。 三个访问控制符: private、 protected 和 public Go中用大小写以及internal文件夹机制,近似实现了权限控制 大小写: 无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用 可以简单的理解成，首字母大写是公有的，首字母小写是私有的 internal: 参考: golang internal代码包 继承 对于Java: 使用 extends 作为继承的关键字，子类扩展了父类，获得父类的全部成员变量和方法。 在重写父类方法应遵循 “两同两小一大“ 规则： “两同” 指方法名相同、形参列表相同； “两小” 指子类方法返回值类型和抛出的异常类型应比父类方法的更小或相等； “一大” 指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 Go中用结构体的嵌套,近似实现了继承 golang之struct入门 golang利用组合实现继承,和php或java面向对象的继承有何不同 多态 Polymorphisn 继承和封装都很好理解,但多态则要相对晦涩一些. 谈谈对Java多态的理解 相同类型的变量调用同一个方法时呈现出多种不同的行为特征。(仅指运行时多态) 编译类型看左边，运行类型看右边 Java的编译时多态: (也称静态多态) 在编译期间就能决定要执行的方法, 一般通过重载(overloading)来实现 方法名相同,参数不同(如参数类型/数量不同) 使用时只要传的参数不同,在代码编译期,就能知道需要执行哪个方法 Java的运行时多态 (也称动态多态) 在运行期间才能决定要执行的是哪个方法 通过覆盖(overriding,也称为重写)和继承来实现(即在继承时,子类覆写父类的方法,且方法名和参数完全一致) 同名同参 JVM决定目标方法 执行结果为: 123456789dog is running...animal is eatting...cat is running...cat is eatting... 在编译时,还无法确定要执行的方法,只有在运行时才能决定到底执行哪个 动态多态的实现: 借助于JVM中的方法表,方法的实际入口地址,指向的是最终实现了这份方法的实例(即为何会输出dog is running而不是animal is running) 重载（Overload）和重写（Override）区别： 重载指的是同一类中多个同名方法； 重写指的是子类和父类的同名方法。 参考: 重写(Override)与重载(Overload) golang”实现”多态 接口与鸭子类型 只要能”嘎嘎叫”,即只要有鸭子的这个行为,就认为这是个鸭子…管你是鸭子还是鸡,还是飞禽走兽,甚至是电脑是玩具,只要能发出叫声,即只要实现了”叫”这个方法,就认为这是鸭子即更关注对象的行为,而不是它的类型 更关注行为,不关注类型…即不问出身,不管是不是贫农,只要一起干革命,心向马列主义,就认为是自己人 golang中的鸭子类型 Python Vs Go，鸭子类型，你有我也有 Golang中的接口与鸭子类型 关于上面链接中提到的: 在golang中，值接收者和指针接收者的方法集是不同的。只是golang会智能地解引用和取引用，使得二者的方法集看上去是一样的。但是，在调用exchangeThese时，就凸显出二者的不同了。 可以参见 用好指针 肯定会与结构体,与接口联系在一起 知道指针,可以知道值;反之则不然. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport \"fmt\"type Substance interface &#123; //body,substance,object均有\"物体\"的意思 Say()&#125;type Dog struct &#123; name string color string age int&#125;type ElectricDog struct &#123; name string color string&#125;type Cat struct &#123;&#125;func (Dog) Say() &#123; fmt.Println(\"汪汪汪\")&#125;func (ElectricDog) Say() &#123; fmt.Println(\"哇哇哇\")&#125;func (Cat) Say() &#123; fmt.Println(\"喵喵喵\")&#125;func DoSay(sth Substance) &#123; sth.Say()&#125;func main() &#123; d := Dog&#123;\"狗\", \"黑色\", 3&#125; e := ElectricDog&#123;\"电动玩具狗\", \"白色\"&#125; c := Cat&#123;&#125; DoSay(d) DoSay(e) DoSay(c)&#125; 输出为: 123汪汪汪哇哇哇喵喵喵 代码中的体现: 参考: 理解 Go interface 的 5 个关键点","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"interface底层实现","date":"2013-12-27T13:22:49.000Z","path":"2013/12/27/interface底层实现/","text":"Go 语言设计与实现-4.2 接口 Go语言底层原理剖析 https://zhuanlan.zhihu.com/p/27652856 Go Interface 实现","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go中三种类型的指针","date":"2013-12-23T13:14:26.000Z","path":"2013/12/23/Go中三种类型的指针/","text":"https://segmentfault.com/a/1190000039165125 https://www.google.com.hk/search?q=uintptr&amp;oq=uintptr&amp;aqs=chrome..69i57j0i512l9.123j0j1&amp;sourceid=chrome&amp;ie=UTF-8 https://shuzang.github.io/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"goexit","date":"2013-12-17T15:13:04.000Z","path":"2013/12/17/goexit/","text":"https://qcrao.com/2021/06/07/where-is-goexit-from/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"死等和忙等","date":"2013-12-15T12:50:24.000Z","path":"2013/12/15/死等和忙等/","text":"https://www.google.com.hk/search?q=%E5%BF%99%E7%AD%89&amp;newwindow=1&amp;sxsrf=AOaemvLKlSjlMsZN0_f35RgB_Gyh6YUppg:1639572605460&amp;ei=feS5YcXFG4ndmAXOs7XwBg&amp;start=0&amp;sa=N&amp;ved=2ahUKEwiF-Oz16-X0AhWJLqYKHc5ZDW44ChDy0wN6BAgBEDY&amp;biw=1800&amp;bih=925&amp;dpr=1.6 https://blog.csdn.net/liuchuo/article/details/51986201","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"符号和符号表","date":"2013-12-15T05:40:16.000Z","path":"2013/12/15/符号和符号表/","text":"https://www.google.com.hk/search?q=%E7%AC%A6%E5%8F%B7%E8%A1%A8&amp;oq=%E7%AC%A6%E5%8F%B7%E8%A1%A8&amp;aqs=chrome..69i57j0i512l9.341j0j1&amp;sourceid=chrome&amp;ie=UTF-8","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"进程调度算法","date":"2013-12-10T13:24:11.000Z","path":"2013/12/10/进程调度算法/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"网络相关","date":"2013-04-23T14:15:39.000Z","path":"2013/04/23/网络相关/","text":"非常赞：计算机网络常用知识总结！ tcp-ip-protocol 计算机网络主要指的就是TCP/IP协议栈 TCP/IP是互联网的基石,也是互联网时代最伟大的发明 一. TCP/IP协议体系的认知 数据链路层,网络层(IP),传输层(TCP,UDP),都封装于操作系统内部,属于内核态的东西. 用户态的只有应用层, 二. 数据链路层 以太网帧的格式 MTU的概念(最大传输单元) ARP协议和RARP协议(地址解析和逆地址解析)网卡的mac地址和ip地址互查的一个机制 ARP协议, 公正来说算是链路层而不是网络层,可以算作是链路层和网络层之间的一个中间协议 ARP查询原理: ARP缓存: 三. 网络层 IP协议 掌握IP首部格式: 如16位分片标识,DF不分片标志,MF更多分片标志,13位片偏移,8位生存时间TTL,16位的首部检验和等 掌握IP分片: 如何避免ip分片(可以在应用层或传输层做限制)?如何确定分片的顺序?怎样确保分片全到达了接收端? 掌握IP选路: 即路由表, Windows上为route print命令;Linux为route -n;Mac为netstat -nr ICMP协议算是一个辅助协议,可以理解为网络层和其上一层即传输层之间的一个协议.在此也归为网络层里 不是太重要 掌握ICMP协议的报文格式,报文的两大分类:查询+差错,两种查询报文+5种差错报文 四. 传输层 UDP协议 比较次要. 掌握其特点:无连接,不可靠 以及掌握其首部各个字段 TCP协议(东西较多,面试考察集中在这里) 特点:可靠的,面向连接的协议 首部字段:序号,确认好,首部长度,窗口大小 可靠机制: TCP的连接控制机制 三次握手,四次挥手,同时打开,同时关闭,半关闭 TCP的流量控制机制: 滑动窗口,慢启动,拥塞避免,快速重传,快速恢复 TCP的超时重传机制: 各种定时器(4个) 为什么要三次握手,四次挥手? 为什么TCP和UDP都存在一个伪包头 五. 应用层 DNS协议 域名到ip地址的解析..典型的应用层协议 掌握DNS协议的名字空间, DNS指针查询(反向查找或逆向解析)基本原理, DNS缓存 FTP协议,网络界的活化石 FTP的两条连接: 控制连接和数据连接 两种工作模式: PASV + PORT 各种FTP指令和响应码 FTP断点续传,匿名FTP HTTP协议 其实东西很少 报文格式:请求报文,响应报文; 重点掌握请求头各种字段,响应头各种字段 http状态码 HTTPS协议 https详细的握手过程 摘要算法,数字签名,数字证书的原理和过程 内容整理自: 计算机网络该怎么学 值得一看: 计算机网络面试题总结 IP 协议解决了数据包（Packet）的路由和传输，上层的 TCP 协议不再关注路由和寻址，而专注解决传输的可靠性和顺序问题 这两个协议不仅能够保证数据会从源机器的源进程发送到目标机器的目标进程中，还能保证数据的不重不漏以及发送的顺序 为什么 TCP 协议有粘包问题 TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧（Message Framing） 基于 UDP 协议的应用层协议应该如何设计？会出现粘包的问题么？有哪些应用层协议使用基于长度的分帧？又有哪些使用基于终结符的分帧？","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://www.dashen.tech/tags/TCP-IP/"}]},{"title":"金融市场基础知识II","date":"2013-04-17T05:36:57.000Z","path":"2013/04/17/金融市场基础知识II/","text":"4. 股票 5. 债券 6. 证券投资基金 7. 金融衍生工具 8. 金融风险管理","tags":[]},{"title":"经管财税金融常识","date":"2013-04-17T03:47:40.000Z","path":"2013/04/17/经管财税金融常识/","text":"支票，本票，汇票 【秒懂金融】我们都在影视作品里见过支票，可你知道该怎么用和它的相关法律吗？ 一时手头吃紧,打张欠条,以后再还的,是本票. (只涉及出票人和收款人两方) 自己没钱,请人帮忙垫付的,是汇票.(涉及三个当事人：出票人、受票人、收款人) 银行账户里有存款,委托银行直接拨款,是支票. (也是涉及三个当事人) 季布一诺 – 本票 promissory note 本票 1234567promissoryadj. 约定的；允诺的；约定支付的promissory: 允诺的promissory building: 期房 【秒懂金融】“当代欠条”本票（票据三大哥之一：本票） 【秒懂金融】我给了钱你不发货咋办？（票据三大哥之一：汇票） 支票（Cheque/Check） 随着移动支付的兴起,支票的使用范围已逐步缩小 汇票（Money Order） 贴现 转贴现和再贴现 票据贴现可以分为三种，分别是贴现、转贴现和再贴现 贴现 discount 贴现 转贴现和再贴现 - 析金百科 “用明天的钱赚后天的钱” 12345678910discountn. 折扣；贴现率vt. 打折扣；将…贴现；贬损；低估；忽视vi. 贴现；打折扣出售商品Discount: 折扣quantity discount: 数量折扣special discount: 特别折扣 比如爽哥持有面额为1000万的汇票,6个月后才到期,但现在急需现金.就找银行,”提前”兑付.但要扣除利息.如这6个月会产生利息5万,那此刻银行只给我995万…相当于打了个折,所以用discount这个词 贴现：指商业票据的持票人在 汇票 到期日前，为了取得资金，贴付一定利息将票据权利转让给银行的票据行为，是持票人向银行融通资金的一种方式。 转贴现：指商业银行在资金临时不足时，将已经贴现但仍未到期的票据，交给其他商业银行或贴现机构给予贴现,以取得资金融通。 再贴现：指中央银行通过买进商业银行持有的已贴现但尚未到期的商业汇票，向商业银行提供融资支持的行为。 逆回购 一种短期融资行为.期限通常为1天,3天,7天等 央行逆回购，指中国人民银行向一级交易商购买有价证券，并约定在未来特定日期，将有价证券卖给一级交易商的交易行为，逆回购为央行向市场上投放流动性的操作，正回购则为央行从市场收回流动性的操作。简单解释就是主动借出资金，获取债券质押的交易就称为逆回购交易，此时央行扮演投资者，是接受债券质押、借出资金的融出方。 即央行把钱投放到市场上 操作灵活,数量可控,期限可选,可以精准,灵活 调节市场上短期货币流动性紧张问题.但因为期限短,效果并不持久 逆回购 MACD指标 异同移动平均线 Moving Average Convergence/Divergence DIF DEA MACD作为中长期技术指标,和短期指标KDJ 是一对技术CP,时常一起使用 MACD、KDJ真的都是骗人的吗？ MACD指标 死记“红柱绿柱”，远比″金叉死叉″准确 MACD指标 https://space.bilibili.com/481530929/video","tags":[]},{"title":"金融市场基础知识II","date":"2013-04-16T13:57:32.000Z","path":"2013/04/16/金融市场基础知识I/","text":"1. 金融市场体系 「货币乘数」是什么？ 证券市场中说的「一板」「二板」「三板」「四板」具体是指什么？有什么区别？ 红筹股（Red Chip）是指在中国境外注册、在香港上市的带有中国大陆概念的股票。“带有中国大陆概念”主要指中资控股和主要业务在中国大陆。 中央银行票据 不是 存托凭证 金融性汇率风险是外汇风险的两大种类之一，另一风险是商业性外汇风险。 它包括债权债务风险和储备风险。所谓债权债务风险是指在国际借贷中因汇率变动而使一方遭受损失的可能性；所谓储备风险是指国家、银行、公司等持有的储备性外汇资产因汇率变动而使其实际价值减少的可能性。 场外交易市场 ( Over-the-Counter ) 也叫做柜台交易市场或简称 OTC 市场，通指在交易所场外进行的交易。OTC 市场最早起源于 20 世纪初美国的证券市场，那时候美国已经有很多投资者通过银行或券商的柜台买卖这些证券，柜台交易因此而得名。上世纪 80 年代，金融衍生品的 OTC 市场迅速兴起。90 年代，以能源为首的大宗商品衍生品的场外交易也逐步得以发展。 2. 中国的金融体系与多层次资本市场 OTC（OverTheCounter），即是场外交易市场，又称柜台交易市场。在很早以前，银行兼营股票买卖业务：因为采取在银行柜台上向客户出售股票的做法，所以这种市场被称为柜台交易市场，如今泛指在交易所之外进行交易的市场，也叫做场外市场。 OTC 没有固定的场所，没有规定的成员资格，没有严格可控的规则制度，没有规定的交易产品和限制，主要是交易对手通过私下协商进行的一对一的交易。在OTC市场中，证券经营机构一般发挥做市商的作用，既是交易的组织者，又是交易的参与者，证券投资者通过柜台，或面谈、电话、传真、网络等方式与做市商直接进行证券交易。 在OTC市场交易的是未能在证券交易所上市的证券。在我国建立柜台交易市场，能为数百万计达不到上市条件的企业提供股权交易平台，有利于中小企业发展，也有助于我国形成一个多层次的资本市场。 货币市场共同基金（Money Market Mutual Funds，简称MMF） 共同基金是将众多的小额投资者的资金集合起来，由专门的经理人进行市场运作，赚取收益后按一定的期限及持有的份额进行分配的一种金融组织形式。 LOF基金，英文全称是”Listed Open-Ended Fund”，汉语称为”上市型开放式基金”。也就是上市型开放式基金发行结束后，投资者既可以在指定网点申购与赎回基金份额，也可以在交易所买卖该基金。 不过投资者如果是在指定网点申购的基金份额，想要上网抛出，须办理一定的转托管手续；同样，如果是在交易所网上买进的基金份额，想要在指定网点赎回，也要办理一定的转托管手续。 LOFs（LISTED OPEN-ENDED FUNDS ）是一种既可以同时在场外市场进行基金份额申购或赎回，并通过份额转托管机制将场外市场与场内市场有机联系在一起的一种开放式基金。 LOF是指在证券交易所发行、上市及交易的开放式证券投资基金。上市开放式基金既可通过证券交易所发行认购和集中交易，也可通过基金管理人、银行及其他代销机构认购、申购和赎回。即是在保持现行开放式基金运作模式不变的基础上，增加交易所发行和交易的渠道。 交易型开放式指数基金，通常又被称为交易所交易基金（Exchange Traded Fund，简称ETF），是一种在交易所上市交易的、基金份额可变的一种开放式基金。 交易型开放式指数基金属于开放式基金的一种特殊类型，它结合了封闭式基金和开放式基金的运作特点，投资者既可以向基金管理公司申购或赎回基金份额，同时，又可以像封闭式基金一样在二级市场上按市场价格买卖ETF份额，不过，申购赎回必须以一篮子股票换取基金份额或者以基金份额换回一篮子股票。由于同时存在二级市场交易和申购赎回机制，投资者可以在ETF市场价格与基金单位净值之间存在差价时进行套利交易。套利机制的存在，使得ETF避免了封闭式基金普遍存在的折价问题。 根据投资方法的不同，ETF可以分为指数基金和积极管理型基金，国外绝大多数ETF是指数基金。目前国内推出的ETF也是指数基金。ETF指数基金代表一篮子股票的所有权，是指像股票一样在证券交易所交易的指数基金，其交易价格、基金份额净值走势与所跟踪的指数基本一致。因此，投资者买卖一只ETF，就等同于买卖了它所跟踪的指数，可取得与该指数基本一致的收益。通常采用完全被动式的管理方法，以拟合某一指数为目标，兼具股票和指数基金的特色。 职业责任保险累计赔偿限额 达到人民币 600万元的,可以不再增加职业责任保险的赔偿额度 货币供应量M↑→实际利率水平i↓→投资I↑→总产出Y↑。 央行四种货币政策工具介绍：SLO、SLF、MLF和PSL 短期流动性调节工具（Short-term Liquidity Operations, SLO） 常备借贷便利(Standing Lending Facility，简称SLF) 中期借贷便利（Medium-term Lending Facility，MLF） 抵押补充贷款（Pledged Supplementary Lending，PSL） 3. 证券市场主体 股市开盘生死时速——集合竞价 目前,沪深两市的开盘价,深市的收盘价,都是通过集合竞价产生 前5分钟和后5分钟,还不太一样.后5分钟不允许撤单 为什么有的股票的开盘价和上个交易日的收盘价不一样？","tags":[]},{"title":"金融市场基础知识","date":"2013-04-13T10:23:57.000Z","path":"2013/04/13/金融市场基础知识/","text":"1. 金融市场体系 2. 中国的金融体系与多层次资本市场 3. 证券市场主体 4. 股票 5. 债券 6. 证券投资基金 7. 金融衍生工具 8. 金融风险管理","tags":[]},{"title":"面试题 04.12. 求和路径","date":"2012-11-30T16:04:12.000Z","path":"2012/12/01/面试题-04-12-求和路径/","text":"面试题 04.12. 求和路径 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"面试题 04.05. 合法二叉搜索树","date":"2012-11-30T16:04:05.000Z","path":"2012/12/01/面试题-04-05-合法二叉搜索树/","text":"面试题 04.05. 合法二叉搜索树 难度: 中等","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"}]},{"title":"Golang实现常见数据结构","date":"2012-11-26T13:26:10.000Z","path":"2012/11/26/Golang实现常见数据结构/","text":"第三方库 golang-algorithms 另外几个不错的库: GoDS: GoDS (Go Data Structures). Containers (Sets, Lists, Stacks, Maps, Trees), Sets (HashSet, TreeSet, LinkedHashSet), Lists (ArrayList, SinglyLinkedList, DoublyLinkedList), Stacks (LinkedListStack, ArrayStack), Maps (HashMap, TreeMap, HashBidiMap, TreeBidiMap, LinkedHashMap), Trees (RedBlackTree, AVLTree, BTree, BinaryHeap), Comparators, Iterators, … argo: 使用go语言实现数据结构与算法，涵盖字符串、数组、链表、队列、栈、树、图等数据结构。在实现算法的基础上，进行go语言实战。此外也包含经典算法在go实战项目中的应用，以及开源项目算法方面源码分析。 https://studygolang.com/topics/3172 https://hansedong.github.io/2019/04/02/15/ https://my.oschina.net/u/615967/blog/689219 https://www.jianshu.com/p/d1f9a309f364 自己实现 list set二叉树","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"熟悉Shell中的一些奇葩命令","date":"2012-11-23T15:18:58.000Z","path":"2012/11/23/熟悉Shell中的一些奇葩命令/","text":"2&gt;&amp;1Shell 重定向 2&gt;&amp;1 含义说明 Shell 输入/输出重定向 linux shell中”2&gt;&amp;1”含义","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Redis内部数据结构之压缩列表(ZipList)","date":"2012-11-23T15:07:21.000Z","path":"2012/11/23/Redis内部数据结构之压缩列表-ZipList/","text":"https://www.google.com.hk/search?q=ziplist&amp;oq=ziplist&amp;aqs=chrome..69i57.209j0j1&amp;sourceid=chrome&amp;ie=UTF-8 Redis内部数据结构详解(4)——ziplist 压缩列表 Redis 选择hash还是string 存储数据？","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"Redis常用命令汇总","date":"2012-11-21T07:43:13.000Z","path":"2012/11/21/Redis常用命令汇总/","text":"使用redis客户端登录某服务器(或集群) redis-cli -h ip地址 -p 端口 查看key的类型 type 键名 Hash相关命令 Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储$2^{32}$键值对（4 294 967 295，即40多亿） redis本身是k-v，v又是一个k-v，记作k2-v2。即一个二维数组 所谓的filed即k2,也称为域 或字段，其实就是二级key Redis 哈希(Hash) Redis Hmget 命令 Redis 选择hash还是string 存储数据？ hset 为哈希表中的字段赋值 hset key_name field value 无则新建，有则更新 (如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 ) 之前HSET只能设置单个键值对，想要同时设置多个则必须使用HMSET。但现在HSET也可以设置多个键值对了，HMSET几乎没啥用了 hget 获取哈希表指定字段的值 hget key_name field_name 无法同时获取多个field的值 Hmget 获取哈希类型的value中，一个或多个给定字段的值 m 即multiple hmget key field1 [field2] hgetall 获取哈希类型的key的所有字段和值 若 key 不存在，返回空列表 redis获取哈希类型的值，hget、hmget、hgetall hget 获取hash类型的值: hget 键名 value值的键名 hmget 获取多个hash的值: hmget 键名 value值的键1 value值的键2 value值的键3 ... hgetall 获取hash中的所有数据(键和值): hgetall 键名 hexists 查看哈希表的指定字段是否存在 hexists key_name field_name Hkeys 获取哈希表中的所有域（field） Hvals 返回哈希表所有的值 Hlen 获取哈希表中字段的数量 Hsetnx 无则创建 有则忽略 nx 即 not exist 为哈希表中不存在的的字段赋值 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，操作无效。 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令 hscan 迭代器 当需要遍历Redis所有key或指定模式的key时，首先想到的是keys命令，但如果redis数据非常大，且key非常多的情况下，查询时很可能会较慢，造成整个redis阻塞，有什么办法解决呢？ SCAN命令是一个基于游标的迭代器, 这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程, 当SCAN命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束，HSCAN同SCAN命令相同。 hincrby 为字段值加上指定增量值 [hincrbyfloat](https://www.runoob.com/redis/hashes-hincrbyfloat.html） 为字段值加上指定浮点数增量值","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Docker常用命令汇总","date":"2012-11-19T12:53:29.000Z","path":"2012/11/19/Docker常用命令汇总/","text":"一键删除所有已Exited的容器 docker rmdocker ps -a | grep Exited | awk ‘{print $1}’ 如何批量删除Docker中已停止的容器？-可以有多种方式 ###","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"进入某个运行中的容器,做修改后打包为新镜像","date":"2012-11-19T05:45:19.000Z","path":"2012/11/19/进入某个运行中的容器-做修改后打包为新镜像/","text":"https://blog.csdn.net/star1210644725/article/details/104196865 curl https://bootstrap.pypa.io/pip/2.7/get-pip.py –output get-pip.py python2 get-pip.py pip install diff_cover","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Go异常注入/故障模拟工具","date":"2012-11-18T12:20:29.000Z","path":"2012/11/18/Go异常注入-故障模拟工具/","text":"https://blog.csdn.net/lanyang123456/article/details/103091671 https://kms.netease.com/article/3769","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go time.NewTicker()与定时器","date":"2012-11-17T14:34:58.000Z","path":"2012/11/17/Go-time-NewTicker-与定时器/","text":"一次性定时器和周期性定时器 n个定时器需要n个协程吗？ 即是否每个定时器，都需要后台有一个协程来专门维护？？ 如不如此，是如何做到的？ 参考 Go语言中的定时器–简书，验证如下： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"os\" \"runtime/debug\" \"time\")func main() &#123; debug.SetTraceback(\"system\") fmt.Println(\"os.Args:\", os.Args) fmt.Println(\"len(os.Args):\", len(os.Args)) // 如果不带参数执行，会在定时器之前就panic，并打印出所有goroutine if len(os.Args) == 1 &#123; // \"不用panic的话，就没有什么简单的方法来查看运行时的goroutine ---- 它们被runtime.NumGoroutines和runtime.Stack排除了，所以仅剩的方法就是让程序crash掉\" panic(\"before timers\") &#125; // 如果带有参数，则会打印出生成1万个定时器之后的所有goroutine for i := 0; i &lt; 10000; i++ &#123; time.AfterFunc(5*time.Second, func() &#123; fmt.Println(\"Hello!\", i) &#125;) &#125; panic(\"after timers\")&#125; 如果不带参数执行，即go run xxx.go: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162os.Args: [/var/folders/9t/839s3jmj73bcgyp5x_xh3gw00000gn/T/go-build3283038849/b001/exe/panic]len(os.Args): 1panic: before timersgoroutine 1 [running]:panic(0x1007730c0, 0x10078ce68) /usr/local/go/src/runtime/panic.go:1065 +0x4d8 fp=0x1400011fed0 sp=0x1400011fe00 pc=0x1006de848main.main() /Users/fliter/go/src/shuang/ticker/panic.go:19 +0x22c fp=0x1400011ff70 sp=0x1400011fed0 pc=0x1007466fcruntime.main() /usr/local/go/src/runtime/proc.go:225 +0x26c fp=0x1400011ffd0 sp=0x1400011ff70 pc=0x1006e104cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x1400011ffd0 sp=0x1400011ffd0 pc=0x10070e5e4goroutine 2 [force gc (idle)]:runtime.gopark(0x10078cb20, 0x100805f00, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x14000042fa0 sp=0x14000042f80 pc=0x1006e1450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:276 +0xbc fp=0x14000042fd0 sp=0x14000042fa0 pc=0x1006e12dcruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x14000042fd0 sp=0x14000042fd0 pc=0x10070e5e4created by runtime.init.6 /usr/local/go/src/runtime/proc.go:264 +0x30goroutine 3 [GC sweep wait]:runtime.gopark(0x10078cb20, 0x100806020, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x140000437a0 sp=0x14000043780 pc=0x1006e1450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.bgsweep(0x14000026070) /usr/local/go/src/runtime/mgcsweep.go:163 +0xb0 fp=0x140000437d0 sp=0x140000437a0 pc=0x1006cee30runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x140000437d0 sp=0x140000437d0 pc=0x10070e5e4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:217 +0x54goroutine 4 [GC scavenge wait]:runtime.gopark(0x10078cb20, 0x1008060c0, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x14000043f70 sp=0x14000043f50 pc=0x1006e1450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.bgscavenge(0x14000026070) /usr/local/go/src/runtime/mgcscavenge.go:265 +0xec fp=0x14000043fd0 sp=0x14000043f70 pc=0x1006cd24cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x14000043fd0 sp=0x14000043fd0 pc=0x10070e5e4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:218 +0x74goroutine 5 [finalizer wait]:runtime.gopark(0x10078cb20, 0x100833310, 0x14000021410, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x14000042730 sp=0x14000042710 pc=0x1006e1450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xb8 fp=0x140000427d0 sp=0x14000042730 pc=0x1006c4a48runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x140000427d0 sp=0x140000427d0 pc=0x10070e5e4created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78exit status 2 如果带参数执行，即go run xxx.go -666: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162os.Args: [/var/folders/9t/839s3jmj73bcgyp5x_xh3gw00000gn/T/go-build466442962/b001/exe/panic -123]len(os.Args): 2panic: after timersgoroutine 1 [running]:panic(0x104e6f0c0, 0x104e88e78) /usr/local/go/src/runtime/panic.go:1065 +0x4d8 fp=0x14000096ed0 sp=0x14000096e00 pc=0x104dda848main.main() /Users/fliter/go/src/shuang/ticker/panic.go:28 +0x210 fp=0x14000096f70 sp=0x14000096ed0 pc=0x104e426e0runtime.main() /usr/local/go/src/runtime/proc.go:225 +0x26c fp=0x14000096fd0 sp=0x14000096f70 pc=0x104ddd04cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x14000096fd0 sp=0x14000096fd0 pc=0x104e0a5e4goroutine 2 [force gc (idle)]:runtime.gopark(0x104e88b20, 0x104f01f00, 0x1411, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x14000042fa0 sp=0x14000042f80 pc=0x104ddd450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:276 +0xbc fp=0x14000042fd0 sp=0x14000042fa0 pc=0x104ddd2dcruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x14000042fd0 sp=0x14000042fd0 pc=0x104e0a5e4created by runtime.init.6 /usr/local/go/src/runtime/proc.go:264 +0x30goroutine 17 [GC sweep wait]:runtime.gopark(0x104e88b20, 0x104f02020, 0x140c, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x1400003e7a0 sp=0x1400003e780 pc=0x104ddd450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.bgsweep(0x1400008c000) /usr/local/go/src/runtime/mgcsweep.go:163 +0xb0 fp=0x1400003e7d0 sp=0x1400003e7a0 pc=0x104dcae30runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x1400003e7d0 sp=0x1400003e7d0 pc=0x104e0a5e4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:217 +0x54goroutine 18 [GC scavenge wait]:runtime.gopark(0x104e88b20, 0x104f020c0, 0x140d, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x1400003ef70 sp=0x1400003ef50 pc=0x104ddd450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.bgscavenge(0x1400008c000) /usr/local/go/src/runtime/mgcscavenge.go:265 +0xec fp=0x1400003efd0 sp=0x1400003ef70 pc=0x104dc924cruntime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x1400003efd0 sp=0x1400003efd0 pc=0x104e0a5e4created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:218 +0x74goroutine 3 [finalizer wait]:runtime.gopark(0x104e88b20, 0x104f2f310, 0x1410, 0x1) /usr/local/go/src/runtime/proc.go:336 +0xd0 fp=0x14000043730 sp=0x14000043710 pc=0x104ddd450runtime.goparkunlock(...) /usr/local/go/src/runtime/proc.go:342runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:175 +0xb8 fp=0x140000437d0 sp=0x14000043730 pc=0x104dc0a48runtime.goexit() /usr/local/go/src/runtime/asm_arm64.s:1130 +0x4 fp=0x140000437d0 sp=0x140000437d0 pc=0x104e0a5e4created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x78exit status 2 两次都是5个goroutine 实际上，亲测出的结果，即便新增了1万个定时器，也没有新增一个goroutine 以上代码在基于amd64的Mac M1上执行，go版本为1.16 使用amd64的机器，go 1.11上运行，则符合原文预期，即不起定时器前4个goroutine，之后5个goroutine： 即 123go run xxxx.go 2&gt;&amp;1 | grep \"^goroutine\" | wc -l4 123go run xxxx.go -123 2&gt;&amp;1 | grep \"^goroutine\" | wc -l5 直接run，具体输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142os.Args: [/tmp/go-build548947945/b001/exe/ticker]len(os.Args): 1panic: before timersgoroutine 1 [running]:panic(0x49f060, 0x4d3ee0) /usr/local/go/src/runtime/panic.go:556 +0x2cb fp=0xc00006af10 sp=0xc00006ae80 pc=0x4270dbmain.main() /home/ubuntu/go_lab/ticker.go:19 +0x1fd fp=0xc00006af98 sp=0xc00006af10 pc=0x48ea5druntime.main() /usr/local/go/src/runtime/proc.go:201 +0x207 fp=0xc00006afe0 sp=0xc00006af98 pc=0x428e07runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc00006afe8 sp=0xc00006afe0 pc=0x4515c1goroutine 2 [runnable]:runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:243 fp=0xc000032fe0 sp=0xc000032fd8 pc=0x428fb0runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc000032fe8 sp=0xc000032fe0 pc=0x4515c1created by runtime.init.4 /usr/local/go/src/runtime/proc.go:240 +0x35goroutine 3 [GC sweep wait]:runtime.gopark(0x4c7058, 0x55cfa0, 0x41140c, 0x1) /usr/local/go/src/runtime/proc.go:302 +0xeb fp=0xc000033780 sp=0xc000033760 pc=0x4291ebruntime.goparkunlock(0x55cfa0, 0x4d140c, 0x1) /usr/local/go/src/runtime/proc.go:308 +0x53 fp=0xc0000337b0 sp=0xc000033780 pc=0x429293runtime.bgsweep(0xc00004a000) /usr/local/go/src/runtime/mgcsweep.go:52 +0x8f fp=0xc0000337d8 sp=0xc0000337b0 pc=0x41cc8fruntime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0000337e0 sp=0xc0000337d8 pc=0x4515c1created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:216 +0x58goroutine 4 [runnable]:runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:161 fp=0xc000033fe0 sp=0xc000033fd8 pc=0x414700runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc000033fe8 sp=0xc000033fe0 pc=0x4515c1created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x61exit status 2 带参数之后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950os.Args: [/tmp/go-build829376033/b001/exe/ticker -111]len(os.Args): 2panic: after timersgoroutine 1 [running]:panic(0x49f060, 0x4d3ef0) /usr/local/go/src/runtime/panic.go:556 +0x2cb fp=0xc00006af10 sp=0xc00006ae80 pc=0x4270dbmain.main() /home/ubuntu/go_lab/ticker.go:28 +0x1df fp=0xc00006af98 sp=0xc00006af10 pc=0x48ea3fruntime.main() /usr/local/go/src/runtime/proc.go:201 +0x207 fp=0xc00006afe0 sp=0xc00006af98 pc=0x428e07runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc00006afe8 sp=0xc00006afe0 pc=0x4515c1goroutine 2 [runnable]:runtime.forcegchelper() /usr/local/go/src/runtime/proc.go:243 fp=0xc000030fe0 sp=0xc000030fd8 pc=0x428fb0runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc000030fe8 sp=0xc000030fe0 pc=0x4515c1created by runtime.init.4 /usr/local/go/src/runtime/proc.go:240 +0x35goroutine 3 [GC sweep wait]:runtime.gopark(0x4c7058, 0x55cfa0, 0x41140c, 0x1) /usr/local/go/src/runtime/proc.go:302 +0xeb fp=0xc000031780 sp=0xc000031760 pc=0x4291ebruntime.goparkunlock(0x55cfa0, 0x4d140c, 0x1) /usr/local/go/src/runtime/proc.go:308 +0x53 fp=0xc0000317b0 sp=0xc000031780 pc=0x429293runtime.bgsweep(0xc00004a000) /usr/local/go/src/runtime/mgcsweep.go:52 +0x8f fp=0xc0000317d8 sp=0xc0000317b0 pc=0x41cc8fruntime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0000317e0 sp=0xc0000317d8 pc=0x4515c1created by runtime.gcenable /usr/local/go/src/runtime/mgc.go:216 +0x58goroutine 4 [runnable]:runtime.runfinq() /usr/local/go/src/runtime/mfinal.go:161 fp=0xc000031fe0 sp=0xc000031fd8 pc=0x414700runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc000031fe8 sp=0xc000031fe0 pc=0x4515c1created by runtime.createfing /usr/local/go/src/runtime/mfinal.go:156 +0x61goroutine 5 [runnable]:runtime.timerproc(0x55fb80) /usr/local/go/src/runtime/time.go:224 fp=0xc0000307d8 sp=0xc0000307d0 pc=0x442d00runtime.goexit() /usr/local/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0000307e0 sp=0xc0000307d8 pc=0x4515c1created by runtime.(*timersBucket).addtimerLocked /usr/local/go/src/runtime/time.go:170 +0x114exit status 2 原文中使用的命令如下：go run xxx.go 2&gt;&amp;1 | grep “^goroutine” | wc -l https://studygolang.com/articles/21597 https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-timer/ https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/ http://xiaorui.cc/archives/6483 https://www.google.com.hk/search?q=site:http://xiaorui.cc/+%E5%AE%9A%E6%97%B6%E5%99%A8&amp;newwindow=1&amp;sxsrf=AOaemvIfh6H5ii2THKYpt0lZfLNlN_ULIg:1635769019251&amp;ei=u9p_YezPDtGTr7wPgPGdmA4&amp;start=10&amp;sa=N&amp;ved=2ahUKEwismc66kvfzAhXRyYsBHYB4B-MQ8tMDegQIARA0&amp;biw=1800&amp;bih=993&amp;dpr=1.6 https://www.zhihu.com/zvideo/1350812665179152384 https://www.zhihu.com/question/424920760/answer/1520371371 https://www.zhihu.com/question/424920760/answer/1520371371 https://zhuanlan.zhihu.com/p/423934269 https://zhuanlan.zhihu.com/p/338356039 https://www.bilibili.com/video/BV1rK411N7M3 https://xargin.com/go-timer/ https://www.jianshu.com/p/427dfe8ad3c0 https://juejin.cn/post/6884914839308533774#heading-2 https://studygolang.com/articles/5224 https://mp.weixin.qq.com/s/QahprdKrlcaatG8poWsNrA https://mp.weixin.qq.com/s/gaQhIo544VHYeGcKq34GIw https://mp.weixin.qq.com/s/i8XWQgsgySIneZ6G_GPzuw https://mp.weixin.qq.com/s/yYYgOfzwknh53yqBc3vL0Q https://mp.weixin.qq.com/s/bV097lsHfdIaJFLYjaYYFA","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"跨平台构建 Docker 镜像","date":"2012-11-15T11:44:50.000Z","path":"2012/11/15/跨平台构建-Docker-镜像/","text":"https://blog.csdn.net/alex_yangchuansheng/article/details/103146303 但在ubuntu上apt-get update命令总失败 尝试看下docker能不能像go build一样可以交叉编译 跨平台构建 Docker 镜像新姿势，x86、arm 一把梭 https://www.jianshu.com/p/4dab04e6d1e4","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Docker的四种网络模式","date":"2012-11-12T01:47:03.000Z","path":"2012/11/12/Docker的四种网络模式/","text":"","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go手动内存管理","date":"2012-11-09T02:21:54.000Z","path":"2012/11/09/Go手动内存管理/","text":"https://studygolang.com/articles/14283 https://blog.haohtml.com/golang https://github.com/LeoYang90/Golang-Internal-Notes/blob/master/Go%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md https://www.cnblogs.com/jiujuan/p/13922551.html https://gobea.cn/blog/detail/WoK7mBoB.html https://dreamgoing.github.io/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html https://blog.csdn.net/u013929635/article/details/80108919 https://pengrl.com/p/35302/ https://pengrl.com/p/38720/","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"jonboulle/clockwork包的使用","date":"2012-11-09T02:06:59.000Z","path":"2012/11/09/jonboulle-clockwork包的使用/","text":"https://github.com/jonboulle/clockwork 时间模拟库 作者：meission https://www.bilibili.com/read/cv1870715 出处：bilibili 在很多项目中都有使用https://mp.weixin.qq.com/s/3Wj0RWFBzxPp-LyEiRx4XA k8s etcd spf13/viper bluele/gcache","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"GODEBUG:用于控制runtime调度变量的环境变量","date":"2012-11-08T11:13:09.000Z","path":"2012/11/08/GODEBUG-用于控制runtime调度变量的环境变量/","text":"https://blog.haohtml.com/archives/21778","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"常见的树","date":"2012-11-06T13:54:26.000Z","path":"2012/11/06/常见的树/","text":"常见“树”概念解析（1） treap在Go中有很多处使用 2万字长文从源码角度看 Golang 的调度 信号量semaphore实现 一份详细注释的go Mutex源码平衡树（一）替罪羊树你真的了解 sync.Mutex吗 [数据结构与算法]红黑树（上） 树型结构 图形化模块上线 | 数据结构演示平衡树系列之——SBTree 伸展树面试官问我：什么是 “伸展树” ？二叉树–伸展树(splay tree)数据结构与算法专题——第十题 输入法跳不过的坎-伸展树这个树，怎么一下就平衡了？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"同步和异步，阻塞与非阻塞","date":"2012-11-03T15:06:55.000Z","path":"2012/11/03/同步和异步，阻塞与非阻塞/","text":"https://mp.weixin.qq.com/s/Ivg5nxsMyeL3xJcZsYMmUQ https://mp.weixin.qq.com/s/mX_Cj8uaOz5NaVo4Sf5t6w 深入理解同步/异步与阻塞/非阻塞区别 阻塞和死锁的区别：","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://www.dashen.tech/tags/操作系统/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go GC的写屏障","date":"2012-11-03T13:12:44.000Z","path":"2012/11/03/Go-GC的写屏障/","text":"https://github.com/golang-design/under-the-hood/issues/20 http://www.icewater.xyz/p/go-gc/ https://github.com/golang-design/under-the-hood/issues/79 https://zhuanlan.zhihu.com/p/74853110 https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.6.GC-GC.md https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/barrier/ https://jishuin.proginn.com/p/763bfbd641c8 https://segmentfault.com/a/1190000022030353 https://zhuanlan.zhihu.com/p/340455930 https://www.bookstack.cn/read/For-learning-Go-Tutorial/src-spec-02.0.md https://www.jianshu.com/p/52ab0bebefa0 http://www.yuasa.kuis.kyoto-u.ac.jp/~yuasa/ https://dblp.org/pid/30/3398.html https://jishuin.proginn.com/p/763bfbd4ec55 https://mp.weixin.qq.com/s/iklfWLmSD4XMAKmFcffp9g 1Go uses a hybrid barrier that combines a Yuasa-style deletion barrier—which shades the object whose reference is being overwritten—with Dijkstra insertion barrier—which shades the object whose reference is being written. The insertion part of the barrier is necessary while the calling goroutine's stack is grey. In pseudocode, the barrier is: writePointer(slot, ptr): shade(*slot) if current stack is grey: shade(ptr) *slot = ptr slot is the destination in Go code. ptr is the value that goes into the slot in Go code. Shade indicates that it has seen a white pointer by adding the referent to wbuf as well as marking it. The two shades and the condition work together to prevent a mutator from hiding an object from the garbage collector: 1. shade(*slot) prevents a mutator from hiding an object by moving the sole pointer to it from the heap to its stack. If it attempts to unlink an object from the heap, this will shade it. 2. shade(ptr) prevents a mutator from hiding an object by moving the sole pointer to it from its stack into a black object in the heap. If it attempts to install the pointer into a black object, this will shade it. 3. Once a goroutine's stack is black, the shade(ptr) becomes unnecessary. shade(ptr) prevents hiding an object by moving it from the stack to the heap, but this requires first having a pointer hidden on the stack. Immediately after a stack is scanned, it only points to shaded objects, so it's not hiding anything, and the shade(*slot) prevents it from hiding any other pointers on its stack. For a detailed description of this barrier and proof of correctness, see https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md Dealing with memory ordering: Both the Yuasa and Dijkstra barriers can be made conditional on the color of the object containing the slot. We chose not to make these conditional because the cost of ensuring that the object holding the slot doesn't concurrently change color without the mutator noticing seems prohibitive. Consider the following example where the mutator writes into a slot and then loads the slot's mark bit while the GC thread writes to the slot's mark bit and then as part of scanning reads the slot. Initially both [slot] and [slotmark] are 0 (nil) Mutator thread GC thread st [slot], ptr st [slotmark], 1 ld r1, [slotmark] ld r2, [slot] Without an expensive memory barrier between the st and the ld, the final result on most HW (including 386/amd64) can be r1==r2==0. This is a classic example of what can happen when loads are allowed to be reordered with older stores (avoiding such reorderings lies at the heart of the classic Peterson/Dekker algorithms for mutual exclusion). Rather than require memory barriers, which will slow down both the mutator and the GC, we always grey the ptr object regardless of the slot's color. Another place where we intentionally omit memory barriers is when accessing mheap_.arena_used to check if a pointer points into the heap. On relaxed memory machines, it's possible for a mutator to extend the size of the heap by updating arena_used, allocate an object from this new region, and publish a pointer to that object, but for tracing running on another processor to observe the pointer but use the old value of arena_used. In this case, tracing will not mark the object, even though it's reachable. However, the mutator is guaranteed to execute a write barrier when it publishes the pointer, so it will take care of marking the object. A general consequence of this is that the garbage collector may cache the value of mheap_.arena_used. (See issue #9984.) Stack writes: The compiler omits write barriers for writes to the current frame, but if a stack pointer has been passed down the call stack, the compiler will generate a write barrier for writes through that pointer (because it doesn't know it's not a heap pointer). One might be tempted to ignore the write barrier if slot points into to the stack. Don't do it! Mark termination only re-scans frames that have potentially been active since the concurrent scan, so it depends on write barriers to track changes to pointers in stack frames that have not been active. Global writes: The Go garbage collector requires write barriers when heap pointers are stored in globals. Many garbage collectors ignore writes to globals and instead pick up global -&gt; heap pointers during termination. This increases pause time, so we instead rely on write barriers for writes to globals so that we don't have to rescan global during mark termination. Publication ordering: The write barrier is *pre-publication*, meaning that the write barrier happens prior to the *slot = ptr write that may make ptr reachable by some goroutine that currently cannot reach it. Signal handler pointer writes: In general, the signal handler cannot safely invoke the write barrier because it may run without a P or even during the write barrier. There is exactly o","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"好文集录","date":"2012-04-27T12:07:22.000Z","path":"2012/04/27/好文集录/","text":"漫谈编程语言的设计和实现 图解 Rust 所有权与生命周期","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"通过自签名方式 实现iPhone不越狱双开微信","date":"2012-04-18T13:19:50.000Z","path":"2012/04/18/通过自签名方式-实现iPhone不越狱双开微信/","text":"https://1linelayouts.glitch.me .ex1 .parent { display: grid; place-items: center; } 下载sideloadly 下载sideloadly","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Eisel-Lemire算法与浮点数解析","date":"2012-04-17T13:03:38.000Z","path":"2012/04/17/Eisel-Lemire算法与浮点数解析/","text":"Rust v1.55.0 发布(2021-09-10)，其中 标准库对浮点解析的实现更新为 Eisel-Lemire 算法，更快、更准确，覆盖了边界情况 Go 1.16(2021-02-16) strcov包的ParseFloat方法，也改成了使用Eisel-Lemire 算法实现： 12strconvParseFloat now uses the Eisel-Lemire algorithm, improving performance by up to a factor of 2. This can also speed up decoding textual formats like encoding/json. 【发起分享提案】分析 Eisel-Lemire 算法 #719 The Eisel-Lemire ParseNumberF64 Algorithm https://go-review.googlesource.com/c/go/+/260858 https://go-review.googlesource.com/c/go/+/264517","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"马大帅","date":"2012-04-12T14:41:22.000Z","path":"2012/04/12/马大帅/","text":"而玉芬看着浸韵鲜血的工装，只剩百感交集。等马大帅回了家，还在吹嘘自己与领导推杯换盏 深受重视的丰功伟绩，而一旁的玉芬早是垂下了眉眼。 等那装满苦涩的黑色背包呈上，马大帅倔强的夸夸其谈，才渐渐停下。 玉芬的泪水哽住马大帅的喉咙。思绪万千，到最好却只剩几句干瘪的辩解。他为了她无惧风寒险阻，她只求他平安幸福。 马大帅能扛起生活压力千万重，可无论怎样逞强，蝼蚁本性在残酷现实面前都无处躲藏，她虽不求荣华富贵，但马大帅怎甘心让她跟着自己一起荜门圭窦。面对玉芬，马大帅也只能无力的附和。 喜剧是「马大帅」系列最大的标签，而「现实」则是藏在喜剧标签下，最为珍贵的内核，直到第三部，依旧如此。 故事开篇，马大帅没有了风光的校长头衔，由此也不用强撑华而不实的体面。当雏鸟不再奢望翱翔太空的痴梦，胸腔才能不断回荡 那股人间烟火气独有的芬芳。 范德彪活过半生，璀璨落寞亦有他桀骜不驯的身影，他不断渴望重回当年震慑整座开原的雄风，却渐渐发现，想象中的美丽画卷，似乎不过幻梦一片。 当梦开始的那刻，屹立在辽北大地上的孤独巨人，终究踏上了那条败于自命不凡的道路","tags":[]},{"title":"grpc-gateway自定义header,并设置当数据为空时返回默认值","date":"2012-04-12T13:05:18.000Z","path":"2012/04/12/grpc-gateway自定义header-并设置当数据为空时返回默认值/","text":"https://github.com/grpc-ecosystem/grpc-gateway https://github.com/grpc-ecosystem/grpc-gateway/blob/master/examples/internal/proto/examplepb/a_bit_of_everything.proto","tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"interface{}转为其他类型","date":"2012-04-12T09:56:37.000Z","path":"2012/04/12/interface-转为其他类型/","text":"https://blog.csdn.net/sinat_35406909/article/details/104950795 https://blog.csdn.net/qq_42214953/article/details/118939629 https://blog.csdn.net/xiaoyida11/article/details/84880234","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"string和[]byte转换会发生内存拷贝吗","date":"2012-04-03T13:41:19.000Z","path":"2012/04/03/string和-byte转换会发生内存拷贝吗/","text":"前文预览： golang之string类型变量操作的原子性 Go生僻字符串操作 大佬们，小白问个问题， 用string() 转换一个 []byte 时，内存会重新分配吗？ 浅拷贝和深拷贝 浅拷贝(也称为位拷贝)就是拷贝指向对象的指针，即拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间，(改其中一个会影响到另外一个)。浅拷贝只是一种简单的拷贝，让几个对象共用一个内存。 浅拷贝可能会有数据安全方面的隐患 深拷贝则是另辟了一个完全独立的内存空间，源对象与拷贝对象互相独立，改其中一个不会影响另外一个。 但需为新的变量 重新分配一块内存 string(byteSli)操作，会为新生成的str，重新分配(一块)内存吗 Go源码里大多都是[]byte而不是string：想改变其中几个字符的时候直接通过下标修改[]byte里面的内容，在需要string的时候通过string([]byte)得到字符串。这可以提高效率，还不会产生太多的子字符串浪费内存，导致GC任务加重 但如下细节需注意： 用 string(字节数组)方式转换生成的字符串，是重新开辟了一块内存（如str := string(byteSli)）。在转换后，再去修改原来buyeSli的某几个字符(如byteSli[1] = &#39;x&#39;)，str将不会跟随改变 (str[1]还是原来的字符，而不是’x’) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\" \"github.com/davecgh/go-spew/spew\" \"unsafe\")//仿造string的底层结构type FakeString struct &#123; ptr *byte len int&#125;//仿造[]byte的底层结构type FakeByteSlice struct &#123; ptr *byte len int cap int&#125;func main() &#123; var tmp FakeString var byteSli = []byte(\"hai\") str := string(byteSli) //str是通过强制转换[]byte而来，str底层的dataPtr与[]byte底层的ptr指向不同的内存地址， spew.Dump(\"byteSli\", &amp;byteSli) fmt.Println(\"------\") spew.Dump(\"str\", &amp;str) fmt.Println(\"------\") //下面是证明： //利用unsafe包，强制把byteSli的起始地址看成FakeByteSlice的起始地址，并赋值给tmpByte tmpByte := *((*FakeByteSlice)(unsafe.Pointer(&amp;byteSli))) //打印byteSli的一些信息: fmt.Printf(\"size of bytes :%d, len(byteSli):%d, cap(byteSli):%d,&amp;byteSli[0]:%p\\n\", unsafe.Sizeof(byteSli), len(byteSli), cap(byteSli), &amp;byteSli[0]) //通过tmpByte查看byteSli里面的东西： fmt.Printf(\"tmpByte-&gt; len:%d, cap:%d, ptr:%p\\n\", tmpByte.len, tmpByte.cap, tmpByte.ptr) /*输出： size of bytes :24, len(byteSli):3, cap(byteSli):3,&amp;byteSli[0]:0x140000a2160 tmpByte-&gt; len:3, cap:3, ptr:0x140000a2160 */ fmt.Println(\"------\") //强制把str的起始地址看成FakeString 的起始地址，并赋值给tmp 变量 tmp = *((*FakeString)(unsafe.Pointer(&amp;str))) //通过tmp查看str里面的东西 fmt.Printf(\"len of string :%d, addr of data:%p, len of str:%d\\n\", len(str), tmp.ptr, tmp.len) /*输出： len of string :3, addr of data:0x140000a2163, len of str:3 可见 tmp.ptr != tmpByte.ptr */ //进一步的证明 byteSli[1] = 'o' //修改byte[1] fmt.Printf(\"str:%s, data addr: %x \\n\", str, *((*uintptr)(unsafe.Pointer(&amp;str)))) //输出:str:hai, data addr: 140000a2163 //修改了byte[1]之后，str还是原来的hai。&#125; 输出为： 12345678910111213(string) (len=7) \"byteSli\"(*[]uint8)(0x140000ae048)((len=3 cap=3) &#123; 00000000 68 61 69 |hai|&#125;)------(string) (len=3) \"str\"(*string)(0x1400009e120)((len=3) \"hai\")------size of bytes :24, len(byteSli):3, cap(byteSli):3,&amp;byteSli[0]:0x140000a2160tmpByte-&gt; len:3, cap:3, ptr:0x140000a2160------len of string :3, addr of data:0x140000a2163, len of str:3str:hai, data addr: 140000a2163 内存地址不同，给str新分配(一块)内存，可以写benchmark验证一下 byte切片转字符串，有没有可以零拷贝的方式？ 当然有，使用unsafe的方式 不同写法的性能差异之byte切片转string 一些底层实现和细节 参考： 面试官：string和[]byte转换原理知道吗？会发生内存拷贝吗？ Golang中[]byte与string转换 go string与[]byte转换以及性能分析 go中string是如何实现的","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Go生僻字符串操作","date":"2012-04-01T12:44:21.000Z","path":"2012/04/01/Go生僻字符串操作/","text":"提取出两个符号之间的内容 &amp; 将第偶数个指定字符换成另一个字符 前端传递如( $124$ &amp;&amp; $66$) || $253$ 这样的字符串，我需要解析得到$符之间的数字，不能使用正则。 考虑分成两步：将包裹数字的后一个$替换为#， 即由 ( $124$ &amp;&amp; $66$) || $253$ —&gt; ( $124# &amp;&amp; $66#) || $253# 再按#切分，提取出数字 12345678910111213141516171819202122232425262728293031323334353637383940// GetRuleIdSli \"($124$ &amp;&amp; $66$) || $253$\" ---&gt; [\"124\", \"66\", \"253\"]func GetRuleIdSli(ruleRelation string) (ruleIdSli []string) &#123; sharpStr := ReplaceRuneInEvenPosition(ruleRelation, '$', '#') // \"($124# &amp;&amp; $66#) || $253#\" strSli := strings.SplitN(sharpStr, \"#\", -1) // [\"($124\", \"&amp;&amp; $66\", \") || $253\"] for _, v := range strSli &#123; if strings.Contains(v, \"$\") &#123; pos := strings.Index(v, \"$\") ruleIdSli = append(ruleIdSli, v[pos+1:]) &#125; &#125; return&#125;/*ReplaceRuneInEvenPosition 将第偶数个指定字符换成另一个字符 \"($124$&amp;&amp; $66#$) || $253$\" ---&gt; \"($124# &amp;&amp; $66#) || $253#\"*/func ReplaceRuneInEvenPosition(str string, oldRune, newRune uint8) string &#123; var newStr []uint8 j := 0 for i := 0; i &lt; len(str); i++ &#123; c := str[i] if str[i] == oldRune &#123; j++ if j%2 == 0 &#123; c = newRune &#125; &#125; newStr = append(newStr, c) &#125; return string(newStr)&#125; 单元测试： 12345678910111213141516171819202122232425262728package utilsimport ( \"github.com/stretchr/testify/assert\" \"testing\")func TestGetRuleIdSli(t *testing.T) &#123; str := \"($124$ &amp;&amp; $66$) || $253$\" rs := GetRuleIdSli(str) expect := []string&#123;\"124\", \"66\", \"253\"&#125; for k, item := range rs &#123; assert.Equal(t, expect[k], item) &#125;&#125;func TestReplaceRuneInEvenPosition(t *testing.T) &#123; str := \"($124$ &amp;&amp; $66$) || $253$\" rs := ReplaceRuneInEvenPosition(str, '$', '#') assert.Equal(t, \"($124# &amp;&amp; $66#) || $253#\", rs)&#125; ###","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"南北流量与东西流量","date":"2012-03-30T03:44:10.000Z","path":"2012/03/30/南北流量与东西流量/","text":"https://www.google.com.hk/search?q=%E5%8D%97%E5%8C%97%E5%90%91%E6%B5%81%E9%87%8F&amp;newwindow=1&amp;sxsrf=APq-WBs21mVWYauEW31QqQ8IQbA7lir_1A%3A1648611278916&amp;ei=zs9DYojON_2hseMP0beKiA0&amp;ved=0ahUKEwiI7ZvN8-z2AhX9UGwGHdGbAtEQ4dUDCA4&amp;uact=5&amp;oq=%E5%8D%97%E5%8C%97%E5%90%91%E6%B5%81%E9%87%8F&amp;gs_lcp=Cgdnd3Mtd2l6EAMyBQgAEIAEMgYIABAFEB46BwgjEOoCECdKBAhBGAFKBAhGGABQpAJYsARgrAVoAnAAeACAAW-IAW-SAQMwLjGYAQCgAQGgAQKwAQrAAQE&amp;sclient=gws-wiz https://blog.csdn.net/ZYQDuron/article/details/81232992 https://h1z3y3.me/posts/gophercon-china-2021/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go单测之mock数据库","date":"2012-03-26T09:22:38.000Z","path":"2012/03/26/Go单测之mock数据库/","text":"本文是对Go单测从零到溜系列—2.mock数据库测试的实践 Mock Mysql DATA-DOG/go-sqlmock 是一个实现了 sql/driver (我给这个package修过一次typo) 的mock库。 DATA-DOG/go-sqlmock 不需要建立真正的数据库连接就可以在测试中模拟任何 sql 驱动程序的行为，可以很方便的在编写单元测试时mock sql语句的执行结果 以官方README为例： 需要预先在本地建一个名为shuang的库，新建两张表12345678910111213141516CREATE TABLE `products` ( `id` int NOT NULL AUTO_INCREMENT, `views` int DEFAULT NULL, `ctime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;- --------------------------------CREATE TABLE `product_viewers` ( `id` int NOT NULL AUTO_INCREMENT, `user_id` int DEFAULT NULL, `product_id` int DEFAULT NULL, `ctime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;并在products表里插入一条id=5的记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"database/sql\" _ \"github.com/go-sql-driver/mysql\")func recordStats(db *sql.DB, userID, productID int64) (err error) &#123; tx, err := db.Begin() if err != nil &#123; return &#125; defer func() &#123; switch err &#123; case nil: err = tx.Commit() default: tx.Rollback() &#125; &#125;() if _, err = tx.Exec(\"UPDATE products SET views = views + 1\"); err != nil &#123; return &#125; if _, err = tx.Exec(\"INSERT INTO product_viewers (user_id, product_id) VALUES (?, ?)\", userID, productID); err != nil &#123; return &#125; return&#125;func main() &#123; //db, err := sql.Open(\"mysql\", \"root@/blog\") //db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/库名\") db, err := sql.Open(\"mysql\", \"root:12345678@tcp(127.0.0.1:3306)/shuang\") if err != nil &#123; panic(err) &#125; defer db.Close() if err = recordStats(db, 1 /*some user id*/, 5 /*some product id*/); err != nil &#123; panic(err) &#125;&#125; 运行后可以发现products表的views字段每次会加1， product_viewers表也会新增一条记录 如何在不真正连接数据库进行操作的前提下，测试recordStats这个func的代码？ 单测代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"fmt\" \"testing\" \"github.com/DATA-DOG/go-sqlmock\")// TestShouldUpdateStats sql执行成功的测试用例func TestShouldUpdateStats(t *testing.T) &#123; // mock一个*sql.DB对象，不需要连接真实的数据库 db, mock, err := sqlmock.New() if err != nil &#123; t.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err) &#125; defer db.Close() // mock执行指定SQL语句时的返回结果 mock.ExpectBegin() mock.ExpectExec(\"UPDATE products\").WillReturnResult(sqlmock.NewResult(1, 1)) mock.ExpectExec(\"INSERT INTO product_viewers\").WithArgs(2, 3).WillReturnResult(sqlmock.NewResult(1, 1)) mock.ExpectCommit() // 将mock的DB对象传入我们的函数中 if err = recordStats(db, 2, 3); err != nil &#123; t.Errorf(\"error was not expected while updating stats: %s\", err) &#125; // 确保期望的结果都满足 if err := mock.ExpectationsWereMet(); err != nil &#123; t.Errorf(\"there were unfulfilled expectations: %s\", err) &#125;&#125;// TestShouldRollbackStatUpdatesOnFailure sql执行失败回滚的测试用例func TestShouldRollbackStatUpdatesOnFailure(t *testing.T) &#123; db, mock, err := sqlmock.New() if err != nil &#123; t.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err) &#125; defer db.Close() mock.ExpectBegin() mock.ExpectExec(\"UPDATE products\").WillReturnResult(sqlmock.NewResult(1, 1)) mock.ExpectExec(\"INSERT INTO product_viewers\"). WithArgs(2, 3). WillReturnError(fmt.Errorf(\"some error\")) mock.ExpectRollback() // now we execute our method if err = recordStats(db, 2, 3); err == nil &#123; t.Errorf(\"was expecting an error, but there was none\") &#125; // we make sure that all expectations were met if err := mock.ExpectationsWereMet(); err != nil &#123; t.Errorf(\"there were unfulfilled expectations: %s\", err) &#125;&#125; 单测中定义了一个执行成功的测试用例和一个执行失败回滚的测试用例，确保代码中的每个逻辑分支都能被测试到，提高单元测试覆盖率。 展示测试覆盖率,并生成覆盖统计文件到 count.out: go test ./... -v -coverprofile=count.out 用go tool来分析 count.out 文件并生成想要的结果： 用 -func 生成每个函数的覆盖率 go tool cover -func=count.out 展示每一个函数单元测试的覆盖率,若100% 则测试完整,若0.0% 则没有测试 用 -html 生成 html 文件,以图形方式展示每个函数,每一行代码的覆盖率 go tool cover -html=count.out 会打开默认浏览器,图形化展示测试覆盖率 可切换当前库下的每个文件,看每一行代码是否测试执行。没有执行的显示为红色, 灰色是不需要测试的, 亮绿色是测试通过的 Mock Redis 更多参考： golang三大基础mock大法 Golang 单元测试：有哪些误区和实践？","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go单测之mock网络","date":"2012-03-26T09:22:15.000Z","path":"2012/03/26/Go单测之mock网络/","text":"本文是对Go单测从零到溜系列—1.mock网络测试的实践 自己对外提供的api接口： 以gin框架为例，演示如何为http server编写单元测试 12345678910111213141516171819202122232425262728293031323334353637383940// gin.gopackage mainimport ( \"fmt\" \"net/http\" \"github.com/gin-gonic/gin\")// Param 请求参数type Param struct &#123; Name string `json:\"name\"`&#125;// helloHandler /hello请求处理函数func helloHandler(c *gin.Context) &#123; var p Param if err := c.ShouldBindJSON(&amp;p); err != nil &#123; c.JSON(http.StatusOK, gin.H&#123; \"msg\": \"name参数缺失\", &#125;) return &#125; c.JSON(http.StatusOK, gin.H&#123; \"msg\": fmt.Sprintf(\"hello %s\", p.Name), &#125;)&#125;// SetupRouter 路由func SetupRouter() *gin.Engine &#123; router := gin.Default() router.POST(\"/hello\", helloHandler) return router&#125;func main() &#123; g := SetupRouter() g.Run() // listen and serve on 0.0.0.0:8080&#125; 12345678curl -X POST \\ http://127.0.0.1:8080/hello \\ -H 'cache-control: no-cache' \\ -H 'content-type: application/json' \\ -H 'postman-token: ed1c03e8-7b65-637e-4dc5-35cf38bbe5ac' \\ -d '&#123; \"name\": \"Alex\"&#125;' 当有传name参数时，返回hello $name， 否则返回name参数缺失 使用Go标准库 net/http/httptest 进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// gin_test.gopackage mainimport ( \"encoding/json\" \"net/http\" \"net/http/httptest\" \"strings\" \"testing\" \"github.com/stretchr/testify/assert\")func Test_helloHandler(t *testing.T) &#123; // 定义两个测试用例 tests := []struct &#123; name string param string expect string &#125;&#123; &#123;\"base case\", `&#123;\"name\": \"Alex\"&#125;`, \"hello Alex\"&#125;, &#123;\"bad case\", \"\", \"name参数缺失\"&#125;, &#125; r := SetupRouter() for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; // mock一个HTTP请求 req := httptest.NewRequest( \"POST\", // 请求方法 \"/hello\", // 请求URL strings.NewReader(tt.param), // 请求参数 ) // mock一个响应记录器 w := httptest.NewRecorder() // 让server端处理mock请求并记录返回的响应内容 r.ServeHTTP(w, req) // 校验状态码是否符合预期 assert.Equal(t, http.StatusOK, w.Code) // 解析并检验响应内容是否复合预期 var resp map[string]string err := json.Unmarshal([]byte(w.Body.String()), &amp;resp) assert.Nil(t, err) assert.Equal(t, tt.expect, resp[\"msg\"]) &#125;) &#125;&#125; 展示测试覆盖率,并生成覆盖统计文件到 count.out: go test ./... -v -coverprofile=count.out 用go tool来分析 count.out 文件并生成想要的结果： 用 -func 生成每个函数的覆盖率 go tool cover -func=count.out 展示每一个函数单元测试的覆盖率,若100% 则测试完整,若0.0% 则没有测试 用 -html 生成 html 文件,以图形方式展示每个函数,每一行代码的覆盖率 go tool cover -html=count.out 会打开默认浏览器,图形化展示测试覆盖率 可切换当前库下的每个文件,看每一行代码是否测试执行。没有执行的显示为红色, 灰色是不需要测试的, 亮绿色是测试通过的 请求别人的接口： 对这类场景写单测时，不想在测试过程中真正去发送请求(或依赖的外部接口还未开发完成)，可以在单元测试中使用gock这个库，对依赖的API进行mock。 go get -u gopkg.in/h2non/gock.v1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// api.gopackage mainimport ( \"bytes\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\")// ReqParam API请求参数type ReqParam struct &#123; X int `json:\"x\"`&#125;// Result API返回结果type Result struct &#123; Value int `json:\"value\"`&#125;func GetResultByAPI(x, y int) int &#123; p := &amp;ReqParam&#123;X: x&#125; b, _ := json.Marshal(p) // 调用其他服务的API resp, err := http.Post( \"http://your-api.com/post\", \"application/json\", bytes.NewBuffer(b), ) if err != nil &#123; return -1 &#125; body, _ := ioutil.ReadAll(resp.Body) var ret Result if err := json.Unmarshal(body, &amp;ret); err != nil &#123; return -1 &#125; // 这里对API返回的数据做一些逻辑处理 return ret.Value + y&#125;func main() &#123; fmt.Println(\"结果为:\", GetResultByAPI(1, 2))&#125; 使用gock 对外部API进行mock，即带着参数，返回约定好的响应内容 1234567891011121314151617181920212223242526272829303132333435363738394041// api_test.gopackage mainimport ( \"testing\" \"github.com/stretchr/testify/assert\" \"gopkg.in/h2non/gock.v1\")func TestGetResultByAPI(t *testing.T) &#123; defer gock.Off() // 测试执行后刷新挂起的mock // mock 请求外部api时传参x=1返回100 gock.New(\"http://your-api.com\"). Post(\"/post\"). MatchType(\"json\"). JSON(map[string]int&#123;\"x\": 1&#125;). Reply(200). JSON(map[string]int&#123;\"value\": 100&#125;) // 调用我们的业务函数 res := GetResultByAPI(1, 1) // 校验返回结果是否符合预期 assert.Equal(t, res, 101) // mock 请求外部api时传参x=2返回200 gock.New(\"http://your-api.com\"). Post(\"/post\"). MatchType(\"json\"). JSON(map[string]int&#123;\"x\": 2&#125;). Reply(200). JSON(map[string]int&#123;\"value\": 200&#125;) // 调用我们的业务函数 res = GetResultByAPI(2, 2) // 校验返回结果是否符合预期 assert.Equal(t, res, 202) assert.True(t, gock.IsDone()) // 断言mock被触发&#125; 展示测试覆盖率,并生成覆盖统计文件到 count.out: go test ./... -v -coverprofile=count.out 用go tool来分析 count.out 文件并生成想要的结果： 用 -func 生成每个函数的覆盖率 go tool cover -func=count.out 展示每一个函数单元测试的覆盖率,若100% 则测试完整,若0.0% 则没有测试 用 -html 生成 html 文件,以图形方式展示每个函数,每一行代码的覆盖率 go tool cover -html=count.out 会打开默认浏览器,图形化展示测试覆盖率 可切换当前库下的每个文件,看每一行代码是否测试执行。没有执行的显示为红色, 灰色是不需要测试的, 亮绿色是测试通过的","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go实现猴子补丁","date":"2012-03-26T08:54:10.000Z","path":"2012/03/26/Go实现猴子补丁/","text":"本文是对涛叔在Go夜读119期119 Go monkey patch 的原理及应用的学习与记录 相关ppt 关于猴子补丁 Python异步库gevent有一个猴子补丁模块，from gevent import monkey; monkey.patch_all()，可以将python标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和select等，变为协作式运行 猴子补丁的这个叫法起源于Zope框架(1998年就诞生的一个Python Web框架)，大家在修正Zope的Bug的时候经常在程序后面追加更新部分，这些被称作是“杂牌军补丁(guerilla patch)”，后来guerilla就渐渐的写成了gorllia(猩猩)，再后来就写了monkey(猴子)，所以猴子补丁的叫法是这么莫名其妙的得来的。后来在动态语言中，不改变源代码而对功能进行追加和变更，统称为“猴子补丁”。所以猴子补丁并不是Python中专有的。猴子补丁这种东西充分利用了动态语言的灵活性，可以对现有的语言Api进行追加，替换，修改Bug，甚至性能优化等等。使用猴子补丁的方式，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。也就是通过猴子补丁的monkey.patch_xxx()来将python标准库中模块或函数改成gevent中的响应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式的。 python协程初步–gevent库使用以及解释什么是猴子补丁monkey_patch Gevent和猴子补丁 Go实现猴子补丁 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; n := foo() fmt.Println(n)&#125;// 有没有办法让 time.Now和rand.Int63返回一个固定的数字，让单测能够重复跑func foo() int64 &#123; n := time.Now() r := rand.Int63() return n.UnixNano() + r&#125; 最好的方式是找到main()调foo()的地方，将其指向bar(). 但Go中实现不了这种效果，只能找到foo()指向的内存区域，将该区域前面的指令替换为跳转到bar() 不同CPU的跳转指令不同，下面以amd64架构为例 只要内存布局一样，不同类型的指针是可以通过unsafe.Pointor强转的，如float64类型的指针可以转为int64类型的指针 unsafe包的用处就是绕过编译器对指针类型转换的检测逻辑，但程序员需自己保证两种指针的底层数据结构一致(即不让编译器做类型检查) //todo 一些相关的库 最早有个bouk/monkey项目，作者是荷兰人，但已经不维护了 打桩神器gomonkey gomonkey 全面支持 arm64 了 Go语言实现猴子补丁Go语言实现猴子补丁【二】Go语言实现猴子补丁【三】 go-kiss/monkey","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"用Markdown做PPT","date":"2012-03-20T11:06:49.000Z","path":"2012/03/20/用Markdown做PPT/","text":"Slidevnpm init slidev@latest 用 Markdown 做的 PPT，真的太强了！ Go具之present - 编写go特色的ppt go get -u golang.org/x/tools/cmd/present go install golang.org/x/tools/cmd/present present 语法点： 表示章节，每一个章节用单独的一个文档表示 - 表示无序列表 四个空格表示插入一行代码 str* 表示加粗，记得前面要加个空格 .link https://golang.org/ 插入一个url .image aaa.png 300 300 插入图片，这个图片在我当前目录下 相关语法可参考文档 或 dave cheney的这个slide Golang技术幻灯片的查看方法 https://go-talks.appspot.com/github.com/davecheney/presentations/performance-without-the-event-loop.slide#2","tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"Go语言版本演进","date":"2012-03-18T13:11:39.000Z","path":"2012/03/18/Go语言版本演进/","text":"Go 1.0 - 2012 年 3 月： Go 1 Release Notes 随着 Go 第一个版本发布的还有一份兼容性说明文档。该文档承诺，Go 的未来版本会尽可能确保向后兼容性，不会破坏现有程序。 For instance, code that runs under Go 1.2 should be compatible with Go 1.2.1, Go 1.3, Go 1.4, etc., although not necessarily with Go 1.1 since it may use features added only in Go 1.2 此版本中已包含 go tool pprof 命令，它是Google的pprof C++分析器的一个变种； 同时还包含 go vet 命令（之前的是 go tool vet），它可以报告程序包中可能存在的错误。 Go 1.1 - 2013 年 5 月： Go 1.1 Release Notes The most significant improvements are performance-related. We have made optimizations in the compiler and linker, garbage collector, goroutine scheduler, map implementation, and parts of the standard library. It is likely that your Go code will run noticeably faster when built with Go 1.1. 这个版本的 Go 致力于增强语言特性（编译器、垃圾回收机制、映射、goroutine 调度器）与性能。 下面是改进的图例：(图片来自Go 1.1 performance improvements–Dave Cheney) 重新编写后的Go的调度器性能有了显著提高。调度器目前的设计如下： M 是操作系统线程，P 表示一个处理器（P 的数量不能超过 GOMAXPROCS），其中每个 P 对应一个本地 go 协程队列。 1.1 版本之前，P 的概念没有被引入，go 协程在全局范围通过存在于全局的单个互斥锁管理。 这次改进实现了“任务窃取（work-stealing）”，允许一个 P 处理队列“窃取”另外一个 P 处理队列的协程任务。 (图片来自Go’s work-stealing scheduler) Go 1.0需要在每个函数最后，显式地return(或panic)；在Go 1.1中，如果函数的最终语句可以在语法上显示为终止语句，则可以省略最终的“return”语句 增加了竞态检测器，提高并发编程的安全性. Go: Race Detector with ThreadSanitizer Go 1.2 - 2013 年 12 月： Go 1.2 Release Notes Three-index slices Go 1.2之前，切片的参数只允许有两个，即 sli[i:j]，即初始位置i和(长度的)结束位置j，其cap默认是底层数组的容器，如： 1234567891011121314package mainimport \"fmt\"func main()&#123; var array [10]int sli := array[0:8] slice := array[2:4] //只看头(从哪里切)，不看尾，即顾头不顾腚... fmt.Println(cap(sli)) //10 fmt.Println(cap(slice)) //8&#125; Go 1.2 adds new syntax to allow a slicing operation to specify the capacity as well as the length. A second colon introduces the capacity value, which must be less than or equal to the capacity of the source slice or array, adjusted for the origin. 即之前的slice := array[2:4] 等价于 slice := array[2:4:10]，在Go 1.2中因为引入了新的语法，即支持第三个参数，可以调整切片的容量。 “第二个冒号引入容量值，该值必须小于或等于源切片或数组的容量” slice := array[2:4:7]的cap为 7-2=5 如果第一项不写，[:i:j]，即认为是0 更多细节参考设计文件 go test 命令支持代码覆盖率报告，并提供新的 go tool cover 命令输出代码测试覆盖率的统计信息. The cover story One major new feature of go test is that it can now compute and, with help from a new, separately installed “go tool cover” program, display test coverage results. Go 1.3 - 2014 年 6 月： Go 1.3 Release Notes Changes to the runtime have improved the performance of Go binaries, with an improved garbage collector, a new “contiguous” goroutine stack management strategy, a faster race detector, and improvements to the regular expression engine. 堆栈管理在此版本中得到了重要改善。 堆栈现在会分配连续的内存片段，并提高了分配效率。这使得 Go 语言在下个版本中将堆栈大小减少到 2KB。 同时改进了某些组件中堆栈的错误拆分所导致的性能下降问题，此类问题会在堆栈密集分配/释放状态下出现。以下 json 包的例子展示了性能对于堆栈大小的相关度： 引入连续堆栈的机制修复了这类组件的性能问题。下面是另一个 html/template 包的例子，它也展示出了性能对于堆栈大小的敏感度： 更多信息可阅读： How Does the Goroutine Stack Size Evolve? 翻译：Go: Goroutine 的堆栈大小是如何演进的 发布了 sync 包的 Pool 组件 通过 Pool可以复用代码结构，减少分配资源的数量. 该组件随后成为 Go 生态中许多改进的来源，如标准库中的 encoding/json 和 net/http 包，及 Go 社区中的 zap 等包。 更多信息可阅读： Go: Understand the Design of Sync.Pool 翻译：Go: 理解 Sync.Pool 的设计 改进了channel的实现，提升了性能 Go 1.2 与 Go 1.3 版本间 channel 的性能对比: Go 1.4 - 2014 年 12 月： Go 1.4 Release Notes The release focuses primarily on implementation work, improving the garbage collector and preparing the ground for a fully concurrent collector to be rolled out in the next few releases. Stacks are now contiguous, reallocated when necessary rather than linking on new “segments”; this release therefore eliminates the notorious “hot stack split” problem. 该版本主要侧重于实现工作、改进垃圾收集器并为在接下来的几个版本中推出的完全并发收集器奠定基础。 堆栈现在是连续的，在必要时重新分配，而不是链接到新的“段”； 因此，此版本消除了臭名昭著的“热堆栈拆分”问题。 For-range loops支持新语法 1234567891011121314151617package mainimport \"fmt\"func main() &#123; sli := []string&#123;\"shandong\", \"zhejiang\", \"guangdong\", \"jiangsu\"&#125; for k, v := range sli &#123; fmt.Println(\"k-v:\", k, v) //go 1.3及之前的For-range loops &#125; for range sli &#123; fmt.Println(\"从1.4开始这种写法是可以通过编译的\") &#125;&#125; Android 的官方支持包golang.org/x/mobile随该版本一同发布，使开发者可以仅用 Go 代码编写简单的 Android 应用。 之前用 C 和汇编语言编写的大多数运行时已转换为用 Go 语言实现 &amp;&amp; 使用了更精准的垃圾收集器，堆栈大小减少了 10~30% Prior to Go 1.4, the runtime (garbage collector, concurrency support, interface management, maps, slices, strings, …) was mostly written in C, with some assembler support. In 1.4, much of the code has been translated to Go so that the garbage collector can scan the stacks of programs in the runtime and get accurate information about what variables are active. This change was large but should have no semantic effect on programs.This rewrite allows the garbage collector in 1.4 to be fully precise, meaning that it is aware of the location of all active pointers in the program. This means the heap will be smaller as there will be no false positives keeping non-pointers alive. Other related changes also reduce the heap size, which is smaller by 10%-30% overall relative to the previous release.A consequence is that stacks are no longer segmented, eliminating the “hot split” problem. When a stack limit is reached, a new, larger stack is allocated, all active frames for the goroutine are copied there, and any pointers into the stack are updated. Performance can be noticeably better in some cases and is always more predictable. Details are available in the design document.The use of contiguous stacks means that stacks can start smaller without triggering performance issues, so the default starting size for a goroutine’s stack in 1.4 has been reduced from 8192 bytes to 2048 bytes.As preparation for the concurrent garbage collector scheduled for the 1.5 release, writes to pointer values in the heap are now done by a function call, called a write barrier, rather than directly from the function updating the value. In this next release, this will permit the garbage collector to mediate writes to the heap while it is running. This change has no semantic effect on programs in 1.4, but was included in the release to test the compiler and the resulting performance.The implementation of interface values has been modified. In earlier releases, the interface contained a word that was either a pointer or a one-word scalar value, depending on the type of the concrete object stored. This implementation was problematical for the garbage collector, so as of 1.4 interface values always hold a pointer. In running programs, most interface values were pointers anyway, so the effect is minimal, but programs that store integers (for example) in interfaces will see more allocations.As of Go 1.3, the runtime crashes if it finds a memory word that should contain a valid pointer but instead contains an obviously invalid pointer (for example, the value 3). Programs that store integers in pointer values may run afoul of this check and crash. In Go 1.4, setting the GODEBUG variable invalidptr=0 disables the crash as a workaround, but we cannot guarantee that future releases will be able to avoid the crash; the correct fix is to rewrite code not to alias integers and pointers. 发布 go generate 命令，此命令会扫描//go:generate 指令提供的信息生成代码，简化了代码生成的方式。 Generating code 引入了Internal包 Go 1.4 “Internal” Packages Go 的项目代码管理工具从 Mercurial 切换为 Git，与此同时，项目也从 Google Code 迁移到了 Github 上 Go 1.5 - 2015 年 8 月： Go 1.5 Release Notes 从该版本开始，Go的发布时间延迟两个月，从之前的每年6月和12月 调整为每年 8 月和 2 月发布新版本： Go Release Cycle 图片来源 垃圾回收器被完全重新设计实现 Go 1.5 concurrent garbage collector pacing Go GC: Latency Problem Solved 归功于基于并发的回收器，垃圾回收延迟被显著降低。 以下来自于 Twitter 生产环境服务器的例子，其中 GC 延迟从 300 毫秒降低到 30 毫秒： 图片来源:Getting to Go: The Journey of Go’s Garbage Collector 调度程序的相关改进允许将默认的 GOMAXPROCS 值（并发执行的 goroutine 的数量）从 1 更改为逻辑 CPU 的数量。在以前的版本中，默认值为 1 Go 1.5 GOMAXPROCS Default RuntimeIn Go 1.5, the order in which goroutines are scheduled has been changed. The properties of the scheduler were never defined by the language, but programs that depend on the scheduling order may be broken by this change. We have seen a few (erroneous) programs affected by this change. If you have programs that implicitly depend on the scheduling order, you will need to update them.Another potentially breaking change is that the runtime now sets the default number of threads to run simultaneously, defined by GOMAXPROCS, to the number of cores available on the CPU. In prior releases the default was 1. Programs that do not expect to run with multiple cores may break inadvertently. They can be updated by removing the restriction or by setting GOMAXPROCS explicitly. For a more detailed discussion of this change, see the design document. go tool trace 可以在运行时可视化跟踪程序 追踪信息可在测试或运行期间生成，展示在浏览器窗口中 Go Execution Tracer map语法的更改 由于疏忽，允许从slice literals中省略元素类型的规则未应用于map。在1.5版本得到了修正 以下两种定义map的方式从1.5及之后都可以（即可以省略Point的类型） 123456789101112131415161718192021222324package mainfunc main() &#123; type Point struct &#123; a float64 b float64 &#125; m1 := map[Point]string&#123; Point&#123;29.935523, 52.891566&#125;: \"Persepolis\", Point&#123;-25.352594, 131.034361&#125;: \"Uluru\", Point&#123;37.422455, -122.084306&#125;: \"Googleplex\", &#125; m2 := map[Point]string&#123; &#123;29.935523, 52.891566&#125;: \"Persepolis\", &#123;-25.352594, 131.034361&#125;: \"Uluru\", &#123;37.422455, -122.084306&#125;: \"Googleplex\", &#125; _, _ = m1, m2&#125; Go 1.6 - 2016 年 2 月： Go 1.6 Release Notes 增加对于 HTTP/2 协议的默认支持 再一次降低了垃圾回收器的延迟 runtime改变了打印程序结束恐慌的方式。现在只打印发生panic的 goroutine 的堆栈，而不是所有现有的 goroutine (可以使用 GOTRACEBACK 环境变量或调用 debug.SetTraceback 函数来配置此行为。对搞清楚当前程序一共起了多少个goroutine还是很有用的~) For program-ending panics, the runtime now by default prints only the stack of the running goroutine, not all existing goroutines. Usually only the current goroutine is relevant to a panic, so omitting the others significantly reduces irrelevant output in a crash message. To see the stacks from all goroutines in crash messages, set the environment variable GOTRACEBACK to all or call debug.SetTraceback before the crash, and rerun the program. See the runtime documentation for details.Updating: Uncaught panics intended to dump the state of the entire program, such as when a timeout is detected or when explicitly handling a received signal, should now call debug.SetTraceback(“all”) before panicking. Searching for uses of signal.Notify may help identify such code. 默认启用vendor目录 sort.Sort 内部的算法进行了改进，运行速度提高了约 10% In the sort package, the implementation of Sort has been rewritten to make about 10% fewer calls to the Interface’s Less and Swap methods, with a corresponding overall time savings. The new algorithm does choose a different ordering than before for values that compare equal (those pairs for which Less(i, j) and Less(j, i) are false).Updating: The definition of Sort makes no guarantee about the final order of equal values, but the new behavior may still break programs that expect a specific order. Such programs should either refine their Less implementations to report the desired order or should switch to Stable, which preserves the original input order of equal values. Go 1.7 - 2016 年 8 月： Go 1.7 Release Notes context包转正 可以为用户提供处理超时和任务取消的机制 Over the past few years, the golang.org/x/net/context package has proven to be essential to many Go applications. Contexts are used to great effect in applications related to networking, infrastructure, and microservices (such as Kubernetes and Docker). They make it easy to enable cancellation, timeouts, and passing request-scoped data. To make use of contexts within the standard library and to encourage more extensive use, the package has been moved from the x/net repository to the standard library as the context package. Support for contexts has been added to the net, net/http, and os/exec packages. For more information about contexts, see the package documentation and the Go blog post Go Concurrency Patterns: Context. 在过去的几年里，golang.org/x/net/context 包已被证明对许多 Go 应用程序至关重要。上下文在与网络、基础设施和微服务（例如 Kubernetes 和 Docker）相关的应用程序中发挥了重要作用。它们使启用取消、超时和传递请求范围的数据变得容易。为了在标准库中使用上下文并鼓励更广泛的使用，该包已作为上下文包从 x/net 存储库移至标准库。对上下文的支持已添加到 net、net/http 和 os/exec 包中。有关上下文的更多信息，请参阅包文档和 Go 博客文章 Go Concurrency Patterns: Context。 编译时间显着加快 二进制文件大小减少了 20-30%, CPU 时间减少了 5-35% A new compiler back end, based on static single-assignment form (SSA), has been under development for the past year. By representing a program in SSA form, a compiler may perform advanced optimizations more easily. This new back end generates more compact, more efficient code that includes optimizations like bounds check elimination and common subexpression elimination. We observed a 5–35% speedup across our benchmarks. For now, the new backend is only available for the 64-bit x86 platform (“amd64”), but we’re planning to convert more architecture backends to SSA in future releases. 过去一年一直在开发基于静态单一赋值形式 (SSA) 的新编译器后端。通过以 SSA 形式表示程序，编译器可以更轻松地执行高级优化。这个新的后端生成更紧凑、更高效的代码，包括边界检查消除和公共子表达式消除等优化。我们在基准测试中观察到了 5-35% 的加速。目前，新后端仅适用于 64 位 x86 平台（“amd64”），但我们计划在未来版本中将更多架构后端转换为 SSA。 编译器前端使用一种新的、更紧凑的导出数据格式，并更有效地处理导入声明。虽然编译器工具链中的这些变化大多是不可见的，但用户已经观察到编译时间显着加快，二进制文件大小减少了 20-30%。 为 crypto/sha1, crypto/sha256, encoding/binary, fmt, hash/adler32, hash/crc32, hash/crc64, image/color, math/big, strconv, strings, unicode, and unicode/utf16包的实现带来了 10% 以上的提升 垃圾收集器的加速和标准库的优化 程序应该运行得更快一些。与 Go 1.6 相比，具有许多空闲 goroutine 的程序将经历更短的垃圾收集暂停。 改进了 go tool trace Go 1.8 - 2017 年 2 月： Go 1.8 Release Notes 优化编译 CPU 时间在 32 位 ARM 系统上减少了 20-30%, 还针对 64 位 x86 系统进行了一些适度的性能改进。编译器和链接器变得更快。 编译时间应该比 Go 1.7 改进了大约 15% 对垃圾回收器改进，使两次垃圾回收的暂停时间减小到了毫秒级 同时识别了剩余仍未解决的暂停模式，并在下一个版本中得到修复。修复后，通常情况下暂停时间能控制在 100 微秒左右,甚至能低至 10 微秒。 改进了 defer 函数 部分标准库使用context包来改造 Go 1.7中进入标准库的context，提供了取消和超时机制。 Go 1.8 让标准库中更多package使用(支持)context，包括 database/sql，net 包， net/http 包中的 Server.Shutdown等 sort 包中新添加的 Slice 函数，对切片进行排序变得比之前简单得多 例如，对一个结构体类型的切片，使用结构体的一个字段来进行排序： sort.Slice(s, func(i, j int) bool { return s[i].Name &lt; s[j].Name }) Go 1.9 - 2017 年 8 月： Go 1.9 Release Notes 提升了垃圾收集器和编译器 Most of the engineering effort put into this release went to improvements of the runtime and tooling, which makes for a less exciting announcement, but nonetheless a great release. GC性能进一步提升，这要归功于一些库函数会触发并发垃圾收集机制，这样的话只会阻塞调用协程（goroutine），而不会阻塞整个程序。另外，大对象的堆内存分配也得到了明显提升。 Go 1.9 编译器能够并行编译同一个包中的函数。在之前版本的编译器中，已经支持了并行编译不同包中的函数。 增加了类型别名 支持通过声明类型别名（type alias）实现渐进式代码重构（gradual code repair） 渐进式代码修复是代码重构中一种很有用的方式，对于大型的代码库来说很有价值。简而言之，渐进式代码修复的目标是通过一系列的步骤完成一个较大规模的重构，也就是说不会在一次自动化的提交中完成所有的变更，而是分成多次提交。原子性的重构方式在概念上通常很简单，但是如果代码库很大的话，就会造成规模很大的代码提交，这样很难审查和合并。借助渐进式代码修复，我们可以按照三个步骤来重构代码：首先，引入新的API，它应该能与旧的API 共存，所以我们不必立即修改所有使用旧API 的代码；然后，我们将使用旧API 的所有地方替换为新API；最后，将旧的API 移除。为了启用渐进式代码修复，必须能为常量、函数、变量和类型创建另外一个备选的名称。现在，Go 允许通过如下的方式声明类型别名：type OldAPI = NewPackage.API这样的话，所有引用OldAPI的地方都会使用重构之后的类型—详见Russ Cox Codebase Refactoring (with help from Go) 新增了sync.Map 提供了线程安全的并发map，具有恒定分摊时间（amortized-constant-time）的加载、存储和删除功能 其诞生是GopherCon 2017 - Lightning Talk: Bryan C Mills - An overview of sync.Map得到灵感的 time包更加安全 Go 1.9 借助单调时间跟踪（monotonic time tracking），让time包的使用变得更加安全。即便是存在挂钟时间调整（wall clock adjustment），Time的对比也会更加容易。 (可以透明地跟踪每个时间值的 monotonic time，使两个时间之间的差值计算不受墙上时钟调整的影响) testing包新增helper方法 新的 Helper 方法，添加到 testing.T 和 testing.B 中，将调用函数标记为测试助手函数。当测试包打印文件和行信息时，它会显示对辅助函数的调用位置，而不是辅助函数本身中的一行。 go1.9_test.go: 123456789101112package userimport \"testing\"func failure(t *testing.T) &#123; t.Helper() // This call silences this function in error reports. t.Fatal(\"failure\")&#125;func Test(t *testing.T) &#123; failure(t)&#125; 因为 failure 将自己标识为测试助手，所以在 Test 期间打印的错误消息将指示第 11 行调用失败的位置，而不是第 7 行调用失败调用 t.Fatal 的位置。 Go 1.9 引入了类型别名并提升了运行时和工具支持 Go 1.9发布 支持渐进式代码重构 Go 1.10 - 2018 年 2 月： Go 1.10 Release Notes Most of its changes are in the implementation of the toolchain, runtime, and libraries. …There are no significant changes to the language specification. 它的大部分更改都在工具链、运行时和库的实现中,语言规范没有重大变化 go test命令可以缓存测试结果 &gt;The go test command now caches test results: if the test executable and command line match a previous run and the files and environment variables consulted by that run have not changed either, go test will print the previous test output, replacing the elapsed time with the string “(cached).” Test caching applies only to successful test results; only to go test commands with an explicit list of packages; and only to command lines using a subset of the -cpu, -list, -parallel, -run, -short, and -v test flags. The idiomatic way to bypass test caching is to use -count=1.go test命令现在可以缓存测试结果：如果测试的可执行文件和命令行与之前的运行相匹配，并且该运行所查询的文件和环境变量也没有改变，go test将打印之前的测试输出，用字符串”（cached）”代替经过的时间。测试缓存只适用于成功的测试结果；只适用于有明确软件包列表的go test命令；只适用于使用-cpu、-list、-parallel、-run、-short和-v测试标志的子集的命令行。绕过测试缓存的习惯性方法是使用-count=1。 12345first run:ok /go/src/retro 0.027ssecond run:ok /go/src/retro (cached) go build 命令会缓存最近构建过的包，从而加快了构建过程 Go语言具有较高的编译性能是Go语言最初设计时就确定下来的目标，Go编译器的性能在Go 1.4.3版本达到顶峰，这虽然是得益于其使用C语言实现，但更重要的是其为高性能构建而定义的便于依赖分析的语言构建模型，同时避免了像C/C++那样的重复多次扫描大量头文件的负担。随着Go自举的实现，使用Go语言实现的go compiler性能有较大下降，但即便这样，其编译速度在主流编程语言中仍然是数一数二的。在经过了Go 1.6到Go1.9等多个版本对compiler的优化后，go compiler的编译速度已经恢复到Go 1.4.3 compiler的2/3左右或是更为接近的水平。在Go 1.9版本引入并行编译后，Go team在提升工具性能方面的思路发生了些许变化：不再是一味地进行代码级的性能优化，而是选择通过Cache，重复利用中间结果，实现增量构建，来减少编译构建所用的时间 Go 1.10中值得关注的几个变化 Go 1.11 - 2018 年 8 月： Go 1.11 Release Notes There are many changes and improvements to the toolchain, runtime, and libraries, but two features stand out as being especially exciting: modules and WebAssembly support. Go modules 根据Go 2018 Survey Results问卷调查，大多数人面临的最大挑战是包管理 &gt;This release adds preliminary support for a new concept called “modules,” an alternative to GOPATH with integrated support for versioning and package distribution.此版本增加了对名为“模块”的新概念的初步支持，它是 GOPATH 的替代方案，具有对版本控制和包分发的集成支持。 Using Go Modules 增加了实验性的WebAssembly支持 这允许程序员将 Go 程序编译为与四种主要 Web 浏览器兼容的二进制格式 Go 1.12 - 2019 年 2 月： Go 1.12 Release Notes 改进了Go modules 准备成为 Go 1.13 中的默认设置 在analysis包基础上重写了 go vet 命令 这个包有着更大的灵活性，允许开发人员编写自己的代码检查工具。 go vet 命令已被重写，可作为一系列不同源代码分析工具的基础。 一个副作用是不再支持 go tool vet。 使用 go tool vet 的外部工具必须更改为使用 go vet。 使用 go vet 而不是 go tool vet 应该适用于所有受支持的 Go 版本。 Go 1.13 - 2019 年 9 月： Go 1.13 Release Notes 优化sync.Pool sync 包的 Pool 组件得到改进，得其中的资源不会在垃圾回收时被清除(通过新机制里引入的缓存，两次垃圾回收之间没有被使用过的实例才会被清除) 重了逃逸分析逻辑，使得 Go 程序减少了堆上的分配次数 go 命令默认使用 Go module mirror and Go checksum database下载和验证模块 对数字文字的改进 错误换行 默认开启 TLS 1.3 Go 1.14 - 2020 年 2 月： Go 1.14 Release Notes Go Module已可用于生产使用 鼓励所有用户迁移到 go modules进行依赖管理 嵌入具有重叠方法集的接口 &gt;Per the overlapping interfaces proposal, Go 1.14 now permits embedding of interfaces with overlapping method sets: methods from an embedded interface may have the same names and identical signatures as methods already present in the (embedding) interface. This solves problems that typically (but not exclusively) occur with diamond-shaped embedding graphs. Explicitly declared methods in an interface must remain unique, as before.根据重叠接口提案，Go 1.14 现在允许嵌入具有重叠方法集的接口：来自嵌入式接口的方法可能与（嵌入）接口中已经存在的方法具有相同的名称和相同的签名。这解决了菱形嵌入图通常（但不是唯一）出现的问题。像以前一样，接口中显式声明的方法必须保持唯一。 Diamond interface composition in Go 1.14 改进了defer的性能 &gt; This release improves the performance of most uses of defer to incur almost zero overhead compared to calling the deferred function directly. As a result, defer can now be used in performance-critical code without overhead concerns. goroutines 是异步可抢占的 &gt;Goroutines are now asynchronously preemptible. As a result, loops without function calls no longer potentially deadlock the scheduler or significantly delay garbage collection. This is supported on all platforms except windows/arm, darwin/arm, js/wasm, and plan9/.A consequence of the implementation of preemption is that on Unix systems, including Linux and macOS systems, programs built with Go 1.14 will receive more signals than programs built with earlier releases. This means that programs that use packages like syscall or golang.org/x/sys/unix will see more slow system calls fail with EINTR errors. Those programs will have to handle those errors in some way, most likely looping to try the system call again. For more information about this see man 7 signal for Linux systems or similar documentation for other systems.Goroutines 现在是异步可抢占的。因此，没有函数调用的循环不再可能使调度程序死锁或显着延迟垃圾收集。这在除 windows/arm、darwin/arm、js/wasm 和 plan9/ 之外的所有平台上都受支持。实施抢占的结果是，在包括 Linux 和 macOS 系统在内的 Unix 系统上，使用 Go 1.14 构建的程序将接收到比使用早期版本构建的程序更多的信号。这意味着使用 syscall 或 golang.org/x/sys/unix 等软件包的程序将看到更多缓慢的系统调用失败并出现 EINTR 错误。这些程序必须以某种方式处理这些错误，很可能会循环以再次尝试系统调用。有关这方面的更多信息，请参阅 Linux 系统的 man 7 signal 或其他系统的类似文档。 页面分配器更高效 &gt;The page allocator is more efficient and incurs significantly less lock contention at high values of GOMAXPROCS. This is most noticeable as lower latency and higher throughput for large allocations being done in parallel and at a high rate.页面分配器效率更高，并且在 GOMAXPROCS 值较高时会显着减少锁争用。这是最明显的，因为并行和高速完成的大型分配具有更低的延迟和更高的吞吐量。 内部定时器更高效 &gt;Internal timers, used by time.After, time.Tick, net.Conn.SetDeadline, and friends, are more efficient, with less lock contention and fewer context switches. This is a performance improvement that should not cause any user visible changes.time.After、time.Tick、net.Conn.SetDeadline 等使用的内部计时器效率将会更高，锁争用更少，上下文切换更少。这是一项性能改进，不会导致任何用户可见的更改。 Go 1.15 - 2020 年 8 月： Go 1.15 Release Notes 一些优化，如改进了对高核心数的小对象的分配 Allocation of small objects now performs much better at high core counts, and has lower worst-case latency.Converting a small integer value into an interface value no longer causes allocation.Non-blocking receives on closed channels now perform as well as non-blocking receives on open channels.现在，小对象的分配在高核心数下表现得更好，并且具有更低的最坏情况延迟。将小整数值转换为接口值不再导致分配。现在，关闭通道上的非阻塞接收与开放通道上的非阻塞接收一样好。 编译器/汇编器/链接器的优化 Go 1.15 reduces typical binary sizes by around 5% compared to Go 1.14 by eliminating certain types of GC metadata and more aggressively eliminating unused type metadata. 与 Go 1.14 相比，Go 1.15 通过消除某些类型的 GC 元数据并更积极地消除未使用的类型元数据，将二进制大小减少了约 5%。 This release includes substantial improvements to the Go linker, which reduce linker resource usage (both time and memory) and improve code robustness/maintainability. Go 1.15包括对 Go 链接器的重大改进，这减少了链接器资源的使用（时间和内存）并提高了代码的稳健性/可维护性。 内置了tzdata包 Go 1.15 包含一个新包 time/tzdata，它允许将时区数据库嵌入到程序中。导入此包（如 import _ “time/tzdata”）允许程序查找时区信息，即使本地系统上没有时区数据库。还可以嵌入时区数据库 Go的LoadLocation 有个问题，其依赖于 IANA Time Zone Database (简称 tzdata)这个数据库Linux系统一般都有，是windows系统都没带。没有 tzdata 就会从$GOROOT/中找。对于没有安装go环境的windows系统来说，就没办法通过 LoadLocation 设置时区。在Go 1.15现在之前解决这个问题的办法，是自己把tzdata文件放到程序目录中，保证 time包能够从目录中加载到时区文件go设置时区 X.509 CommonName 弃用 GOPROXY 支持跳过返回错误的代理 一些库改进（基本每个版本都有） 如 sql库支持 DB.SetConnMaxIdleTime; time.Ticker 支持 Reset；strconv库增加了FormatComplex和ParseComplex用来处理复数 Go 1.16 - 2021 年 2 月： Go 1.16 Release Notes GO111MODULE 默认为 on 根据 2020 年 Go 开发者调查，96% 的 Go 开发者已经改用Modules //go:embed 可以在编译阶段将静态资源文件打包进编译好的程序中，并提供访问这些文件的能力 Go 1.16新特性-embed包及其使用 对macOS ARM64的支持 Linux 上释放内存改回用Go 1.12之前的 MADV_DONTNEED 之前为了使监控不告警，都需要指定 GODEBUG=madvdontneed=1 &gt;On Linux, the runtime now defaults to releasing memory to the operating system promptly (using MADV_DONTNEED), rather than lazily when the operating system is under memory pressure (using MADV_FREE). This means process-level memory statistics like RSS will more accurately reflect the amount of physical memory being used by Go processes. Systems that are currently using GODEBUG=madvdontneed=1 to improve memory monitoring behavior no longer need to set this environment variable.在 Linux 上，运行时现在默认立即向操作系统释放内存（使用 MADV_DONTNEED），而不是在操作系统处于内存压力下时懒惰地释放内存（使用 MADV_FREE）。这意味着像 RSS 这样的进程级内存统计数据将更准确地反映 Go 进程正在使用的物理内存量。当前使用 GODEBUG=madvdontneed=1 来改善内存监控行为的系统不再需要设置此环境变量。 Go 1.12 关于内存释放的一个”改进” 弃用io/ioutil 该包的函数， 挪到了io包和os包 许多其他改进和错误修复 包括构建速度提高了 25%，内存使用量减少了 15% Go 1.17 - 2021 年 8 月： Go 1.17 Release Notes As always, the release maintains the Go 1 promise of compatibility. We expect almost all Go programs to continue to compile and run as before. 与往常一样，该版本保持了 Go 1 的兼容性承诺。我们希望几乎所有 Go 程序都能像以前一样继续编译和运行。 go modules 支持“修剪模块图”（Pruned module graphs） 如果模块指定 go 1.17 或更高版本，则模块图仅包含其他 go 1.17 模块的直接依赖关系，而不包括它们完整传递依赖关系 但是会在 go.mod 记录间接依赖的库版本。执行以下命令升级go mod tidy -go=1.17 编译器带来了额外的改进 即一种传递函数参数和结果的新方法，程序性能提高了约 5%，amd64 平台的二进制大小减少了约 2%。 unsafe包新增了unsafe.Add和unsafe.Slice 一些包的改变 如net包： URL 参数解析对 ; 支持的变化，原先 example?a=1;b=2&amp;c=3 会解析成 map[a:[1] b:[2] c:[3]], 现在解析成map[c:[3]] 增加 IP.IsPrivate 判断私有 IPa.b.c.d 格式的 ip v4 地址不允许每段有前缀 0（因为某些系统会认为前缀 0 表示 8进制） Go 1.18 - 2022 年 3 月： Go 1.18 Release Notes Go 1.18 is a massive release that includes new features, performance improvements, and our biggest change ever to the language. 按惯例应该在2月份发布，Delay了一个多月 泛型 千呼万唤，伴随争议终于到来 Type Parameters Proposal Go Blog提到 It isn’t a stretch to say that the design for parts of Go 1.18 started over a decade ago when we first released Go.,指的可能就是2009年rsc在博客里探讨泛型如何设计 好奇为啥用[]而不是其他语言普遍采用的&lt;&gt; Rob Pike的担忧,建议先不要用泛型，改动 Go 1.18 中的标准库 模糊测试（Fuzzing） Go is the first major language with fuzzing fully integrated into its standard toolchain Go Fuzzing 作为代价，fuzzing 会消耗大量内存，影响机器性能，占用也许是几个G的存储空间 Rob Pike对fuzzing的疑虑 Workspaces 工作区 在2021 年用户调查中，反馈最多的挑战是跨多个模块工作。 在 Go 1.18 中，使用新的 Go 工作区模式解决了这个问题，使用多个模块将变得简单。 如在工作目录或父目录中有go.work文件，或使用GOWORK环境变量进行指定，将使go命令进入工作区模式。 在此模式下，go.work文件将被用来确定作为模块解析根的一组主模块，而不是使用通常找到的go.mod文件来指定单一的主模块。 20%的性能提升 Go 1.18将为ARM64架构带来高达 20% 的 CPU 性能改进 但由于编译器中与支持泛型有关的变化，Go 1.18 的编译速度可能比Go 1.17的编译速度大约慢15%。编译后的代码的执行时间不受影响。打算在Go 1.19中提高编译器的速度。 所有版本的发布说明 Go 语言历史 Go 语言的历史回顾","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"常用压测工具","date":"2012-03-17T12:16:57.000Z","path":"2012/03/17/常用压测工具/","text":"Locust Python写的,有图形界面 官方文档 https://lxkaka.wang/locust/ wrk C写的 siege C写的 Jmeter Java写的 ab https://www.jianshu.com/p/43d04d8baaf7 hey Go写的","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"gin路由相关方法","date":"2012-03-17T11:38:31.000Z","path":"2012/03/17/gin路由相关方法/","text":"https://blog.csdn.net/BlackNamePlate/article/details/121563708 https://cloud.tencent.com/developer/article/1889863 https://www.jianshu.com/p/d4b52187d233 https://www.jianshu.com/p/44b005b660a2","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"MySQL字符集和排序规则","date":"2012-03-16T13:19:01.000Z","path":"2012/03/16/MySQL字符集和排序规则/","text":"https://blog.csdn.net/thebestleo/article/details/108126597https://blog.csdn.net/legendaryhaha/article/details/106391112 https://www.geek-share.com/detail/2804377456.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"为微软开源项目贡献代码","date":"2012-02-28T14:15:41.000Z","path":"2012/02/28/为微软开源项目贡献代码/","text":"和给Google贡献代码一样，先签署cla（Contributor License Agreement）cla.microsoft.com/ 1234567We appreciate community contributions to code repositories open sourced by Microsoft. By signing a contributor license agreement, we ensure that the community is free to use your contributions.Review the CLA documentThe Microsoft Contributor License Agreement (CLA) document is available for review as a PDF.Sign the CLAWhen you contribute to a Microsoft open source project on GitHub with a new pull request, a bot will evaluate whether you have signed the CLA. If required, the bot will comment on the pull request, including a link to this system to accept the agreement. 12345678910111213141516171819202122232425262728Contribution License AgreementThis Contribution License Agreement (“Agreement”) is agreed to by the party signing below (“You”), and conveys certain license rights to Microsoft Corporation and its affiliates (“Microsoft”) for Your contributions to Microsoft open source projects. This Agreement is effective as of the latest signature date below.Definitions. “Code” means the computer software code, whether in human-readable or machine-executable form, that is delivered by You to Microsoft under this Agreement. “Project” means any of the projects owned or managed by Microsoft and offered under a license approved by the Open Source Initiative (www.opensource.org). “Submit” is the act of uploading, submitting, transmitting, or distributing code or other content to any Project, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Project for the purpose of discussing and improving that Project, but excluding communication that is conspicuously marked or otherwise designated in writing by You as “Not a Submission.” “Submission” means the Code and any other copyrightable material Submitted by You, including any associated comments and documentation.Your Submission. You must agree to the terms of this Agreement before making a Submission to any Project. This Agreement covers any and all Submissions that You, now or in the future (except as described in Section 4 below), Submit to any Project.Originality of Work. You represent that each of Your Submissions is entirely Your original work. Should You wish to Submit materials that are not Your original work, You may Submit them separately to the Project if You (a) retain all copyright and license information that was in the materials as You received them, (b) in the description accompanying Your Submission, include the phrase “Submission containing materials of a third party:” followed by the names of the third party and any licenses or other restrictions of which You are aware, and (c) follow any other instructions in the Project’s written guidelines concerning Submissions.Your Employer. References to “employer” in this Agreement include Your employer or anyone else for whom You are acting in making Your Submission, e.g. as a contractor, vendor, or agent. If Your Submission is made in the course of Your work for an employer or Your employer has intellectual property rights in Your Submission by contract or applicable law, You must secure permission from Your employer to make the Submission before signing this Agreement. In that case, the term “You” in this Agreement will refer to You and the employer collectively. If You change employers in the future and desire to Submit additional Submissions for the new employer, then You agree to sign a new Agreement and secure permission from the new employer before Submitting those Submissions.Licenses.Copyright License. You grant Microsoft, and those who receive the Submission directly or indirectly from Microsoft, a perpetual, worldwide, non-exclusive, royalty-free, irrevocable license in the Submission to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute the Submission and such derivative works, and to sublicense any or all of the foregoing rights to third parties.Patent License. You grant Microsoft, and those who receive the Submission directly or indirectly from Microsoft, a perpetual, worldwide, non-exclusive, royalty-free, irrevocable license under Your patent claims that are necessarily infringed by the Submission or the combination of the Submission with the Project to which it was Submitted to make, have made, use, offer to sell, sell and import or otherwise dispose of the Submission alone or with the Project.Other Rights Reserved. Each party reserves all rights not expressly granted in this Agreement. No additional licenses or rights whatsoever (including, without limitation, any implied licenses) are granted by implication, exhaustion, estoppel or otherwise.Representations and Warranties. You represent that You are legally entitled to grant the above licenses. You represent that each of Your Submissions is entirely Your original work (except as You may have disclosed under Section 3). You represent that You have secured permission from Your employer to make the Submission in cases where Your Submission is made in the course of Your work for Your employer or Your employer has intellectual property rights in Your Submission by contract or applicable law. If You are signing this Agreement on behalf of Your employer, You represent and warrant that You have the necessary authority to bind the listed employer to the obligations contained in this Agreement. You are not expected to provide support for Your Submission, unless You choose to do so. UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, AND EXCEPT FOR THE WARRANTIES EXPRESSLY STATED IN SECTIONS 3, 4, AND 6, THE SUBMISSION PROVIDED UNDER THIS AGREEMENT IS PROVIDED WITHOUT WARRANTY OF ANY KIND, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.Notice to Microsoft. You agree to notify Microsoft in writing of any facts or circumstances of which You later become aware that would make Your representations in this Agreement inaccurate in any respect.Information about Submissions. You agree that contributions to Projects and information about contributions may be maintained indefinitely and disclosed publicly, including Your name and other information that You submit with Your Submission.Governing Law/Jurisdiction. This Agreement is governed by the laws of the State of Washington, and the parties consent to exclusive jurisdiction and venue in the federal courts sitting in King County, Washington, unless no federal subject matter jurisdiction exists, in which case the parties consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington. The parties waive all defenses of lack of personal jurisdiction and forum non-conveniens.Entire Agreement/Assignment. This Agreement is the entire agreement between the parties, and supersedes any and all prior agreements, understandings or communications, written or oral, between the parties relating to the subject matter hereof. This Agreement may be assigned by Microsoft.","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Golang url解析","date":"2012-02-28T08:22:42.000Z","path":"2012/02/28/Golang-url解析/","text":"https://www.ipeapea.cn/post/go-url/ https://cloud.tencent.com/developer/section/1143773 https://www.jianshu.com/p/48e32675bdce https://blog.csdn.net/wohu1104/article/details/106629308","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"Go生态的几个依赖注入框架","date":"2012-02-27T10:47:12.000Z","path":"2012/02/27/Go生态的几个依赖注入框架/","text":"控制反转与依赖注入的关系IOC/DIP其实是一种管理思想 GO编程模式：委托和反转控制 设计模式-控制反转IOC.Go实例(十二) Go生态圈几种依赖注入框架Google wireGo工程化(三) 依赖注入框架 wire Go 每日一库之 wire golang依赖注入工具wire指南 Compile-time Dependency Injection With Go Cloud’s Wire Golang依赖注入框架wire使用详解 控制反转(IoC) &amp; 依赖注入(DI) &amp; Go Uber diggolang 依赖注入 wire 和 dig 体验对比 Facebook injectgo 依赖注入与控制反转–inject框架","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"编程语言演进史","date":"2012-02-24T13:25:34.000Z","path":"2012/02/24/编程语言演进史/","text":"https://catcoding.me/2022/01/12/a-book-on-programming-language.html https://codeantenna.com/a/mE4VrjUOFE 编程语言概要（EOPL） https://eopl3.com/ Essentials of Programming Languages (EOPL) , 作者 Daniel P. Friedman, Mitchell Wand, Christopher T. Haynes. https://www.zhihu.com/question/23014211 大型机盛行的60年代开始出现高级编程语言，大大提高了代码编写效率，然后是微机、网络和现在的云计算时代，相继出现结构化、面向对象和服务导向的计算机语言，让程序代码更接近自然语言的表达，更真实地反映现实中的实体关系。本文的信息图展示了过去数十年来编程语言的演化过程。 计算机编程语言在过去几十年发现了许多变化。最先出现的语言是用于科学计算的Fortan和逻辑推演的LISP语言，而现在用于网络编程的语言包括C#、Ruby on Rails、Note.JS。下面由Services Angle制作的信息图展示了过去数十年来编程语言的演化过程。 1954 Fortranhttps://github.com/fortran-lang FORTRAN（FORmula TRANslator的缩写）意为“公式翻译器”，是世界上最早出现的计算机高级程序设计语言，广泛应用于科学和工程计算领域。FORTRAN语言以其特有的功能在数值、科学和工程计算领域发挥着重要作用。 1958 LISPLISP语言（全名LISt Processor，即链表处理语言）由约翰·麦卡锡在1960年左右创造的一种基于λ演算的函数式编程语言。 1959 CobolCOBOL（Common Business Oriented Language）是数据处理领域最为广泛的程序设计语言，是第一个广泛使用的高级编程语言。主要应用于数值计算并不复杂，但数据处理信息量却很大的商业领域。 1962 SimulaSimula 67被认为是最早的面向对象程序设计语言，它引入了所有后来面向对象程序设计语言所遵循的基础概念：对象、类、继承。 1964 BasicBASIC（Beginners’ All-purpose Symbolic Instruction Code）的意思就是“初学者的全方位符号指令代码”，是一种设计给初学者使用的程序设计语言。BASIC是一种解释语言，在完成编写后不须经过编译及连结即可执行，但如果要单独执行仍然需要编译成可执行文件。 1968 PascalPascal语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。Pascal的取名是为了纪念十七世纪法国著名哲学家和数学家Blaise Pascal，它由瑞士Niklaus Wirth教授于六十年代末设计并创立。 1969 CC语言既具有高级语言的特点，又具有汇编语言的特点，由美国贝尔研究所的D.M.Ritchie于1972年推出。1978后，C语言已先后被移植到大、中、小及微型机上。 1975 SQLSQL（Structured Query Language，结构化查询语言）是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 1983 C++C++是一种静态数据类型检查的、支持多重编程范式的通用程序设计语言。它支持过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计等多种程序设计风格。 1987 PerlPerl象C一样强大，象awk、sed等脚本描述语言一样方便。Perl借取了C、sed、awk、shell scripting以及很多其他程序语言的特性。其中最重要的特性是它内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。Perl最初的设计者是拉里·沃尔（Larry Wall），发表于1987年12月18日。 1991 PythonPython是一种面向对象、直译式计算机程序设计语言，由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样。它使你能够专注于解决问题而不是去搞明白语言本身。 1995 JavaJava是一种可以撰写跨平台应用软件的面向对象的程序设计语言，是由Sun Microsystems公司于1995年5月推出的Java程序设计语言和Java平台（即JavaSE, JavaEE, JavaME）的总称。 1995 JavaScriptJavaScript是一种能让你的网页更加生动活泼的程式语言，也是目前网页中设计中最容易学又最方便的语言。 2001 CC#（C Sharp)是微软为.NET框架量身订做的程序语言，C#拥有C/C++的强大功能以及Visual Basic简易使用的特性，是第一个组件导向的程序语言，与C++和Java同样是面向对象程序设计语言。 2002 .Net.NET 是 Microsoft XML Web服务平台。XML Web服务允许应用程序通过Internet进行通讯和共享数据，而不管所采用的是哪种操作系统、设备或编程语言。 2005 Ruby On RailsRuby on Rails是一个可以使你开发、部署、维护web应用程序变得简单的框架，Ruby以7月的诞生石ruby（红宝石）命名。 2009 Node.JSNode是一个服务器端 JavaScript 解释器，它改变了服务器应该如何工作的概念。它的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一台物理机的连接代码。","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"gin中间件的编写和使用","date":"2012-02-23T03:02:56.000Z","path":"2012/02/23/gin中间件的编写和使用/","text":"https://www.flysnow.org/2020/06/28/golang-gin-middleware.html gin里的中间件类似于Java里的拦截器（过滤器）可以对请求进行一些提前或者滞后的处理 Gin学习笔记 - Middleware(中间件) 这种通用业务独立开发并灵活配置使用的组件，一般称之为”中间件”，因为其位于服务器和实际业务处理程序之间。其含义就是相当于在请求和具体的业务逻辑处理之间增加某些操作，这种以额外添加的方式不会影响编码效率，也不会侵入到框架中。 Gin 中间件的编写和使用——Go Gin框架（六） gin常用中间件 中间件(middleware)，其原理就是对一个方法进行包裹装饰，然后返回同类型的方法，在Python中又名装饰器，甚至成为了Python的语法糖。应用场景大多是需要对某一类函数进行通用的前置或者后置处理。 查看handle源码，添加的中间件最终是与处理逻辑handler一起组装成了HandlersChain，毕竟他们本质上一样的，都是HandlerFunc，只不过业务逻辑是最后一个执行的handlerFunc。","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"常见的几种限流算法","date":"2012-02-22T12:07:20.000Z","path":"2012/02/22/常见的几种限流算法/","text":"https://xie.infoq.cn/article/bf4eeabeecf0d87b399c82e4e http://dockone.io/article/9746 https://juejin.cn/post/7002027704912445448 限流又称为流量控制，是指限制到达系统的并发请求数，当达到限制条件则可以拒绝请求，可以起到保护下游服务，防止服务过载等作用。常用的限流策略有漏桶算法、令牌桶算法、滑动窗口 漏桶算法较好理解，假设有一个水桶，向其中添水，虽然无法预计一次会添多少水，也无法预计水流入的速度，但是可以固定出水的速度，不论添水的速率有多大，都按照固定的速率流出，如果桶满了，溢出的上方水直接抛弃。我们把水当作HTTP请求，每次都把请求放到一个桶中，然后以固定的速率处理请求 这两种方法(漏桶和令牌桶)看起来很像，不过还是有区别的。漏桶流出的速率固定，而令牌桶只要在桶中有令牌，那就可以拿。也就是说令牌桶是允许一定程度的并发的，比如同一个时刻，有100个用户请求，只要令牌桶中有100个令牌，那么这100个请求全都会放过去。令牌桶在桶中没有令牌的情况下也会退化为漏桶模型，实际应用中令牌桶应用较为广泛。 Gin 限流中间件 高并发系统的限流策略：漏桶和令牌桶(附源码剖析) Go生态比较流行的基于漏桶限流算法实现的限流库uber-go/ratelimit Go生态比较流行的基于令牌桶限流算法实现的限流库 juju/ratelimit,Go官方也提供了相关功能，在golang.org/x/time/rate Golang限流器time/rate使用介绍 Golang限流器time/rate实现剖析 实践 Go 中基于 IP 地址的 HTTP 请求限流","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"探讨10年前Go 1.0发行时的一处关键概念","date":"2012-02-19T14:17:20.000Z","path":"2012/02/19/探讨10年前Go-1-0发行时的一处关键概念/","text":"10年前的3月28日，Go Team发表了一篇 Go version 1 is released 的博客，宣告Go 1.0版本正式发行。此后Go团队大致以半年一个版本的进度，为Go语言及工具链赋予更多特性与功能。 出身名门巨匠，发轫之始便锋芒尽显。激荡10年间，尤是在云时代，有越来越多的基础设施与核心应用由Go开发或重构，也有越来越多的软件开发人员，充满热忱地成为Gopher。 最近不算太多的空余时间，交付给了 The Go Blog 上的文章。仔细阅读了各个版本新增的feature，如Go 1.1 P及竞态检测的引入，G0 1.3对垃圾回收和栈的优化，sync.Pool的引入，Go 1.7 context包的“转正”等。 同时也在想一个问题：新feature的不断引入，如何保证对旧有代码的兼容？Python开发者想必对此更有共鸣—升级到Python3的代价，是之前基于Python2开发的代码无法正常运行。 而Go在发布1.0版本时，就同时附带了一份兼容性说明文档 。该文档承诺，Go 的未来版本会尽可能确保向后兼容性(Backward Compatibility)，不会破坏现有程序。 It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. At some indefinite point, a Go 2 specification may arise, but until that time, Go programs that work today should continue to work even as future “point” releases of Go 1 arise (Go 1.1, Go 1.2, etc.). 所谓 向后兼容，即较高版本的程序能正常处理较低版本程序的数据(代码)。简而言之，在未来也许可能破坏兼容性的Go 2.0之前，基于Go 1.0写的程序，在10年后的Go 1.18版本上依然可以正常编译和运行。 (反之则不然，基于Go 1.16可正常编译&amp;运行的代码，用Go 1.11版本，则可能编译不通过；同样，用Java 17开发并打的jar包，用Java 8运行会报错) 因为“前”“后”的二义性，一般可能会认为向后兼容是向以后的版本兼容，向前兼容是向之前的版本兼容，这理解其实是错误的. 为此之前特意写了篇博客 向前兼容与向后兼容 向前兼容（Forward Compatibility）：指老版本的软／硬件可以使用或运行新版本的软／硬件产生的数据。也称 向上兼容（Upward Compatibility） 向后兼容（Backward Compatibility）：指新的版本的软／硬件可以使用或运行老版本的软／硬件产生的数据。是新版本对旧版本的兼容，向下兼容（Downward Compatibility） Go承诺的是向后兼容(Backward Compatibility)，所有的基准点和着眼点都是现在，是此刻。我需要回头需要转身向后面，去兼容之前的版本。即「新瓶可以装旧酒」。 但尴尬的是，在阅读10年前的Go 1.0版本发行说明时，却赫然看到了如下这样的描述，不啻晴天霹雳—-是我之前自以为是的标准有误吗？总不能是Go Team对这个概念理解有误吧… 但还是本着“有理有据，即便错了，虽败犹荣” 的心态，不要怂，就是干，在我29岁生日那晚，提交了一个mr： Reviewer选择了Ian Lance Taylor，这位毕业于耶鲁大学，常年活跃在Go社区的大佬不多时便给予了回复： 即 「Go 低版本」 向前兼容高版本的Go（向时间轴的右侧，未来）， 「Go 高版本」向后兼容低版本的Go（向时间轴的左侧，以前）。 不过，Go 1.11兼容未来的Go 1.17，指的究竟是Go本身，还是指用Go编写的应用程序(数据)？ 基于Go 1.11写的程序自然可以被后来的Go 1.17正常执行，我的理解，这应该说明Go具有向后兼容；而Go 1.11很可能无法执行Go 1.17写的程序(如用到了Go 1.16新增的特性)，则说明Go不具备向前兼容… 大佬已有断言，不再过分深究。还是在此记录下我的疑惑。","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"Http Requests Header","date":"2012-02-14T12:10:14.000Z","path":"2012/02/14/Http-Requests-Header/","text":"https://www.sojson.com/httpRequest/ http://coolaf.com/zh https://tonydeng.github.io/2015/07/10/httpie-howto/","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"MySQL blob类型","date":"2012-02-14T11:56:35.000Z","path":"2012/02/14/MySQL-blob类型/","text":"https://www.cnblogs.com/wt645631686/p/10102509.html select id, CAST(config AS CHAR(10000) CHARACTER SET utf8) from 表名 where id=111 https://www.google.com.hk/search?q=MySQL+blob&amp;oq=MySQL+blob&amp;aqs=chrome..69i57j0i512l3j69i65j69i60l3.1133j0j4&amp;sourceid=chrome&amp;ie=UTF-8","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"亲测RSA算法","date":"2012-02-13T14:12:36.000Z","path":"2012/02/13/亲测RSA算法/","text":"更多细节的理解RSA算法 RSA算法原理（简单易懂）","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"素数检验","date":"2012-02-13T14:10:56.000Z","path":"2012/02/13/素数检验/","text":"原来早有耳闻的「米勒-拉宾检验」，可以认为是费马小定理的优化版，被广泛用于计算机判断某数是否为质数。…（虽然路径并不相同。AKS更像是对费马素性检验思路上的优化） 人类对质数的检验方法的升级，大概经历4个阶段，跨越两千年。 埃拉托色尼：地理学之父，首位测量地球周长的人，和秦始皇差不多一个年代。他提出的（暴力尝试）方法，不仅可以判断某个数n是否为质数，还可以得到所有小于n的质数。但缺陷在于时间复杂度太高，对于大数如2的256次方，耗时比宇宙年龄还要长，对大数实际没法应用。 2.费马素性检验：直接基于费马小定理，时间复杂度相比之下低得多，对一个大数n，可以优化到（以2为底n的对数）的三次方。这是一个概率算法，即因为有费马证人数和骗子数的存在，得到的结果无法保证100%准确。更大的缺陷在于有卡迈克尔数（如合数561），按费马素性检验会得出这是个质数的错误结论。 3.米勒-拉宾检验，无 卡迈克尔数，并且时间复杂度最优可以到（以2为底n的对数）的平方——这也是目前计算机应用最广的质数检验方法。 AKS检验算法：方法2，3均为概率算法，无法确凿判断某数一定是质数。2002年三个印度人搞出了AKS算法，是精确的而不是概率算法；另外是一般的，不依赖其他（猜想），如最早米勒-拉宾检验，依赖（还未被证明的）广义黎曼猜想。…但这个算法的毛病在于时间复杂度比较高，需要 （以2为底n的对数）的12次方，经过改进也还是要到（以2为底n的对数）的6次方。所以实际用的也不多。 米勒拉宾素数检验–Google 米勒-拉宾素性检验","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数学","slug":"数学","permalink":"http://www.dashen.tech/tags/数学/"}]},{"title":"比json效率更高的gob编解码","date":"2012-02-11T02:11:52.000Z","path":"2012/02/11/比json效率更高的gob编解码/","text":"https://www.cnblogs.com/yjf512/archive/2012/08/24/2653697.html 类似python的pickle","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"使用Aria2优化下载","date":"2012-01-27T15:04:26.000Z","path":"2012/01/27/使用Aria2优化下载/","text":"brew install aria2 https://aria2.github.io/ https://www.kancloud.cn/codepan/mac-aria2/533478 https://www.jianshu.com/p/97efbb73a747 https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme https://www.google.com.hk/search?q=aria2+mac&amp;newwindow=1&amp;sxsrf=APq-WBs-8WUDGPD4KlUOJ__DZbyfI7Gy7Q%3A1643294181236&amp;ei=5a3yYYroDcqaseMPp_2dUA&amp;oq=aria2+&amp;gs_lcp=Cgdnd3Mtd2l6EAEYAjIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgARKBAhBGABKBAhGGABQAFgAYI8VaABwAHgAgAH7A4gB-wOSAQM1LTGYAQCgAQKgAQHAAQE&amp;sclient=gws-wiz","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Tools","slug":"Tools","permalink":"http://www.dashen.tech/tags/Tools/"}]},{"title":"golang中list的源码","date":"2011-12-31T16:00:05.000Z","path":"2012/01/01/golang中list的源码/","text":"源码位于: container/list.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package list implements a doubly linked list.//// To iterate over a list (where l is a *List):// for e := l.Front(); e != nil; e = e.Next() &#123;// // do something with e.Value// &#125;//package list// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// Next returns the next list element or nil.func (e *Element) Next() *Element &#123; if p := e.next; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// Prev returns the previous list element or nil.func (e *Element) Prev() *Element &#123; if p := e.prev; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125;// Len returns the number of elements of list l.// The complexity is O(1).func (l *List) Len() int &#123; return l.len &#125;// Front returns the first element of list l or nil if the list is empty.func (l *List) Front() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.next&#125;// Back returns the last element of list l or nil if the list is empty.func (l *List) Back() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.prev&#125;// lazyInit lazily initializes a zero List value.func (l *List) lazyInit() &#123; if l.root.next == nil &#123; l.Init() &#125;&#125;// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// remove removes e from its list, decrements l.len, and returns e.func (l *List) remove(e *Element) *Element &#123; e.prev.next = e.next e.next.prev = e.prev e.next = nil // avoid memory leaks e.prev = nil // avoid memory leaks e.list = nil l.len-- return e&#125;// move moves e to next to at and returns e.func (l *List) move(e, at *Element) *Element &#123; if e == at &#123; return e &#125; e.prev.next = e.next e.next.prev = e.prev n := at.next at.next = e e.prev = at e.next = n n.prev = e return e&#125;// Remove removes e from l if e is an element of list l.// It returns the element value e.Value.// The element must not be nil.func (l *List) Remove(e *Element) interface&#123;&#125; &#123; if e.list == l &#123; // if e.list == l, l must have been initialized when e was inserted // in l or l == nil (e is a zero Element) and l.remove will crash l.remove(e) &#125; return e.Value&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125;// MoveToFront moves element e to the front of list l.// If e is not an element of l, the list is not modified.// The element must not be nil.func (l *List) MoveToFront(e *Element) &#123; if e.list != l || l.root.next == e &#123; return &#125; // see comment in List.Remove about initialization of l l.move(e, &amp;l.root)&#125;// MoveToBack moves element e to the back of list l.// If e is not an element of l, the list is not modified.// The element must not be nil.func (l *List) MoveToBack(e *Element) &#123; if e.list != l || l.root.prev == e &#123; return &#125; // see comment in List.Remove about initialization of l l.move(e, l.root.prev)&#125;// MoveBefore moves element e to its new position before mark.// If e or mark is not an element of l, or e == mark, the list is not modified.// The element and mark must not be nil.func (l *List) MoveBefore(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.move(e, mark.prev)&#125;// MoveAfter moves element e to its new position after mark.// If e or mark is not an element of l, or e == mark, the list is not modified.// The element and mark must not be nil.func (l *List) MoveAfter(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.move(e, mark)&#125;// PushBackList inserts a copy of an other list at the back of list l.// The lists l and other may be the same. They must not be nil.func (l *List) PushBackList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() &#123; l.insertValue(e.Value, l.root.prev) &#125;&#125;// PushFrontList inserts a copy of an other list at the front of list l.// The lists l and other may be the same. They must not be nil.func (l *List) PushFrontList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() &#123; l.insertValue(e.Value, &amp;l.root) &#125;&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"golang中map的源码","date":"2011-12-31T16:00:00.000Z","path":"2012/01/01/golang中map的源码/","text":"底层使用桶结构 负载因子为6.5/8=0.8125, (Java的HashMap为0.75) 参考: 深度解密Go语言之 map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380// Copyright 2014 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.package runtime// This file contains the implementation of Go's map type.//// A map is just a hash table. The data is arranged// into an array of buckets. Each bucket contains up to// 8 key/value pairs. The low-order bits of the hash are// used to select a bucket. Each bucket contains a few// high-order bits of each hash to distinguish the entries// within a single bucket.//// If more than 8 keys hash to a bucket, we chain on// extra buckets.//// When the hashtable grows, we allocate a new array// of buckets twice as big. Buckets are incrementally// copied from the old bucket array to the new bucket array.//// Map iterators walk through the array of buckets and// return the keys in walk order (bucket #, then overflow// chain order, then bucket index). To maintain iteration// semantics, we never move keys within their bucket (if// we did, keys might be returned 0 or 2 times). When// growing the table, iterators remain iterating through the// old table and must check the new table if the bucket// they are iterating through has been moved (\"evacuated\")// to the new table.// Picking loadFactor: too large and we have lots of overflow// buckets, too small and we waste a lot of space. I wrote// a simple program to check some stats for different loads:// (64-bit, 8 byte keys and values)// loadFactor %overflow bytes/entry hitprobe missprobe// 4.00 2.13 20.77 3.00 4.00// 4.50 4.05 17.30 3.25 4.50// 5.00 6.85 14.77 3.50 5.00// 5.50 10.55 12.94 3.75 5.50// 6.00 15.27 11.67 4.00 6.00// 6.50 20.90 10.79 4.25 6.50// 7.00 27.14 10.15 4.50 7.00// 7.50 34.03 9.73 4.75 7.50// 8.00 41.10 9.40 5.00 8.00//// %overflow = percentage of buckets which have an overflow bucket// bytes/entry = overhead bytes used per key/value pair// hitprobe = # of entries to check when looking up a present key// missprobe = # of entries to check when looking up an absent key//// Keep in mind this data is for maximally loaded tables, i.e. just// before the table grows. Typical tables will be somewhat less loaded.import ( \"runtime/internal/atomic\" \"runtime/internal/math\" \"runtime/internal/sys\" \"unsafe\")const ( // Maximum number of key/value pairs a bucket can hold. bucketCntBits = 3 bucketCnt = 1 &lt;&lt; bucketCntBits // Maximum average load of a bucket that triggers growth is 6.5. // Represent as loadFactorNum/loadFactDen, to allow integer math. loadFactorNum = 13 loadFactorDen = 2 // Maximum key or value size to keep inline (instead of mallocing per element). // Must fit in a uint8. // Fast versions cannot handle big values - the cutoff size for // fast versions in cmd/compile/internal/gc/walk.go must be at most this value. maxKeySize = 128 maxValueSize = 128 // data offset should be the size of the bmap struct, but needs to be // aligned correctly. For amd64p32 this means 64-bit alignment // even though pointers are 32 bit. dataOffset = unsafe.Offsetof(struct &#123; b bmap v int64 &#125;&#123;&#125;.v) // Possible tophash values. We reserve a few possibilities for special marks. // Each bucket (including its overflow buckets, if any) will have either all or none of its // entries in the evacuated* states (except during the evacuate() method, which only happens // during map writes and thus no one else can observe the map during that time). emptyRest = 0 // this cell is empty, and there are no more non-empty cells at higher indexes or overflows. emptyOne = 1 // this cell is empty evacuatedX = 2 // key/value is valid. Entry has been evacuated to first half of larger table. evacuatedY = 3 // same as above, but evacuated to second half of larger table. evacuatedEmpty = 4 // cell is empty, bucket is evacuated. minTopHash = 5 // minimum tophash for a normal filled cell. // flags iterator = 1 // there may be an iterator using buckets oldIterator = 2 // there may be an iterator using oldbuckets hashWriting = 4 // a goroutine is writing to the map sameSizeGrow = 8 // the current map growth is to a new map of the same size // sentinel bucket ID for iterator checks noCheck = 1&lt;&lt;(8*sys.PtrSize) - 1)// isEmpty reports whether the given tophash array entry represents an empty bucket entry.func isEmpty(x uint8) bool &#123; return x &lt;= emptyOne&#125;// A header for a Go map.type hmap struct &#123; // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125;// mapextra holds fields that are not present on all maps.type mapextra struct &#123; // If both key and value do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and value do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap&#125;// A bucket for a Go map.type bmap struct &#123; // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] &lt; minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt values. // NOTE: packing all the keys together and then all the values together makes the // code a bit more complicated than alternating key/value/key/value/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer.&#125;// A hash iteration structure.// If you modify hiter, also change cmd/compile/internal/gc/reflect.go to indicate// the layout of this structure.type hiter struct &#123; key unsafe.Pointer // Must be in first position. Write nil to indicate iteration end (see cmd/internal/gc/range.go). value unsafe.Pointer // Must be in second position (see cmd/internal/gc/range.go). t *maptype h *hmap buckets unsafe.Pointer // bucket ptr at hash_iter initialization time bptr *bmap // current bucket overflow *[]*bmap // keeps overflow buckets of hmap.buckets alive oldoverflow *[]*bmap // keeps overflow buckets of hmap.oldbuckets alive startBucket uintptr // bucket iteration started at offset uint8 // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1) wrapped bool // already wrapped around from end of bucket array to beginning B uint8 i uint8 bucket uintptr checkBucket uintptr&#125;// bucketShift returns 1&lt;&lt;b, optimized for code generation.func bucketShift(b uint8) uintptr &#123; if sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != 0 &#123; b &amp;= sys.PtrSize*8 - 1 // help x86 archs remove shift overflow checks &#125; return uintptr(1) &lt;&lt; b&#125;// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.func bucketMask(b uint8) uintptr &#123; return bucketShift(b) - 1&#125;// tophash calculates the tophash value for hash.func tophash(hash uintptr) uint8 &#123; top := uint8(hash &gt;&gt; (sys.PtrSize*8 - 8)) if top &lt; minTopHash &#123; top += minTopHash &#125; return top&#125;func evacuated(b *bmap) bool &#123; h := b.tophash[0] return h &gt; emptyOne &amp;&amp; h &lt; minTopHash&#125;func (b *bmap) overflow(t *maptype) *bmap &#123; return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))&#125;func (b *bmap) setoverflow(t *maptype, ovf *bmap) &#123; *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf&#125;func (b *bmap) keys() unsafe.Pointer &#123; return add(unsafe.Pointer(b), dataOffset)&#125;// incrnoverflow increments h.noverflow.// noverflow counts the number of overflow buckets.// This is used to trigger same-size map growth.// See also tooManyOverflowBuckets.// To keep hmap small, noverflow is a uint16.// When there are few buckets, noverflow is an exact count.// When there are many buckets, noverflow is an approximate count.func (h *hmap) incrnoverflow() &#123; // We trigger same-size map growth if there are // as many overflow buckets as buckets. // We need to be able to count to 1&lt;&lt;h.B. if h.B &lt; 16 &#123; h.noverflow++ return &#125; // Increment with probability 1/(1&lt;&lt;(h.B-15)). // When we reach 1&lt;&lt;15 - 1, we will have approximately // as many overflow buckets as buckets. mask := uint32(1)&lt;&lt;(h.B-15) - 1 // Example: if h.B == 18, then mask == 7, // and fastrand &amp; 7 == 0 with probability 1/8. if fastrand()&amp;mask == 0 &#123; h.noverflow++ &#125;&#125;func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap &#123; var ovf *bmap if h.extra != nil &amp;&amp; h.extra.nextOverflow != nil &#123; // We have preallocated overflow buckets available. // See makeBucketArray for more details. ovf = h.extra.nextOverflow if ovf.overflow(t) == nil &#123; // We're not at the end of the preallocated overflow buckets. Bump the pointer. h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize))) &#125; else &#123; // This is the last preallocated overflow bucket. // Reset the overflow pointer on this bucket, // which was set to a non-nil sentinel value. ovf.setoverflow(t, nil) h.extra.nextOverflow = nil &#125; &#125; else &#123; ovf = (*bmap)(newobject(t.bucket)) &#125; h.incrnoverflow() if t.bucket.kind&amp;kindNoPointers != 0 &#123; h.createOverflow() *h.extra.overflow = append(*h.extra.overflow, ovf) &#125; b.setoverflow(t, ovf) return ovf&#125;func (h *hmap) createOverflow() &#123; if h.extra == nil &#123; h.extra = new(mapextra) &#125; if h.extra.overflow == nil &#123; h.extra.overflow = new([]*bmap) &#125;&#125;func makemap64(t *maptype, hint int64, h *hmap) *hmap &#123; if int64(int(hint)) != hint &#123; hint = 0 &#125; return makemap(t, int(hint), h)&#125;// makehmap_small implements Go map creation for make(map[k]v) and// make(map[k]v, hint) when hint is known to be at most bucketCnt// at compile time and the map needs to be allocated on the heap.func makemap_small() *hmap &#123; h := new(hmap) h.hash0 = fastrand() return h&#125;// makemap implements Go map creation for make(map[k]v, hint).// If the compiler has determined that the map or the first bucket// can be created on the stack, h and/or bucket may be non-nil.// If h != nil, the map can be created directly in h.// If h.buckets != nil, bucket pointed to can be used as the first bucket.func makemap(t *maptype, hint int, h *hmap) *hmap &#123; mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem &gt; maxAlloc &#123; hint = 0 &#125; // initialize Hmap if h == nil &#123; h = new(hmap) &#125; h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt. B := uint8(0) for overLoadFactor(hint, B) &#123; B++ &#125; h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. if h.B != 0 &#123; var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil &#123; h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow &#125; &#125; return h&#125;// makeBucketArray initializes a backing array for map buckets.// 1&lt;&lt;b is the minimum number of buckets to allocate.// dirtyalloc should either be nil or a bucket array previously// allocated by makeBucketArray with the same t and b parameters.// If dirtyalloc is nil a new backing array will be alloced and// otherwise dirtyalloc will be cleared and reused as backing array.func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) &#123; base := bucketShift(b) nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. if b &gt;= 4 &#123; // Add on the estimated number of overflow buckets // required to insert the median number of elements // used with this value of b. nbuckets += bucketShift(b - 4) sz := t.bucket.size * nbuckets up := roundupsize(sz) if up != sz &#123; nbuckets = up / t.bucket.size &#125; &#125; if dirtyalloc == nil &#123; buckets = newarray(t.bucket, int(nbuckets)) &#125; else &#123; // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.kind&amp;kindNoPointers == 0 &#123; memclrHasPointers(buckets, size) &#125; else &#123; memclrNoHeapPointers(buckets, size) &#125; &#125; if base != nbuckets &#123; // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket's overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) last.setoverflow(t, (*bmap)(buckets)) &#125; return buckets, nextOverflow&#125;// mapaccess1 returns a pointer to h[key]. Never returns nil, instead// it will return a reference to the zero object for the value type if// the key is not in the map.// NOTE: The returned pointer may keep the whole map live, so don't// hold onto it for very long.func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123; if raceenabled &amp;&amp; h != nil &#123; callerpc := getcallerpc() pc := funcPC(mapaccess1) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) &#125; if msanenabled &amp;&amp; h != nil &#123; msanread(key, t.key.size) &#125; if h == nil || h.count == 0 &#123; if t.hashMightPanic() &#123; t.key.alg.hash(key, 0) // see issue 23734 &#125; return unsafe.Pointer(&amp;zeroVal[0]) &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map read and map write\") &#125; alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize))) if c := h.oldbuckets; c != nil &#123; if !h.sameSizeGrow() &#123; // There used to be half as many buckets; mask down one more power of two. m &gt;&gt;= 1 &#125; oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize))) if !evacuated(oldb) &#123; b = oldb &#125; &#125; top := tophash(hash)bucketloop: for ; b != nil; b = b.overflow(t) &#123; for i := uintptr(0); i &lt; bucketCnt; i++ &#123; if b.tophash[i] != top &#123; if b.tophash[i] == emptyRest &#123; break bucketloop &#125; continue &#125; k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() &#123; k = *((*unsafe.Pointer)(k)) &#125; if alg.equal(key, k) &#123; v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) if t.indirectvalue() &#123; v = *((*unsafe.Pointer)(v)) &#125; return v &#125; &#125; &#125; return unsafe.Pointer(&amp;zeroVal[0])&#125;func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) &#123; if raceenabled &amp;&amp; h != nil &#123; callerpc := getcallerpc() pc := funcPC(mapaccess2) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) &#125; if msanenabled &amp;&amp; h != nil &#123; msanread(key, t.key.size) &#125; if h == nil || h.count == 0 &#123; if t.hashMightPanic() &#123; t.key.alg.hash(key, 0) // see issue 23734 &#125; return unsafe.Pointer(&amp;zeroVal[0]), false &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map read and map write\") &#125; alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&amp;m)*uintptr(t.bucketsize))) if c := h.oldbuckets; c != nil &#123; if !h.sameSizeGrow() &#123; // There used to be half as many buckets; mask down one more power of two. m &gt;&gt;= 1 &#125; oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&amp;m)*uintptr(t.bucketsize))) if !evacuated(oldb) &#123; b = oldb &#125; &#125; top := tophash(hash)bucketloop: for ; b != nil; b = b.overflow(t) &#123; for i := uintptr(0); i &lt; bucketCnt; i++ &#123; if b.tophash[i] != top &#123; if b.tophash[i] == emptyRest &#123; break bucketloop &#125; continue &#125; k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() &#123; k = *((*unsafe.Pointer)(k)) &#125; if alg.equal(key, k) &#123; v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) if t.indirectvalue() &#123; v = *((*unsafe.Pointer)(v)) &#125; return v, true &#125; &#125; &#125; return unsafe.Pointer(&amp;zeroVal[0]), false&#125;// returns both key and value. Used by map iteratorfunc mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) &#123; if h == nil || h.count == 0 &#123; return nil, nil &#125; alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) m := bucketMask(h.B) b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&amp;m)*uintptr(t.bucketsize))) if c := h.oldbuckets; c != nil &#123; if !h.sameSizeGrow() &#123; // There used to be half as many buckets; mask down one more power of two. m &gt;&gt;= 1 &#125; oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&amp;m)*uintptr(t.bucketsize))) if !evacuated(oldb) &#123; b = oldb &#125; &#125; top := tophash(hash)bucketloop: for ; b != nil; b = b.overflow(t) &#123; for i := uintptr(0); i &lt; bucketCnt; i++ &#123; if b.tophash[i] != top &#123; if b.tophash[i] == emptyRest &#123; break bucketloop &#125; continue &#125; k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() &#123; k = *((*unsafe.Pointer)(k)) &#125; if alg.equal(key, k) &#123; v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) if t.indirectvalue() &#123; v = *((*unsafe.Pointer)(v)) &#125; return k, v &#125; &#125; &#125; return nil, nil&#125;func mapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer &#123; v := mapaccess1(t, h, key) if v == unsafe.Pointer(&amp;zeroVal[0]) &#123; return zero &#125; return v&#125;func mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool) &#123; v := mapaccess1(t, h, key) if v == unsafe.Pointer(&amp;zeroVal[0]) &#123; return zero, false &#125; return v, true&#125;// Like mapaccess, but allocates a slot for the key if it is not present in the map.func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123; if h == nil &#123; panic(plainError(\"assignment to entry in nil map\")) &#125; if raceenabled &#123; callerpc := getcallerpc() pc := funcPC(mapassign) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) &#125; if msanenabled &#123; msanread(key, t.key.size) &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map writes\") &#125; alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) // Set hashWriting after calling alg.hash, since alg.hash may panic, // in which case we have not actually done a write. h.flags ^= hashWriting if h.buckets == nil &#123; h.buckets = newobject(t.bucket) // newarray(t.bucket, 1) &#125;again: bucket := hash &amp; bucketMask(h.B) if h.growing() &#123; growWork(t, h, bucket) &#125; b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize))) top := tophash(hash) var inserti *uint8 var insertk unsafe.Pointer var val unsafe.Pointerbucketloop: for &#123; for i := uintptr(0); i &lt; bucketCnt; i++ &#123; if b.tophash[i] != top &#123; if isEmpty(b.tophash[i]) &amp;&amp; inserti == nil &#123; inserti = &amp;b.tophash[i] insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) &#125; if b.tophash[i] == emptyRest &#123; break bucketloop &#125; continue &#125; k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) if t.indirectkey() &#123; k = *((*unsafe.Pointer)(k)) &#125; if !alg.equal(key, k) &#123; continue &#125; // already have a mapping for key. Update it. if t.needkeyupdate() &#123; typedmemmove(t.key, k, key) &#125; val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) goto done &#125; ovf := b.overflow(t) if ovf == nil &#123; break &#125; b = ovf &#125; // Did not find mapping for key. Allocate new cell &amp; add entry. // If we hit the max load factor or we have too many overflow buckets, // and we're not already in the middle of growing, start growing. if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123; hashGrow(t, h) goto again // Growing the table invalidates everything, so try again &#125; if inserti == nil &#123; // all current buckets are full, allocate a new one. newb := h.newoverflow(t, b) inserti = &amp;newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) val = add(insertk, bucketCnt*uintptr(t.keysize)) &#125; // store new key/value at insert position if t.indirectkey() &#123; kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem &#125; if t.indirectvalue() &#123; vmem := newobject(t.elem) *(*unsafe.Pointer)(val) = vmem &#125; typedmemmove(t.key, insertk, key) *inserti = top h.count++done: if h.flags&amp;hashWriting == 0 &#123; throw(\"concurrent map writes\") &#125; h.flags &amp;^= hashWriting if t.indirectvalue() &#123; val = *((*unsafe.Pointer)(val)) &#125; return val&#125;func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) &#123; if raceenabled &amp;&amp; h != nil &#123; callerpc := getcallerpc() pc := funcPC(mapdelete) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) &#125; if msanenabled &amp;&amp; h != nil &#123; msanread(key, t.key.size) &#125; if h == nil || h.count == 0 &#123; if t.hashMightPanic() &#123; t.key.alg.hash(key, 0) // see issue 23734 &#125; return &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map writes\") &#125; alg := t.key.alg hash := alg.hash(key, uintptr(h.hash0)) // Set hashWriting after calling alg.hash, since alg.hash may panic, // in which case we have not actually done a write (delete). h.flags ^= hashWriting bucket := hash &amp; bucketMask(h.B) if h.growing() &#123; growWork(t, h, bucket) &#125; b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) bOrig := b top := tophash(hash)search: for ; b != nil; b = b.overflow(t) &#123; for i := uintptr(0); i &lt; bucketCnt; i++ &#123; if b.tophash[i] != top &#123; if b.tophash[i] == emptyRest &#123; break search &#125; continue &#125; k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize)) k2 := k if t.indirectkey() &#123; k2 = *((*unsafe.Pointer)(k2)) &#125; if !alg.equal(key, k2) &#123; continue &#125; // Only clear key if there are pointers in it. if t.indirectkey() &#123; *(*unsafe.Pointer)(k) = nil &#125; else if t.key.kind&amp;kindNoPointers == 0 &#123; memclrHasPointers(k, t.key.size) &#125; v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) if t.indirectvalue() &#123; *(*unsafe.Pointer)(v) = nil &#125; else if t.elem.kind&amp;kindNoPointers == 0 &#123; memclrHasPointers(v, t.elem.size) &#125; else &#123; memclrNoHeapPointers(v, t.elem.size) &#125; b.tophash[i] = emptyOne // If the bucket now ends in a bunch of emptyOne states, // change those to emptyRest states. // It would be nice to make this a separate function, but // for loops are not currently inlineable. if i == bucketCnt-1 &#123; if b.overflow(t) != nil &amp;&amp; b.overflow(t).tophash[0] != emptyRest &#123; goto notLast &#125; &#125; else &#123; if b.tophash[i+1] != emptyRest &#123; goto notLast &#125; &#125; for &#123; b.tophash[i] = emptyRest if i == 0 &#123; if b == bOrig &#123; break // beginning of initial bucket, we're done. &#125; // Find previous bucket, continue at its last entry. c := b for b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123; &#125; i = bucketCnt - 1 &#125; else &#123; i-- &#125; if b.tophash[i] != emptyOne &#123; break &#125; &#125; notLast: h.count-- break search &#125; &#125; if h.flags&amp;hashWriting == 0 &#123; throw(\"concurrent map writes\") &#125; h.flags &amp;^= hashWriting&#125;// mapiterinit initializes the hiter struct used for ranging over maps.// The hiter struct pointed to by 'it' is allocated on the stack// by the compilers order pass or on the heap by reflect_mapiterinit.// Both need to have zeroed hiter since the struct contains pointers.func mapiterinit(t *maptype, h *hmap, it *hiter) &#123; if raceenabled &amp;&amp; h != nil &#123; callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit)) &#125; if h == nil || h.count == 0 &#123; return &#125; if unsafe.Sizeof(hiter&#123;&#125;)/sys.PtrSize != 12 &#123; throw(\"hash_iter size incorrect\") // see cmd/compile/internal/gc/reflect.go &#125; it.t = t it.h = h // grab snapshot of bucket state it.B = h.B it.buckets = h.buckets if t.bucket.kind&amp;kindNoPointers != 0 &#123; // Allocate the current slice and remember pointers to both current and old. // This preserves all relevant overflow buckets alive even if // the table grows and/or overflow buckets are added to the table // while we are iterating. h.createOverflow() it.overflow = h.extra.overflow it.oldoverflow = h.extra.oldoverflow &#125; // decide where to start r := uintptr(fastrand()) if h.B &gt; 31-bucketCntBits &#123; r += uintptr(fastrand()) &lt;&lt; 31 &#125; it.startBucket = r &amp; bucketMask(h.B) it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1)) // iterator state it.bucket = it.startBucket // Remember we have an iterator. // Can run concurrently with another mapiterinit(). if old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123; atomic.Or8(&amp;h.flags, iterator|oldIterator) &#125; mapiternext(it)&#125;func mapiternext(it *hiter) &#123; h := it.h if raceenabled &#123; callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext)) &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map iteration and map write\") &#125; t := it.t bucket := it.bucket b := it.bptr i := it.i checkBucket := it.checkBucket alg := t.key.algnext: if b == nil &#123; if bucket == it.startBucket &amp;&amp; it.wrapped &#123; // end of iteration it.key = nil it.value = nil return &#125; if h.growing() &amp;&amp; it.B == h.B &#123; // Iterator was started in the middle of a grow, and the grow isn't done yet. // If the bucket we're looking at hasn't been filled in yet (i.e. the old // bucket hasn't been evacuated) then we need to iterate through the old // bucket and only return the ones that will be migrated to this bucket. oldbucket := bucket &amp; it.h.oldbucketmask() b = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) if !evacuated(b) &#123; checkBucket = bucket &#125; else &#123; b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) checkBucket = noCheck &#125; &#125; else &#123; b = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize))) checkBucket = noCheck &#125; bucket++ if bucket == bucketShift(it.B) &#123; bucket = 0 it.wrapped = true &#125; i = 0 &#125; for ; i &lt; bucketCnt; i++ &#123; offi := (i + it.offset) &amp; (bucketCnt - 1) if isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123; // TODO: emptyRest is hard to use here, as we start iterating // in the middle of a bucket. It's feasible, just tricky. continue &#125; k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize)) if t.indirectkey() &#123; k = *((*unsafe.Pointer)(k)) &#125; v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize)) if checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123; // Special case: iterator was started during a grow to a larger size // and the grow is not done yet. We're working on a bucket whose // oldbucket has not been evacuated yet. Or at least, it wasn't // evacuated when we started the bucket. So we're iterating // through the oldbucket, skipping any keys that will go // to the other new bucket (each oldbucket expands to two // buckets during a grow). if t.reflexivekey() || alg.equal(k, k) &#123; // If the item in the oldbucket is not destined for // the current new bucket in the iteration, skip it. hash := alg.hash(k, uintptr(h.hash0)) if hash&amp;bucketMask(it.B) != checkBucket &#123; continue &#125; &#125; else &#123; // Hash isn't repeatable if k != k (NaNs). We need a // repeatable and randomish choice of which direction // to send NaNs during evacuation. We'll use the low // bit of tophash to decide which way NaNs go. // NOTE: this case is why we need two evacuate tophash // values, evacuatedX and evacuatedY, that differ in // their low bit. if checkBucket&gt;&gt;(it.B-1) != uintptr(b.tophash[offi]&amp;1) &#123; continue &#125; &#125; &#125; if (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || alg.equal(k, k)) &#123; // This is the golden data, we can return it. // OR // key!=key, so the entry can't be deleted or updated, so we can just return it. // That's lucky for us because when key!=key we can't look it up successfully. it.key = k if t.indirectvalue() &#123; v = *((*unsafe.Pointer)(v)) &#125; it.value = v &#125; else &#123; // The hash table has grown since the iterator was started. // The golden data for this key is now somewhere else. // Check the current hash table for the data. // This code handles the case where the key // has been deleted, updated, or deleted and reinserted. // NOTE: we need to regrab the key as it has potentially been // updated to an equal() but not identical key (e.g. +0.0 vs -0.0). rk, rv := mapaccessK(t, h, k) if rk == nil &#123; continue // key has been deleted &#125; it.key = rk it.value = rv &#125; it.bucket = bucket if it.bptr != b &#123; // avoid unnecessary write barrier; see issue 14921 it.bptr = b &#125; it.i = i + 1 it.checkBucket = checkBucket return &#125; b = b.overflow(t) i = 0 goto next&#125;// mapclear deletes all keys from a map.func mapclear(t *maptype, h *hmap) &#123; if raceenabled &amp;&amp; h != nil &#123; callerpc := getcallerpc() pc := funcPC(mapclear) racewritepc(unsafe.Pointer(h), callerpc, pc) &#125; if h == nil || h.count == 0 &#123; return &#125; if h.flags&amp;hashWriting != 0 &#123; throw(\"concurrent map writes\") &#125; h.flags ^= hashWriting h.flags &amp;^= sameSizeGrow h.oldbuckets = nil h.nevacuate = 0 h.noverflow = 0 h.count = 0 // Keep the mapextra allocation but clear any extra information. if h.extra != nil &#123; *h.extra = mapextra&#123;&#125; &#125; // makeBucketArray clears the memory pointed to by h.buckets // and recovers any overflow buckets by generating them // as if h.buckets was newly alloced. _, nextOverflow := makeBucketArray(t, h.B, h.buckets) if nextOverflow != nil &#123; // If overflow buckets are created then h.extra // will have been allocated during initial bucket creation. h.extra.nextOverflow = nextOverflow &#125; if h.flags&amp;hashWriting == 0 &#123; throw(\"concurrent map writes\") &#125; h.flags &amp;^= hashWriting&#125;func hashGrow(t *maptype, h *hmap) &#123; // If we've hit the load factor, get bigger. // Otherwise, there are too many overflow buckets, // so keep the same number of buckets and \"grow\" laterally. bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) &#123; bigger = 0 h.flags |= sameSizeGrow &#125; oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags &amp;^ (iterator | oldIterator) if h.flags&amp;iterator != 0 &#123; flags |= oldIterator &#125; // commit the grow (atomic wrt gc) h.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 if h.extra != nil &amp;&amp; h.extra.overflow != nil &#123; // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil &#123; throw(\"oldoverflow is not nil\") &#125; h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil &#125; if nextOverflow != nil &#123; if h.extra == nil &#123; h.extra = new(mapextra) &#125; h.extra.nextOverflow = nextOverflow &#125; // the actual copying of the hash table data is done incrementally // by growWork() and evacuate().&#125;// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125;// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we'd have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // \"too many\" means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn't see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125;// growing reports whether h is growing. The growth may be to the same size or bigger.func (h *hmap) growing() bool &#123; return h.oldbuckets != nil&#125;// sameSizeGrow reports whether the current growth is to a map of the same size.func (h *hmap) sameSizeGrow() bool &#123; return h.flags&amp;sameSizeGrow != 0&#125;// noldbuckets calculates the number of buckets prior to the current map growth.func (h *hmap) noldbuckets() uintptr &#123; oldB := h.B if !h.sameSizeGrow() &#123; oldB-- &#125; return bucketShift(oldB)&#125;// oldbucketmask provides a mask that can be applied to calculate n % noldbuckets().func (h *hmap) oldbucketmask() uintptr &#123; return h.noldbuckets() - 1&#125;func growWork(t *maptype, h *hmap, bucket uintptr) &#123; // make sure we evacuate the oldbucket corresponding // to the bucket we're about to use evacuate(t, h, bucket&amp;h.oldbucketmask()) // evacuate one more oldbucket to make progress on growing if h.growing() &#123; evacuate(t, h, h.nevacuate) &#125;&#125;func bucketEvacuated(t *maptype, h *hmap, bucket uintptr) bool &#123; b := (*bmap)(add(h.oldbuckets, bucket*uintptr(t.bucketsize))) return evacuated(b)&#125;// evacDst is an evacuation destination.type evacDst struct &#123; b *bmap // current destination bucket i int // key/val index into b k unsafe.Pointer // pointer to current key storage v unsafe.Pointer // pointer to current value storage&#125;func evacuate(t *maptype, h *hmap, oldbucket uintptr) &#123; b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) newbit := h.noldbuckets() if !evacuated(b) &#123; // TODO: reuse overflow buckets instead of using new ones, if there // is no iterator using the old buckets. (If !oldIterator.) // xy contains the x and y (low and high) evacuation destinations. var xy [2]evacDst x := &amp;xy[0] x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize))) x.k = add(unsafe.Pointer(x.b), dataOffset) x.v = add(x.k, bucketCnt*uintptr(t.keysize)) if !h.sameSizeGrow() &#123; // Only calculate y pointers if we're growing bigger. // Otherwise GC can see bad pointers. y := &amp;xy[1] y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize))) y.k = add(unsafe.Pointer(y.b), dataOffset) y.v = add(y.k, bucketCnt*uintptr(t.keysize)) &#125; for ; b != nil; b = b.overflow(t) &#123; k := add(unsafe.Pointer(b), dataOffset) v := add(k, bucketCnt*uintptr(t.keysize)) for i := 0; i &lt; bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) &#123; top := b.tophash[i] if isEmpty(top) &#123; b.tophash[i] = evacuatedEmpty continue &#125; if top &lt; minTopHash &#123; throw(\"bad map state\") &#125; k2 := k if t.indirectkey() &#123; k2 = *((*unsafe.Pointer)(k2)) &#125; var useY uint8 if !h.sameSizeGrow() &#123; // Compute hash to make our evacuation decision (whether we need // to send this key/value to bucket x or bucket y). hash := t.key.alg.hash(k2, uintptr(h.hash0)) if h.flags&amp;iterator != 0 &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.alg.equal(k2, k2) &#123; // If key != key (NaNs), then the hash could be (and probably // will be) entirely different from the old hash. Moreover, // it isn't reproducible. Reproducibility is required in the // presence of iterators, as our evacuation decision must // match whatever decision the iterator made. // Fortunately, we have the freedom to send these keys either // way. Also, tophash is meaningless for these kinds of keys. // We let the low bit of tophash drive the evacuation decision. // We recompute a new random tophash for the next level so // these keys will get evenly distributed across all buckets // after multiple grows. useY = top &amp; 1 top = tophash(hash) &#125; else &#123; if hash&amp;newbit != 0 &#123; useY = 1 &#125; &#125; &#125; if evacuatedX+1 != evacuatedY || evacuatedX^1 != evacuatedY &#123; throw(\"bad evacuatedN\") &#125; b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY dst := &amp;xy[useY] // evacuation destination if dst.i == bucketCnt &#123; dst.b = h.newoverflow(t, dst.b) dst.i = 0 dst.k = add(unsafe.Pointer(dst.b), dataOffset) dst.v = add(dst.k, bucketCnt*uintptr(t.keysize)) &#125; dst.b.tophash[dst.i&amp;(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check if t.indirectkey() &#123; *(*unsafe.Pointer)(dst.k) = k2 // copy pointer &#125; else &#123; typedmemmove(t.key, dst.k, k) // copy value &#125; if t.indirectvalue() &#123; *(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v) &#125; else &#123; typedmemmove(t.elem, dst.v, v) &#125; dst.i++ // These updates might push these pointers past the end of the // key or value arrays. That's ok, as we have the overflow pointer // at the end of the bucket to protect against pointing past the // end of the bucket. dst.k = add(dst.k, uintptr(t.keysize)) dst.v = add(dst.v, uintptr(t.valuesize)) &#125; &#125; // Unlink the overflow buckets &amp; clear key/value to help GC. if h.flags&amp;oldIterator == 0 &amp;&amp; t.bucket.kind&amp;kindNoPointers == 0 &#123; b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)) // Preserve b.tophash because the evacuation // state is maintained there. ptr := add(b, dataOffset) n := uintptr(t.bucketsize) - dataOffset memclrHasPointers(ptr, n) &#125; &#125; if oldbucket == h.nevacuate &#123; advanceEvacuationMark(h, t, newbit) &#125;&#125;func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) &#123; h.nevacuate++ // Experiments suggest that 1024 is overkill by at least an order of magnitude. // Put it in there as a safeguard anyway, to ensure O(1) behavior. stop := h.nevacuate + 1024 if stop &gt; newbit &#123; stop = newbit &#125; for h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123; h.nevacuate++ &#125; if h.nevacuate == newbit &#123; // newbit == # of oldbuckets // Growing is all done. Free old main bucket array. h.oldbuckets = nil // Can discard old overflow buckets as well. // If they are still referenced by an iterator, // then the iterator holds a pointers to the slice. if h.extra != nil &#123; h.extra.oldoverflow = nil &#125; h.flags &amp;^= sameSizeGrow &#125;&#125;func ismapkey(t *_type) bool &#123; return t.alg.hash != nil&#125;// Reflect stubs. Called from ../reflect/asm_*.s//go:linkname reflect_makemap reflect.makemapfunc reflect_makemap(t *maptype, cap int) *hmap &#123; // Check invariants and reflects math. if !ismapkey(t.key) &#123; throw(\"runtime.reflect_makemap: unsupported map key type\") &#125; if t.key.size &gt; maxKeySize &amp;&amp; (!t.indirectkey() || t.keysize != uint8(sys.PtrSize)) || t.key.size &lt;= maxKeySize &amp;&amp; (t.indirectkey() || t.keysize != uint8(t.key.size)) &#123; throw(\"key size wrong\") &#125; if t.elem.size &gt; maxValueSize &amp;&amp; (!t.indirectvalue() || t.valuesize != uint8(sys.PtrSize)) || t.elem.size &lt;= maxValueSize &amp;&amp; (t.indirectvalue() || t.valuesize != uint8(t.elem.size)) &#123; throw(\"value size wrong\") &#125; if t.key.align &gt; bucketCnt &#123; throw(\"key align too big\") &#125; if t.elem.align &gt; bucketCnt &#123; throw(\"value align too big\") &#125; if t.key.size%uintptr(t.key.align) != 0 &#123; throw(\"key size not a multiple of key align\") &#125; if t.elem.size%uintptr(t.elem.align) != 0 &#123; throw(\"value size not a multiple of value align\") &#125; if bucketCnt &lt; 8 &#123; throw(\"bucketsize too small for proper alignment\") &#125; if dataOffset%uintptr(t.key.align) != 0 &#123; throw(\"need padding in bucket (key)\") &#125; if dataOffset%uintptr(t.elem.align) != 0 &#123; throw(\"need padding in bucket (value)\") &#125; return makemap(t, cap, nil)&#125;//go:linkname reflect_mapaccess reflect.mapaccessfunc reflect_mapaccess(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123; val, ok := mapaccess2(t, h, key) if !ok &#123; // reflect wants nil for a missing element val = nil &#125; return val&#125;//go:linkname reflect_mapassign reflect.mapassignfunc reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer) &#123; p := mapassign(t, h, key) typedmemmove(t.elem, p, val)&#125;//go:linkname reflect_mapdelete reflect.mapdeletefunc reflect_mapdelete(t *maptype, h *hmap, key unsafe.Pointer) &#123; mapdelete(t, h, key)&#125;//go:linkname reflect_mapiterinit reflect.mapiterinitfunc reflect_mapiterinit(t *maptype, h *hmap) *hiter &#123; it := new(hiter) mapiterinit(t, h, it) return it&#125;//go:linkname reflect_mapiternext reflect.mapiternextfunc reflect_mapiternext(it *hiter) &#123; mapiternext(it)&#125;//go:linkname reflect_mapiterkey reflect.mapiterkeyfunc reflect_mapiterkey(it *hiter) unsafe.Pointer &#123; return it.key&#125;//go:linkname reflect_mapitervalue reflect.mapitervaluefunc reflect_mapitervalue(it *hiter) unsafe.Pointer &#123; return it.value&#125;//go:linkname reflect_maplen reflect.maplenfunc reflect_maplen(h *hmap) int &#123; if h == nil &#123; return 0 &#125; if raceenabled &#123; callerpc := getcallerpc() racereadpc(unsafe.Pointer(h), callerpc, funcPC(reflect_maplen)) &#125; return h.count&#125;//go:linkname reflect_ismapkey reflect.ismapkeyfunc reflect_ismapkey(t *_type) bool &#123; return ismapkey(t)&#125;const maxZero = 1024 // must match value in cmd/compile/internal/gc/walk.govar zeroVal [maxZero]byte","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.dashen.tech/tags/数据结构/"}]},{"title":"git rm 命令","date":"2011-09-13T06:30:51.000Z","path":"2011/09/13/git-rm-命令/","text":"https://www.runoob.com/git/git-rm.html","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"}]},{"title":"MySQL where条件字符串区分大小写问题","date":"2011-09-11T12:58:21.000Z","path":"2011/09/11/MySQL-where条件字符串区分大小写问题/","text":"https://blog.csdn.net/lz6363/article/details/107441840","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"数据库","slug":"数据库","permalink":"http://www.dashen.tech/tags/数据库/"}]},{"title":"Go Slice 秘籍实战","date":"2011-04-04T11:25:27.000Z","path":"2011/04/04/Go-Slice-秘籍实战/","text":"参考: [译]Go Slice 秘籍 Cut 切掉一段数据 1a = append(a[:i], a[j:]...) 切掉[i,j)之间的元素 如: 123456789101112func cut() &#123; //切掉一段数据 a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; a = append(a[:1], a[4:]...) fmt.Println(a)&#125;//------------//[0 400 500 600 700 800 900 1000] Delete 删除某个元素 1a = append(a[:i], a[i+1:]...) 删掉第i个元素 12345678910func delete() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; a = append(a[:2], a[2+1:]...) fmt.Println(a)&#125;//-----------//[0 100 300 400 500 600 700 800 900 1000] Expand 插入一段到中间 1a = append(a[:i], append(make([]T, j), a[i:]...)...) a = append(a[:i], append(make([]T, j), a[i:]…)…) 其中,i为插入的位置,j为插入元素的个数; 即:在i位置后面,插入j个对应元素的空值 12345678910func expand() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; //i=4,j=8,i为插入的位置,j为插入的元素个数 a = append(a[:4], append(make([]int, 8), a[4:]...)...) fmt.Println(a)&#125;//------------//[0 100 200 300 0 0 0 0 0 0 0 0 400 500 600 700 800 900 1000] Extend 插入一段到尾部 1a = append(a, make([]T, j)...) 在原切片后面,插入j个对应元素的空值 123456789func extend() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; a = append(a, make([]int, 3)...) fmt.Println(a)&#125;//--------------//[0 100 200 300 400 500 600 700 800 900 1000 0 0 0] Insert 插入某个元素到指定的位置 1a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...) 在i位置处,插入(挤进)一个新元素x 12345678func insert()&#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; //i=3,x=10086 a = append(a[:3], append([]int&#123;10086&#125;, a[3:]...)...) fmt.Println(a)&#125;//-----------//[0 100 200 10086 300 400 500 600 700 800 900 1000] InsertVector 插入某个切片到指定的位置 1a = append(a[:i], append(b, a[i:]...)...) 在i位置处,插入(挤进)一个(同类型的)新切片b 1234567891011121314func insertvector() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; b := []int&#123;-280, -975, -764&#125; //i=6 a = append(a[:], append(b, a[6:]...)...) fmt.Println(a)&#125;//-----------//[0 100 200 300 400 500 600 700 800 900 1000 -280 -975 -764 600 700 800 900 1000] Pop 从切片中取出最后一个元素 1x, a := a[len(a)-1], a[:len(a)-1] 从切片a中”切除”最后一个元素,返回最后一个元素x,和切除最后一个元素后的切片a append()的反操作 123456789101112func pop() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; x, a := a[len(a)-1], a[:len(a)-1] fmt.Println(a) fmt.Println(x)&#125;//------------------//[0 100 200 300 400 500 600 700 800 900]//1000 Shift 从切片中”切除”第一个元素 1x, a := a[0], a[1:] 从切片a中切除第一个元素,返回第一个元素x,和切除第一个元素之后的切片a 123456789func shift() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; x, a := a[0], a[1:] fmt.Println(a) fmt.Println(x)&#125;//------------//[100 200 300 400 500 600 700 800 900 1000]//0 Unshift 从切片中”切除”第一个元素 1a = append([]T&#123;x&#125;, a...) 将元素x插入到切片的开头 也算是append()的反操作 123456789func unshift() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; //x为271828 a = append([]int&#123;271828&#125;, a...) fmt.Println(a)&#125;//------------------//[271828 0 100 200 300 400 500 600 700 800 900 1000] Reverse 反转切片中的元素 1234for i := len(a)/2-1; i &gt;= 0; i-- &#123; opp := len(a)-1-i a[i], a[opp] = a[opp], a[i]&#125; 或 123for left, right := 0, len(a)-1; left &lt; right; left, right = left+1, right-1 &#123; a[left], a[right] = a[right], a[left]&#125; 反转切片中的元素 12345678910func reverse() &#123; a := []int&#123;0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000&#125; for i := len(a)/2 - 1; i &gt;= 0; i-- &#123; opp := len(a) - 1 - i a[i], a[opp] = a[opp], a[i] &#125; fmt.Println(a)&#125;//---------------//[1000 900 800 700 600 500 400 300 200 100 0]","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"「编程珠玑」书摘","date":"2010-03-24T15:51:33.000Z","path":"2010/03/24/「编程珠玑」书摘/","text":"","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"书摘/影评","slug":"书摘-影评","permalink":"http://www.dashen.tech/tags/书摘-影评/"}]},{"title":"深探Linux","date":"2010-03-21T12:31:18.000Z","path":"2010/03/21/深探Linux/","text":"Linux系统调用(syscall)原理 syscall https://www.lagou.com/lgeduarticle/58851.html https://cloud.tencent.com/developer/section/1144463 epoll Linux IO模式及 select、poll、epoll详解 Linux的inode的理解","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Linux","slug":"Linux","permalink":"http://www.dashen.tech/tags/Linux/"}]},{"title":"口述Raft算法","date":"2010-03-18T14:07:33.000Z","path":"2010/03/18/口述Raft算法/","text":"raft论文","tags":[{"name":"算法","slug":"算法","permalink":"http://www.dashen.tech/tags/算法/"},{"name":"微服务","slug":"微服务","permalink":"http://www.dashen.tech/tags/微服务/"}]},{"title":"Go并发编程","date":"2010-03-02T16:02:55.000Z","path":"2010/03/03/Go并发编程/","text":"参考: Go并发编程小测验： 你能答对几道题？ Go并发设计模式之 Half-Sync/Half-Async Go并发设计模式之 Active Object Gopher 2019 Go并发编程的分享 [译]Go开发中一些有用的模式","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"向更底层迈进","date":"2010-03-02T15:58:22.000Z","path":"2010/03/02/向更底层迈进/","text":"参考: 得到Go程序的汇编代码的方法 cacheline 对 Go 程序的影响 [译]利用 gopackage 进行包的捕获、注入和分析 这个不是底层如何在Go的函数中得到调用者函数名?","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"sync包-Map","date":"2010-03-02T15:49:38.000Z","path":"2010/03/02/sync包-Map/","text":"sync.map 则是一种并发安全的 map，在 Go 1.9 引入 Go 1.9 sync.Map揭秘 https://tonybai.com/2020/11/10/understand-sync-map-inside-through-examples/ 标准库 sync.Map 支持并发读写 map，但写入性能较差,更适用于读多写少的场景 sync.map内部使用了读写分离的机制，即将耗时较长的写操作与耗时较短的读操作分离，放在俩个容器中进行，极大的提高了map的并发性能，且不用管理锁机制，使用起来更加便捷。(空间换时间的方式，使用 read 和 dirty 两个 map 来进行读写分离，降低锁时间来提高效率。) sync.Map的中有read和dirty俩个容器，其中写操作优先放在dirty中进行，读操作优先放在read中进行。 读写分离的优点在于： 执行读操作时是不用加锁的，写操作需要加锁在dirty存在时，写操作都放在dirty中执行，不影响read中的读操作，因此当读的元素在read中时，是可以并发读写的 在对sync.Map的增、删、改、查操作时，都是先对read做操作，再对dirty操作。因此read中做标记可以有效减少对dirty的无效操作，nil表示dirty未创建，无需对dirty操作，expunged表示dirty创建成功，写操作可以放入dirty中执行。 一口气搞懂 Go sync.map 所有知识点 亲儿子sync.Map，性能为何不如读写锁+Map？ 深度解密Go语言之sync.map 看过这篇剖析，你还不懂 Go sync.Map 吗？ @bcmills Do not you think it’s very ridiculous that Go has a built in func len for map while sync.Map does not have a corresponding function func (Map)Len() int to get its size? No, I don’t think it’s “very [ridiculous]”. Concurrent data structures are not the same as unsynchronized data structures. The built-in map type doesn’t have (and doesn’t need) a LoadOrStore, for example. We should decide the API of each type based on its own tradeoffs. Consistency is a benefit, but there are costs to weigh it against. 吐槽sync.Map为什么没有len方法的issue golang 并发安全Map以及分段锁的实现","tags":[{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之slice中的小tips","date":"2010-03-02T15:44:28.000Z","path":"2010/03/02/golang之slice中的小tips/","text":"参考: Golang 之 切片 使用make()构造切片 语法为: make ([]T, size, cap)T:切片的元素类型size:切片中元素的数量cap:切片的容量 1234567891011package mainimport \"fmt\"func main() &#123; a := make([]int, 2, 10) fmt.Printf(\"len(a):%d,cap(a):%d\\n\", len(a), cap(a))&#125;----------len(a):2,cap(a):10 如果不写容量，则默认长度就是容量。12345678910package main import \"fmt\" func main() &#123; a := make([]int, 2) fmt.Printf(\"len(a):%d,cap(a):%d\\n\", len(a), cap(a))&#125;----------len(a):2,cap(a):2 切片的比较 切片之间不能比较, 不能使用==操作符来判断两个切片是否含有全部相等元素. 切片唯一合法的比较操作是和nil比较.一个nil值的切片并没有底层数组,一个nil值的切片的长度和容量都是0. 基于数组定义切片 &amp; 基于切片再切片 情况下的各种陷阱 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport \"fmt\"func main() &#123; //定义一个包含10个int型元素的数组 a := [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; // 或定义为 //a := [...]int&#123;0,1,2,3,4,5,6,7,8,9&#125; //得到[0 1 2 3 4 5 6 7 8 9] fmt.Println(a) // 左闭右开, sli1 := a[3:6] // sli为[3,4,5] fmt.Println(sli1) //切片sli1的长度为3,容量为7---这是因为 容量是从数组中切片的首元素下标开始数, (默认)数到数组的尾下标 //sli为[3,4,5],其底层数组为[3 4 5 6 7 8 9] fmt.Println(len(sli1), cap(sli1)) //可以通过第三个参数 来控制切片的容量 //结果为3,4 fmt.Println(len(a[3:6:7]), cap(a[3:6:7])) //基于切片再切片, 并不是在原来的切片上面切片, 因为切片是引用类型, 所以再切片也是在底层数组上进行切分的. //再切片不能超过数组的长度,否则会panic:越界 //同时如果切片限制了容量, 那么再切片自然也不能超过这个容量,否则同样会报panic:越界.. //此时sli1的底层数组为[...]int&#123;3,4,5,6,7,8,9&#125; sli2 := sli1[4:7] //输出为[7,8,9] fmt.Println(sli2) // panic: runtime error: slice bounds out of range [:8] with capacity 7 //即容量为7,却切到了第8个元素,发生了越界 // fmt.Println(sli1[4:8]) // 修改切片中元素的值,会不会影响底层数组?及由该底层数组切分出的其他切片? // 切片是引用类型,所以是会影响的 sli3 := sli1[1:3] fmt.Println(\"sli3的值为:\", sli3) // [4 5] //sli为[3,4,5],其底层数组为[3 4 5 6 7 8 9] fmt.Println(sli1[2]) //输出为5 sli1[2] = 10086 fmt.Println(a) //为 [0 1 2 3 4 10086 6 7 8 9] fmt.Println(sli3) //为 [4 10086]&#125; 切片是引用类型，只要它们是从同一个底层”链接”出去的，那其修改操作就会影响底层。 再如: 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"var s []intfunc main() &#123; s = append(s, 1) s = append(s, 2) s = append(s, 3) s = append(s, 4) s = append(s, 5) s = append(s, 6) s = append(s, 7) s = append(s, 8) s = append(s, 9) //此时s为[1,2,3,4,5,6,7,8,9] x := getBuff() //x的值为[2],容量为8,底层数组为[2,3,4,5,6,7,8,9] fmt.Println(x) x[0] = 666 fmt.Println(x) //x为666 fmt.Println(s) //[1,666,3,4,5,6,7,8,9]&#125;func getBuff() []int &#123; b := s[1:2] fmt.Println(\"s的值为:\", s) return b&#125; 输出为: 1234s的值为: [1 2 3 4 5 6 7 8 9][2][666][1 666 3 4 5 6 7 8 9] 使用copy(深度)拷贝切片 123456789101112131415161718192021222324252627package mainimport \"fmt\"func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; b := a c := make([]int, 5, 5) //新(独立)切片的长度和容量,都不能小于要copy的切片,否则会报 index out of range copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Printf(\"a:%v,len(a):%d,cap(a):%d\\n\", a, len(a), cap(a)) fmt.Printf(\"c:%v,len(c):%d,cap(c):%d\\n\", c, len(c), cap(c)) c[0] = 1000 // copy操作之后的切片c和切片a之间没有任何关系 是两个独立的切片 fmt.Printf(\"a:%v,len(a):%d,cap(a):%d\\n\", a, len(a), cap(a)) fmt.Printf(\"c:%v,len(c):%d,cap(c):%d\\n\", c, len(c), cap(c)) a[0] = 666 fmt.Println(\"b的值为:\", b)&#125;//--------//a:[1 2 3 4 5],len(a):5,cap(a):5//c:[1 2 3 4 5],len(c):5,cap(c):5//a:[1 2 3 4 5],len(a):5,cap(a):5//c:[1000 2 3 4 5],len(c):5,cap(c):5//b的值为: [666 2 3 4 5] copy操作之后的切片c和切片a之间没有任何关系 是两个独立的切片 !!!append及切片的扩容策略 1.如果要的容量没有原来容量两倍大, 那就扩充到原来容量的两倍. 2.如果要的容量是原来容量的两倍还要多, 那新的容量就是所要求的容量大小. 3.如果原来的容量大于1024,那么每次提升25%,不再是两倍扩容. 4.还有更复杂的内存对齐问题,可参考 golang中slice扩容一定是double或1.25倍吗 双倍 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport \"fmt\"func main() &#123; var s []int s = append(s, 1) fmt.Println(\"此时的长度和容量为:111\", len(s), cap(s)) s = append(s, 2) fmt.Println(\"此时的长度和容量为:222\", len(s), cap(s)) s = append(s, 3) fmt.Println(\"此时的长度和容量为:333\", len(s), cap(s)) s = append(s, 4) fmt.Println(\"此时的长度和容量为:444\", len(s), cap(s)) s = append(s, 5) fmt.Println(\"此时的长度和容量为:555\", len(s), cap(s)) s = append(s, 6) fmt.Println(\"此时的长度和容量为:666\", len(s), cap(s)) s = append(s, 7) fmt.Println(\"此时的长度和容量为:777\", len(s), cap(s)) s = append(s, 8) fmt.Println(\"此时的长度和容量为:888\", len(s), cap(s)) s = append(s, 9) fmt.Println(\"此时的长度和容量为:999\", len(s), cap(s)) fmt.Println(\"此时s的值为:\", s) //此时s的值为: [1 2 3 4 5 6 7 8 9],长度为9,容量为16; 小于1024个元素时两倍扩容 x := getBuff1(s) fmt.Println(\"x的值为:\", x) //[2] x[0] = 666 fmt.Println(\"此时x的值为:\", x) //[666] fmt.Println(\"此时s的值为:\", s) //[1 666 3 4 5 6 7 8 9] fmt.Println(\"此时s的长度和容量为:\", len(s), cap(s))&#125;func getBuff1(s []int) []int &#123; fmt.Println(\"s的容量为:\", cap(s)) b := s[1:2] //b的值为2,底层数组为[2,3,4,5,6,7,8,9, 0,0,0,0,0,0,0] fmt.Println(\"s[:16]的值为:\", s[:16]) //s[:16]的值为: [1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0] fmt.Println(\"b的容量为:\", cap(b)) //15 //可用第三个参数指定容量,即如c:=s[1:2:4] c := s[1:2:4] fmt.Println(\"c的长度和容量为:\", len(c), cap(c)) //c的长度和容量为: 1 3 return b&#125; 输出为: 123456789101112131415161718此时的长度和容量为:111 1 1此时的长度和容量为:222 2 2此时的长度和容量为:333 3 4此时的长度和容量为:444 4 4此时的长度和容量为:555 5 8此时的长度和容量为:666 6 8此时的长度和容量为:777 7 8此时的长度和容量为:888 8 8此时的长度和容量为:999 9 16此时s的值为: [1 2 3 4 5 6 7 8 9]s的容量为: 16s[:16]的值为: [1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0]b的容量为: 15c的长度和容量为: 1 3x的值为: [2]此时x的值为: [666]此时s的值为: [1 666 3 4 5 6 7 8 9]此时s的长度和容量为: 9 16 再如: 12345678910111213141516171819202122package mainimport \"fmt\"func main()&#123; s := []int&#123;1,2,3,4,5,6&#125; fmt.Println(len(s))//6 fmt.Println(cap(s))//6 s = append(s,100) fmt.Println(len(s))//7 fmt.Println(cap(s))//12 s6 := s[2:5] //[3,4,5] fmt.Println(s6)//因为没有置顶第三个参数,所以切到底, 其底层数组为[3 4 5 6 100 0 0 0 0 0] fmt.Println(s6[:10]) //[3 4 5 6 100 0 0 0 0 0] fmt.Println(cap(s6))//10&#125; 输出为:123456766712[3 4 5][3 4 5 6 100 0 0 0 0 0]10 一次压入多个元素, 要的容量大于原容量的两倍,则新容量就是其需要的容量 1234567891011121314package mainimport \"fmt\"func main() &#123; s1 := []string&#123;\"北京\", \"上海\", \"深圳\"&#125; fmt.Printf(\"len(s1):%d,cap(s1):%d\\n\", len(s1), cap(s1)) s1 = append(s1, \"广州\", \"成都\", \"重庆\", \"石家庄\", \"保定\", \"邢台\", \"张家口\") fmt.Printf(\"len(s1):%d,cap(s1):%d\\n\", len(s1), cap(s1))&#125;----------len(s1):3,cap(s1):3len(s1):10,cap(s1):10 元素个数大于1024时,变为1.25倍扩容 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; sli := make([]int, 0) fmt.Println(\"最开始sli长度和容量为:\", len(sli), cap(sli)) //0,0 for i := 0; i &lt; 1024; i++ &#123; sli = append(sli, i) &#125; fmt.Println(\"循环之后sli长度和容量为:\", len(sli), cap(sli)) //1024,1024 sli = append(sli, 10086) fmt.Println(\"最终sli长度和容量为:\", len(sli), cap(sli)) //1025,1280&#125; !!!扩容时底层数组的变化 1234567891011package mainimport \"fmt\"func main() &#123; var numSlice []int for i := 0; i &lt; 10; i++ &#123; numSlice = append(numSlice, i) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", numSlice, len(numSlice), cap(numSlice), numSlice) &#125;&#125; 输出为: 1234567891011121314[0] len:1 cap:1 ptr:0xc000016068[0 1] len:2 cap:2 ptr:0xc0000160a0[0 1 2] len:3 cap:4 ptr:0xc000014160[0 1 2 3] len:4 cap:4 ptr:0xc000014160[0 1 2 3 4] len:5 cap:8 ptr:0xc0000181c0[0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000181c0[0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000181c0[0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000181c0[0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc000080000[0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc000080000 共享同一个底层数组时,切片2修改值,会影响切片1的值; 当两个切片不再共享一个底层数组时,修改就互不影响. 如下: 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"func main() &#123; var sli []int for i := 0; i &lt; 4; i++ &#123; sli = append(sli, i) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli, len(sli), cap(sli), sli) &#125; fmt.Println(\"---------\") sli2 := sli[:] fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli2, len(sli2), cap(sli2), sli2) sli2[0] = 10086 fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli2, len(sli2), cap(sli2), sli2) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli, len(sli), cap(sli), sli) sli = append(sli, 666) fmt.Println(\"==========\") fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli, len(sli), cap(sli), sli) sli2[2] = 271828 fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli2, len(sli2), cap(sli2), sli2) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli, len(sli), cap(sli), sli)&#125; 输出为: 123456789101112[0] len:1 cap:1 ptr:0xc00008c008[0 1] len:2 cap:2 ptr:0xc00008c040[0 1 2] len:3 cap:4 ptr:0xc000092020[0 1 2 3] len:4 cap:4 ptr:0xc000092020---------[0 1 2 3] len:4 cap:4 ptr:0xc000092020[10086 1 2 3] len:4 cap:4 ptr:0xc000092020[10086 1 2 3] len:4 cap:4 ptr:0xc000092020==========[10086 1 2 3 666] len:5 cap:8 ptr:0xc000084080[10086 1 271828 3] len:4 cap:4 ptr:0xc000092020[10086 1 2 3 666] len:5 cap:8 ptr:0xc000084080 再如:(原因待解) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455func main() &#123; var sli []int sli1 := append(sli, 1) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli1, len(sli1), cap(sli1), sli1) sli2 := append(sli, 1, 2) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli2, len(sli2), cap(sli2), sli2) sli3 := append(sli,1,2,3) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli3, len(sli3), cap(sli3), sli3) sli4 := append(sli,1,2,3,4) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli4, len(sli4), cap(sli4), sli4) sli5 := append(sli,1,2,3,4,5) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli5, len(sli5), cap(sli5), sli5) sli6 := append(sli,1,2,3,4,5,6) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli6, len(sli6), cap(sli6), sli6) sli7 := append(sli,1,2,3,4,5,6,7) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli7, len(sli7), cap(sli7), sli7) sli8 := append(sli,1,2,3,4,5,6,7,8) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli8, len(sli8), cap(sli8), sli8) sli9 := append(sli,1,2,3,4,5,6,7,8,9) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli9, len(sli9), cap(sli9), sli9) sli10 := append(sli,1,2,3,4,5,6,7,8,9,10) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli10, len(sli10), cap(sli10), sli10) sli11 := append(sli,1,2,3,4,5,6,7,8,9,10,11) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli11, len(sli11), cap(sli11), sli11) sli12 := append(sli,1,2,3,4,5,6,7,8,9,10,11,12) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli12, len(sli12), cap(sli12), sli12) sli13 := append(sli,1,2,3,4,5,6,7,8,9,10,11,12,13) fmt.Printf(\"%v len:%d cap:%d ptr:%p\\n\", sli13, len(sli13), cap(sli13), sli13)&#125; 输出为: 12345678910111213[1] len:1 cap:1 ptr:0xc00008c008[1 2] len:2 cap:2 ptr:0xc00008c040[1 2 3] len:3 cap:4 ptr:0xc00009a020[1 2 3 4] len:4 cap:4 ptr:0xc00009a040[1 2 3 4 5] len:5 cap:6 ptr:0xc00008e030[1 2 3 4 5 6] len:6 cap:6 ptr:0xc00008e060[1 2 3 4 5 6 7] len:7 cap:8 ptr:0xc000084080[1 2 3 4 5 6 7 8] len:8 cap:8 ptr:0xc0000840c0[1 2 3 4 5 6 7 8 9] len:9 cap:10 ptr:0xc00009c000[1 2 3 4 5 6 7 8 9 10] len:10 cap:10 ptr:0xc00009c050[1 2 3 4 5 6 7 8 9 10 11] len:11 cap:12 ptr:0xc000064060[1 2 3 4 5 6 7 8 9 10 11 12] len:12 cap:12 ptr:0xc0000640c0[1 2 3 4 5 6 7 8 9 10 11 12 13] len:13 cap:14 ptr:0xc00009e000 个中原因,//TODO 对 数组/切片 进行排序 可以使用自带的sort包进行排序,但入参必须是切片.所以如果是数组a1排序,要传入其对应的切片a1[:] 123456789101112131415161718192021package mainimport ( \"fmt\" \"sort\")func main() &#123; var a1 = [...]int&#123;3, 7, 8, 9, 1&#125; sort.Ints(a1[:]) fmt.Println(a1) a2 := [...]string&#123;\"v\", \"u\", \"a\", \"f\"&#125; sort.Strings(a2[:]) fmt.Println(a2)&#125;//-----//[1 3 7 8 9]//[a f u v] 更多关于slice的”黑魔法”, 参考: [译]Go Slice 秘籍","tags":[{"name":"Pearl","slug":"Pearl","permalink":"http://www.dashen.tech/tags/Pearl/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"golang之用好指针","date":"2010-03-02T15:41:28.000Z","path":"2010/03/02/golang之用好指针/","text":"https://newt0n.github.io/2016/11/07/%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80-Go-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%99%B7%E9%98%B1/ 关于range二三事 golang之struct入门 参考: []T 还是 []*T, 这是一个问题 Go的函数参数总是传值","tags":[{"name":"Todo","slug":"Todo","permalink":"http://www.dashen.tech/tags/Todo/"},{"name":"Go","slug":"Go","permalink":"http://www.dashen.tech/tags/Go/"}]},{"title":"浙闽穿行","date":"1093-02-17T15:43:21.000Z","path":"1093/02/17/浙闽穿行/","text":"浙江 素有 七山一水二分田之说， 临接的福建 则是八山一水一分田。浙南闽北，山水相连。 温州宁德福州莆田泉州","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"天涯羁客","date":"1093-02-17T14:34:18.000Z","path":"1093/02/17/天涯羁客/","text":"我不曾失约依期而来,却不见问东问西不闻谆谆叮咛,只有躺在床榻恹恹昏睡的奶奶,和歇斯底里癔病缠身的爷爷. 2020-01-22 22:39:18","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"微山湖上","date":"1093-02-17T13:04:43.000Z","path":"1093/02/17/微山湖上/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"世纪相见","date":"1093-02-17T10:13:57.000Z","path":"1093/02/17/世纪相见/","text":"2020-01-23 18:18:57","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.dashen.tech/tags/杂谈/"}]},{"title":"索句渝州","date":"1093-02-17T05:39:01.000Z","path":"1093/02/17/索句渝州/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"芙蓉秋梦","date":"1093-02-17T05:38:46.000Z","path":"1093/02/17/芙蓉秋梦/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>潇湘夜雨","date":"1093-02-17T04:34:40.000Z","path":"1093/02/17/潇湘夜雨/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>淮海遗珠","date":"1093-02-17T04:34:24.000Z","path":"1093/02/17/淮海遗珠/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>洙泗之滨","date":"1093-02-17T04:34:01.000Z","path":"1093/02/17/洙泗之滨/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>梦华东京","date":"1093-02-17T04:31:47.000Z","path":"1093/02/17/梦华东京/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>登封揽胜","date":"1093-02-17T04:31:40.000Z","path":"1093/02/17/登封揽胜/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>庐州新月","date":"1093-02-17T03:58:18.000Z","path":"1093/02/17/庐州新月/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>江城瞰江","date":"1093-02-17T03:35:32.000Z","path":"1093/02/17/江城瞰江/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>星城观星","date":"1093-02-17T03:35:19.000Z","path":"1093/02/17/星城观星/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>鹏城展翅","date":"1093-02-17T03:34:05.000Z","path":"1093/02/17/鹏城展翅/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>二泉闻声","date":"1093-02-17T03:33:51.000Z","path":"1093/02/17/二泉闻声/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>秦淮灯影","date":"1093-02-17T03:33:01.000Z","path":"1093/02/17/秦淮灯影/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>北固楼头","date":"1093-02-17T03:32:47.000Z","path":"1093/02/17/北固楼头/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>姑苏城外","date":"1093-02-17T03:32:31.000Z","path":"1093/02/17/姑苏城外/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>鹭岛夜幕","date":"1093-02-17T03:32:14.000Z","path":"1093/02/17/鹭岛夜幕/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>锦簇花都","date":"1093-02-17T03:31:20.000Z","path":"1093/02/17/锦簇花都/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>碧海潮生","date":"1093-02-17T00:28:25.000Z","path":"1093/02/17/碧海潮生/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]},{"title":"<待填坑>海定波宁","date":"1093-02-17T00:28:14.000Z","path":"1093/02/17/海定波宁/","text":"","tags":[{"name":"读城记","slug":"读城记","permalink":"http://www.dashen.tech/tags/读城记/"}]}]